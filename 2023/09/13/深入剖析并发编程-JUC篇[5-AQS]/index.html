<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="AQS、Reentrantlock、ReadAndWriterLock   第一篇是JUC并发编程基础 第二篇是JMM、Volatile关键字、synchronize锁详解 第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量 第四篇是Atomic原子包源码详解 第五篇是AQS源码以及机制详解   本篇前言 在并发编程中，我们学习到了JUC的并发">
<meta property="og:type" content="article">
<meta property="og:title" content="深入剖析并发编程-JUC篇[5-AQS]">
<meta property="og:url" content="https://username.github.io/2023/09/13/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[5-AQS]/index.html">
<meta property="og:site_name" content="KkkerAn&#39;s Blog">
<meta property="og:description" content="AQS、Reentrantlock、ReadAndWriterLock   第一篇是JUC并发编程基础 第二篇是JMM、Volatile关键字、synchronize锁详解 第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量 第四篇是Atomic原子包源码详解 第五篇是AQS源码以及机制详解   本篇前言 在并发编程中，我们学习到了JUC的并发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181044445.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181742497.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230929131807036.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230929132619749.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930202252236.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930202739393.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930202812518.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930203116496.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930180647588.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930180804316.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181742497.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007182801004.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007183346412.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007183935160.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007184327495.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007184610289.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007184847981.png">
<meta property="og:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007185104698.png">
<meta property="article:published_time" content="2023-09-13T12:43:59.000Z">
<meta property="article:modified_time" content="2023-10-11T14:58:20.674Z">
<meta property="article:author" content="KkkerAn">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://username.github.io/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181044445.png"><title>深入剖析并发编程-JUC篇[5-AQS] | KkkerAn's Blog</title><link ref="canonical" href="https://username.github.io/2023/09/13/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[5-AQS]/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">深入剖析并发编程-JUC篇[5-AQS]</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">55分</span></span></div></header><div class="post-body"><p>AQS、Reentrantlock、ReadAndWriterLock</p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
<li>第四篇是Atomic原子包源码详解</li>
<li>第五篇是AQS源码以及机制详解</li>
</ul>
<hr>
<p><strong>本篇前言</strong></p>
<p>在并发编程中，我们学习到了JUC的并发编程基础，了解了变量在计算机中的存储方式以及内存一致性协议，然后引入了JMM内存模型，并且了解了Volatile关键字怎么将变量可见性，然后为了不加锁我们引入了CAS乐观锁机制，通过Unsafe实现CAS机制，同时有了Atomic原子操作包，而后面乐观锁之后还有Synchronized悲观锁，但是Synchronized悲观锁又是隐式锁，再加锁和释放锁都不需要我们自己手动操作。于是接下来的就是悲观锁中的显式锁Lock，需要我们自己手动加锁和释放锁流程。</p>
<p>但是在提显式锁之前我们先得提一个AQS机制，一个锁再竞争失败之后需要一个容器来接受等待锁的线程，而这个就是AQS</p>

        <h1 id="AQS"   >
          <a href="#AQS" class="heading-link"><i class="fas fa-link"></i></a><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1>
      <p>AQS：AbstractQueuedSynchronizer也即抽象队列同步器，它是Java并发包的核心组件</p>
<p>我们直接从源码开始看起</p>

        <h2 id="成员变量以及内部类"   >
          <a href="#成员变量以及内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步队列的头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步队列的尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">//Unsafe类以及对应偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>又因为AbstractQueuedSynchronizer继承了<strong>AbstractOwnableSynchronizer</strong>所以还有一个成员变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//持锁线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></div></figure>

<p>也即AQS成员变量有<strong>队列头指针、队列尾指针、锁的状态字以及持锁线程</strong></p>
<p>而内部类有<strong>Node</strong>以及<strong>ConditionObject</strong></p>

        <h3 id="Node"   >
          <a href="#Node" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node" class="headerlink" title="Node"></a>Node</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//共享模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="comment">//独占模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是四个信号量 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;	<span class="comment">//表示线程已经结束</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;	<span class="comment">//表示等待被唤醒</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;	<span class="comment">//表示在条件队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;	<span class="comment">//表示共享模式下同步行为会被传播</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前结点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾结点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">Node nextWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空参构造用于创建队列的头或者共享标记</span></span><br><span class="line">Node() &#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于添加Node</span></span><br><span class="line">Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">      <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">      <span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于Condition创建Node</span></span><br><span class="line">Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>也即Node的成员变量有<strong>锁的模式、锁的状态字、锁的信号量、前一结点指针、下一结点指针、线程、nextWaiter</strong></p>
<p>而Node中的方法我们会具体碰到的时候再进行展开</p>

        <h3 id="ConditionObject"   >
          <a href="#ConditionObject" class="heading-link"><i class="fas fa-link"></i></a><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头结点指针 firstWaiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾结点指针	lastWaiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是两个中断标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>因此目前已知情报可公开的数据可能如图所示(<strong>假设</strong>)，我们带着这个假设的模型去进行学习也许可能会更简单一些</p>
<p><em>猜想模型有误，只是提供一个最初印象的模型图，仅供参考</em></p>
<p><strong>同步队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181044445.png"  alt="同步队列猜测模型">
      </p>
<p><strong>条件队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181742497.png"  alt="条件队列猜测模型">
      </p>
<p>又因为Reentrantlock中的加锁调用了acquire方法，而这个方法在AQS中声明，所以我们要了解加锁过程必然要从acquire方法入手</p>

        <h2 id="同步队列"   >
          <a href="#同步队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2>
      
        <h3 id="acquire方法"   >
          <a href="#acquire方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>我们按照总分总的顺序拆分一点点理解代码</p>
<p>1.先调用tryAcquire方法，返回结果为true的时候，直接判断为false也即不会进行逻辑与后面的方法</p>
<p>2.当调用tryAcquire方法，返回结果为false的时候，调用acquireQueued方法</p>
<p>也即：先调用tryAcquire，当tryAcquire不成功则进行acquireQueued方法</p>
<p>进入if语句的情况：</p>
<ul>
<li><strong>tryAcquire失败并且acquireQueued成功</strong></li>
</ul>

        <h3 id="tryAcquire方法"   >
          <a href="#tryAcquire方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试以独占模式获取锁，具体操作由对应子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>当tryAcquire失败，也即获取锁失败，那么说明锁被独占了，<strong>也即进入acquireQueued方法说明获取锁失败有线程竞争</strong></p>

        <h3 id="acquireQueued方法"   >
          <a href="#acquireQueued方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里传参中还调用了一个addWaiter(Node.EXCLUSIVE), arg)</span></span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断标志位为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前结点的前一个结点p</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句中先判断前一个结点p是否是头结点</span></span><br><span class="line"><span class="comment">                	只有是头结点才会去尝试加锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功获取锁，更新AQS同步器头结点，移动同步队列，将failed置为false</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//return 中断标志位</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句判断为false就来到第二个if语句，而第一个if失败的可能有</span></span><br><span class="line"><span class="comment">                		1.前一个结点p不是头结点，所以没有资格获取锁</span></span><br><span class="line"><span class="comment">                		2.前一个结点是p但是没有获取锁成功</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//失败获取锁之后阻塞，阻塞线程并检查中断位，如果中断位为true则更新中断标志位为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           		因为finally方法一定会执行，而acquireQueued方法什么时候会结束</span></span><br><span class="line"><span class="comment">           			1.当获取锁成功，failed==false</span></span><br><span class="line"><span class="comment">           			2.当try中的方法报错，而当try中的方法报错有什么情况</span></span><br><span class="line"><span class="comment">           				2-1.锁的状态state&gt;Integer.MAX_VALUE,也即可重入次数超过上限</span></span><br><span class="line"><span class="comment">           				2-2.当子类的tryAcquire方法报错</span></span><br><span class="line"><span class="comment">            	也即:情况1则说明正常结束，不会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            		情况2则说明报错结束，会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">//怎么都获取不到锁，移除当前线程结点，唤醒之后的线程</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>因为先调用了addWaiter方法所以我们先看向addWaiter方法，看完之后再来具体看acquireQueued方法做了什么事</p>

        <h3 id="addWaiter方法"   >
          <a href="#addWaiter方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    	<span class="comment">//new一个Node对象，传入参数有当前线程和锁的模式</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">		<span class="comment">//将尾结点指针赋值给pred</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断尾结点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当尾结点不为空，说明有同步队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将new出来的对象的前驱结点指向pred</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//CAS更新尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//如果更新尾结点成功，将pred指向node结点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//也即更新AQS尾指针，并且更新同步队列</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	运行到这里有两个情况：</span></span><br><span class="line"><span class="comment">    		1.同步队列为空，调用enq方法</span></span><br><span class="line"><span class="comment">    		2.CAS更新尾结点失败，说明线程竞争入同步队列失败</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>那么我们接下来要看向enq方法，看看具体怎么入队</p>

        <h3 id="enq方法"   >
          <a href="#enq方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#enq方法" class="headerlink" title="enq方法"></a>enq方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//死循环不断尝试入队</span></span><br><span class="line">    	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取尾指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="comment">//当尾指针为空说明队列为空，则需要对同步队列初始化</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//同步队列初始化，初始化成功之后tail！=null</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//说明同步队列存在，将node入队</span></span><br><span class="line">                <span class="comment">//原先尾结点设置为当前结点的前驱结点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//CAS设置尾指针，设置尾指针成功再更新队列</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="comment">//返回t，尾结点的前一个结点(也即原先的尾结点)</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法做了两件事</p>
<ul>
<li>1.当队列为空的时候，初始化队列，并且队列的头结点为新的node结点(空参构造)</li>
<li>2.当队列不为空的时候，将node结点入队，更新AQS同步器也更新同步队列</li>
</ul>
<p>返回了<strong>当前结点的前一个结点</strong></p>

        <h4 id="enq方法流程图"   >
          <a href="#enq方法流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#enq方法流程图" class="headerlink" title="enq方法流程图"></a>enq方法流程图</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230929131807036.png"  alt="enq方法流程图">
      </p>
<p><strong>enq方法当同步队列为空时</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230929132619749.png"  alt="同步队列初始化">
      </p>
<p><strong>enq方法当同步队列不为空时</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930202252236.png"  alt="当同步队列不为空">
      </p>
<p>也即同步队列如果存在，那么<strong>同步队列的第一个结点是空参构造的结点</strong>，可以把它看成当前持锁线程</p>
<p>enq方法将队列初始化或者将新结点添加到队尾，于是我们反过头来看<strong>acquireQueued</strong>方法做了什么事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断标志位为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前结点的前一个结点p</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句中先判断前一个结点p是否是头结点</span></span><br><span class="line"><span class="comment">                	只有是头结点才会去尝试加锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功获取锁，更新AQS同步器头结点，移动同步队列，将failed置为false</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//return 中断标志位</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句判断为false就来到第二个if语句，而第一个if失败的可能有</span></span><br><span class="line"><span class="comment">                		1.前一个结点p不是头结点，所以没有资格获取锁</span></span><br><span class="line"><span class="comment">                		2.前一个结点是p但是没有获取锁成功</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//失败获取锁之后阻塞，阻塞线程并检查中断位，如果中断位为true则更新中断标志位为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           		因为finally方法一定会执行，而acquireQueued方法什么时候会结束</span></span><br><span class="line"><span class="comment">           			1.当获取锁成功，failed==false</span></span><br><span class="line"><span class="comment">           			2.当try中的方法报错，而当try中的方法报错有什么情况</span></span><br><span class="line"><span class="comment">           				2-1.锁的状态state&gt;Integer.MAX_VALUE,也即可重入次数超过上限</span></span><br><span class="line"><span class="comment">           				2-2.当子类的tryAcquire方法报错</span></span><br><span class="line"><span class="comment">            	也即:情况1则说明正常结束，不会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            		情况2则说明报错结束，会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">//怎么都获取不到锁，移除当前线程结点，唤醒之后的线程</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node中的方法，目的是获取当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="comment">//获取当前结点的前一个结点</span></span><br><span class="line">    		<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>当请求结点是头结点的下一个结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930202739393.png"  alt="更新结点前">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930202812518.png"  alt="更新结点后">
      </p>
<p><strong>当请求结点前一个结点不是头结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930203116496.png"  alt="请求结点前一个结点不是头结点">
      </p>

        <h3 id="shouldParkAfterFailedAcquire方法"   >
          <a href="#shouldParkAfterFailedAcquire方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#shouldParkAfterFailedAcquire方法" class="headerlink" title="shouldParkAfterFailedAcquire方法"></a>shouldParkAfterFailedAcquire方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//获取pred中的锁的状态字</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">//当ws==Node.SIGNAL也即ws==-1，意思是当前结点已经阻塞</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当ws&gt;0 也即ws==Node.CANCELLED==1，也即这个结点无效需要退出同步队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将pred移除同步队列</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	将pred指向前一个结点，将node的前一个结点指向pred</span></span><br><span class="line"><span class="comment">            	也即删除同步队列的pred结点</span></span><br><span class="line"><span class="comment">            	直到pred.waitStatus&lt;=0 说明结点有效</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到有效结点，链接双向链表更新pred结点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当ws==0 || ws==-2 || ws==-3</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//说明pred结点是需要更新成SINGAL状态，也即将状态字置为-1表示阻塞</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>shouldParkAfterFailedAcquire方法就是更新waitStatus状态字</p>
<blockquote>
<p>ws&#x3D;pred.waitStatus</p>
<p>static final int CANCELLED &#x3D;  1;	&#x2F;&#x2F;表示线程已经结束</p>
<p>static final int SIGNAL    &#x3D; -1;	&#x2F;&#x2F;表示等待被唤醒</p>
<p>static final int CONDITION &#x3D; -2;	&#x2F;&#x2F;表示在条件队列中 </p>
<p>static final int PROPAGATE &#x3D; -3;	&#x2F;&#x2F;在共享状态表示同步状态会被传播</p>
</blockquote>
<ul>
<li><p>ws &#x3D;&#x3D; -1(ws &#x3D;&#x3D; Node.SIGNAL)</p>
<p>意思是当前已经在阻塞队列中，所以不用操作直接返回true</p>
</li>
<li><p>ws &gt; 0 (ws &#x3D;&#x3D; Node.CANCELLED)</p>
<p>意思是这个结点线程已经结束或者无效，所以需要删除这个结点，直到结点指向一个正常的结点</p>
</li>
<li><p>ws &#x3D;&#x3D; 0 || ws &#x3D;&#x3D; -2 ||ws&#x3D;&#x3D;-3</p>
<p>用CAS更新ws状态成-1</p>
<ul>
<li>ws &#x3D;&#x3D; 0 :表示线程在活跃中</li>
<li>ws &#x3D;&#x3D; -2:表示线程在条件队列中</li>
<li>ws &#x3D;&#x3D; -3:表示线程在共享模式下的同步状态会被传播</li>
</ul>
</li>
</ul>
<p>当更新状态字成功，要调用pardAndCheckInterrupt方法</p>

        <h3 id="parkAndCheckInterrupt方法"   >
          <a href="#parkAndCheckInterrupt方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#parkAndCheckInterrupt方法" class="headerlink" title="parkAndCheckInterrupt方法"></a>parkAndCheckInterrupt方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用LockSupport工具类下的park方法阻塞当前线程，然后返回线程的中断标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="cancelAcquire方法"   >
          <a href="#cancelAcquire方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#cancelAcquire方法" class="headerlink" title="cancelAcquire方法"></a>cancelAcquire方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//如果node为空则结束，肯定不在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//将node的线程置为空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取node的前一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将node的前驱结点指向一个有效的结点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//predNext记录移动后的pred指针的下一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//将node的ws设置成1</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		如果node结点是尾结点，则进入if语句中移除尾结点</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line"></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//node在中间结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	进入下方if语句有两种情况</span></span><br><span class="line"><span class="comment">        	1.pred不是头结点并且pred的线程存在以及ws==SIGNAL</span></span><br><span class="line"><span class="comment">        	2.pred不是头结点并且pred的线程存在以及ws被设置成SIGNAL</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">           ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将next指向下一个结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//next是有效结点，则设置pred的后继结点是next</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	运行到这里有几种可能性</span></span><br><span class="line"><span class="comment">            	1.pred是头结点，也即前驱结点是头结点</span></span><br><span class="line"><span class="comment">            	2.pred的线程不存在</span></span><br><span class="line"><span class="comment">            	3.pred的状态不是SIGNAL</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//唤醒线程</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继结点指向自己</span></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>Node结点在队尾，移除队尾元素</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930180647588.png"  alt="Node结点在队尾">
      </p>
<p><strong>Node结点在队中，移除Node结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230930180804316.png"  alt="Node结点在队中">
      </p>

        <h3 id="unparkSuccessor方法"   >
          <a href="#unparkSuccessor方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#unparkSuccessor方法" class="headerlink" title="unparkSuccessor方法"></a>unparkSuccessor方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Node结点的waitStatus</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node有效将ws置为0，意思为活跃中</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	从同步队列的后面往前找，第一个靠近node的结点s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里也即Acquire方法的全部流程，由此我们也可得出一个结论</p>
<p><strong>AQS是一个非公平同步器，当线程需要加锁的时候会直接进行tryAcquire加锁，只有加锁失败才会进入同步队列中</strong></p>
<p>接下来加完锁就要看解锁，所以我们看向release方法</p>

        <h3 id="release方法"   >
          <a href="#release方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//尝试解锁成功进入下面语句，尝试唤醒其他线程</span></span><br><span class="line">    	<span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//获取头结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	当头结点不为空，也即存在同步队列</span></span><br><span class="line"><span class="comment">            	并且ws.waitStatus不为0，说明有线程在等待唤醒</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//唤醒h之后的第一个需要被唤醒的线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Node结点的waitStatus</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node有效将ws置为0，意思为活跃中</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	从同步队列的后面往前找，第一个靠近node的结点s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="tryRelease方法"   >
          <a href="#tryRelease方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由子类去重写</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>释放锁流程</strong></p>
<ul>
<li>尝试tryRelease，如果锁的statu为0，说明解锁成功返回true<ul>
<li>获取AQS同步器的头结点<ul>
<li>同步器头结点如果为null，说明没有同步队列也即没有等待线程直接返回true即可</li>
<li>同步器头结点不为空，并且ws!&#x3D;0,说明有线程在等待，唤醒离头结点最近的第一个需要被唤醒的线程</li>
</ul>
</li>
</ul>
</li>
<li>解锁失败返回false</li>
</ul>
<p>而上面我们有返回中断标志位，这是让我们自己去响应中断返回结果，而有没有能帮我们抛出异常而不用我们来反应中断的呢？</p>
<p>当然是有的，那就是acquireInterruptibly方法</p>

        <h3 id="acquireInterruptibly方法"   >
          <a href="#acquireInterruptibly方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireInterruptibly方法" class="headerlink" title="acquireInterruptibly方法"></a>acquireInterruptibly方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">   	<span class="comment">//线程中断标志位为true那么就抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//尝试去加锁，加锁失败之后走doAcquireInterruptibly方法加锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="doAcquireInterruptibly方法"   >
          <a href="#doAcquireInterruptibly方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireInterruptibly方法" class="headerlink" title="doAcquireInterruptibly方法"></a>doAcquireInterruptibly方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前线程的前一个线程，只有前一个线程是头结点才允许加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//检查中断标志位为true则抛出异常，而不用我们自己处理</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这一段方法逻辑和acquireQueued方法逻辑是一致的，只是在响应中断方面，acquireQueued方法会返回中断标志位交给我们自己处理，而这个方法是出现中断之后会抛出异常，而不用我们自己处理中断</p>
<p>而上面都在说独占锁的过程，而我们知道共享锁，所以我们接下来看共享锁的获取流程</p>

        <h3 id="acquireShared方法"   >
          <a href="#acquireShared方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//获取共享锁</span></span><br><span class="line">    	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果加锁失败</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="tryAcquireShared方法"   >
          <a href="#tryAcquireShared方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared方法" class="headerlink" title="tryAcquireShared方法"></a>tryAcquireShared方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试加锁，由子类去实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="doAcquireShared方法"   >
          <a href="#doAcquireShared方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireShared方法" class="headerlink" title="doAcquireShared方法"></a>doAcquireShared方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个模式为共享模式的结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱结点是头指针结点，那么就尝试进行加锁，如果加锁成功则将头结点更新，并将头结点移除</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//记录一下可以获取共享锁的资源数，也即拿到锁r将大于0</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//如果加锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">//将p的下一个结点置空</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">//判断中断</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否阻塞和处理响应中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	如果failed为false，说明获取到了锁结束方法</span></span><br><span class="line"><span class="comment">        	如果failed为true，说明获取不到锁，将当前线程移除同步队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="setHeadAndPropagate方法"   >
          <a href="#setHeadAndPropagate方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#setHeadAndPropagate方法" class="headerlink" title="setHeadAndPropagate方法"></a>setHeadAndPropagate方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="comment">//记录老的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//设置新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**以下IF语句有五种情况</span></span><br><span class="line"><span class="comment">    	1.当前结点node获取锁成功，也即propagate＞0</span></span><br><span class="line"><span class="comment">    	2.原来的头结点为空，也即同步队列头结点为空</span></span><br><span class="line"><span class="comment">    	3.原来的头结点不为空但是锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    	4.将当前结点更新成头结点为空</span></span><br><span class="line"><span class="comment">    	5.将当前结点更新成头结点之后锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前结点的下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//判断下一个结点如果是共享模式则进入唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="doReleaseShared方法"   >
          <a href="#doReleaseShared方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared方法" class="headerlink" title="doReleaseShared方法"></a>doReleaseShared方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//死循环一直去唤醒</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//当h不为空并且不为尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果头结点没有变化则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里有一个关键点在于每一次循环都会获取头结点<code>Node h = head</code>,并且最后每次还会判断<code>if( h == head ) break;</code></p>
<p>这是因为当头结点不为空，并且不是尾结点的时候都会将其唤醒，如果CAS更新失败则会continue，只有CAS成功进入唤醒状态或者ws从0更新成-3，那么才会进入h&#x3D;&#x3D;head的判断</p>
<p>而每次成功唤醒之后，应该会进行doAcquireShared方法去尝试获取锁，也即当获取锁成功则head还会被重新设置，只有头结点没有改变才会跳出循环</p>
<p>理想状态下：</p>
<p><strong>当第一个获取共享锁的线程成功，则会不断唤醒排在其身后连在一起的共享模式线程</strong></p>

        <h3 id="doAcquireSharedInterruptibly方法"   >
          <a href="#doAcquireSharedInterruptibly方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireSharedInterruptibly方法" class="headerlink" title="doAcquireSharedInterruptibly方法"></a>doAcquireSharedInterruptibly方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败取消线程任务</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法和doAcquireShared方法的唯一区别就在于响应中断的方式不同，这个则是直接抛出中断异常，而那个方法是返回上层我们程序员自己手动处理中断状态</p>
<p>至此，AQS的同步队列中获取锁的方式已经全部说完，我们下一个就是看条件队列</p>

        <h2 id="条件队列"   >
          <a href="#条件队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2>
      <p>条件队列也是阻塞队列，在线程等待某个资源的释放然后唤醒，也即<strong>当条件不成立的时候线程进入条件队列，当条件成立则将线程从条件队列移除并继续执行</strong></p>
<p>而条件队列也主要依靠两个方法，一个是<strong>await方法</strong>(使线程进入条件队列等待资源)，另一个则是<strong>signal方法</strong>(使线程从阻塞唤醒，从条件队列中移除)</p>
<p>我们一开始也将带着条件队列猜测模型学习</p>
<p><em>猜想模型有误，只是提供一个最初印象的模型图，仅供参考</em></p>
<p><strong>条件队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20230928181742497.png"  alt="条件队列猜测模型">
      </p>

        <h3 id="await方法"   >
          <a href="#await方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果线程中断了则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//添加新的结点入条件队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前线程获取的锁全部释放，记录重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="comment">//中断模式为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	进入while循环的条件：不在同步队列中</span></span><br><span class="line"><span class="comment">    	退出while循环的情景：</span></span><br><span class="line"><span class="comment">    		1.因为中断唤醒线程，所以设置中断模式</span></span><br><span class="line"><span class="comment">    		2.因为signal唤醒线程也即资源满足条件，所以结点一定在同步队列中不符合while循环条件</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//如果结点不在同步队列中(在条件队列中)=&gt;阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线程唤醒如果是因为中断过，那么就设置中断模式并且跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新争抢锁成功，并且不是因为中断唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//那么就设置中断模式为REINTERRUPT，需要本线程自己中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果条件队列中的下一个结点不为空，那么清除条件队列的失效结点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果中断模式不为0，也即发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="addConditionWaiter方法"   >
          <a href="#addConditionWaiter方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#addConditionWaiter方法" class="headerlink" title="addConditionWaiter方法"></a>addConditionWaiter方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取条件队列最后一个Waiter</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后一个Waiter存在但是状态不是条件队列状态(-2)，那么并且重新获取LastWaiter</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前线程的结点，状态为条件队列状态(-2)</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后一个Waiter为空，也即条件队列为空，那么当前结点就是条件队列的头结点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将条件队列的头结点修改成node</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//条件队列不为空，将node加入到条件队列的尾部</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">//将尾指针指向最后一个结点</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="unlinkCancelledWaiters方法"   >
          <a href="#unlinkCancelledWaiters方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlinkCancelledWaiters方法" class="headerlink" title="unlinkCancelledWaiters方法"></a>unlinkCancelledWaiters方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//t为第一个Waiter</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="comment">//跟踪指针trail，用于记录操作的结点前一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//当t不为空也即同步队列不为空</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">//当前结点的状态不为条件队列状态，也即要移除出条件队列</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//将t指向下一个结点设置为空</span></span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//如果trail为空也即taril还没被设置值也即头结点就是不合法，则更新头指针</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//trail不为空，则更新trail的下一个结点为当前结点的下一个结点</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果下一个结点为空，也即到了队列的末尾则更新尾指针</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            trail = t; <span class="comment">//当前结点状态是条件队列状态(-2)则保留 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动指针t向后遍历</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="条件队列新增结点和移除结点图解"   >
          <a href="#条件队列新增结点和移除结点图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件队列新增结点和移除结点图解" class="headerlink" title="条件队列新增结点和移除结点图解"></a>条件队列新增结点和移除结点图解</h5>
      <p><strong>新增结点</strong>，判断尾结点是否是条件队列状态，如果不是则进行<strong>删除不合法结点</strong>，如果是则将当前结点添加到条件队列尾部</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007182801004.png"  alt="条件队列新增结点">
      </p>
<p><strong>移除结点</strong>，从<strong>头结点开始</strong>判断是否满足条件队列要求</p>
<ul>
<li>当头结点不合法</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007183346412.png"  alt="删除结点，头结点不合法">
      </p>
<p>删除头结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007183935160.png"  alt="删除头结点">
      </p>
<ul>
<li><p>当中间结点不合法</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007184327495.png"  alt="当中间结点不合法">
      </p>
</li>
</ul>
<p>移除不合法的中间结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007184610289.png"  alt="移除不合法的中间结点">
      </p>
<ul>
<li><p>当尾结点不合法</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007184847981.png"  alt="尾结点不合法">
      </p>
</li>
</ul>
<p>移除尾结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%5D/image-20231007185104698.png"  alt="移除尾结点">
      </p>

        <h4 id="fullyRelease方法"   >
          <a href="#fullyRelease方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullyRelease方法" class="headerlink" title="fullyRelease方法"></a>fullyRelease方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//失败解锁标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁的重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">//将failed标志位置为false，意思是全部解锁成功</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//没有全部解锁成功，那么就将此节点置为失效结点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="release方法-1"   >
          <a href="#release方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#release方法-1" class="headerlink" title="release方法"></a>release方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试解锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//成功唤醒同步队列中头结点的下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="isOnSyncQueue方法"   >
          <a href="#isOnSyncQueue方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#isOnSyncQueue方法" class="headerlink" title="isOnSyncQueue方法"></a>isOnSyncQueue方法</h4>
      <p>判断当前结点是不是在同步队列中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回true说明在同步队列中，返回false说明不在同步队列中</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果结点等待状态为-2(条件队列)，或者结点的前驱结点为空，说明不在同步队列中</span></span><br><span class="line">  	<span class="comment">//也即同步队列的结点状态不能为-2，并且前驱结点不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后继结点不为空，说明在同步队列中(也即：同步队列除了尾结点后继结点不为空)</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果后继节点为空判断是不是在同步队列的尾结点</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="findNodeFromTail方法"   >
          <a href="#findNodeFromTail方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#findNodeFromTail方法" class="headerlink" title="findNodeFromTail方法"></a>findNodeFromTail方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾结点开始搜索结点node，遍历结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果尾结点是当前结点node，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果搜索结点为空，说明搜索完同步队列还没找到结点node，说明node不在同步队列中</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//向前搜索</span></span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>checkInterruptWhileWaiting方法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">	<span class="comment">//如果中断过，那么返回值要么是THROW_IE(-1)要么是REINTERRUPT(1)</span></span><br><span class="line">    <span class="comment">//没有中断过则返回0</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也即返回值有 -1(THROW_IE),0,1(REINTERRUPT)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="transferAfterCancelledWait方法"   >
          <a href="#transferAfterCancelledWait方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#transferAfterCancelledWait方法" class="headerlink" title="transferAfterCancelledWait方法"></a>transferAfterCancelledWait方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//CAS设置结点状态标志位从-2到0(也即这是中断唤醒线程再导致添加在同步队列中，所以设置中断模式为THROW_IE)</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//CAS成功，添加结点到同步队列，返回true</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果结点不在同步队列中，那么就让出CPU，直到它在同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="reportInterruptAfterWait方法"   >
          <a href="#reportInterruptAfterWait方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#reportInterruptAfterWait方法" class="headerlink" title="reportInterruptAfterWait方法"></a>reportInterruptAfterWait方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果中断模式是THROW_IE，也即条件队列线程唤醒是因为线程中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">//如果中断模式是REINTERRUPT说明是SSignal唤醒线程，则线程自己中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="signal方法"   >
          <a href="#signal方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//判断是否是持锁线程唤醒，如果当前线程不是持锁线程那么则抛错</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//持锁线程可以去唤醒条件队列的结点</span></span><br><span class="line">    </span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取条件队列的第一个Waiter</span></span><br><span class="line">    		<span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="comment">//如果条件线程不为空那么尝试从第一个结点开始Signal唤醒</span></span><br><span class="line">    		<span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="isHeldExclusively方法"   >
          <a href="#isHeldExclusively方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#isHeldExclusively方法" class="headerlink" title="isHeldExclusively方法"></a>isHeldExclusively方法</h4>
      <p>方法由子类实现，如果当前线程不是持锁线程则抛错</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="doSignal方法"   >
          <a href="#doSignal方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#doSignal方法" class="headerlink" title="doSignal方法"></a>doSignal方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将条件队列队首开始，尝试将一个结点从条件队列移到同步队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//将第一个结点移出条件队列(无论是否成功移到同步队列)</span></span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//将头结点指针更新成第一个结点的下一个结点，如果下一个结点为空同时也更新条件队列尾指针</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//将第一个结点指针更新为空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;  <span class="comment">//将第一个结点尝试移到同步队列中，当成功则返回true，失败返回false</span></span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一个结点移到同步队列失败，则重新获取第一个结点直到同步队列为空或者成功移动一个结点到同步队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="transferForSignal方法"   >
          <a href="#transferForSignal方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#transferForSignal方法" class="headerlink" title="transferForSignal方法"></a>transferForSignal方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回false:通过Signal转移到同步队列失败</span></span><br><span class="line"><span class="comment">//返回true:通过Signal转移到同步队列成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//如果CAS更新结点状态失败，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//CAS成功，结点状态更新成0</span></span><br><span class="line">    <span class="comment">//将结点入同步队列尾部，enq返回原先的尾结点(此时同步队列的倒数第二个结点)</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果p状态大于0(结点P失效)或者p状态更新成-1失败(0-&gt;-1) 那么唤醒结点线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">//唤醒结点线程，让它去争抢一次锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	因为AQS同步队列中只有前一个结点的是头结点才能争锁成功</span></span><br><span class="line"><span class="comment">        	这里可能是让本线程更新同步队列结点的状态</span></span><br><span class="line"><span class="comment">        	或者移除不合法结点之后此节点前一个结点是头结点，于是能尝试争锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回true，也即通过Signal添加到同步队列成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="signalAll方法"   >
          <a href="#signalAll方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a>signalAll方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="comment">//判断是否是持锁线程进行全部唤醒，不是则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    		<span class="comment">//获取同步队列的头指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    		<span class="comment">//如果同步队列存在则唤醒全部</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>








        <h4 id="doSignalAll方法"   >
          <a href="#doSignalAll方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#doSignalAll方法" class="headerlink" title="doSignalAll方法"></a>doSignalAll方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    		<span class="comment">//将同步队列的首尾指针指向空</span></span><br><span class="line">            lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//将原先的头结点向后遍历，尝试唤醒全部条件队列线程</span></span><br><span class="line">    		<span class="keyword">do</span> &#123;</span><br><span class="line">          	</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <p>AQS是一个<strong>非公平锁</strong>，当需要加锁的时候都是先尝试获取一把锁，如果获取失败才会进入AQS同步队列中。又因为AQS分有独占锁和共享锁，以及同步队列和条件队列，所以这里单独对加锁、解锁以及两个队列再进行一个知识性总结</p>

        <h4 id="独占锁"   >
          <a href="#独占锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4>
      
        <h5 id="加锁"   >
          <a href="#加锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5>
      
        <h5 id="解锁"   >
          <a href="#解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5>
      </div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://username.github.io">KkkerAn</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://username.github.io/2023/09/13/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[5-AQS]/">https://username.github.io/2023/09/13/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[5-AQS]/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://username.github.io/tags/java/">java</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2023/09/26/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B8.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%5D/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">死之前要做完的算法手册-[8.贪心算法]</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2023/09/07/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B7.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%5D/"><span class="paginator-prev__text">死之前要做完的算法手册-[7.回溯算法]</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS"><span class="toc-number">1.</span> <span class="toc-text">
          AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">
          成员变量以及内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Node"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConditionObject"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          ConditionObject</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.2.</span> <span class="toc-text">
          同步队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#acquire%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          acquire方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryAcquire%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          tryAcquire方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acquireQueued%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          acquireQueued方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWaiter%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.</span> <span class="toc-text">
          addWaiter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enq%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.5.</span> <span class="toc-text">
          enq方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enq%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">
          enq方法流程图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shouldParkAfterFailedAcquire%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">
          shouldParkAfterFailedAcquire方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parkAndCheckInterrupt%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.7.</span> <span class="toc-text">
          parkAndCheckInterrupt方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cancelAcquire%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.8.</span> <span class="toc-text">
          cancelAcquire方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unparkSuccessor%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.9.</span> <span class="toc-text">
          unparkSuccessor方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#release%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.10.</span> <span class="toc-text">
          release方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryRelease%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.11.</span> <span class="toc-text">
          tryRelease方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acquireInterruptibly%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.12.</span> <span class="toc-text">
          acquireInterruptibly方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doAcquireInterruptibly%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.13.</span> <span class="toc-text">
          doAcquireInterruptibly方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acquireShared%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.14.</span> <span class="toc-text">
          acquireShared方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tryAcquireShared%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.15.</span> <span class="toc-text">
          tryAcquireShared方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doAcquireShared%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.16.</span> <span class="toc-text">
          doAcquireShared方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setHeadAndPropagate%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.17.</span> <span class="toc-text">
          setHeadAndPropagate方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doReleaseShared%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.18.</span> <span class="toc-text">
          doReleaseShared方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doAcquireSharedInterruptibly%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.19.</span> <span class="toc-text">
          doAcquireSharedInterruptibly方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">
          条件队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#await%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          await方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addConditionWaiter%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">
          addConditionWaiter方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unlinkCancelledWaiters%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">
          unlinkCancelledWaiters方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E6%96%B0%E5%A2%9E%E7%BB%93%E7%82%B9%E5%92%8C%E7%A7%BB%E9%99%A4%E7%BB%93%E7%82%B9%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">
          条件队列新增结点和移除结点图解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fullyRelease%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">
          fullyRelease方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#release%E6%96%B9%E6%B3%95-1"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">
          release方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isOnSyncQueue%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">
          isOnSyncQueue方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findNodeFromTail%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.6.</span> <span class="toc-text">
          findNodeFromTail方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transferAfterCancelledWait%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.7.</span> <span class="toc-text">
          transferAfterCancelledWait方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reportInterruptAfterWait%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.1.8.</span> <span class="toc-text">
          reportInterruptAfterWait方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signal%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          signal方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#isHeldExclusively%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">
          isHeldExclusively方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doSignal%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">
          doSignal方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transferForSignal%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">
          transferForSignal方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#signalAll%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          signalAll方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#doSignalAll%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">
          doSignalAll方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">
          独占锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">1.3.4.1.1.</span> <span class="toc-text">
          加锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%94%81"><span class="toc-number">1.3.4.1.2.</span> <span class="toc-text">
          解锁</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">43</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>KkkerAn</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>