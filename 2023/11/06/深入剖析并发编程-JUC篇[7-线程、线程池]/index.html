<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="本篇是进程、线程、多线程详解   第一篇是JUC并发编程基础 第二篇是JMM、Volatile关键字、synchronize锁详解 第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量 第四篇是Atomic原子包源码详解 第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC">
<meta property="og:type" content="article">
<meta property="og:title" content="深入剖析并发编程-JUC篇[7-线程、线程池]">
<meta property="og:url" content="https://username.github.io/2023/11/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[7-%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0]/index.html">
<meta property="og:site_name" content="KkkerAn&#39;s Blog">
<meta property="og:description" content="本篇是进程、线程、多线程详解   第一篇是JUC并发编程基础 第二篇是JMM、Volatile关键字、synchronize锁详解 第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量 第四篇是Atomic原子包源码详解 第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106203624571.png">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106214636721.png">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231113181935844.png">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231114000324848.png">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117193515963.png">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194238410.png">
<meta property="og:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194303107.png">
<meta property="article:published_time" content="2023-11-06T10:43:10.000Z">
<meta property="article:modified_time" content="2023-11-17T11:58:26.589Z">
<meta property="article:author" content="KkkerAn">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106203624571.png"><title>深入剖析并发编程-JUC篇[7-线程、线程池] | KkkerAn's Blog</title><link ref="canonical" href="https://username.github.io/2023/11/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[7-%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0]/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">深入剖析并发编程-JUC篇[7-线程、线程池]</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-11-06</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">101分</span></span></div></header><div class="post-body"><p><strong>本篇是进程、线程、多线程详解</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
<li>第四篇是Atomic原子包源码详解</li>
<li>第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC并发工具包</li>
<li>第六篇是并发容器</li>
<li>第七篇是进程、线程、线程池</li>
</ul>
<hr>

        <h1 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h1>
      
        <h2 id="基础概念"   >
          <a href="#基础概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2>
      
        <h3 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程" class="headerlink" title="进程"></a>进程</h3>
      <p>进程是也就是平时所说的程序，是系统运行程序的基本单位。进程是用于加载指令、管理内存、管理IO的，是系统中运行的程序的独立实例。</p>
<p>进程也是<strong>系统分配资源的基本单位</strong>，也即系统分配资源以进程为单位分配资源。</p>

        <h3 id="线程-1"   >
          <a href="#线程-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3>
      <p>线程又叫<strong>轻量级进程</strong>，是进程内的执行单位，一个进程可以包含多个线程。</p>
<p>线程也是<strong>操作系统调度(CPU调度)的执行的最小单位</strong></p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>两者关系：线程是进程内的执行单元，一个进程可以包含多个线程</li>
<li>资源隔离：<ul>
<li>进程：进程是高度资源隔离的，一个进程崩溃通常不会影响其他进程</li>
<li>线程：线程有共享的内存单元，一个线程崩溃可能会影响整个进程</li>
</ul>
</li>
<li>通信<ul>
<li>进程：进程之间相互独立，具有较高的隔离性所以进程之间通信是在面对多进程场景下的需要<ul>
<li><strong>管道</strong><ul>
<li>管道应用在具有亲缘关系的父子进程之间的通信（单向通信，由父进程写子进程接收）</li>
<li>命名管道：可以应用在无亲缘关系的进程通信（双向通信）</li>
</ul>
</li>
<li><strong>消息队列</strong>：允许进程之间异步通信</li>
<li><strong>共享内存</strong>：多个进程指向同一块内存区域，这也是最快速和高效的通信方式</li>
<li>**信号(singal)**：用于进程之间的异步通新，一个进程通知另一个进程某些事情发生，如进程中断、终止或者其他</li>
<li>**信号量(Semaphore)**：信号量是用于控制多个进程之间访问同一个资源的方式</li>
<li><strong>套接字(socket)<strong>：通常用于网络通信，也可以用于进程之间的通信。</strong>这一方式更常用于进程中通信</strong></li>
</ul>
</li>
<li>线程：线程之间有共享的内存单元而进行线程之间通信有以下几种方法:<ul>
<li><strong>共享内存</strong>：多个线程之间有共享相同的内存区域，所以这是最快速和高效的通信方式</li>
<li><strong>消息队列</strong>：通过消息队列发送消息以及接收消息，实现异步通信</li>
<li><strong>互斥锁</strong>：用互斥锁来保护共享资源</li>
<li><strong>信号量</strong>：可以用信号量来控制资源访问和释放的同步机制，类似生产者-消费者环境</li>
<li><strong>套接字(socket)<strong>：如果线程在不同计算机或者不同进程中，可以使用socket通信。</strong>这一方式更多用于进程中通信</strong></li>
</ul>
</li>
</ul>
</li>
<li>并发性<ul>
<li>进程：进程隔离性较高、相互独立，所以并发性较低</li>
<li>线程：线程共享进程内的内存空间，并发性较高</li>
</ul>
</li>
<li>开销<ul>
<li>进程：创建和销毁以及进程之间切换具有较高的系统开销</li>
<li>线程：创建和销毁以及线程之间切换较小的系统开销，也即叫<strong>轻量级进程</strong></li>
</ul>
</li>
</ul>

        <h3 id="协程"   >
          <a href="#协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程" class="headerlink" title="协程"></a><strong>协程</strong></h3>
      <p>协程又叫<strong>轻量级线程</strong>，由程序管理的轻量级线程，对于内核态是不可见的。正如线程和进程的关系，一个线程可以由多个协程</p>

        <h2 id="生命周期"   >
          <a href="#生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2>
      <p>操作系统中的线程生命周期一共有五种状态：<strong>新建状态、就绪状态（可运行状态）、运行状态、阻塞状态、结束状态</strong></p>
<p>如图所示</p>
<blockquote>
<p> 操作系统中线程生命周期</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106203624571.png"  alt="操作系统中线程生命周期">
      </p>
<p>而java中有Thread类也即线程类，这里的生命周期和我们操作系统中定义的生命周期五种状态有一部分区别</p>
<p>我们从<code>Thread.java</code>中直接找到这部分源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        NEW,	<span class="comment">//创建状态</span></span><br><span class="line">        </span><br><span class="line">        RUNNABLE,<span class="comment">//可运行状态（对应操作系统中的就绪态和运行态）</span></span><br><span class="line">        </span><br><span class="line">        BLOCKED,<span class="comment">//阻塞状态</span></span><br><span class="line"></span><br><span class="line">        WAITING,<span class="comment">//等待状态</span></span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,<span class="comment">//等待超时状态</span></span><br><span class="line"></span><br><span class="line">        TERMINATED;<span class="comment">//终止状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略部分源码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Thread类中的线程运行状态枚举：</p>
<ul>
<li><u>NEW</u>：线程新建状态</li>
<li><u>RUNNABLE</u>：线程可运行状态（对应就绪态和运行态），也即就绪态和运行态在java中是合并在一起的</li>
<li><u>BLOCKED</u>：线程阻塞状态，等待锁的释放（竞争Synchronized锁失败，进入阻塞状态或者wait被唤醒之后获取Synchronized锁失败），·<em>这个状态针对Synchronized锁</em></li>
<li><u>WAITING</u>：线程等待状态，处于等待状态的线程等待另一个线程执行特定操作。可以由以下方法进入此状态<ul>
<li>**Object.wait()**：等待其他线程调用Object.notify()或者Object.notifyAll()唤醒</li>
<li>**Thread.join()**：等待指定线程结束</li>
<li>**LockSupport.park()**：等待线程调用LockSupport.unpark()</li>
</ul>
</li>
<li><u>TIMED_WAITING</u>：线程超时等待状态，处于指定等待时间的线程状态。可以由以下方法进入此状态<ul>
<li>**Thread.sleep(long)**：超出指定时间之后会结束此状态</li>
<li>**Object.wait(long)**：超出指定时间或者Object.motify()或者Object.notifyAll()唤醒</li>
<li>**LockSupport.parkNanos(long)**：超出等待时间或者LockSupport.unpark(Thread)唤醒</li>
<li>**LockSupport.parkUntil(long)**：超出等待时间或者LockSupport.unpark(Thread)唤醒</li>
<li>**Thread.join(long)**：等待指定线程结束（规定时间内）或者超出指定时间之后会结束此状态</li>
</ul>
</li>
<li><u>TERMINATED</u>：线程终止状态</li>
</ul>
<p>也即Java中线程生命周期如下图所示</p>
<blockquote>
<p>Java中线程生命周期</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106214636721.png"  alt="Java中线程生命周期">
      </p>
<p><strong>小结</strong></p>
<p>因此，在Java中线程的生命周期中一共有6种状态：<strong>新建状态、可运行状态、阻塞状态、等待状态、超时等待状态、结束状态</strong></p>
<p>和操作系统中线程生命周期相比，可运行状态包含了就绪态和运行态，阻塞状态更为细致地分成了阻塞状态、等待状态、超时等待状态</p>

        <h2 id="创建线程"   >
          <a href="#创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2>
      <blockquote>
<p> 在之前我写了一篇文章来谈到创建线程的方式——浅谈java中创建线程，在这里我们还是要用到创建线程的知识</p>
</blockquote>
<p>我们创建线程有以下几种方式</p>
<ol>
<li>创建Thread或者创建继承Thread类的子类</li>
<li>Runnable接口的实现类</li>
<li>Callable接口的实现类，需要利用FutureTask类</li>
<li>lambda表达式中匿名内部类创建线程</li>
<li>线程池创建线程</li>
</ol>

        <h3 id="第一种、直接创建新线程"   >
          <a href="#第一种、直接创建新线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一种、直接创建新线程" class="headerlink" title="第一种、直接创建新线程"></a>第一种、直接创建新线程</h3>
      <p>创建Thread或者创建继承Thread类的子类</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我重写了run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();<span class="comment">//调用start()方法创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第二种、Runnable接口的实现类"   >
          <a href="#第二种、Runnable接口的实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二种、Runnable接口的实现类" class="headerlink" title="第二种、Runnable接口的实现类"></a>第二种、Runnable接口的实现类</h3>
      <p>利用Runnable的实现类传入到<code>new Thread()</code>方法中的参数实现创建线程</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我重写了Runnable中的run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implRunnableDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());<span class="comment">//创建Thread类传入自己实现的Runnable实现类对象</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第三种、Callable接口的实现类"   >
          <a href="#第三种、Callable接口的实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三种、Callable接口的实现类" class="headerlink" title="第三种、Callable接口的实现类"></a>第三种、Callable接口的实现类</h3>
      <p>我们知道在创建线程的时候因为前两种的Run()方法返回值都是void，也即无返回值。而我们在部分场景中需要某个线程的执行结果，我们就可以用Callable实现类，利用FutureTask来<strong>获取到线程的执行结果</strong></p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implCallableDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(myCallable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将任务传入到Thread的构造函数中</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = task.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="第四种、lambda表达式创建线程"   >
          <a href="#第四种、lambda表达式创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四种、lambda表达式创建线程" class="headerlink" title="第四种、lambda表达式创建线程"></a>第四种、lambda表达式创建线程</h3>
      <p>lambda表达式实际上就是匿名内部类，实现了Runnable接口</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambdaThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第五种、线程池创建线程"   >
          <a href="#第五种、线程池创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五种、线程池创建线程" class="headerlink" title="第五种、线程池创建线程"></a>第五种、线程池创建线程</h3>
      <p>样例：我们可以调用<code>Executors</code>工具类调用默认的线程工厂创建线程，而线程池相关代码我们到线程池那再继续开展</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ThreadPoolCreateDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Executors.defaultThreadFactory().newThread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我重写了Run方法&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <p>这五种方法本质上都是一个方式创建线程，都是实现了Runnable接口之后调用new Thread()方法创建线程对象，然后调用Thread.start()方法创建线程</p>

        <h4 id="Thread类"   >
          <a href="#Thread类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;...&#125; <span class="comment">//实现Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="Runnable接口实现类"   >
          <a href="#Runnable接口实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Runnable接口实现类" class="headerlink" title="Runnable接口实现类"></a>Runnable接口实现类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;...&#125; <span class="comment">//实现了Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="Callable接口实现类"   >
          <a href="#Callable接口实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Callable接口实现类" class="headerlink" title="Callable接口实现类"></a>Callable接口实现类</h4>
      <p>因为Callable接口实现类需要用到FutureTask类，而在FutureTask类中实现了RunnableFuture接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;...&#125;<span class="comment">//实现了RunnableFuture接口</span></span><br></pre></td></tr></table></div></figure>

<p>而在RunnableFuture接口中又实现了Runnable接口和Future接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;...&#125;<span class="comment">//实现了Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="lambda表达式"   >
          <a href="#lambda表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4>
      <p>lambda表达式的匿名内部类实际上就是匿名Runnable接口的实现类，所以本质上也是实现了Runnable接口</p>

        <h4 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4>
      <p>线程池的线程工厂需要我们传入一个Runnable实现类对象，也即我们需要实现Runnable接口</p>
<p><strong>而这样实际上都是实现Runnable接口然后调用new Thread()方法创建线程对象</strong>，那我们常说的启动线程的Start()方法和直接调用run()方法具有区别，直接调用Run()方法是不会创建新的线程，这又是怎么一回事呢？这需要我们接下来理解线程的常见方法</p>

        <h3 id="常用方法"   >
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3>
      
        <h4 id="sleep"   >
          <a href="#sleep" class="heading-link"><i class="fas fa-link"></i></a><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></div></figure>

<p>我们知道native方法是需要看c++代码的，所以我们从方法注册表中找到cpp中对应的方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_Sleep&#125;, <span class="comment">//这就是我们要找到的sleep方法对应关系</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="type">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="type">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="type">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="type">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setNativeName&quot;</span>,    <span class="string">&quot;(&quot;</span> STR <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p>JVM.cpp中JVM_Sleep方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_Sleep</span>(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_Sleep&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果休眠时间为负数，则抛出异常，时间不能是负数</span></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>(), <span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果休眠被中断过，则抛出异常，休眠被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread::<span class="built_in">is_interrupted</span> (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>(), <span class="string">&quot;sleep interrupted&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//记录现场</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__begin, millis);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_SLEEP_BEGIN</span>(</span><br><span class="line">                             millis);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  EventThreadSleep event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      <span class="comment">//调用yield()方法，让出CPU</span></span><br><span class="line">      os::<span class="built_in">yield</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">      thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(SLEEPING);</span><br><span class="line">      os::<span class="built_in">sleep</span>(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadState old_state = thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(SLEEPING);</span><br><span class="line">    <span class="keyword">if</span> (os::<span class="built_in">sleep</span>(thread, millis, <span class="literal">true</span>) == OS_INTRPT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">          <span class="comment">//休眠</span></span><br><span class="line">          event.<span class="built_in">set_time</span>(millis);</span><br><span class="line">          event.<span class="built_in">commit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">        <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__end,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="built_in">HOTSPOT_THREAD_SLEEP_END</span>(</span><br><span class="line">                                 <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>(), <span class="string">&quot;sleep interrupted&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">    event.<span class="built_in">set_time</span>(millis);</span><br><span class="line">    event.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_SLEEP_END</span>(</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事：</p>
<ul>
<li>调用<code>yield()</code>方法让出CPU</li>
<li>休眠，时长为：<code>millis</code></li>
</ul>

        <h4 id="start"   >
          <a href="#start" class="heading-link"><i class="fas fa-link"></i></a><a href="#start" class="headerlink" title="start"></a>start</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="comment">//校验线程是否已经初始化完成(准备好进入就绪态)，如果没有初始化完成则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>在这里最关键的是<code>start0()</code>方法，也即这个方法应该和创建线程关联</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>而这又是native方法，我们只能找到cpp源码中的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,<span class="comment">//这就是我们要找到的start0方法对应关系</span></span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>JVM.cpp</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命名一个本地线程变量 所以创建的线程和JavaThread有关系</span></span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::<span class="built_in">thread</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::<span class="built_in">stackSize</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread));</span><br><span class="line">      <span class="type">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="type">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//创建了一个JavaThread对象和native_thread绑定也即创建本地线程和C++线程结构绑定</span></span><br><span class="line">      <span class="comment">//而其中这个参数&amp;thread_entry也是一个方法</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">//JVM线程创建成功之后和JAVA线程绑定</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalThreadStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(native_thread != <span class="literal">NULL</span>, <span class="string">&quot;Starting null thread?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果创建了空线程，那么说明无法</span></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> native_thread;</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_resource_exhausted</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_resource_exhausted</span>(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_OutOfMemoryError</span>(),</span><br><span class="line">              <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定成功之后调用start方法启动线程</span></span><br><span class="line">  Thread::<span class="built_in">start</span>(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li><p>创建<code>JavaThread</code>对象，调用<code>	thread_entry</code>也即线程入口</p>
</li>
<li><p>线程创建之后<code>JavaThread</code>对象和真正创建的线程绑定</p>
</li>
<li><p>调用<code>start</code>方法启动线程</p>
</li>
</ul>
<p>JavaThread对象</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaThread</span>: <span class="keyword">public</span> Thread &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  JavaThread*    _next;                          <span class="comment">// The next thread in the Threads list</span></span><br><span class="line">  oop            _threadObj;                     <span class="comment">// The Java level thread object</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="built_in">JavaThread</span>(ThreadFunction entry_point, <span class="type">size_t</span> stack_size = <span class="number">0</span>); <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>线程入口</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> &#123;</span><br><span class="line">  HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">  Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">  JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),</span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>操作系统内核创建线程，调用pthread_create方法创建操作系统真正的线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统内核创建线程，调用pthread_create方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type, <span class="type">size_t</span> stack_size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>, <span class="string">&quot;caller responsible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate the OSThread object</span></span><br><span class="line">  OSThread* osthread = <span class="keyword">new</span> <span class="built_in">OSThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_thread_type</span>(thr_type);</span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_state</span>(ALLOCATED);</span><br><span class="line"></span><br><span class="line">  thread-&gt;<span class="built_in">set_osthread</span>(osthread);</span><br><span class="line">    </span><br><span class="line">  <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">  <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">  <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stack size</span></span><br><span class="line">  <span class="keyword">if</span> (os::Linux::<span class="built_in">supports_variable_stack_size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack_size == <span class="number">0</span>) &#123;</span><br><span class="line">      stack_size = os::Linux::<span class="built_in">default_stack_size</span>(thr_type);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (thr_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> os::java_thread:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span> (JavaThread::<span class="built_in">stack_size_at_create</span>() &gt; <span class="number">0</span>, <span class="string">&quot;this should be set&quot;</span>);</span><br><span class="line">        stack_size = JavaThread::<span class="built_in">stack_size_at_create</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> os::compiler_thread:</span><br><span class="line">        <span class="keyword">if</span> (CompilerThreadStackSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          stack_size = (<span class="type">size_t</span>)(CompilerThreadStackSize * K);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      <span class="keyword">case</span> os::vm_thread:</span><br><span class="line">      <span class="keyword">case</span> os::pgc_thread:</span><br><span class="line">      <span class="keyword">case</span> os::cgc_thread:</span><br><span class="line">      <span class="keyword">case</span> os::watcher_thread:</span><br><span class="line">        <span class="keyword">if</span> (VMThreadStackSize &gt; <span class="number">0</span>) stack_size = (<span class="type">size_t</span>)(VMThreadStackSize * K);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack_size = <span class="built_in">MAX2</span>(stack_size, os::Linux::min_stack_allowed);</span><br><span class="line">    <span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_attr_setguardsize</span>(&amp;attr, os::Linux::<span class="built_in">default_guard_size</span>(thr_type));</span><br><span class="line"></span><br><span class="line">  ThreadState state;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">bool</span> lock = os::Linux::<span class="built_in">is_LinuxThreads</span>() &amp;&amp; !os::Linux::<span class="built_in">is_floating_stack</span>();</span><br><span class="line">    <span class="comment">//创建线程先上锁，如果上锁了则到达线程安全点开始创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">      os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">lock_without_safepoint_check</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//调用pthread_create()方法创建线程</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, (<span class="type">void</span>* (*)(<span class="type">void</span>*)) java_start, thread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      thread-&gt;<span class="built_in">set_osthread</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">if</span> (lock) os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    osthread-&gt;<span class="built_in">set_pthread_id</span>(tid);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      Monitor* sync_with_child = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line">      <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//等待子线程初始化完成或者中止</span></span><br><span class="line">      <span class="keyword">while</span> ((state = osthread-&gt;<span class="built_in">get_state</span>()) == ALLOCATED) &#123;</span><br><span class="line">        sync_with_child-&gt;<span class="built_in">wait</span>(Mutex::_no_safepoint_check_flag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">      os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state == ZOMBIE) &#123;</span><br><span class="line">      thread-&gt;<span class="built_in">set_osthread</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//线程处于初始化完成状态</span></span><br><span class="line">  <span class="built_in">assert</span>(state == INITIALIZED, <span class="string">&quot;race condition&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>调用<code>pthread_create</code>函数，让操作系统创建线程</li>
<li>线程创建完成之后调用<code>java_start</code>方法初始化线程</li>
<li>等待子线程创建完成或者中止</li>
</ul>
<p>我们知道线程创建之后要初始化，而线程初始化则关键在java_start方法中</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">java_start</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pid = os::<span class="built_in">current_process_id</span>();</span><br><span class="line">  <span class="built_in">alloca</span>(((pid ^ counter++) &amp; <span class="number">7</span>) * <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">  ThreadLocalStorage::<span class="built_in">set_thread</span>(thread);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  Monitor* sync = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_thread_safety_check(thread)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">    osthread-&gt;<span class="built_in">set_state</span>(ZOMBIE);</span><br><span class="line">    sync-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_thread_id</span>(os::Linux::<span class="built_in">gettid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">    <span class="type">int</span> lgrp_id = os::<span class="built_in">numa_get_group_id</span>();</span><br><span class="line">    <span class="keyword">if</span> (lgrp_id != <span class="number">-1</span>) &#123;</span><br><span class="line">      thread-&gt;<span class="built_in">set_lgrp_id</span>(lgrp_id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  os::Linux::<span class="built_in">hotspot_sigmask</span>(thread);</span><br><span class="line"></span><br><span class="line">  os::Linux::<span class="built_in">init_thread_fpu_state</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程为初始化完成</span></span><br><span class="line">    osthread-&gt;<span class="built_in">set_state</span>(INITIALIZED);</span><br><span class="line">    <span class="comment">//唤醒所有线程</span></span><br><span class="line">    sync-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋判断线程是否是初始化完成</span></span><br><span class="line">    <span class="keyword">while</span> (osthread-&gt;<span class="built_in">get_state</span>() == INITIALIZED) &#123;</span><br><span class="line">      sync-&gt;<span class="built_in">wait</span>(Mutex::_no_safepoint_check_flag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程被notify/notifyAll唤醒执行run方法</span></span><br><span class="line">  thread-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>初始化线程</li>
<li>当初始化线程完成之后设置线程生命状态：<strong>INITIALIZED</strong></li>
<li><code>notify_all()</code>唤醒线程</li>
<li><code>wait()</code>挂起线程，使其初始化完成</li>
<li>线程被唤醒之后调用<code>thread_run()</code>方法</li>
</ul>
<p>绑定线程成功之后调用start方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">trace</span>(<span class="string">&quot;start&quot;</span>, thread);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!DisableStartThread) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;<span class="built_in">is_Java_thread</span>()) &#123;</span><br><span class="line">      java_lang_Thread::<span class="built_in">set_thread_status</span>(((JavaThread*)thread)-&gt;<span class="built_in">threadObj</span>(),</span><br><span class="line">                                          java_lang_Thread::RUNNABLE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用具体操作系统对应的启动线程方法</span></span><br><span class="line">    os::<span class="built_in">start_thread</span>(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>调用操作系统启动线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// guard suspend/resume</span></span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="comment">//将线程设置成Runnable状态</span></span><br><span class="line">  osthread-&gt;<span class="built_in">set_state</span>(RUNNABLE);</span><br><span class="line">  <span class="comment">//调用方法去唤醒线程</span></span><br><span class="line">  <span class="built_in">pd_start_thread</span>(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::pd_start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  OSThread * osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="built_in">assert</span>(osthread-&gt;<span class="built_in">get_state</span>() != INITIALIZED, <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line">  Monitor* sync_with_child = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  <span class="comment">//唤醒线程，使其能够去执行run方法</span></span><br><span class="line">  sync_with_child-&gt;<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="run"   >
          <a href="#run" class="heading-link"><i class="fas fa-link"></i></a><a href="#run" class="headerlink" title="run"></a>run</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Thread类中实现了Runnable接口，所以重写了run方法</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果有具体的任务，那么就调用具体任务的run方法(我们重写的run方法)</span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Runnable接口实现类,具体线程需要做的内容</span></span><br><span class="line">	<span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></div></figure>



<p>而在操作系统之后创建了线程那么如何执行run方法的呢？</p>
<p>我们找到thread.cpp中的run方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化一些数据</span></span><br><span class="line">  <span class="built_in">this</span>-&gt;initialize_tlab();</span><br><span class="line">  <span class="built_in">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class="line">  <span class="built_in">this</span>-&gt;record_stack_base_and_size();</span><br><span class="line">  <span class="built_in">this</span>-&gt;initialize_thread_local_storage();</span><br><span class="line">  <span class="built_in">this</span>-&gt;create_stack_guard_pages();</span><br><span class="line">  <span class="built_in">this</span>-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  ThreadStateTransition::transition_and_fence(<span class="built_in">this</span>, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="built_in">this</span>, <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">assert</span>(!Thread::current()-&gt;owns_locks(), <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  DTRACE_THREAD_PROBE(start, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  EventThreadStart event;</span><br><span class="line">  <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">     event.set_javalangthread(java_lang_Thread::thread_id(<span class="built_in">this</span>-&gt;threadObj()));</span><br><span class="line">     event.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  thread_main_inner();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个run方法主要做的事：</p>
<ul>
<li>初始化一些数据</li>
<li>调用<code>thread_main_inner()</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="built_in">this</span>, <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">this</span>-&gt;threadObj() != NULL, <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正常情况下会回到线程入口，除非有异常挂起</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">      !java_lang_Thread::is_stillborn(<span class="built_in">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      ResourceMark <span class="title function_">rm</span><span class="params">(<span class="built_in">this</span>)</span>;</span><br><span class="line">      <span class="comment">//设置线程name</span></span><br><span class="line">      <span class="built_in">this</span>-&gt;set_native_thread_name(<span class="built_in">this</span>-&gt;get_thread_name());</span><br><span class="line">    &#125;</span><br><span class="line">    HandleMark <span class="title function_">hm</span><span class="params">(<span class="built_in">this</span>)</span>;</span><br><span class="line">    <span class="comment">//回到线程入口</span></span><br><span class="line">    <span class="built_in">this</span>-&gt;entry_point()(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(stop, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>-&gt;exit(<span class="literal">false</span>);</span><br><span class="line">  delete <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事：</p>
<ul>
<li>如果正常情况下会回到线程入口</li>
</ul>
<p><strong>线程入口</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> &#123;</span><br><span class="line">  HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">  Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">  JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),<span class="comment">//回调我们自己重写的run方法</span></span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法在这里做的事：</p>
<ul>
<li>回调 <code>vmSymbols::run_method_name()</code>：回到我们自己重写的run方法</li>
</ul>

        <h4 id="yield"   >
          <a href="#yield" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield" class="headerlink" title="yield"></a>yield</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>这个方法又是native方法，所以我们找到<code>Thread.c</code>中的方法注册表，找到对应的方法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,<span class="comment">//这就是我们要找到的yield方法对应关系</span></span><br><span class="line">	<span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中代码</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_Yield</span>(JNIEnv *env, jclass threadClass))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_Yield&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (os::<span class="built_in">dont_yield</span>()) <span class="keyword">return</span>; <span class="comment">//如果操作系统不允许让出CPU，那么直接返回(不让频繁yield浪费性能)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE0</span>(hotspot, thread__yield);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_YIELD</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断操作系统对应的yield要不要让线程休眠</span></span><br><span class="line">  <span class="keyword">if</span> (ConvertYieldToSleep) &#123;</span><br><span class="line">    os::<span class="built_in">sleep</span>(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//调用相应操作系统yield方法</span></span><br><span class="line">    os::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>判断是否能让出CPU，如果频繁<code>yield</code>则会浪费性能</li>
<li>调用操作系统中的yield方法，具体看操作系统的方法实现</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sched_yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="join"   >
          <a href="#join" class="heading-link"><i class="fas fa-link"></i></a><a href="#join" class="headerlink" title="join"></a>join</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);<span class="comment">//调用有参重载函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用有参重载函数</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果没有等待时间</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//运行到这里是有等待时间</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="comment">//如果现在已经超出了超出等待时间，那么就结束方法</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，调用wait方法阻塞，时长为delay</span></span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>调用<code>isAlive</code>方法，判断当前线程是否结束</p>
</li>
<li><p>没有等待时间，那么就调用<code>wait(0)</code>，等待线程唤醒直至当前线程死亡</p>
</li>
<li><p>如果有等待时间，那么就调用<code>wait(delay)</code>，等待超时或者当前线程死亡</p>
</li>
</ul>
<p><code>isAlive</code>方法是native方法，所以找到jvm.cpp中相关方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_IsThreadAlive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">oop</span> <span class="variable">thread_oop</span> <span class="operator">=</span> JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="keyword">return</span> java_lang_Thread::is_alive(thread_oop);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>返回线程是否结束</li>
</ul>

        <h5 id="join方法使用案例"   >
          <a href="#join方法使用案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#join方法使用案例" class="headerlink" title="join方法使用案例"></a>join方法使用案例</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestJoinMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>); <span class="comment">//模拟线程执行逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);<span class="comment">//模拟线程执行逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让主线程等待t1和t2完成逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>正因为有<code>t1.join</code>以及<code>t2.join</code>所以主线程会等待t1和t2线程完成之后再执行后序任务</p>
<p> 也即最后执行结果是如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">2</span>已经完成</span><br><span class="line">Thread-<span class="number">3</span>已经完成</span><br><span class="line">主线程已经结束</span><br></pre></td></tr></table></div></figure>




        <h4 id="stop"   >
          <a href="#stop" class="heading-link"><i class="fas fa-link"></i></a><a href="#stop" class="headerlink" title="stop"></a>stop</h4>
      <p>这个方法已经被废弃，但是为了提到如何优雅结束线程，我们要从这个最见名知意的stop方法开始看如何结束线程</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">           checkAccess();</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">               security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">           resume(); <span class="comment">// Wake up thread if it was suspended; no-op otherwise</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用stop0方法真正结束线程</span></span><br><span class="line">       stop0(<span class="keyword">new</span> <span class="title class_">ThreadDeath</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>stop0</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></div></figure>

<p>不出意料地，这个方法果然又是native方法，所以我们还是继续找到源码去看具体做了什么事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中代码</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StopThread</span>(JNIEnv* env, jobject jthread, jobject throwable))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StopThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">  oop java_throwable = JNIHandles::<span class="built_in">resolve</span>(throwable);</span><br><span class="line">  <span class="keyword">if</span> (java_throwable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//空指针异常</span></span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_NullPointerException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oop java_thread = JNIHandles::<span class="built_in">resolve_non_null</span>(jthread);</span><br><span class="line">  JavaThread* receiver = java_lang_Thread::<span class="built_in">thread</span>(java_thread);</span><br><span class="line">  Events::<span class="built_in">log_exception</span>(JavaThread::<span class="built_in">current</span>(),</span><br><span class="line">                        <span class="string">&quot;JVM_StopThread thread JavaThread &quot;</span> INTPTR_FORMAT <span class="string">&quot; as oop &quot;</span> INTPTR_FORMAT <span class="string">&quot; [exception &quot;</span> INTPTR_FORMAT <span class="string">&quot;]&quot;</span>,</span><br><span class="line">                        <span class="built_in">p2i</span>(receiver), <span class="built_in">p2i</span>((address)java_thread), <span class="built_in">p2i</span>(throwable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果线程还在活动，那么可能产生了异常</span></span><br><span class="line">  <span class="keyword">if</span> (receiver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      </span><br><span class="line">  	<span class="comment">//是否是self产生</span></span><br><span class="line">    <span class="keyword">if</span> (java_thread == thread-&gt;<span class="built_in">threadObj</span>()) &#123;</span><br><span class="line">      <span class="built_in">THROW_OOP</span>(java_throwable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//暂停所有线程，传递异常</span></span><br><span class="line">      Thread::<span class="built_in">send_async_exception</span>(java_thread, JNIHandles::<span class="built_in">resolve</span>(throwable));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//反之 1.线程在停止前未启动 2.线程已经停止  </span></span><br><span class="line">   </span><br><span class="line">    java_lang_Thread::<span class="built_in">set_stillborn</span>(java_thread);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法做的事：</p>
<ul>
<li>强制线程进入<strong>线程安全点</strong>，这可能会导致有部分代码会没能执行完毕，假如一个业务逻辑并未执行完成就被强制结束线程，那么可能会对整个业务造成影响</li>
<li>如果发起结束线程是自身线程那么就不需要安全点</li>
</ul>
<p>利用stop方法来停机是不优雅的，所以我们要优雅结束线程需要用到线程中断</p>

        <h4 id="interrupt"   >
          <a href="#interrupt" class="heading-link"><i class="fas fa-link"></i></a><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//如果不是自身中断，那么检查是否有权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//设置中断标志位</span></span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>interrupt0()</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>



<p>因此我们找到方法注册表，看看究竟是个什么事</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p><code>jvm.cpp</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_Interrupt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren&#x27;t freed before we operate</span></span><br><span class="line">  <span class="type">oop</span> <span class="variable">java_thread</span> <span class="operator">=</span> JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  MutexLockerEx <span class="title function_">ml</span><span class="params">(thread-&gt;threadObj()</span> == java_thread ? NULL : Threads_lock);</span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    <span class="comment">//设置中断标志位</span></span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>Thread::interrupt(thr)</code></li>
</ul>
<p><code>thread.cpp</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(<span class="string">&quot;interrupt&quot;</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用操作系统具体的<code>interrupt</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(Thread::<span class="built_in">current</span>() == thread || Threads_lock-&gt;<span class="built_in">owned_by_self</span>(),</span><br><span class="line">    <span class="string">&quot;possibility of dangling Thread pointer&quot;</span>);</span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;<span class="built_in">interrupted</span>()) &#123;</span><br><span class="line">    osthread-&gt;<span class="built_in">set_interrupted</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//加屏障，让unpark()之前对其他线程可见    </span></span><br><span class="line">    OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">    ParkEvent * <span class="type">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;<span class="built_in">is_Java_thread</span>())</span><br><span class="line">    ((JavaThread*)thread)-&gt;<span class="built_in">parker</span>()-&gt;<span class="built_in">unpark</span>();</span><br><span class="line">    </span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="小结-1"   >
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4>
      <ul>
<li>start</li>
</ul>
<ol>
<li>操作系统调用<code>pthread_create</code>指令创建了一个线程，并且和JavaThread相关联</li>
<li>Java中的Thread对象和操作系统中创建线程相关联，做到了真正的创建线程</li>
<li>让初始化完成之后会被唤醒之后执行run方法</li>
</ol>
<ul>
<li><p>run</p>
<p>正常情况下会回调我们自己写的run方法</p>
</li>
<li><p>join</p>
<p>让某线程等待调用了join方法的线程结束，使用于异步线程执行完结果之后的场景</p>
</li>
<li><p>yield</p>
<p>让当前线程让出cpu，根据对应操作系统的线程调度，让优先级高的可能获取到时间片，但是不会释放对象锁</p>
</li>
<li><p>stop</p>
<p>强制结束线程，并且stop会释放对象锁所以可能会造成数据的不安全</p>
</li>
<li><p>interrupt</p>
<p>线程中断，当线程执行完相应逻辑并感应到线程中断可以自己选择该如何响应中断，相较于stop方法的强制执行更加温柔更加优雅</p>
</li>
<li><p>sleep </p>
<p>让线程从<code>Runnable</code>的执行状态到<code>TIMED_WAITNG</code>状态，会让线程睡眠，但是不会释放对象锁</p>
</li>
</ul>

        <h2 id="线程的通知机制"   >
          <a href="#线程的通知机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程的通知机制" class="headerlink" title="线程的通知机制"></a>线程的通知机制</h2>
      <p>这里的通知机制有：1.Volatile关键字 。 **2.通知唤醒机制(wait&#x2F;notify)**。 3.条件队列通知机制(await&#x2F;signal) </p>
<p>因为Volatile关键字以及条件队列的通知唤醒机制我们在之前的场景说过了,所以我们这里着重将第二点wait&#x2F;notify</p>

        <h3 id="wait"   >
          <a href="#wait" class="heading-link"><i class="fas fa-link"></i></a><a href="#wait" class="headerlink" title="wait"></a>wait</h3>
      <p><code>thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>找到有参方法，发现又是一个native方法，所以我们又要找到注册表</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hashCode&quot;</span>,    <span class="string">&quot;()I&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;wait&quot;</span>,        <span class="string">&quot;(J)V&quot;</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notify&quot;</span>,      <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notifyAll&quot;</span>,   <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;clone&quot;</span>,       <span class="string">&quot;()Ljava/lang/Object;&quot;</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorWait</span>(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorWait&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  <span class="function">JavaThreadInObjectWaitState <span class="title">jtiows</span><span class="params">(thread, ms != <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_wait</span>()) &#123;</span><br><span class="line">    JvmtiExport::<span class="built_in">post_monitor_wait</span>((JavaThread *)THREAD, (oop)<span class="built_in">obj</span>(), ms);</span><br><span class="line">      <span class="comment">//该线程已经获取了监视器，但是还没有添加到等待队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用同步器中的wait方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">wait</span>(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>ObjectSynchronizer::wait</code></li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::wait</span><span class="params">(Handle obj, jlong millis, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">//如果持有偏向锁</span></span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果阻塞时间小于0</span></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">TEVENT</span> (wait - <span class="keyword">throw</span> IAX) ;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>(), <span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectMonitor* monitor = ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>());</span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_WAIT_PROBE</span>(monitor, <span class="built_in">obj</span>(), THREAD, millis);</span><br><span class="line">  <span class="comment">//调用monitor的wait方法</span></span><br><span class="line">  monitor-&gt;<span class="built_in">wait</span>(millis, <span class="literal">true</span>, THREAD);</span><br><span class="line">  <span class="built_in">dtrace_waited_probe</span>(monitor, obj, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>如果是偏向锁的情况下会消除偏向状态</li>
<li>调用monitor的wait方法</li>
</ul>

        <h3 id="notify"   >
          <a href="#notify" class="heading-link"><i class="fas fa-link"></i></a><a href="#notify" class="headerlink" title="notify"></a>notify</h3>
      <p><code>thread.java</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>因此找到cpp中的代码</p>
<p><code>jvm.cpp</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorNotify</span>(JNIEnv* env, jobject handle))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorNotify&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  <span class="comment">//调用同步器的notify方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">notify</span>(obj, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的<code>notify</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::notify</span><span class="params">(Handle obj, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">notify</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的冲突情况下唤醒线程Thread</li>
</ul>

        <h3 id="notifyAll"   >
          <a href="#notifyAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3>
      <p><code>thread.java</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>因此找到cpp中的代码</p>
<p><code>jvm.cpp</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorNotifyAll</span>(JNIEnv* env, jobject handle))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorNotifyAll&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">notifyall</span>(obj, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的<code>notifyall</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::notifyall</span><span class="params">(Handle obj, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">notifyAll</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的冲突情况下唤醒全部线程</li>
</ul>

        <h3 id="小结-2"   >
          <a href="#小结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3>
      
        <h4 id="sleep、wait、yield方法比较"   >
          <a href="#sleep、wait、yield方法比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#sleep、wait、yield方法比较" class="headerlink" title="sleep、wait、yield方法比较"></a>sleep、wait、yield方法比较</h4>
      <ul>
<li><p><strong>sleep</strong>、<strong>yield</strong>不会释放锁，而<strong>wait</strong>会释放锁</p>
</li>
<li><p><strong>sleep</strong>方法到了时间之后会自己苏醒（也可以感知线程中断而结束休眠），<strong>wait</strong>方法进入等待队列之后必须要调用同一个对象的<code>notify</code>&#x2F;<code>notifyAll</code>唤醒</p>
</li>
<li><p><strong>sleep</strong>方法作用于线程休眠<strong>暂停执行</strong>，而<strong>wait</strong>方法常用于线程之间通信</p>
</li>
<li><p><strong>sleep</strong>方法是Thread类的静态本地方法，因为一个线程休眠只是使线程自己休眠，不会涉及到锁的释放</p>
<p><strong>wait</strong>方法是Object类的本地方法，每个对象阻塞需要释放对象锁，因此应该操作对象（object）而不是线程</p>
</li>
</ul>

        <h1 id="线程池-1"   >
          <a href="#线程池-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h1>
      <p>线程池的引入是为了避免在并发情况下，如果线程执行逻辑很短则需要频繁创建、结束线程，而我们知道线程是一个很重要的资源，所以我们可以利用线程池来复用线程，来避免频繁创建、销毁的操作。</p>
<p>我们可以从Executors（线程池框架）着手对线程池的学习，而我们要知道阿里Java开发手册中禁止使用Excutors来创建线程池，我们会慢慢知道这是为什么？</p>
<p>我们可以从Executors创建三种线程池CachedThreadPool、FixedThreadPool、SingleThreadPool。从这三个线程池开始入手</p>

        <h2 id="CachedThreadPool"   >
          <a href="#CachedThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newCachedThreadPool方法</li>
</ul>
<p><strong>newCachedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="SignleThreadPool"   >
          <a href="#SignleThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#SignleThreadPool" class="headerlink" title="SignleThreadPool"></a>SignleThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SingleThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singlePool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            singlePool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newSingleThreadPool方法</li>
</ul>
<p><strong>newSingleThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (	<span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="FixedThreadPool"   >
          <a href="#FixedThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FixedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newFixedThreadPool方法</li>
</ul>
<p><strong>newFixedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="ThreadPoolExecutor"   >
          <a href="#ThreadPoolExecutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2>
      <p>因此我们都能发现都是返回的ThreadPoolExecutors对象，只是传入的参数不一样，所以我们要认识线程池就得认识ThreadPoolExecutor</p>
<p>我们可以用一个自定义线程池的Demo简单看看这个类到底怎么用</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MyThreadPoolDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">5</span>,	<span class="comment">//核心线程数</span></span><br><span class="line">                <span class="number">10</span>,	<span class="comment">//最大线程数</span></span><br><span class="line">                <span class="number">60L</span>,<span class="comment">//空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">5</span>)<span class="comment">//阻塞队列</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数（范围0~Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大线程数(范围1~Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非核心线程空闲时的超时时间(范围0~Long.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的拒绝策略(抛出异常并且拒绝执行任务)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//移位29位，高3位表示线程池状态，低29位表示线程数量(000 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池最大线程数量1左移29位再-1(000 11111111111111111111111111111)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池运行状态（高三位）</span></span><br><span class="line"><span class="comment">//正在运行(111 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭中(000 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止中(001 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整理中(010 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已终止(011 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁，用于保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池已有线程集合，因为是HashSet结构所以对数据做修改的时候需要加锁处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池中曾经拥有线程的最大数量 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计线程池完成任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心线程是否按照keepAliveTime存活，默认为false(也即核心线程空闲也保持活跃)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>线程池的五种状态</p>
<ul>
<li>RUNNING(-1):运行中，可以正常接收任务，能处理workQueue中的任务</li>
<li>SHUTDOWN(0):关闭中，不能接收新的任务，但是能处理workQueue中的任务</li>
<li>STOP(1):停止中，不能接收新的任务，也不再处理workQueue中的任务，会中断还在执行任务的线程</li>
<li>TIDYING(2):整理中，所有任务已经完成，并且线程数量为0，等待调用terminated()方法进入终止状态</li>
<li>TERMINATED(3)：线程池已经终止</li>
</ul>

        <h3 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,						//核心线程数</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,				//最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,				//超时存活时间</span></span><br><span class="line"><span class="params">                              TimeUnit unit,					//时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务排队队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,		//线程工厂</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler	//拒绝策略</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">    	<span class="comment">//校验参数的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//为成员变量赋值</span></span><br><span class="line">        <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>另外三个重载的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="内部类"   >
          <a href="#内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3>
      
        <h4 id="Worker"   >
          <a href="#Worker" class="heading-link"><i class="fas fa-link"></i></a><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计线程完全任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造方法    </span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">//更新线程状态成-1(阻塞)，目的是在运行worker之前禁止线程中断</span></span><br><span class="line">        </span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);<span class="comment">//调用线程工厂创建线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试解锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        	<span class="comment">//设置锁持有线程为空</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        	</span><br><span class="line">        	<span class="comment">//将线程状态置为0(运行中)</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="CallerRunsPolicy"   >
          <a href="#CallerRunsPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4>
      
        <h4 id="AbortPolicy"   >
          <a href="#AbortPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4>
      
        <h4 id="DiscardPolicy"   >
          <a href="#DiscardPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4>
      
        <h4 id="DiscardOldestPolicy"   >
          <a href="#DiscardOldestPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4>
      <p>这四个内部类是具体的拒绝策略，我们在这里先不看，会单独出一个来讲拒绝策略</p>
<p>因此我们可以获得<code>ThreadPoolExecutor</code>的结构图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231113181935844.png"  alt="ThreadPoolExecutor">
      </p>

        <h3 id="execute"   >
          <a href="#execute" class="heading-link"><i class="fas fa-link"></i></a><a href="#execute" class="headerlink" title="execute"></a>execute</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//对线程任务做非空判断</span></span><br><span class="line">    	<span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//获取到线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/*下面一共三种情况</span></span><br><span class="line"><span class="comment">    		1.已有核心线程数没有到最大核心线程数（还有核心线程可以创建）</span></span><br><span class="line"><span class="comment">    		2.线程池还在运行，并且任务能成功排队</span></span><br><span class="line"><span class="comment">    		3.任务不能排队，那么尝试新建一个线程来执行任务</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况1：已有工作线程小于最大核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//添加工作线程，将任务作为初始任务交给新线程，成功后结束方法</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况2：如果线程池还在运行，并且任务成功添加到等待队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//复查，如果线程池要停止运行或者已经停止运行并且成功从池中移除任务</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">//拒绝任务</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//新起一个空初始任务线程</span></span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况3：如果我们不能对任务进行排队，那么尝试新建一个线程执行任务，如果失败了我们就拒绝执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            <span class="comment">//拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>execute方法做的事</p>
<ul>
<li><p>如果已有线程数小于最大核心线程数（任务能提交到核心线程中）</p>
<p>将任务交给新的核心线程执行<code>addWorker(command,true)</code></p>
</li>
<li><p>如果线程池还在运行并且任务能够成功添加到等待队列中</p>
<ol>
<li>复查，线程池停止运行（不能接受任务）并且任务从队列中去除：拒绝任务</li>
<li>线程池还在运行，那么新起一个新的空线程</li>
</ol>
</li>
<li><p>如果我们不能对任务进行排队，那么尝试新建一个线程执行任务，失败了就拒绝执行任务</p>
</li>
</ul>
<p>以下是简化版流程图,假设核心线程数为10，最大线程数为20，队列容量为10，即将有50个任务待执行</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231114000324848.png"  alt="简化版流程图">
      </p>

        <h3 id="addWorker"   >
          <a href="#addWorker" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">//循环入口retry，判断线程池是否能够添加线程    </span></span><br><span class="line">    retry: 			</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           	<span class="comment">//获取线程池控制状态c和运行状态rs</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			这里判断添加线程失败需要满足两个条件：</span></span><br><span class="line"><span class="comment">				1.线程池状态需要大于等于SHUTDOWN (0) ，也即线程池正在关闭或者已经关闭</span></span><br><span class="line"><span class="comment">				2.第二个判断为false，有以下三种情况：</span></span><br><span class="line"><span class="comment">					2.1: rs!=SHUTDOWN (0)也即rs&gt;0，线程池已经关闭</span></span><br><span class="line"><span class="comment">					2.2: rs==SHUTDOWN &amp;&amp; firstTask != null 也即线程池正在关闭，还有未执行的初始任务也不允许创建新线程</span></span><br><span class="line"><span class="comment">					2.3: rs==SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty() 也即线程池正在关闭，排队队列为空</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">			也即当满足添加线程的条件：</span></span><br><span class="line"><span class="comment">				1.线程池状态小于SHUTDOWN，表示线程池还在运行中能够添加线程</span></span><br><span class="line"><span class="comment">				2.线程池处于关闭状态 &amp;&amp; firstTask==null &amp;&amp;!workQueue.isEmpty()</span></span><br><span class="line"><span class="comment">                	表示线程池正在关闭，排队队列中还有任务未执行</span></span><br><span class="line"><span class="comment">                	</span></span><br><span class="line"><span class="comment">               	也即当线程池关闭状态不接受新任务，但是能处理完已有任务</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">//运行到这里说明线程池能够添加线程</span></span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取现在已有线程数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果已有线程数超出了线程池最大限制(2的29次方-1)或者创建对应线程失败</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="comment">//已有线程数大于核心线程数创建核心线程失败（core为true表示创建核心线程）</span></span><br><span class="line">                    <span class="comment">//已有线程数大于总线程数创建非核心线程失败（core为false表示创建非核心线程）</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS添加线程数成功，跳出外层retry循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//运行到这里CAS失败，重新拉取线程池状态</span></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果线程池状态已经改变则重新判断线程池是否能够添加线程，回到外层循环retry</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//线程池状态没有改变，CAS失败，重新尝试CAS添加线程数，回到内层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//跳出retry循环，下面开始真正创建线程</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//线程启动成功标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//添加线程成功标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//线程标记</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建worker</span></span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">            <span class="comment">//获取线程t</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取锁，因为workers是HashSet结构，所以加锁保证线程安全</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//复查线程池状态</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//如果线程池处于RUNNING（可以创建线程）</span></span><br><span class="line">                    <span class="comment">//或者线程池处于正在关闭并且没有初始任务，那么可以创建线程来处理WorkQueue中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//线程池可以添加新的线程</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//如果线程t已经启动，那么抛出异常（还没有start启动线程但是线程t已经启动说明有问题）</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//当w添加到workers集合中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="comment">//如果工作线程数大于池有过最大线程数，那么更新池有过最大线程数</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        <span class="comment">//将线程添加成功标记置为true</span></span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//解锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果线程成功添加</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">//start启动，并将启动标记置为true</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//添加线程失败，调用addWorkerFailed方法</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//返回线程是否启动成功</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>addWorker逻辑上做了两件事：</p>
<ol>
<li>判断线程池是否能够创建线程<ul>
<li>线程池处于<strong>RUNNING</strong>(运行中)的时候可以接收新的任务也可以处理等待队列(WorkQueue)中的任务</li>
<li>线程池处于**SHUTDOWN(**关闭中)的时候不可以接收新的任务，但是可以处理等待队列<code>WorkQueue</code>中的任务</li>
<li>CAS操作，增加线程数</li>
</ul>
</li>
<li>创建线程，并将worker添加到线程池中<ul>
<li>加锁（因为workers是HashSet集合所以为了线程安全而加锁）</li>
<li>复查线程池状态，确保是可以创建线程状态</li>
<li>检查worker状态，并将正常worker添加到线程池中<code>workers</code>集合</li>
<li>解锁</li>
<li>添加线程成功，调用<code>t.start()</code>启动线程</li>
</ul>
</li>
</ol>
<p>如果创建线程失败，最终会调用addWorkerFailed方法，所以我们看一下如果线程添加失败之后会做什么事</p>

        <h3 id="addWorkerFailed"   >
          <a href="#addWorkerFailed" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取到worker的锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//加锁，因为workers是Hashset结构，所以保证线程安全</span></span><br><span class="line">    	mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">                workers.remove(w); <span class="comment">//将workers中去除失败的w</span></span><br><span class="line">            decrementWorkerCount();<span class="comment">//CAS将线程数--，因为addWorker的时候判断线程池可以创建线程的时候CAS线程数++</span></span><br><span class="line">            tryTerminate();<span class="comment">//可能线程池状态变化或者有问题，于是尝试结束线程池</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>如果创建线程失败：</p>
<ul>
<li>加锁，减去线程池中workers的失败worker</li>
<li>CAS将线程数–</li>
<li>尝试关闭线程池 <del>(因为线程失败是线程池状态出现问题)</del></li>
</ul>

        <h4 id="decrementWorkerCount"   >
          <a href="#decrementWorkerCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#decrementWorkerCount" class="headerlink" title="decrementWorkerCount"></a>decrementWorkerCount</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//自旋直到CAS成功，也即直到线程池的线程数成功-1</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line"> 		<span class="comment">//CAS，将线程数-1</span></span><br><span class="line">    	<span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>CAS将线程数–</p>

        <h4 id="tryTerminate"   >
          <a href="#tryTerminate" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">    	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池控制状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断线程池是否可以结束</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||					<span class="comment">//如果线程池正在运行，则不允许结束</span></span><br><span class="line">                runStateAtLeast(c, TIDYING) ||	<span class="comment">//如果线程池处于整理或者已经结束</span></span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))	<span class="comment">//如果线程池在停止中，但是还有任务没完成</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//有资格结束线程池</span></span><br><span class="line">            <span class="comment">//如果还有存活线程，则先让线程自身中断</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//运行到这里说明线程池可以结束</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//把线程池加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//尝试CAS将线程池更新成TIDYING（整理中）状态</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//终止线程池</span></span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//将线程池更新成(TERMINATED)终止状态</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法做的事就两件</p>
<ul>
<li>判断线程池的状态是否能结束</li>
<li>如果线程池能结束，那么上锁结束线程池</li>
</ul>

        <h3 id="runWorker"   >
          <a href="#runWorker" class="heading-link"><i class="fas fa-link"></i></a><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3>
      <p>线程经过<code>t.start()</code>启动之后会调用<code>run()</code>方法，而<code>Worker</code>中的<code>run()</code>方法会调用<code>runWorker()</code>方法，所以我们当创建线程成功之后启动线程之后要来到这个runWorker方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    	<span class="comment">//task记录worker的初始任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//将worker的第一个线程置空</span></span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//将线程解锁，允许中断（因为会调用tryRelease()方法更新线程状态为0)</span></span><br><span class="line">        w.unlock();</span><br><span class="line">    	<span class="comment">//判断线程是否异常退出，默认为true，如果成功执行则会置为false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*while循环有两个情况可以进入：</span></span><br><span class="line"><span class="comment">            	1.task!=null,这个说明线程携带初始任务，那么优先执行初始任务</span></span><br><span class="line"><span class="comment">            	2.task==null &amp;&amp; (task=getTask())!=null,说明线程一开始没有初始任务，但是从排队队列中获取到了任务</span></span><br><span class="line"><span class="comment">            	</span></span><br><span class="line"><span class="comment">            	也即线程优先做初始任务，然后再从WorkQueue中获取任务</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">				</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	这个IF语句有两种情况，并且当前线程不是中断状态：</span></span><br><span class="line"><span class="comment">                		1.线程池状态大于等于STOP,说明线程池中线程要被中断</span></span><br><span class="line"><span class="comment">                		2.线程池状态小于STOP，则线程不应该出现中断，</span></span><br><span class="line"><span class="comment">                		但是此时Thread.interrupted()为true说明出现了线程中断并且清空了线程中断标志位</span></span><br><span class="line"><span class="comment">                		那么有可能是线程池调用了shutdownNow方法</span></span><br><span class="line"><span class="comment">                		所以重新判断线程池状态，如果线程池状态为STOP则需要执行线程中断</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">//中断线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行前执行的钩子函数，可以子类重写该方法来达到目的</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//运行任务，调用任务的run方法</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//任务执行之后执行的钩子函数，可以子类重写该方法达到目的</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行完成，置空任务，线程任务完成数++，解锁</span></span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程正常处理任务，所以将异常退出标志置为false</span></span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*一定会运行到这里，而运行到这里有两种可能：</span></span><br><span class="line"><span class="comment">            	1.作业队列没有任务了，调用processWorkerExit()方法</span></span><br><span class="line"><span class="comment">            	2.某个线程出现执行过程中产生异常，此时completedAbruptly=true</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>worker的调用run方法会来到这个方法，而这个方法所做的事</p>
<ul>
<li>如果线程有初始任务那么就执行初始任务，完成之后相应计数++</li>
<li>如果线程没有初始任务，那么去尝试获取任务队列(workQueue)中的任务</li>
<li>如果队列中没有任务或者线程执行某任务出错，那么就会进入finally语句中的<code>processWorkerExit()</code>方法中</li>
</ul>

        <h3 id="processWorkerExit"   >
          <a href="#processWorkerExit" class="heading-link"><i class="fas fa-link"></i></a><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	到这个方法有两种可能：</span></span><br><span class="line"><span class="comment">		1.队列中没有任务，线程正常结束，参数completedAbruptly为false</span></span><br><span class="line"><span class="comment">		2.线程执行任务中出现异常，线程异常结束，参数completedAbruptly为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//如果线程出现异常结束，cas将线程池线程数-1</span></span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//加锁，因为要操作workers集合，保证安全</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//统计线程完成数</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将worker移出workers集合中</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//因为线程结束，所以尝试关闭线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//获取线程池控制状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//如果线程池运行状态&lt;STOP，也即RUNNING、SHUTDOWN之一，还能够执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果线程是正常退出也即队列中没有任务了(正常退出completedAbruptly为false)</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">//获取线程池最小的核心线程数min，如果核心线程有存活时间则是0，反之为corePoolSize</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果最少线程数为0但是队列中还有任务，则保持最少有一个线程存活来执行队列中任务</span></span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果线程池已有线程数量足够支持，那么就不添加线程</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果线程执行异常结束，增加一个空任务线程</span></span><br><span class="line">            <span class="comment">//如果线程是正常结束，但是线程池需要最少一个线程来维持队列任务，所以增加一个空任务线程</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>当线程结束的情况下有两种可能：队列没有任务、线程执行任务异常结束</p>
<ul>
<li>队列没有任务，线程正常结束，线程数–</li>
<li>线程异常结束，会添加一个空线程来执行任务</li>
</ul>

        <h3 id="钩子函数"   >
          <a href="#钩子函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3>
      
        <h4 id="beforeExecute"   >
          <a href="#beforeExecute" class="heading-link"><i class="fas fa-link"></i></a><a href="#beforeExecute" class="headerlink" title="beforeExecute"></a>beforeExecute</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//空方法，由子类实现，在执行前执行</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="afterExecute"   >
          <a href="#afterExecute" class="heading-link"><i class="fas fa-link"></i></a><a href="#afterExecute" class="headerlink" title="afterExecute"></a>afterExecute</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//空方法，由子类实现，在执行后执行</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="拒绝策略"   >
          <a href="#拒绝策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3>
      
        <h4 id="CallerRunPolicy"   >
          <a href="#CallerRunPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#CallerRunPolicy" class="headerlink" title="CallerRunPolicy"></a>CallerRunPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                <span class="comment">//如果线程池未停止，那么由调用execute方法的线程执行任务</span></span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>如果线程池没有关闭，由线程池调用execute方法的线程来执行这个任务</p>

        <h4 id="AbortPolicy-1"   >
          <a href="#AbortPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbortPolicy-1" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="comment">///构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//抛出RejectedExecutionException异常</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>抛出<code>RejectedExecution</code>异常拒绝执行任务</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//而这也是默认的拒绝策略（抛出异常并拒绝执行任务）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h4 id="DiscardPolicy-1"   >
          <a href="#DiscardPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardPolicy-1" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//什么都不做，直接抛弃任务</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>什么都不做，直接抛弃任务</p>

        <h4 id="DiscardOldestPolicy-1"   >
          <a href="#DiscardOldestPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardOldestPolicy-1" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    	<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//抛弃第一个任务（最久的），然后将当前任务重新入队</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>抛弃第一个任务，然后将当前任务重新入队</p>
<div class="table-container"><table>
<thead>
<tr>
<th>拒绝策略</th>
<th>具体做法</th>
</tr>
</thead>
<tbody><tr>
<td>CallerRunPolicy</td>
<td>如果线程池没有关闭，由线程池调用execute方法的线程来执行这个任务</td>
</tr>
<tr>
<td>AbortPolicy</td>
<td>抛出<code>RejectedExecution</code>异常拒绝执行任务</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>什么都不做，直接抛弃任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>抛弃第一个任务，然后将当前任务重新入队</td>
</tr>
</tbody></table></div>

        <h2 id="常见问题"   >
          <a href="#常见问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2>
      
        <h3 id="sumbit和execute方法的区别"   >
          <a href="#sumbit和execute方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#sumbit和execute方法的区别" class="headerlink" title="sumbit和execute方法的区别?"></a>sumbit和execute方法的区别?</h3>
      <p>1.sumbit有返回值，而execute没有返回值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;...部分代码&#125;</span><br></pre></td></tr></table></div></figure>



<p>2.sumbit可以接收Runnable和Callable的参数，而execute只能接收Runnable的参数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;...部分代码&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="为什么禁止使用Executors创建线程池"   >
          <a href="#为什么禁止使用Executors创建线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么禁止使用Executors创建线程池" class="headerlink" title="为什么禁止使用Executors创建线程池"></a>为什么禁止使用Executors创建线程池</h3>
      <p><strong>CachedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, 										 <span class="comment">//核心线程数</span></span><br><span class="line">            Integer.MAX_VALUE, 						 <span class="comment">//总线程数</span></span><br><span class="line">            <span class="number">60L</span>,									 <span class="comment">//超时时间</span></span><br><span class="line">            TimeUnit.SECONDS,						 <span class="comment">//时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());		 <span class="comment">//排队队列</span></span><br><span class="line">    		<span class="comment">//默认线程工厂以及拒绝策略</span></span><br><span class="line">    &#125;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>因此我们可以知道CachedThreadPool的模型如下</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117193515963.png"  alt="CachedThreadPool">
      </p>
<p><strong>SingleThreadExecutor</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,						<span class="comment">//核心线程数</span></span><br><span class="line">                                <span class="number">1</span>,						<span class="comment">//总线程数</span></span><br><span class="line">                                <span class="number">0L</span>, 					<span class="comment">//存活时间</span></span><br><span class="line">                                TimeUnit.MILLISECONDS,  <span class="comment">//时间单位</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<span class="comment">//任务阻塞队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此我们可以得到SingleThreadExecutor（单线程的线程池）的模型</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194238410.png"  alt="SingleThreadExecutor">
      </p>
<p><strong>FixedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads,				<span class="comment">//核心线程数 </span></span><br><span class="line">                                  nThreads,				<span class="comment">//总线程数</span></span><br><span class="line">                                  <span class="number">0L</span>,					<span class="comment">//空闲时间 </span></span><br><span class="line">                                  TimeUnit.MILLISECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<span class="comment">//任务阻塞队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此FixedThreadPool的模型我们也能得出</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194303107.png"  alt="FixedThreadPool">
      </p>
<p>因此我们可以由这三个模型图推导出结果</p>
<ul>
<li><p>CachedThreadPool因为非核心线程是最大值，所以会一直创建非核心线程，可能会产生OOM问题</p>
<p>表现形式如下：先CPU达到100％，产生OOM问题</p>
</li>
<li><p>SingleThreadPool和FixedThreadPool因为阻塞作业队列workQueue是无限大的，也即当没有线程足够完成任务时会无止境的放到单向链表中，导致OOM问题</p>
</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://username.github.io">KkkerAn</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://username.github.io/2023/11/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[7-%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0]/">https://username.github.io/2023/11/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87[7-%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0]/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://username.github.io/tags/java/">java</a></span></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/2023/10/13/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/"><span class="paginator-prev__text">死之前要做完的算法手册-[9.动态规划]</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">
          线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">
          基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-1"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.1.3.</span> <span class="toc-text">
          协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.</span> <span class="toc-text">
          生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">
          创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E3%80%81%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          第一种、直接创建新线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E3%80%81Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          第二种、Runnable接口的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E3%80%81Callable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          第三种、Callable接口的实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%A7%8D%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          第四种、lambda表达式创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%A7%8D%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">
          第五种、线程池创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.6.</span> <span class="toc-text">
          小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">
          Thread类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">
          Runnable接口实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">
          Callable接口实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">
          lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.6.5.</span> <span class="toc-text">
          线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.7.</span> <span class="toc-text">
          常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep"><span class="toc-number">1.3.7.1.</span> <span class="toc-text">
          sleep</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start"><span class="toc-number">1.3.7.2.</span> <span class="toc-text">
          start</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-number">1.3.7.3.</span> <span class="toc-text">
          run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#yield"><span class="toc-number">1.3.7.4.</span> <span class="toc-text">
          yield</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-number">1.3.7.5.</span> <span class="toc-text">
          join</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#join%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.7.5.1.</span> <span class="toc-text">
          join方法使用案例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stop"><span class="toc-number">1.3.7.6.</span> <span class="toc-text">
          stop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt"><span class="toc-number">1.3.7.7.</span> <span class="toc-text">
          interrupt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.3.7.8.</span> <span class="toc-text">
          小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">
          线程的通知机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notifyAll"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          notifyAll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.4.4.</span> <span class="toc-text">
          小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep%E3%80%81wait%E3%80%81yield%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">
          sleep、wait、yield方法比较</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-1"><span class="toc-number">2.</span> <span class="toc-text">
          线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CachedThreadPool"><span class="toc-number">2.1.</span> <span class="toc-text">
          CachedThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SignleThreadPool"><span class="toc-number">2.2.</span> <span class="toc-text">
          SignleThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FixedThreadPool"><span class="toc-number">2.3.</span> <span class="toc-text">
          FixedThreadPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">2.4.</span> <span class="toc-text">
          ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">
          成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">
          构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.4.3.</span> <span class="toc-text">
          内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">
          Worker</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CallerRunsPolicy"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">
          CallerRunsPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbortPolicy"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">
          AbortPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardPolicy"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">
          DiscardPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardOldestPolicy"><span class="toc-number">2.4.3.5.</span> <span class="toc-text">
          DiscardOldestPolicy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execute"><span class="toc-number">2.4.4.</span> <span class="toc-text">
          execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWorker"><span class="toc-number">2.4.5.</span> <span class="toc-text">
          addWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addWorkerFailed"><span class="toc-number">2.4.6.</span> <span class="toc-text">
          addWorkerFailed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decrementWorkerCount"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">
          decrementWorkerCount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryTerminate"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">
          tryTerminate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runWorker"><span class="toc-number">2.4.7.</span> <span class="toc-text">
          runWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processWorkerExit"><span class="toc-number">2.4.8.</span> <span class="toc-text">
          processWorkerExit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.9.</span> <span class="toc-text">
          钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#beforeExecute"><span class="toc-number">2.4.9.1.</span> <span class="toc-text">
          beforeExecute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#afterExecute"><span class="toc-number">2.4.9.2.</span> <span class="toc-text">
          afterExecute</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.10.</span> <span class="toc-text">
          拒绝策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CallerRunPolicy"><span class="toc-number">2.4.10.1.</span> <span class="toc-text">
          CallerRunPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AbortPolicy-1"><span class="toc-number">2.4.10.2.</span> <span class="toc-text">
          AbortPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardPolicy-1"><span class="toc-number">2.4.10.3.</span> <span class="toc-text">
          DiscardPolicy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DiscardOldestPolicy-1"><span class="toc-number">2.4.10.4.</span> <span class="toc-text">
          DiscardOldestPolicy</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">
          常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sumbit%E5%92%8Cexecute%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">
          sumbit和execute方法的区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A6%81%E6%AD%A2%E4%BD%BF%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.2.</span> <span class="toc-text">
          为什么禁止使用Executors创建线程池</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">44</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>KkkerAn</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>