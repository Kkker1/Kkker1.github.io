<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="KkkerAn&#39;s Blog">
<meta property="og:url" content="https://username.github.io/index.html">
<meta property="og:site_name" content="KkkerAn&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KkkerAn">
<meta name="twitter:card" content="summary"><title>KkkerAn's Blog</title><link ref="canonical" href="https://username.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/26/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B6.%E4%BA%8C%E5%8F%89%E6%A0%91%5D/">死之前要做完的算法手册-[6.二叉树]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-26</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">35k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">287分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="二叉树的基本理论基础"   >
          <a href="#二叉树的基本理论基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的基本理论基础" class="headerlink" title="二叉树的基本理论基础"></a>二叉树的基本理论基础</h1>
      <p><strong>二叉树的定义代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="comment">//数据</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"> 	<span class="comment">//左右子结点</span></span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode ()&#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val,TreeNode left,TreeNode right)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">        <span class="built_in">this</span>.left=left;</span><br><span class="line">        <span class="built_in">this</span>.right=right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>平衡二叉树</strong></p>
<p>平衡二叉树是指左右子树的高度差不超过1，就是平衡二叉树</p>
<p><strong>满二叉树</strong></p>
<p>满二叉树是指一个二叉树只有度为0的叶子结点和度为2的非叶子结点，除了叶子结点的每个结点都有左右子树</p>
<p><strong>完全二叉树</strong></p>
<p>完全二叉树是指除了最后一层是满二叉树，并且最后一层必须都先填满左边</p>
<p><em>二叉搜索树</em></p>
<p>二叉搜索树是指结点有数值，二叉搜索树是一个<strong>有序树</strong></p>
<p><em>平衡二叉搜索树</em></p>
<p>平衡二叉搜索树是指结点有数值的平衡二叉树，左右子树高度差不超过1</p>

        <h1 id="二叉树的递归遍历"   >
          <a href="#二叉树的递归遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h1>
      <p>二叉树分为<strong>深度优先搜索</strong>和<strong>广度优先搜索</strong>，我们这里先探究的是深度优先遍历中的利用递归遍历</p>
<p><em>深度优先搜索，当某一个方向遍历到最后一个结点则结束当前方向，进行下一个方向的遍历</em></p>
<p><em>广度优先搜索，当遍历完一层之后再遍历下一层，一层一层搜索</em></p>
<p>二叉树的递归遍历主要分为：<strong>前、中、后序遍历</strong></p>
<p>前序遍历的遍历方式为:<strong>中</strong>左右</p>
<p>中序遍历的遍历方式为:左<strong>中</strong>右</p>
<p>后序遍历的遍历方式为:左右<strong>中</strong></p>
<p><em>所以我们记前中后序遍历只要知道这是在说明中间结点的位置</em></p>
<p>例</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230826101301155.png"  alt="前中后序遍历示例">
      </p>
<p>如何用递归来遍历二叉树，主要分三步</p>
<p>①判断递归需要的参数以及返回值 ：这里参数为存放遍历之后的集合以及当前结点。返回值是Void,因为遍历结果已经存放在参数里面了</p>
<p>②明确递归的结束条件：深度优先遍历，即当前遍历的元素为空则结束这一深度遍历</p>
<p>③判断单层递归要做什么：将存放遍历值，遍历左子树以及遍历右子树</p>
<p>所以我们整个的深度优先遍历的代码如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        midItor(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midItor</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    	<span class="comment">//当某一方向遍历到底则结束当前方向递归</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        midItor(node.left,list);	<span class="comment">//遍历左子树</span></span><br><span class="line">        list.add(node.val);			<span class="comment">//存放遍历值</span></span><br><span class="line">        midItor(node.right,list);	<span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//而前序和后序遍历的执行逻辑</span></span><br><span class="line"><span class="comment">//只有存放遍历值的步骤不一样</span></span><br><span class="line"><span class="comment">//	也即前序是先存放遍历值再遍历左右子树</span></span><br><span class="line"><span class="comment">//	也即后序是先遍历左右子树再存放遍历值</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="前序遍历"   >
          <a href="#前序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2>
      <p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>

        <h3 id="144-二叉树的前序遍历"   >
          <a href="#144-二叉树的前序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" >Leetcode.144题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;08&#x2F;26</p>

        <h5 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> prefixIt(root,list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">prefixIt</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                prefixIt(root.left,list);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                prefixIt(root.right,list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        beforeItor(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeItor</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    	<span class="comment">//当某一方向遍历到底则结束当前方向递归</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		list.add(node.val);			<span class="comment">//存放遍历值</span></span><br><span class="line">        beforeItor(node.left,list);	<span class="comment">//遍历左子树</span></span><br><span class="line">        beforeItor(node.right,list);	<span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="中序遍历"   >
          <a href="#中序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2>
      
        <h3 id="94-二叉树的中序遍历"   >
          <a href="#94-二叉树的中序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" >Leetcode.94题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;08&#x2F;26</p>

        <h5 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> midItor(root,list);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">midItor</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>) midItor(root.left,list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>) midItor(root.right,list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        midItor(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midItor</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    	<span class="comment">//当某一方向遍历到底则结束当前方向递归</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        midItor(node.left,list);	<span class="comment">//遍历左子树</span></span><br><span class="line">        list.add(node.val);			<span class="comment">//存放遍历值</span></span><br><span class="line">        midItor(node.right,list);	<span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="后序遍历"   >
          <a href="#后序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2>
      
        <h3 id="145-二叉树的后序遍历"   >
          <a href="#145-二叉树的后序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" >Leetcode.145题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;08&#x2F;26 </p>

        <h5 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> afterItor(root,list);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">afterItor</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>) afterItor(root.left,list);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>) afterItor(root.right,list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        afterItor(root,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterItor</span><span class="params">(TreeNode node,List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    	<span class="comment">//当某一方向遍历到底则结束当前方向递归</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        afterItor(node.left,list);	<span class="comment">//遍历左子树</span></span><br><span class="line">        afterItor(node.right,list);	<span class="comment">//遍历右子树</span></span><br><span class="line">        list.add(node.val);			<span class="comment">//存放遍历值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="二叉树的非递归遍历-迭代遍历"   >
          <a href="#二叉树的非递归遍历-迭代遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的非递归遍历-迭代遍历" class="headerlink" title="二叉树的非递归遍历(迭代遍历)"></a>二叉树的非递归遍历(迭代遍历)</h1>
      <p>上面我们提到了二叉树的<strong>深度优先搜索</strong>中的递归遍历方法，而递归遍历通常也能用非递归的方法解决</p>
<p><strong>迭代遍历</strong>：用一个栈来模拟二叉树的遍历过程</p>
<p>迭代遍历主要的是处理两件事：遍历结点以及处理结点</p>
<p>我们用前序遍历详细说说这个关系</p>

        <h2 id="前序遍历-1"   >
          <a href="#前序遍历-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" >Leetcode.144题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>思路</strong></p>
<p>我们前序遍历也即是<strong>中左右</strong>的遍历方式，而栈是一个先进后出的一个数据结构</p>
<p>在这里我们遍历结点和处理结点都是同时的，也即当我们遍历到中结点就要将中结点数据添加list中</p>
<p>而左右子结点入栈应该是先右子树入栈再是左子树入栈，因为LIFO的特性，先处理左子树那就得后入栈</p>
<p><strong>实现</strong></p>
<p>①将根节点添加进栈中</p>
<p>②将中结点弹出，如果结点非空则添加到结果集合中，并且将结点的右子树和左子树入栈</p>
<p>（<strong>入栈顺序为中，右，左。处理顺序为中，左，右</strong>）</p>
<p>③当处理结束将结果集返回</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//将根节点入栈</span></span><br><span class="line">        stack.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//将中结点弹出</span></span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="comment">//当结点非空添加到结果集，并将右子树，左子树入栈。每个结点都保持中右左的入栈顺序，处理顺序为中左右</span></span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">               </span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">//右子树入栈</span></span><br><span class="line">                stack.add(node.right);</span><br><span class="line">                <span class="comment">//左子树入栈</span></span><br><span class="line">                stack.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="后序遍历-1"   >
          <a href="#后序遍历-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" >Leetcode.145题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>思路</strong></p>
<p>后序遍历也即<strong>左右中</strong>的遍历方式 ，我们前序遍历的遍历方式是中左右，然后先入栈右子树再入栈左子树就能达到处理顺序是中左右。而我们将子树的入栈顺序颠倒，也即入栈左子树再入栈右子树就可以得到中右左的结果集，我们最后再将中右左的结果集反转就能得到左右中的遍历结果。</p>
<p>也即 <strong>左右中</strong> &#x3D;&#x3D;   前序遍历 <strong>中左右</strong> -&gt;将子树入栈顺序颠倒 <strong>中右左</strong> -&gt;  反转结果集 <strong>左右中</strong></p>
<p><strong>实现</strong></p>
<p>①将根节点添加进栈中</p>
<p>②将中结点弹出，如果结点非空则添加到结果集合中，并且将结点的左子树和右子树入栈</p>
<p>（<strong>入栈顺序为中，左，右。处理顺序为中，右，左</strong>）</p>
<p>③反转结果集(中，右，左 反转成 左，右，中)</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        stack.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="comment">//当结点非空，则将左子树、右子树入栈。每个结点入栈顺序为中左右 处理顺序为中右左</span></span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">//左子树入栈</span></span><br><span class="line">                stack.add(node.left);</span><br><span class="line">                <span class="comment">//右子树入栈</span></span><br><span class="line">                stack.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//反转结果集</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="中序遍历-1"   >
          <a href="#中序遍历-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" >Leetcode.94题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><strong>思路</strong></p>
<p>这里遍历结点和处理结点不是同时进行的，也即当我们遍历到这个结点要先去处理左节点，所以我们引入了一个<strong>用于遍历的指针</strong></p>
<p>通过指针的不断移动确认当前遍历到的结点，如果当前指针不为空则将结点入栈，再去操作左右子树</p>
<p>如果当前指针为空 说明上一个结点没有左子树  则返回到上个结点将其出栈，再去判断右子树是否为空</p>
<p><strong>实现</strong></p>
<p>①定义一个用于遍历的指针cur，代表着此时遍历到的结点</p>
<p>②如果当前结点不为空 则入栈，将指针指向当前结点的左子树</p>
<p>③如果当前结点为空，则说明左子树为空，返回上一个结点将其弹出实现了左中的路线，再将当前结点指向右子树</p>
<p>④如果当前指针为空并且栈为空说明遍历已经结束 实现了<strong>左中右</strong>的逻辑</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">//定义一个用于遍历的指针</span></span><br><span class="line">    	TreeNode cur=root;</span><br><span class="line">	</span><br><span class="line">    	<span class="comment">//当当前结点不为空或者栈不为空的时候说明没有遍历完</span></span><br><span class="line">       <span class="keyword">while</span>(cur!=<span class="literal">null</span> || stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当前结点入栈，指向左子树</span></span><br><span class="line">               stack.add(cur);</span><br><span class="line">               cur=cur.left;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//cur==null</span></span><br><span class="line">               <span class="comment">//说明这里没有左子树，返回最近的父节点让它出栈，然后指向父节点的右子树</span></span><br><span class="line">               TreeNode node=stack.pop();</span><br><span class="line">               list.add(node.val);</span><br><span class="line">               cur=node.right;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="统一迭代法"   >
          <a href="#统一迭代法" class="heading-link"><i class="fas fa-link"></i></a><a href="#统一迭代法" class="headerlink" title="统一迭代法"></a>统一迭代法</h2>
      <p>因为前中后序代码的不一致性，所以我们可以引入一个<strong>空指针</strong>，这样可以使其迭代法的代码可以能像递归法一样只要移动几个代码的位置就能分别实现前中后序</p>
<p>思想：以<strong>中序遍历</strong>为假设</p>
<p>当当前结点不为空的时候，将其左右子树和当前结点重新入栈 <del>需要实现左中右的逻辑</del></p>
<ul>
<li><p>假如左右子树都不为空 那么实现栈中 		<strong>右结点 当前结点 null 左结点</strong></p>
</li>
<li><p>假如左子树为空右子树不为空， 那么栈中 <strong>右结点 当前结点 null</strong> </p>
</li>
<li><p>假如左子树不为空右子树为空， 那么栈中 <strong>当前结点 null 左结点</strong></p>
</li>
<li><p>假如左右子树都为空，那么栈中  		       <strong>当前结点 null</strong></p>
</li>
</ul>
<p>当遇见null结点的时候只要pop栈就能找到当前结点，也即维护了一个<strong>当前结点后跟着一个空指针标记</strong></p>

        <h3 id="中序遍历-2"   >
          <a href="#中序遍历-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//根节点为空就直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//根节点不为空</span></span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//重新入栈顺序为 右中左 </span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当右子树结点为空不入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">			</span><br><span class="line">                stack.add(node);</span><br><span class="line">                stack.add(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//当左子树结点为空不入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//node==null</span></span><br><span class="line">                <span class="comment">//那么空节点前一个就是当前结点 直接pop</span></span><br><span class="line">                TreeNode inNode=stack.pop();</span><br><span class="line">                list.add(inNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="前序遍历-2"   >
          <a href="#前序遍历-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//重新入栈顺序为 右左中</span></span><br><span class="line">                <span class="comment">//当右子树结点为空不入栈，当左子树结点为空不入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) stack.add(node.left);</span><br><span class="line"></span><br><span class="line">                stack.add(node);</span><br><span class="line">                stack.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//node==null</span></span><br><span class="line">				<span class="comment">//那么空节点前一个就是当前结点 直接pop</span></span><br><span class="line">                TreeNode inNode=stack.pop();</span><br><span class="line">                list.add(inNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="后序遍历-2"   >
          <a href="#后序遍历-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ublic List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//重新入栈顺序为 中右左</span></span><br><span class="line">                </span><br><span class="line">                stack.add(node);</span><br><span class="line">                stack.add(<span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//当右子树结点为空不入栈，当左子树结点为空不入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//node==null</span></span><br><span class="line">                <span class="comment">//那么空节点前一个就是当前结点 直接pop</span></span><br><span class="line">                TreeNode inNode=stack.pop();</span><br><span class="line">                list.add(inNode.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <p>这个统一迭代法主要利用了一个<strong>空指针来标记当前结点</strong>的位置，当结点不为空的时候统一将有效结点入栈，当结点为空时找前一个元素即可找到当前结点。这样代码只需要移动少部分顺序即可完成前中后序的遍历</p>

        <h1 id="二叉树的层序遍历"   >
          <a href="#二叉树的层序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h1>
      <p>二叉树有<strong>深度优先搜索</strong>与<strong>广度优先搜索</strong>，我们这里来学的就是广度优先搜索中的层序遍历</p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>

        <h2 id="102-二叉树的层序遍历"   >
          <a href="#102-二叉树的层序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" >Leetcode.102题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;27</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; Fatherqueue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; Sonqueue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        Fatherqueue.add(root);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Fatherqueue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            TreeNode node=Fatherqueue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)Sonqueue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)Sonqueue.add(node.right);</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Fatherqueue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(Sonqueue.size()!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Fatherqueue.add(Sonqueue.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root &#x3D;[3,9,20,null,null,15,7]，输出[[3],[20],[7]] 预期输出[[3],[9,20],[15,7]]</p>
<p>原因出在这个list队列每次循环都会重置，而改进逻辑是在每次父队列为空的时候new一个List出来 然后list指向这个新的List</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; Fatherqueue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; Sonqueue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        Fatherqueue.add(root);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(Fatherqueue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">       </span><br><span class="line">            TreeNode node=Fatherqueue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)Sonqueue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)Sonqueue.add(node.right);</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Fatherqueue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(Sonqueue.size()!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Fatherqueue.add(Sonqueue.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                result.add(list);</span><br><span class="line">                list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong></p>
<p>用一个<strong>size</strong>记录每一层的结点数:获取一下队列中的结点个数记录为size，然后当结点数大于0的时候操作队列。当结点为0说明本层遍历完了 重新获取一下队列中的结点数</p>
<p>如</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一层size为<span class="number">1</span> 说明本层只需要弹出一个结点即可，操作队列弹出一个元素进入下一层</span><br><span class="line"></span><br><span class="line">第二层size为<span class="number">2</span> 说明本层需要弹出两个结点，队列只需要弹出两次</span><br><span class="line"></span><br><span class="line">第三层size为<span class="number">3</span> 说明第三层只有三个结点</span><br></pre></td></tr></table></div></figure>

<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//将根节点入队</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//当队列非空说明没有遍历完</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//记录本层结点数  快照size</span></span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="comment">//每一层的list集合</span></span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//弹出结点</span></span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">//将当前结点左右结点(非空)入队</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加进每层的结果集中</span></span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="107-二叉树的层序遍历II"   >
          <a href="#107-二叉树的层序遍历II" class="heading-link"><i class="fas fa-link"></i></a><a href="#107-二叉树的层序遍历II" class="headerlink" title="107.二叉树的层序遍历II"></a>107.二叉树的层序遍历II</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" >Leetcode.107题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题和102题(二叉树的层序遍历)相似，但是要求的是自底向顶的数据输出</p>
<p>那么可以知道层序遍历是自顶向底的顺序输出，所以我们最后只要将层序遍历结果集反转即可达到要求</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//统计每一次要操作的数据量</span></span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                list.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//反转自顶向底的结果集</span></span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="199-二叉树的右视图"   >
          <a href="#199-二叉树的右视图" class="heading-link"><i class="fas fa-link"></i></a><a href="#199-二叉树的右视图" class="headerlink" title="199.二叉树的右视图"></a>199.二叉树的右视图</h2>
      <p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/" >Leetcode.199题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="comment">//当size==0 说明该结点是这层的最后一个结点，也即右视图能看到的结点</span></span><br><span class="line">                <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们层序遍历然后将每层的最后一个元素添加到结果集中返回即可</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="comment">//当size==0 说明该结点是这层的最后一个结点，也即右视图能看到的结点</span></span><br><span class="line">                <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">                    list.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="637-二叉树的层平均值"   >
          <a href="#637-二叉树的层平均值" class="heading-link"><i class="fas fa-link"></i></a><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h2>
      <p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <code>10-5</code> 以内的答案可以被接受。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" >Leetcode.637题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();            </span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> num=size;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                sum+=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(sum/num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: 输入root&#x3D;[2,147,483,647，2,147,483,647，2,147,483,647] 输出[2,147,483,647.0，-1.0] 预期输出[2,147,483,647.0，2,147,483,647.0]</p>
<p>原因在于int的上限为2,147,483,647所以我只要把sum的数据类型改成double即可</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();            </span><br><span class="line">            <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="type">double</span> num=size;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                sum+=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(sum/num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ublic List&lt;Double&gt; <span class="title function_">averageOfLevels</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Double&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//记录每层的结点数</span></span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="comment">//统计每层总和</span></span><br><span class="line">            <span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                sum+=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加每层平均值</span></span><br><span class="line">            result.add(sum/size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="429-N叉树的层序遍历"   >
          <a href="#429-N叉树的层序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#429-N叉树的层序遍历" class="headerlink" title="429.N叉树的层序遍历"></a>429.N叉树的层序遍历</h2>
      <p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" >Leetcode.429(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span>queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.children!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(Node n: node.children)&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-7"   >
          <a href="#提交成功-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-7" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：统计每层个数，然后每个结点获取他的数据入list中并将子结点集合(children)入队</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            </span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span>queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="comment">//当子节点集合不为空</span></span><br><span class="line">                <span class="keyword">if</span>(node.children!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//子结点入队</span></span><br><span class="line">                    <span class="keyword">for</span>(Node n: node.children)&#123;</span><br><span class="line">                        queue.add(n);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="515-在每个树行中找最大值"   >
          <a href="#515-在每个树行中找最大值" class="heading-link"><i class="fas fa-link"></i></a><a href="#515-在每个树行中找最大值" class="headerlink" title="515.在每个树行中找最大值"></a>515.在每个树行中找最大值</h2>
      <p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" >Leetcode.515题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="type">int</span> MAX=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.val&gt;=MAX) MAX=node.val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(MAX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-8"   >
          <a href="#提交成功-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-8" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-8"   >
          <a href="#题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">largestValues</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="comment">//记录每层最大值</span></span><br><span class="line">            <span class="type">int</span> MAX=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.val&gt;=MAX) MAX=node.val;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(MAX);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="116-填充每个节点的下一个右侧节点指针"   >
          <a href="#116-填充每个节点的下一个右侧节点指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116.填充每个节点的下一个右侧节点指针"></a>116.填充每个节点的下一个右侧节点指针</h2>
      <p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" >Leetcode.116题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Node cur;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            cur=queue.peek();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125;</span><br><span class="line">                Node next=queue.poll();</span><br><span class="line">                cur.next=next;</span><br><span class="line">                cur=next;</span><br><span class="line">                <span class="keyword">if</span>(next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(next.left!=<span class="literal">null</span>) queue.add(next.left);</span><br><span class="line">                    <span class="keyword">if</span>(next.right!=<span class="literal">null</span>) queue.add(next.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入[1,2,3,4,5,6,7] 输出[1,#,2,#,4,#] 预期输出[1,#,2,3,#,4,5,6,7,#]</p>
<p>当每层第一个的时候忘记继续操作了</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">       Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       Node cur;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       queue.add(root);</span><br><span class="line">       <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">int</span> size=queue.size();</span><br><span class="line">           cur=queue.peek();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                   Node next=queue.poll();</span><br><span class="line">                   <span class="keyword">if</span>(next.left!=<span class="literal">null</span>) queue.add(next.left);</span><br><span class="line">                   <span class="keyword">if</span>(next.right!=<span class="literal">null</span>) queue.add(next.right);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               Node next=queue.poll();</span><br><span class="line">               cur.next=next;</span><br><span class="line">               cur=next;</span><br><span class="line">               <span class="keyword">if</span>(next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(next.left!=<span class="literal">null</span>) queue.add(next.left);</span><br><span class="line">                   <span class="keyword">if</span>(next.right!=<span class="literal">null</span>) queue.add(next.right);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-9"   >
          <a href="#提交成功-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-9" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-9"   >
          <a href="#题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3>
      <p>思路： 还是层序遍历</p>
<ul>
<li><p>size–之后为0说明是这层最后一个结点就不做处理，只将子结点入队</p>
</li>
<li><p>size–之后不为0说明这层还有结点，通过peek方法取得当前结点的下一个结点 指向下一个结点即可，然后将当前结点的子结点入队</p>
</li>
</ul>
<p>								</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Node cur;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//获取当前结点</span></span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="comment">//当size!=0 说明没到本层最后一个结点，队里还有本层的下一个结点</span></span><br><span class="line">                <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Node next=queue.peek();</span><br><span class="line">                    node.next=next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//子结点入队</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="117-填充每个节点的下一个右侧节点指针-II"   >
          <a href="#117-填充每个节点的下一个右侧节点指针-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117.填充每个节点的下一个右侧节点指针 II"></a>117.填充每个节点的下一个右侧节点指针 II</h2>
      <p>给定一个二叉树：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" >Leetcode.117题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><em>这题于106题的区别在于 106题二叉树是完美二叉树 这道题是普通二叉树</em></p>

        <h3 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue= <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Node next=queue.peek();</span><br><span class="line">                    node.next=next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-10"   >
          <a href="#提交成功-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-10" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-10"   >
          <a href="#题解-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue= <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//获取当前结点</span></span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="comment">//当size!=0 说明没到本层最后一个结点，队里还有本层的下一个结点</span></span><br><span class="line">                <span class="keyword">if</span>(size!=<span class="number">0</span>)&#123;</span><br><span class="line">                    Node next=queue.peek();</span><br><span class="line">                    node.next=next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//子结点入队</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="104-二叉树的最大深度"   >
          <a href="#104-二叉树的最大深度" class="heading-link"><i class="fas fa-link"></i></a><a href="#104-二叉树的最大深度" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2>
      <p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" >Leetcode.104题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    	<span class="comment">//用于统计层数</span></span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//层数自增</span></span><br><span class="line">            dept++;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-11"   >
          <a href="#提交成功-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-11" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="第二次做"   >
          <a href="#第二次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次做" class="headerlink" title="第二次做"></a>第二次做</h3>
      <p>第二次做于23&#x2F;08&#x2F;30</p>

        <h4 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-12"   >
          <a href="#提交成功-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-12" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-11"   >
          <a href="#题解-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3>
      <p>我们只要用一个count来统计层数即可，当层序遍历的时候count++就能统计做大深度</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">     	<span class="comment">//用于统计深度 </span></span><br><span class="line">    	<span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="111-二叉树的最小深度"   >
          <a href="#111-二叉树的最小深度" class="heading-link"><i class="fas fa-link"></i></a><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2>
      <p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" >Leetcode.111题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;28</p>

        <h4 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> dept;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-13"   >
          <a href="#提交成功-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-13" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="第二次做-1"   >
          <a href="#第二次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次做-1" class="headerlink" title="第二次做"></a>第二次做</h3>
      <p>第二次做于23&#x2F;08&#x2F;30</p>

        <h4 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-14"   >
          <a href="#提交成功-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-14" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-12"   >
          <a href="#题解-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3>
      <p>本题目的就是找到离根节点最近的叶子结点，所以我们层序遍历找到第一个叶子结点就是离根最近的叶子结点</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        </span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">    	<span class="comment">//层序遍历</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="comment">//判断当前结点是不是叶子结点(左右子树为空)</span></span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> dept;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="小结-1"   >
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2>
      <p>我们通过这几道题的训练可以明白和使用层序遍历，总之这些题目是大同小异。我们明白了用<strong>队列</strong>来完成<strong>广度优先搜索</strong></p>

        <h1 id="翻转二叉树"   >
          <a href="#翻转二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1>
      <p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>

        <h2 id="226-翻转二叉树"   >
          <a href="#226-翻转二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#226-翻转二叉树" class="headerlink" title="226.翻转二叉树"></a>226.翻转二叉树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/" >LeetCode.226(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;29</p>

        <h4 id="第一次代码-15"   >
          <a href="#第一次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-15" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统一迭代法</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//用统一迭代法(后序遍历)</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(node);</span><br><span class="line">                stack.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode temp=stack.pop();</span><br><span class="line">                TreeNode tempRight=temp.right;</span><br><span class="line">                temp.right=temp.left;</span><br><span class="line">                temp.left=tempRight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-15"   >
          <a href="#提交成功-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-15" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-13"   >
          <a href="#题解-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题用前序和后序的时候可以直接交换中结点的左右子树，然后处理左右子树即可。</p>
<p>而用中序的时候有一个踩坑的顺序点，因为中序是左中右，所以处理完左子树之后就和右子树做了交换，而下一步是处理右子树就等于是又反转了一遍原先的左子树。所以这里比较绕就不用中序</p>
<p><strong>递归法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ReverseTree(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ReverseTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//处理左子树、右子树</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>) ReverseTree(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>) ReverseTree(root.right);</span><br><span class="line">		<span class="comment">//交换左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span>root.right;</span><br><span class="line">        root.right=root.left;</span><br><span class="line">        root.left=temp;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>非递归法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统一迭代法</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//用统一迭代法(后序遍历)</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(node);</span><br><span class="line">                stack.add(<span class="literal">null</span>);</span><br><span class="line">				</span><br><span class="line">                <span class="comment">//添加左右子树结点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) stack.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) stack.add(node.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//node==null</span></span><br><span class="line">                TreeNode temp=stack.pop();</span><br><span class="line">                <span class="comment">//交换左右子树</span></span><br><span class="line">                TreeNode tempRight=temp.right;</span><br><span class="line">                temp.right=temp.left;</span><br><span class="line">                temp.left=tempRight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="对称二叉树"   >
          <a href="#对称二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1>
      <p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>

        <h2 id="101-对称二叉树"   >
          <a href="#101-对称二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/" >Leetcode.101题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;29</p>

        <h4 id="第一次代码-16"   >
          <a href="#第一次代码-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-16" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="type">int</span> arr[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">                arr[i]=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        ReserveTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> newArr[]=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1001</span>];</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">                newArr[j]=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=newArr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ReserveTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        ReserveTree(root.left);</span><br><span class="line">        ReserveTree(root.right);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right=root.left;</span><br><span class="line">        root.left=temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE: root[1,0] 输出true 预期输出false</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                number++;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(number!=<span class="number">1</span>&amp;&amp; number%<span class="number">2</span>!=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="type">int</span> arr[]=<span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">                arr[i++]=node.val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        ReserveTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> newArr[]=<span class="keyword">new</span> <span class="title class_">int</span>[Integer.MAX_VALUE];</span><br><span class="line">        stack.add(root);</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.add(node.left);</span><br><span class="line">                stack.add(node.right);</span><br><span class="line">                newArr[j++]=node.val;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=newArr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ReserveTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        ReserveTree(root.left);</span><br><span class="line">        ReserveTree(root.right);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">        root.right=root.left;</span><br><span class="line">        root.left=temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-1"   >
          <a href="#提交错误-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-1" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:超出内存限制</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       stack.add(root);</span><br><span class="line">       ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           TreeNode node=stack.pop();</span><br><span class="line">           <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">               stack.add(node.right);</span><br><span class="line">               list.add(node.val);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               list.add(<span class="literal">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       ReserveTree(root);</span><br><span class="line"></span><br><span class="line">       ArrayList&lt;Integer&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       stack.add(root);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">           TreeNode node=stack.pop();</span><br><span class="line">           <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">               stack.add(node.left);</span><br><span class="line">               stack.add(node.right);</span><br><span class="line">               tempList.add(node.val);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               tempList.add(<span class="literal">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(list.get(i)!=<span class="literal">null</span> &amp;&amp; tempList.get(i)!=<span class="literal">null</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(!list.get(i).equals(tempList.get(i))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(list.get(i)==<span class="literal">null</span>&amp;&amp;tempList.get(i)!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">if</span>(list.get(i)!=<span class="literal">null</span>&amp;&amp;tempList.get(i)==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ReserveTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">       ReserveTree(root.left);</span><br><span class="line">       ReserveTree(root.right);</span><br><span class="line">       <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">       root.right=root.left;</span><br><span class="line">       root.left=temp;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-16"   >
          <a href="#提交成功-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-16" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>做法是先用list存放原来树的元素，然后反转之后再遍历一遍放到tempList 如果这两个集合元素是一样的说明是对称的</p>

        <h3 id="题解-14"   >
          <a href="#题解-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3>
      <p>我们这道题求一棵树是否是对称二叉树，也即只要左右子树能够相互翻转。 也即<strong>左右子树镜像</strong></p>
<p><strong>思路</strong></p>
<p>求根结点的左子树和右子树是否镜像</p>
<ul>
<li><p>如果左子树为空并且右子树为空  返回true</p>
</li>
<li><p>如果左子树不为空 右子树为空 返回false</p>
</li>
<li><p>如果左子树为空 右子树不为空 返回false</p>
</li>
<li><p>如果左右子树都不为空 但是左结点和右结点值不相等 返回false</p>
</li>
<li><p>如果左右子树不为空 且值相等 则进行判断</p>
<ul>
<li><p>判断传入的左子树的左孩子 于 传入的右子树的右孩子 是否镜像</p>
</li>
<li><p>判断传入的左子树的右孩子 于 传入的右子树的做孩子 是否镜像</p>
</li>
</ul>
</li>
<li><p>如果左右子树镜像则返回true</p>
</li>
</ul>
<p>利用后序遍历最后处理中结点</p>
<p>等于是同时<strong>遍历根节点下的左右子树</strong>，左子树的遍历是左右中，而右子树的遍历是右左中</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="comment">//检查左右子树是否镜像</span></span><br><span class="line">       <span class="keyword">return</span> check(root.left,root.right); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">    	<span class="comment">//如果左右子树为空 </span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>&amp;&amp; right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果左子树为空 右子树不为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//如果左子树不为空 右子树为空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果左右子树不为空但是值不相等</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left.val!=right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行到这里左右子树不为空 值也相等，判断左子树的左结点和右子树的右孩子是否相等</span></span><br><span class="line">        <span class="type">boolean</span> outCheck=check(left.left,right.right);</span><br><span class="line">        <span class="comment">//判断左子树的右节点和右子树的左结点是否相等</span></span><br><span class="line">        <span class="type">boolean</span> inCheck=check(left.right,right.left);</span><br><span class="line">        <span class="comment">//处理中结点 左右为镜像则返回true</span></span><br><span class="line">        <span class="keyword">return</span> outCheck &amp;&amp; inCheck;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>


        <h2 id="100-相同的树"   >
          <a href="#100-相同的树" class="heading-link"><i class="fas fa-link"></i></a><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h2>
      <p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/" >Leetcode.100题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-15"   >
          <a href="#第一次做-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-15" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;29</p>

        <h4 id="第一次代码-17"   >
          <a href="#第一次代码-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-17" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.val!=q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> leftCheck=isSameTree(p.left,q.left);</span><br><span class="line">        <span class="type">boolean</span> rightCheck=isSameTree(p.right,q.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> leftCheck&amp;&amp; rightCheck;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-17"   >
          <a href="#提交成功-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-17" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-15"   >
          <a href="#题解-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3>
      <p>求左子树和右子树是否相等</p>
<ul>
<li><p>如果左子树为空并且右子树为空  返回true</p>
</li>
<li><p>如果左子树不为空 右子树为空 返回false</p>
</li>
<li><p>如果左子树为空 右子树不为空 返回false</p>
</li>
<li><p>如果左右子树都不为空 但是左结点和右结点值不相等 返回false</p>
</li>
<li><p>如果左右子树不为空 且值相等 则进行判断</p>
<ul>
<li><p>判断传入的左子树的左孩子 于 传入的右子树的左孩子 是否镜像</p>
</li>
<li><p>判断传入的左子树的右孩子 于 传入的右子树的右孩子 是否镜像</p>
</li>
</ul>
</li>
<li><p>如果左右子树镜像则返回true</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span>&amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p.val!=q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//运行到这里 左子树和右子树不为空且值相等 ，判断左子树的左孩子和右子树的左孩子是否相等</span></span><br><span class="line">        <span class="type">boolean</span> leftCheck=isSameTree(p.left,q.left);</span><br><span class="line">    	<span class="comment">//判断左子树的右孩子和右子树的右孩子是否相等</span></span><br><span class="line">        <span class="type">boolean</span> rightCheck=isSameTree(p.right,q.right);</span><br><span class="line">		<span class="comment">//判断中结点</span></span><br><span class="line">        <span class="keyword">return</span> leftCheck&amp;&amp; rightCheck;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>本质上还是同时后序遍历两个子树，都是左右中</p>

        <h2 id="572-另一棵树的子树"   >
          <a href="#572-另一棵树的子树" class="heading-link"><i class="fas fa-link"></i></a><a href="#572-另一棵树的子树" class="headerlink" title="572.另一棵树的子树"></a>572.另一棵树的子树</h2>
      <p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/" >Leetcode.572题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-16"   >
          <a href="#第一次做-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-16" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;29</p>

        <h4 id="第一次代码-18"   >
          <a href="#第一次代码-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-18" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> leftContains=Contains(root.left,subRoot);</span><br><span class="line">        <span class="type">boolean</span> rightContains=Contains(root.right,subRoot);</span><br><span class="line">        <span class="keyword">return</span> leftContains || rightContains;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Contains</span><span class="params">(TreeNode node,TreeNode Root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span>&amp;&amp; Root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node!=<span class="literal">null</span> &amp;&amp; Root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node==<span class="literal">null</span> &amp;&amp; Root!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.val!=Root.val)&#123;</span><br><span class="line">            Contains(node.left,Root);</span><br><span class="line">            Contains(node.right,Root);  </span><br><span class="line">        &#125;</span><br><span class="line">        Boolean left=<span class="literal">false</span>;</span><br><span class="line">        Boolean right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.val==Root.val)&#123;</span><br><span class="line">            left=Contains(node.left,Root.left);</span><br><span class="line">            right=Contains(node.right,Root.right);</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: 输入root&#x3D;[3,4,5,1,2,null,null,null,null,0] subRoot&#x3D;[4,1,2]  输出true 预期输出false</p>

        <h4 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> contains(root,subRoot);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(TreeNode node,TreeNode Root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">null</span> &amp;&amp; Root ==<span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node!=<span class="literal">null</span>&amp;&amp; Root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node==<span class="literal">null</span> &amp;&amp; Root !=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.val!=Root.val)&#123;</span><br><span class="line">            <span class="type">boolean</span> left=contains(node.left,Root);</span><br><span class="line">            <span class="type">boolean</span> right=contains(node.right,Root);</span><br><span class="line">            <span class="keyword">return</span> left|| right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node.val==Root.val)&#123;</span><br><span class="line">            <span class="type">boolean</span> left=contains(node.left,Root.left);</span><br><span class="line">            <span class="type">boolean</span> right=contains(node.right,Root.right);</span><br><span class="line">            <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入root&#x3D;[1,1] subRoot&#x3D;[1]  输出false 预期输出true</p>
<p>没做出来</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchRoot(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchRoot</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val!=subRoot.val)&#123;</span><br><span class="line">            <span class="type">boolean</span> left=SearchRoot(root.left,subRoot);</span><br><span class="line">            <span class="type">boolean</span> right=SearchRoot(root.right,subRoot);</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> checkAll(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkAll</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>&amp;&amp;subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root==<span class="literal">null</span> &amp;&amp; subRoot!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root!=<span class="literal">null</span> &amp;&amp; subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val!=subRoot.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> left=checkAll(root.left,subRoot.left);</span><br><span class="line">        <span class="type">boolean</span> right=checkAll(root.right,subRoot.right);</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:[1,1] subRoot&#x3D;[1] 输出false 预期输出true</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSubtree(TreeNode root, TreeNode subRoot) &#123;</span><br><span class="line">        return SearchRoot(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean SearchRoot(TreeNode root,TreeNode subRoot)&#123;</span><br><span class="line">        if(root==null) return false;</span><br><span class="line"></span><br><span class="line">        if(root.val!=subRoot.val)&#123;</span><br><span class="line">            boolean left=SearchRoot(root.left,subRoot);</span><br><span class="line">            boolean right=SearchRoot(root.right,subRoot);</span><br><span class="line">            return left || right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return checkAll(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean checkAll(TreeNode root,TreeNode subRoot)&#123;</span><br><span class="line">        if(root==null&amp;&amp;subRoot==null) return true;</span><br><span class="line">        else if(root==null &amp;&amp; subRoot!=null) return false;</span><br><span class="line">        else if(root!=null &amp;&amp; subRoot==null) return false;</span><br><span class="line">        else if(root.val!=subRoot.val) return false;</span><br><span class="line"></span><br><span class="line">        boolean left=checkAll(root.left,subRoot.left);</span><br><span class="line">        boolean right=checkAll(root.right,subRoot.right);</span><br><span class="line">        if(!(left)&amp;&amp;right)&#123;</span><br><span class="line">            if(root.left!=null)&#123;</span><br><span class="line">                return SearchRoot(root.left,subRoot);</span><br><span class="line">            &#125;else if(root.right!=null)&#123;</span><br><span class="line">                return SearchRoot(root.right,subRoot);</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入root&#x3D;[1,1,1] subRoot&#x3D;[1] 输出false 预期输出true</p>

        <h4 id="第五次代码"   >
          <a href="#第五次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五次代码" class="headerlink" title="第五次代码"></a>第五次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchRoot(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchRoot</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val!=subRoot.val)&#123;</span><br><span class="line">            <span class="type">boolean</span> left=SearchRoot(root.left,subRoot);</span><br><span class="line">            <span class="type">boolean</span> right=SearchRoot(root.right,subRoot);</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> checkAll(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkAll</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>&amp;&amp;subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root==<span class="literal">null</span> &amp;&amp; subRoot!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root!=<span class="literal">null</span> &amp;&amp; subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val!=subRoot.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> left=checkAll(root.left,subRoot.left);</span><br><span class="line">        <span class="type">boolean</span> right=checkAll(root.right,subRoot.right);</span><br><span class="line">        <span class="keyword">if</span>(!(left&amp;&amp;right))&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> SearchRoot(root.left,subRoot);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> SearchRoot(root.right,subRoot);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第六次代码"   >
          <a href="#第六次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六次代码" class="headerlink" title="第六次代码"></a>第六次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchRoot(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchRoot</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val!=subRoot.val)&#123;</span><br><span class="line">            <span class="type">boolean</span> left=SearchRoot(root.left,subRoot);</span><br><span class="line">            <span class="type">boolean</span> right=SearchRoot(root.right,subRoot);</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> checkAll(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkAll</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>&amp;&amp;subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root==<span class="literal">null</span> &amp;&amp; subRoot!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root!=<span class="literal">null</span> &amp;&amp; subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val!=subRoot.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> left=checkAll(root.left,subRoot.left);</span><br><span class="line">        <span class="type">boolean</span> right=checkAll(root.right,subRoot.right);</span><br><span class="line">        <span class="keyword">if</span>(!(left&amp;&amp;right))&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="type">boolean</span> newLeft=SearchRoot(root.left,subRoot);</span><br><span class="line">                <span class="type">boolean</span> newRight=SearchRoot(root.right,subRoot);</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">return</span> newLeft||newRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root &#x3D;[4,1,null,1,null,6,7] subRoot&#x3D;[4,1,null,6,7] 输出true 预期输出false</p>

        <h4 id="第七次代码"   >
          <a href="#第七次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第七次代码" class="headerlink" title="第七次代码"></a>第七次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchRoot(root,subRoot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchRoot</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val!=subRoot.val)&#123;</span><br><span class="line">            <span class="type">boolean</span> left=SearchRoot(root.left,subRoot);</span><br><span class="line">            <span class="type">boolean</span> right=SearchRoot(root.right,subRoot);</span><br><span class="line">            <span class="keyword">return</span> left || right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> result=checkAll(root,subRoot);</span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">boolean</span> left=SearchRoot(root.left,subRoot);</span><br><span class="line">            <span class="type">boolean</span> right=SearchRoot(root.right,subRoot);</span><br><span class="line">            <span class="keyword">return</span> left||right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkAll</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>&amp;&amp;subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root==<span class="literal">null</span> &amp;&amp; subRoot!=<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root!=<span class="literal">null</span> &amp;&amp; subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val!=subRoot.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> left=checkAll(root.left,subRoot.left);</span><br><span class="line">        <span class="type">boolean</span> right=checkAll(root.right,subRoot.right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-18"   >
          <a href="#提交成功-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-18" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-16"   >
          <a href="#题解-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3>
      <p>利用双递归，一个方法来判断当前树是否是相同的子树，一个方法来判断值相同的情况下结构是否相同</p>
<p><strong>思路</strong></p>
<p>方法isSubtree 判断树是否包含子树</p>
<ul>
<li><p>判断当前树是否<strong>是</strong>子树subRoot</p>
</li>
<li><p>判断左子树是否<strong>包含</strong>子树subRoot</p>
</li>
<li><p>判断右子树是否<strong>包含</strong>子树subRoot</p>
</li>
</ul>
<p>方法isSameTree</p>
<ul>
<li>判断当前值是否和子树值相同</li>
<li>判断左子树是否相同</li>
<li>判断右子树是否相同</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">    	<span class="comment">//如果root或者subRoot只有一个为空 那么就一定root不包含subroot</span></span><br><span class="line">    	<span class="keyword">if</span>(root==<span class="literal">null</span> &amp;&amp; subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span> || subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">              isSameTree(root,subRoot) <span class="comment">//判断当前树是否是子树subRoot</span></span><br><span class="line">            ||isSubtree(root.left,subRoot) <span class="comment">//判断左子树是否包含subRoot</span></span><br><span class="line">            ||isSubtree(root.right,subRoot); <span class="comment">//判断右子树是否包含subRoot</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode root,TreeNode subRoot)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span> &amp;&amp; subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root==<span class="literal">null</span>|| subRoot==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//只有值相同且左右子树结构也相同才会返回true</span></span><br><span class="line">        <span class="keyword">return</span> root.val==subRoot.val</span><br><span class="line">                &amp;&amp; isSameTree(root.left,subRoot.left) </span><br><span class="line">                &amp;&amp; isSameTree(root.right,subRoot.right); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉树的最大深度"   >
          <a href="#二叉树的最大深度" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1>
      <p>这道题其实在<strong>层序遍历</strong>的时候接触过了，所以这道求二叉树最大深度的做题过程会放在层序遍历的那块中</p>

        <h2 id="104-二叉树的最大深度-1"   >
          <a href="#104-二叉树的最大深度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#104-二叉树的最大深度-1" class="headerlink" title="104.二叉树的最大深度"></a>104.二叉树的最大深度</h2>
      <p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" >Leetcode.104题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="题解-17"   >
          <a href="#题解-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="层序遍历"   >
          <a href="#层序遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4>
      <p>每遍历到一层，深度计数器++即可，然后最后返回计数器的值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="递归遍历"   >
          <a href="#递归遍历" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h4>
      <p>首先我们先要理解，树的高度和树的深度的意义：</p>
<ul>
<li>高度： 某个结点到子叶结点的距离</li>
<li>深度：某个结点到根节点的距离</li>
</ul>
<p>如图所示一颗二叉树的深度和高度的关系</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230830094022228.png"  alt="高度和深度关系">
      </p>
<p>那么本题就能知道其实根节点的高度也是最大深度</p>
<p>我们通过递归来求树的深度的话，我们选用哪种递归方式比较好求？ 答案是<strong>后序遍历</strong>，因为后序遍历是<strong>左右中</strong>，可以获取到左右子树的高度再+1就能知道本结点的高度。</p>
<p><strong>实现</strong></p>
<ul>
<li><p>明确递归的参数以及返回参数：需传入结点，返回高度</p>
</li>
<li><p>明确递归的结束条件： 结束当遍历到NULL结点时，返回高度为0  那么就能保证子叶结点高度为1</p>
</li>
<li><p>单层遍历要做的： 遍历获取左子树和右子树的高度，然后取最大值+1 就代表本结点的高度</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHight(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftHight=getHight(root.left);   <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="type">int</span> rightHight=getHight(root.right); <span class="comment">//遍历右子树</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rootHight=leftHight&gt;rightHight? leftHight + <span class="number">1</span> : rightHight + <span class="number">1</span>; <span class="comment">//处理中结点</span></span><br><span class="line">        <span class="keyword">return</span> rootHight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>精简代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHight(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>  Math.max(getHight(root.left),getHight(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="559-N叉数的最大深度"   >
          <a href="#559-N叉数的最大深度" class="heading-link"><i class="fas fa-link"></i></a><a href="#559-N叉数的最大深度" class="headerlink" title="559.N叉数的最大深度"></a>559.N叉数的最大深度</h2>
      <p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" >Leetcode.559(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-17"   >
          <a href="#第一次做-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-17" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;30</p>

        <h4 id="第一次代码-19"   >
          <a href="#第一次代码-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-19" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(Node n: node.children)&#123;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-19"   >
          <a href="#提交成功-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-19" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-18"   >
          <a href="#题解-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="层序遍历-1"   >
          <a href="#层序遍历-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h4>
      <p>思路：统计层数，每层将每个结点下的children集合数据添加到队列中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line"></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="comment">//添加子结点入队</span></span><br><span class="line">                <span class="keyword">for</span>(Node n: node.children)&#123;</span><br><span class="line">                    queue.add(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="递归遍历-1"   >
          <a href="#递归遍历-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归遍历-1" class="headerlink" title="递归遍历"></a>递归遍历</h4>
      <p>思想：当传入一个结点Root，先获取子结点的最大高度，然后最大高度++返回即是本结点高度</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHight(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="comment">//空节点高度为0</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//叶子结点高度为1</span></span><br><span class="line">        <span class="keyword">if</span>(root.children.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计本结点下的子结点最大高度</span></span><br><span class="line">        <span class="keyword">for</span>(Node n:root.children)&#123;</span><br><span class="line">           high=Math.max(getHight(n),high);</span><br><span class="line">        &#125;</span><br><span class="line">        high++;</span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉树的最小深度"   >
          <a href="#二叉树的最小深度" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h1>
      <p>这道题其实也在<strong>层序遍历</strong>的时候接触过了，所以这道题的做题过程也会放在层序遍历的那块中</p>

        <h2 id="111-二叉树的最小深度-1"   >
          <a href="#111-二叉树的最小深度-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#111-二叉树的最小深度-1" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h2>
      <p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" >Leetcode.111题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="题解-19"   >
          <a href="#题解-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="层序遍历-2"   >
          <a href="#层序遍历-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#层序遍历-2" class="headerlink" title="层序遍历"></a>层序遍历</h4>
      <p>思路：层序遍历，当找到第一个叶子结点，返回此时层数也就是最小深度</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            dept++;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right==<span class="literal">null</span>) <span class="keyword">return</span> dept;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="递归遍历-2"   >
          <a href="#递归遍历-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归遍历-2" class="headerlink" title="递归遍历"></a>递归遍历</h4>
      <p>思路：我们用后序遍历，求得左右子树的最小高度，然后+1就是每个结点的最小高度</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归的传入参数以及返回值：传入TreeNode结点，返回值为结点的最小高度</p>
</li>
<li><p>递归的结束条件：当root&#x3D;&#x3D;null 说明上一个结点是叶子结点，返回高度0</p>
</li>
<li><p>单层递归逻辑：获取左右子树的最小高度，然后最小高度+1就是本结点的最小高度</p>
<ul>
<li><p>当左子树为空右子树不为空，那么最小高度应该是右子树的高度+1</p>
</li>
<li><p>当左子树不为空右子树为空，那么最小高度应该是左子树的高度+1</p>
</li>
<li><p>当左右子树都不为空，那么最小高度是左右子树的最小高度+1</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHight=getHight(root.left);</span><br><span class="line">        <span class="type">int</span> rightHight=getHight(root.right);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>获取左子树和右子树的高度，然后进行左右子树的判断 如下图分析本结点的最小高度</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230830111621147.png"  alt="二叉树的最小深度">
      </p>
<p>因此完整代码应该如下</p>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getHight(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> leftHight=getHight(root.left);</span><br><span class="line">       <span class="type">int</span> rightHight=getHight(root.right);</span><br><span class="line">    	<span class="comment">//左子树为空 那么本结点最小高度应该是右子树高度+1</span></span><br><span class="line">       <span class="keyword">if</span>(root.left==<span class="literal">null</span>) <span class="keyword">return</span> rightHight+<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//右子树为空 本结点最小高度是左子树高度+1</span></span><br><span class="line">       <span class="keyword">if</span>(root.right==<span class="literal">null</span>) <span class="keyword">return</span> leftHight+<span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//左右子树不为空</span></span><br><span class="line">       <span class="keyword">return</span> leftHight&lt;rightHight? leftHight+<span class="number">1</span>: rightHight+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>精简代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> getHight(root);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span>(root.left==<span class="literal">null</span>) <span class="keyword">return</span> getHight(root.right)+<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(root.right==<span class="literal">null</span> ) <span class="keyword">return</span> getHight(root.left)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> Math.min(getHight(root.left),getHight(root.right))+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="完全二叉树的节点个数"   >
          <a href="#完全二叉树的节点个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1>
      <p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" >完全二叉树</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>

        <h2 id="222-完全二叉树的节点个数"   >
          <a href="#222-完全二叉树的节点个数" class="heading-link"><i class="fas fa-link"></i></a><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/" >Leetcode.222题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-18"   >
          <a href="#第一次做-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-18" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;31</p>

        <h4 id="第一次代码-20"   >
          <a href="#第一次代码-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-20" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> number;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                number++;</span><br><span class="line">                TreeNode node= queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-20"   >
          <a href="#提交成功-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-20" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-20"   >
          <a href="#题解-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>层序遍历</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> number;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//结点数++</span></span><br><span class="line">                number++;</span><br><span class="line">                TreeNode node= queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>递归遍历</strong></p>
<p><em>普通二叉树统计结点个数利用前中后序都可以(这里代码是后序)</em></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> countTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftCount=countTree(root.left);</span><br><span class="line">        <span class="type">int</span> rightCount=countTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftCount+rightCount+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p><em>利用完全二叉树的特性</em></p>
<p>思路</p>
<ul>
<li>因为完全二叉树除了最后一层其他都是满二叉树，所以如果一个二叉树是满二叉树的话 那它的结点个数为2^n -1 个，n为左右子树的深度，而获取左右子树的深度则只需要遍历左子树外侧和右子树外侧</li>
<li>如果一个树不是满二叉树的话，那么统计左右两边子树的个数</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p>递归遍历的返回值和参数：返回值是结点数，参数是传入的根节点</p>
</li>
<li><p>递归遍历的结束条件：</p>
<ul>
<li><p>如果root&#x3D;&#x3D;null 说明是空节点，上一个结点是叶子结点，返回0</p>
</li>
<li><p>如果左子树深度和右子树深度一致，说明是满二叉树，返回2^n-1个结点数(利用位运算 2&lt;&lt;n -1)</p>
<ul>
<li><p>如何获取左右子树深度</p>
</li>
<li><p>左子树深度，定义一个left指向左子树，然后一直往左子树指，当非空深度+1</p>
</li>
<li><p>右子树深度，定义一个right指向右子树，然后一直往右子树指，当非空深度+1</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单层递归的逻辑：</p>
<p>说明这棵完全二叉树不是满二叉树，那么统计左右子树的节点个数，最后返回左右子树结点数之和+1</p>
</li>
</ul>
<blockquote>
<p>这里获取左右子树深度只搜索子树外侧，不搜索内侧</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230831100628439.png"  alt="统计完全二叉树结点个数">
      </p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getNumber(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//空结点</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//指向左子树，指向右子树</span></span><br><span class="line">        TreeNode left=root.left;</span><br><span class="line">        TreeNode right=root.right;</span><br><span class="line">        <span class="comment">//统计深度，左指针一直往左子树的外侧指</span></span><br><span class="line">        <span class="type">int</span> leftDept=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightDept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">null</span>) &#123;</span><br><span class="line">            left=left.left;</span><br><span class="line">            leftDept++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右指针一直往右子树的外侧指</span></span><br><span class="line">        <span class="keyword">while</span>(right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right=right.right;</span><br><span class="line">            rightDept++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左右子树深度相同，说明是满二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(leftDept==rightDept) <span class="keyword">return</span> (<span class="number">2</span>&lt;&lt;leftDept)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不是满二叉树统计左右子树结点数之和+1</span></span><br><span class="line">        <span class="type">int</span> leftNumber=getNumber(root.left);</span><br><span class="line">        <span class="type">int</span> rightNumber=getNumber(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftNumber+rightNumber+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="平衡二叉树"   >
          <a href="#平衡二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1>
      <p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：</p>
<blockquote>
<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>
</blockquote>

        <h2 id="110-平衡二叉树"   >
          <a href="#110-平衡二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/" >Leetcode.110题(平衡二叉树)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-19"   >
          <a href="#第一次做-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-19" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;31</p>

        <h4 id="第一次代码-21"   >
          <a href="#第一次代码-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-21" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> rootBalanced=getHight(root);</span><br><span class="line">        Boolean leftBalanced=isBalanced(root.left);</span><br><span class="line">        Boolean rightBalanced=isBalanced(root.right);</span><br><span class="line">        <span class="keyword">return</span> rootBalanced&lt;=<span class="number">1</span> &amp;&amp; leftBalanced &amp;&amp; rightBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHight=getHight(root.left);</span><br><span class="line">        <span class="type">int</span> rightHight=getHight(root.right);</span><br><span class="line">        <span class="type">int</span> absoluteHight=leftHight-rightHight;</span><br><span class="line">        <span class="keyword">return</span> absoluteHight&gt; <span class="number">0</span> ? absoluteHight : -<span class="number">1</span> * absoluteHight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>无论什么测试案例都会一直返回true，通过debug查找到原来是getHight这个方法有问题，左右子树的深度会一直是0，因为单层逻辑没有对数据进行一个加减，所以获取高度绝对值不能放到getHight方法中，getHight就只做一个获取高度的逻辑就行</p>

        <h4 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> leftHight=getHight(root.left);</span><br><span class="line">        <span class="type">int</span> rightHight=getHight(root.right);</span><br><span class="line">        <span class="type">int</span> rootBalanced=leftHight&gt;rightHight ? </span><br><span class="line">            leftHight-rightHight : rightHight-leftHight;</span><br><span class="line">        Boolean leftBalanced=isBalanced(root.left);</span><br><span class="line">        Boolean rightBalanced=isBalanced(root.right);</span><br><span class="line">        <span class="keyword">return</span> rootBalanced&lt;=<span class="number">1</span> &amp;&amp; leftBalanced &amp;&amp; rightBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHight=getHight(root.left);</span><br><span class="line">        <span class="type">int</span> rightHight=getHight(root.right);</span><br><span class="line">        <span class="keyword">return</span> leftHight&gt;rightHight ? leftHight+<span class="number">1</span>:rightHight+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-21"   >
          <a href="#提交成功-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-21" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-21"   >
          <a href="#题解-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以在求高度的时候定义一个值-1，来代表左右子树其中之一不是平衡二叉树，那么整棵树就不会是平衡二叉树，于是-1就一直往根节点传，如果是平衡二叉树就求出当前结点高度，然后传给父节点由父节点进行比较左右子树结点高度是否绝对值是否超过1</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归遍历的参数和返回值：返回值为高度，传入参数为根节点</p>
<ul>
<li>高度如果为-1 那么说明不是平衡二叉树</li>
<li>高度如果不为-1 那么就说是平衡二叉树</li>
</ul>
</li>
<li><p>递归遍历的结束条件</p>
<ul>
<li>如果root&#x3D;&#x3D;null 返回高度0</li>
<li>如果左&#x2F;右子树高度为-1 则返回-1一直到根节点 代表不是平衡二叉树</li>
<li>如果左右子树高度差超过1 则返回-1到根节点</li>
</ul>
</li>
<li><p>递归遍历的单层逻辑</p>
<p>获取左右子树高度，如果左右子树高度不超过1，那么则返回左右子树最大高度+1</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">	   <span class="comment">//如果传递上来的高度是-1 说明不是平衡二叉树，其他高度都是平衡二叉树</span></span><br><span class="line">       <span class="keyword">return</span> getHight(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHight</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取左子树高度，如果左子树为-1说明左子树不是平衡二叉树往上传递-1 下同</span></span><br><span class="line">        <span class="type">int</span> leftHight=getHight(root.left);</span><br><span class="line">        <span class="keyword">if</span>(leftHight==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightHight=getHight(root.right);</span><br><span class="line">        <span class="keyword">if</span>(rightHight==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">absoluteHight</span></span><br><span class="line">            <span class="operator">=</span>leftHight&gt;rightHight ? leftHight-rightHight: rightHight-leftHight;</span><br><span class="line">        <span class="comment">//如果高度差超过-1 那么就不是平衡二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(absoluteHight&gt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是平衡二叉树往上传高度</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftHight,rightHight)+<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉树的所有路径"   >
          <a href="#二叉树的所有路径" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h1>
      <p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>

        <h2 id="257-二叉树的所有路径"   >
          <a href="#257-二叉树的所有路径" class="heading-link"><i class="fas fa-link"></i></a><a href="#257-二叉树的所有路径" class="headerlink" title="257.二叉树的所有路径"></a>257.二叉树的所有路径</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/" >Leetcode.257题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-20"   >
          <a href="#第一次做-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-20" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;01</p>

        <h4 id="第一次代码-22"   >
          <a href="#第一次代码-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-22" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSearch(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSearch</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(root.val); <span class="comment">//中</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; leftSearch=getSearch(root.left);</span><br><span class="line">        List&lt;String&gt; rightSearch=getSearch(root.right);</span><br><span class="line">        <span class="keyword">if</span>(leftSearch!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s:leftSearch)&#123;</span><br><span class="line">                result.add(sb.toString()+<span class="string">&quot;-&gt;&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     	<span class="keyword">if</span>(rightSearch!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s:rightSearch)&#123;</span><br><span class="line">                result.add(sb.toString()+<span class="string">&quot;-&gt;&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: 返回值一直是[] ，一直是空集合返回</p>

        <h4 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getSearch(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSearch</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(root.val); <span class="comment">//中</span></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; leftSearch=getSearch(root.left);</span><br><span class="line">        List&lt;String&gt; rightSearch=getSearch(root.right);</span><br><span class="line">        <span class="comment">//当左右子树路径有一个不为空则要添加到result中</span></span><br><span class="line">        <span class="keyword">if</span>(leftSearch.size()!=<span class="number">0</span>||rightSearch.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String s:leftSearch)</span><br><span class="line">            result.add(sb.toString()+<span class="string">&quot;-&gt;&quot;</span>+s);</span><br><span class="line">            <span class="keyword">for</span>(String s:rightSearch)&#123;</span><br><span class="line">            result.add(sb.toString()+<span class="string">&quot;-&gt;&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//添加result当前数据</span></span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-22"   >
          <a href="#提交成功-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-22" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-22"   >
          <a href="#题解-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：遍历方式选用前序遍历(中左右)，因为父节点要指向子结点所以采用前序遍历，同时递归的时候要进行一个<strong>回溯</strong>操作。</p>
<p><strong>实现</strong></p>
<ul>
<li><p>选用前序遍历，定义一个result用于装结果集，定义一个path用于表示单层路径</p>
</li>
<li><p>pathGet方法用递归</p>
<ul>
<li>递归的参数和返回类型：递归参数path：单层路径，result：结果集，root：结点</li>
<li>递归的结束条件：当root是叶子结点即可以收获结果集，添加路径到result中。也即叶子结点是left&#x3D;&#x3D;null&amp;&amp;right&#x3D;&#x3D;null</li>
<li>递归的单层逻辑：非叶子结点<ul>
<li>如果左子树不为空则向左收集路径，递归结束调用remove删除最后一个元素进行回溯</li>
<li>如果右子树不为空则向右收集路径，递归结束后调用remove删除最后一个元素进行回溯</li>
</ul>
</li>
</ul>
</li>
<li><p>注意点</p>
<ul>
<li>path要在判断是否为叶子结点之前收集root的数据，因为调用方法时root为叶子结点就结束了，不可能传入空结点所以不用判空。</li>
<li>当向左向右递归结束之后都要回溯数据：删除path路径的最后一个数据，也即左右子树数据</li>
<li>path中的数据是存放的数据，如1-&gt;3-&gt;5存放到path中是135，所以要进行一个拼接再添加到结果集中</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    	<span class="comment">//用于接收结果集</span></span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于表示单层路径</span></span><br><span class="line">    	List&lt;String&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        pathGet(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathGet</span><span class="params">(TreeNode root,List&lt;String&gt; path,List&lt;String&gt; result)</span>&#123;</span><br><span class="line"></span><br><span class="line">        path.add(root.val+<span class="string">&quot;&quot;</span>);<span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果是叶子结点，所以收获结果集。拼接path中的路径  </span></span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="comment">//遍历到倒数第二个元素，都用元素+“-&gt;”拼接，最后一个元素最后直接拼接</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                sb.append(path.get(i)+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(root.val);</span><br><span class="line">            <span class="comment">//添加到结果集中</span></span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树不为空，向左收获结果，然后回溯pop掉左子树数据</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pathGet(root.left,path,result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下同 向右子树收集结果结束递归后回溯</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pathGet(root.right,path,result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="左叶子之和"   >
          <a href="#左叶子之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h1>
      <p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>

        <h2 id="404-左叶子之和"   >
          <a href="#404-左叶子之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#404-左叶子之和" class="headerlink" title="404.左叶子之和"></a>404.左叶子之和</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/" >Leetcode.404题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-21"   >
          <a href="#第一次做-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-21" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;01</p>

        <h4 id="第一次代码-23"   >
          <a href="#第一次代码-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-23" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> getSum(root,sum);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> left=getSum(root.left,sum);</span><br><span class="line">       <span class="type">int</span> right=getSum(root.right,sum);</span><br><span class="line"></span><br><span class="line">       sum+=left+right+ root.left.val;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-2"   >
          <a href="#提交错误-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-2" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>空指针异常，没有root.left</p>

        <h4 id="第二次代码-7"   >
          <a href="#第二次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-7" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getSum(root,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        left=getSum(root.left,sum);</span><br><span class="line">        sum+=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">        right=getSum(root.right,sum);</span><br><span class="line"></span><br><span class="line">        sum+=left+right;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-3"   >
          <a href="#提交错误-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-3" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>输入[3,9,20,null,null,15,7]，输出33 预期输出24</p>

        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> getSum(root,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">        left=getSum(root.left,sum);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">        right=getSum(root.right,sum);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=left+right+root.left.val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             sum+=left+right;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-4"   >
          <a href="#提交错误-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-4" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:root&#x3D;[1,2,3,4,5] ,输出6,预期输出4</p>
<p>原因是我将非叶子结点的左数据也输出了</p>

        <h4 id="第四次代码-1"   >
          <a href="#第四次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-1" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getSum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum+=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)</span><br><span class="line">        left=getSum(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">        right=getSum(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum+=left+right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-5"   >
          <a href="#提交错误-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-5" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>原因是在判断root左结点是叶子结点就直接结束了循环，而没有对左右子树做判断</p>

        <h4 id="第五次代码-1"   >
          <a href="#第五次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五次代码-1" class="headerlink" title="第五次代码"></a>第五次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getSum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)</span><br><span class="line">        left=getSum(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">        right=getSum(root.right);</span><br><span class="line">        <span class="keyword">return</span> sum+=left+right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-23"   >
          <a href="#提交成功-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-23" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-23"   >
          <a href="#题解-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong>：我们用<strong>后序遍历</strong>可以实现这道题的代码过程，具体的处理结点应该是左叶子结点的父结点</p>
<blockquote>
<p>左叶子：为叶子结点，并且是父节点的左孩子。</p>
</blockquote>
<p>因为是要统计左叶子之和，所以我们要在父节点处理左叶子之和</p>
<p><strong>实现</strong>：</p>
<ul>
<li>递归条件的参数和返回值：参数root结点，返回值为当前root结点下的左叶子之和</li>
<li>递归的结束条件<ul>
<li>如果root为空 则返回0</li>
<li>如果root是叶子结点则返回0 <em>(root.left&#x3D;&#x3D;null &amp;&amp; root.right&#x3D;&#x3D;null)</em></li>
</ul>
</li>
<li>单层递归的逻辑：<ul>
<li>统计左孩子的左叶子之和，如果左孩子是左叶子，那么左孩子的左叶子之和就为左孩子的值</li>
<li>统计右孩子的左叶子之和</li>
<li>当前结点的左叶子之和为左右结点的左叶子之和的和</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getSum(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//如果是空节点则返回0  如果是叶子结点则返回0</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span>&amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//遍历左子树统计左叶子之和</span></span><br><span class="line">        <span class="type">int</span> leftNum=getSum(root.left);</span><br><span class="line">        <span class="comment">//如果当前结点的左孩子是叶子结点 则当前结点的左叶子之和就是左孩子的数值</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>) </span><br><span class="line">            leftNum=root.left.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计右子树的左叶子之和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightNum</span> <span class="operator">=</span>getSum(root.right);</span><br><span class="line">        <span class="comment">//返回左右子树的左叶子之和的和 作为当前根节点左叶子之和</span></span><br><span class="line">        <span class="keyword">return</span> leftNum+rightNum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="找树左下角的值"   >
          <a href="#找树左下角的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h1>
      <p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>

        <h2 id="513-找树左下角的值"   >
          <a href="#513-找树左下角的值" class="heading-link"><i class="fas fa-link"></i></a><a href="#513-找树左下角的值" class="headerlink" title="513.找树左下角的值"></a>513.找树左下角的值</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/" >Leetcode.513(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-22"   >
          <a href="#第一次做-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-22" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;02</p>

        <h4 id="第一次代码-24"   >
          <a href="#第一次代码-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-24" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      
        <h5 id="层序遍历-3"   >
          <a href="#层序遍历-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#层序遍历-3" class="headerlink" title="层序遍历"></a>层序遍历</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历，当最后一层时第一个结点就是树最左下角的值</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//最后一层</span></span><br><span class="line">                <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-24"   >
          <a href="#提交成功-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-24" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="递归遍历-3"   >
          <a href="#递归遍历-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归遍历-3" class="headerlink" title="递归遍历"></a>递归遍历</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        List&lt;String&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getLeftLeaves(root,path,result);</span><br><span class="line">        <span class="keyword">if</span>(result.size()==<span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="type">int</span> max=result.get(<span class="number">0</span>).charAt(result.get(<span class="number">0</span>).length()-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;result.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.get(i).charAt(result.get(i).length()-<span class="number">1</span>)&gt;max) index=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.get(index).charAt(result.get(index).length()-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getLeftLeaves</span><span class="params">(TreeNode root,List&lt;String&gt; path,List&lt;String&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        path.add(root.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(String s: path)&#123;</span><br><span class="line">                sb.append(s+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(root.left.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        getLeftLeaves(root.left,path,result);</span><br><span class="line">        getLeftLeaves(root.right,path,result);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:root&#x3D;[0,-1] 输出1 预期输出-1</p>
<p>原因是符号也占了一个字符，所以我输出的是最后的字符只有1</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getLeftLeaves(root,path,result);</span><br><span class="line">        <span class="keyword">if</span>(result.size()==<span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)&#123;</span><br><span class="line">            String s=result.get(i);</span><br><span class="line">            String[] arr=s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr.length&gt;len)&#123;</span><br><span class="line">                index=i;</span><br><span class="line">                len=arr.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String s=result.get(index);</span><br><span class="line">        String[] arr=s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(arr[arr.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getLeftLeaves</span><span class="params">(TreeNode root,List&lt;String&gt; path,List&lt;String&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        path.add(root.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(String s: path)&#123;</span><br><span class="line">                sb.append(s+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(root.left.val);</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        getLeftLeaves(root.left,path,result);</span><br><span class="line">        getLeftLeaves(root.right,path,result);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-12"   >
          <a href="#提交失败-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-12" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:root&#x3D;[1,null,-1] 输出1，预期输出-1</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        getLeftLeaves(root,path,result);</span><br><span class="line">        <span class="keyword">if</span>(result.size()==<span class="number">0</span>) <span class="keyword">return</span> root.val;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)&#123;</span><br><span class="line">            String s=result.get(i);</span><br><span class="line">            String[] arr=s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(arr.length&gt;len)&#123;</span><br><span class="line">                index=i;</span><br><span class="line">                len=arr.length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String s=result.get(index);</span><br><span class="line">        String[] arr=s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(arr[arr.length-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getLeftLeaves</span><span class="params">(TreeNode root,List&lt;String&gt; path,List&lt;String&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        path.add(root.val+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.left.left==<span class="literal">null</span> &amp;&amp; root.left.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(String s: path)&#123;</span><br><span class="line">                sb.append(s+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(root.left.val);</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            getLeftLeaves(root.left,path,result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">              getLeftLeaves(root.right,path,result);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-13"   >
          <a href="#提交失败-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-13" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h3 id="题解-24"   >
          <a href="#题解-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3>
      <p>找到树最左下角的值</p>
<blockquote>
<p>树最左下角的值，最底层最靠左的结点数值</p>
</blockquote>
<p>树最左下角的结点不一定是左孩子 ，例如</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230902092036708.png"  alt="树最左下角的结点">
      </p>
<p>这道题用层序遍历就能秒了。</p>

        <h4 id="层序遍历-4"   >
          <a href="#层序遍历-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#层序遍历-4" class="headerlink" title="层序遍历"></a>层序遍历</h4>
      <p>思路： 利用queue做层序遍历，定义一个list用于接收每一层的结点，如果队列为空就说明这是最后一层。返回list第一个数值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历，当最后一层时第一个结点就是树最左下角的结点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> size=queue.size();</span><br><span class="line">            ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(queue.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//最后一层，list中第一个元素就是最左下角的结点</span></span><br><span class="line">                <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="递归遍历-4"   >
          <a href="#递归遍历-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归遍历-4" class="headerlink" title="递归遍历"></a>递归遍历</h4>
      <p>思路：我们用一个全局变量depth记录深度。当达到新的深度的时候就记录一下结点的数据。最后返回result就是最深深度时第一个记录的结点数值</p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义一个max 用于统计深度，定义一个result用于记录最深深度结点的值</p>
<ul>
<li><p>例如树有三层</p>
<blockquote>
<p>​             5</p>
<p>​		↙    ↘</p>
<p>​		1               2</p>
<p>​                   ↙    ↘       </p>
<p>​				  3              4</p>
</blockquote>
</li>
<li><p>我们用前中后序遍历都可以，只要<strong>左结点先于右节点遍历到</strong></p>
</li>
<li><p>当遍历到结点1的时候 记录此时最大深度为1 记录结点的值为1 。因此遍历到2的时候不会更新result数值</p>
</li>
<li><p>当遍历到结点3的时候 记录此时最大深度为2  记录结点的值为3。 </p>
</li>
<li><p><del>也即当新的一层只会统计最左(第一个遍历到的结点)结点数值</del></p>
</li>
<li><p>只要保证左结点优于右节点遍历</p>
</li>
</ul>
</li>
<li><p>递归函数的返回值和参数：</p>
<ul>
<li><p>返回值为void，结点数据都保存到全局变量result和max中。</p>
</li>
<li><p>参数root：此时遍历的结点</p>
</li>
<li><p>参数depth：当前结点深度</p>
</li>
</ul>
</li>
<li><p>递归函数的结束条件：</p>
<p>当遍历到叶子结点则统计深度，更新数值</p>
</li>
<li><p>单层递归逻辑：</p>
<ul>
<li>如果左结点非空，向左递归遍历。传入++当前深度，结束递归后，<strong>回溯</strong>当前深度也即depth–</li>
<li>如果右节点非空，向右遍历递归。传入++当前深度，结束递归后，<strong>回溯</strong>当前深度也即depth–</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//全局变量max，最深深度。 全局变量result 用于记录最深深度的结点的值</span></span><br><span class="line">    <span class="type">int</span> max=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        treeBottomLeft(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">treeBottomLeft</span><span class="params">(TreeNode node,<span class="type">int</span> depth)</span>&#123;</span><br><span class="line">        <span class="comment">//当遍历到叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp;node.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//判断深度，如果深度大于最深深度则更新数据</span></span><br><span class="line">            <span class="keyword">if</span>(depth&gt;max)&#123;</span><br><span class="line">                max=depth;</span><br><span class="line">                result=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左子树非空，向左遍历。结束遍历回溯当前深度</span></span><br><span class="line">        <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            treeBottomLeft(node.left,depth);</span><br><span class="line">            depth--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果右子树非空，向右遍历。结束遍历回溯当前深度</span></span><br><span class="line">        <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            depth++;</span><br><span class="line">            treeBottomLeft(node.right,depth);</span><br><span class="line">            depth--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="路径总和"   >
          <a href="#路径总和" class="heading-link"><i class="fas fa-link"></i></a><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h1>
      <p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>

        <h2 id="112-路径总和"   >
          <a href="#112-路径总和" class="heading-link"><i class="fas fa-link"></i></a><a href="#112-路径总和" class="headerlink" title="112.路径总和"></a>112.路径总和</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/" >Leetcode.112题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-23"   >
          <a href="#第一次做-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-23" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;02</p>

        <h4 id="第一次代码-25"   >
          <a href="#第一次代码-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-25" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> SearchTreeSon(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchTreeSon</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==targetSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> left=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=root.left.val;</span><br><span class="line">            left=SearchTreeSon(root.left,targetSum);</span><br><span class="line">            sum-=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            sum+=root.right.val;</span><br><span class="line">            right=SearchTreeSon(root.right,targetSum);</span><br><span class="line">            sum-=root.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-14"   >
          <a href="#提交失败-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-14" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次提交"   >
          <a href="#第二次提交" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次提交" class="headerlink" title="第二次提交"></a>第二次提交</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> SearchTreeSon(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchTreeSon</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        sum+=root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==targetSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> left=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            left=SearchTreeSon(root.left,targetSum);</span><br><span class="line">            sum-=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right=SearchTreeSon(root.right,targetSum);</span><br><span class="line">            sum-=root.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-25"   >
          <a href="#提交成功-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-25" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h4 id="题解-25"   >
          <a href="#题解-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-25" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题用递归做，遍历顺序可以是前中后序，这里我的题解是用的后序的方法，用一个全局变量sum统计当前结点的路径之和</p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义一个sum统计当前路径之和</p>
</li>
<li><p>递归的参数和返回值：</p>
<ul>
<li>参数root：遍历的结点</li>
<li>参数targetSum：传入的目标路径总和</li>
<li>返回值：布尔类型，返回是否找到路径之和相等的叶子结点</li>
</ul>
</li>
<li><p>递归的结束条件：</p>
<p>当遍历到叶子结点的时候判断路径是否相等，如果相等返回true表示找到结点，如果不相等则返回false</p>
</li>
<li><p>单层递归的逻辑：(左右中)</p>
<ul>
<li>当左结点不为空，向左搜寻结点，当左孩子遍历结束要<strong>回溯</strong>当前结点路径 (左)</li>
<li>当右孩子不为空，向右搜寻结点，当右孩子遍历结束要回溯当前结点路径 (右)</li>
<li>当左孩子或者右孩子遍历中有一个返回true则返回true 						       (中)</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"> 	<span class="comment">//全局变量sum用于记录当前结点的路径之和</span></span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> SearchTreeSon(root,targetSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">SearchTreeSon</span><span class="params">(TreeNode root,<span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="comment">//添加当前结点路径</span></span><br><span class="line">        sum+=root.val;</span><br><span class="line">		<span class="comment">//如果当前结点是叶子结点，判断路径和目标路径是否相等，如果相等返回true，反之返回false</span></span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==targetSum)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> left=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> right=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//当左孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;  <span class="comment">//左</span></span><br><span class="line">            left=SearchTreeSon(root.left,targetSum);</span><br><span class="line">            <span class="comment">//回溯到当前结点路径</span></span><br><span class="line">            <span class="comment">//因为向左孩子遍历的时候递归中sum+=root.val        (遍历中是root是当前结点的左孩子)</span></span><br><span class="line">            <span class="comment">//所以结束递归sum-=root.left.val				  (遍历结束后root是当前结点)</span></span><br><span class="line">            sum-=root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下同 当右孩子不为空</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123; <span class="comment">//右</span></span><br><span class="line">            right=SearchTreeSon(root.right,targetSum);</span><br><span class="line">            sum-=root.right.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left || right; <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="从中序与后序遍历序列构造二叉树"   >
          <a href="#从中序与后序遍历序列构造二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h1>
      <p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>

        <h2 id="106-从中序与后序遍历序列构造二叉树"   >
          <a href="#106-从中序与后序遍历序列构造二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106.从中序与后序遍历序列构造二叉树"></a>106.从中序与后序遍历序列构造二叉树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" >Leetcode.106题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-24"   >
          <a href="#第一次做-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-24" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;03</p>

        <h4 id="第一次代码-26"   >
          <a href="#第一次代码-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-26" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> root=postorder[postorder.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> rootIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rootIndex=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rootIndex==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] leftInorder=<span class="keyword">new</span> <span class="title class_">int</span>[rootIndex];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rootIndex;i++)&#123;</span><br><span class="line">            leftInorder[i]=inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> postNumber=inorder.length-rootIndex-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(postNumber==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] rightPostorder=<span class="keyword">new</span> <span class="title class_">int</span>[postNumber];</span><br><span class="line">        <span class="type">int</span> j=postorder.length-<span class="number">1</span>;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=postNumber-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightPostorder[i]=postorder[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] rightInorder=<span class="keyword">new</span> <span class="title class_">int</span>[postNumber];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;postNumber;i++)&#123;</span><br><span class="line">            rightInorder[i]=inorder[++rootIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] leftPostorder=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length-<span class="number">1</span>-postNumber&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            leftPostorder=<span class="keyword">new</span> <span class="title class_">int</span>[postorder.length-<span class="number">1</span>-postNumber];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;leftPostorder.length;i++)&#123;</span><br><span class="line">            leftPostorder[i]=postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(leftInorder.length==<span class="number">0</span> &amp;&amp;rightInorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftInorder.length==<span class="number">0</span>||leftPostorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,<span class="literal">null</span>,buildTree(rightInorder,rightPostorder));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rightInorder.length==<span class="number">0</span>||rightPostorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,buildTree(leftInorder,leftPostorder),<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,buildTree(leftInorder,leftPostorder),buildTree(rightInorder,rightPostorder));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-6"   >
          <a href="#提交错误-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-6" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:inorder&#x3D;[2,1] postorder&#x3D;[2,1] 输出[1,null,2] 预期输出[1,2]</p>
<p>原因：确定根节点索引位置的时候没有遍历inorder数组的最后一个元素</p>

        <h4 id="第二次代码-8"   >
          <a href="#第二次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-8" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> root=postorder[postorder.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> rootIndex=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//找到根节点索引位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==inorder[i])</span><br><span class="line">            &#123;</span><br><span class="line">                rootIndex=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rootIndex==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//左结点中序遍历数组</span></span><br><span class="line">        <span class="type">int</span>[] leftInorder=<span class="keyword">new</span> <span class="title class_">int</span>[rootIndex];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rootIndex;i++)&#123;</span><br><span class="line">            leftInorder[i]=inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//右子树个数</span></span><br><span class="line">        <span class="type">int</span> postNumber=inorder.length-rootIndex-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(postNumber==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//没有右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//右子树后序遍历数组</span></span><br><span class="line">        <span class="type">int</span>[] rightPostorder=<span class="keyword">new</span> <span class="title class_">int</span>[postNumber];</span><br><span class="line">        <span class="type">int</span> j=postorder.length-<span class="number">1</span>;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=postNumber-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            rightPostorder[i]=postorder[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//右子树中序遍历数组</span></span><br><span class="line">        <span class="type">int</span>[] rightInorder=<span class="keyword">new</span> <span class="title class_">int</span>[postNumber];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;postNumber;i++)&#123;</span><br><span class="line">            rightInorder[i]=inorder[++rootIndex];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//左子树后序遍历数组</span></span><br><span class="line">        <span class="type">int</span>[] leftPostorder=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length-<span class="number">1</span>-postNumber&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            leftPostorder=<span class="keyword">new</span> <span class="title class_">int</span>[postorder.length-<span class="number">1</span>-postNumber];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;leftPostorder.length;i++)&#123;</span><br><span class="line">            leftPostorder[i]=postorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//左子树和右子树为空 是叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(leftInorder.length==<span class="number">0</span> &amp;&amp;rightInorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//左子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(leftInorder.length==<span class="number">0</span>||leftPostorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,<span class="literal">null</span>,buildTree(rightInorder,rightPostorder));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//右子树为空</span></span><br><span class="line">        <span class="keyword">if</span>(rightInorder.length==<span class="number">0</span>||rightPostorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,buildTree(leftInorder,leftPostorder),<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//左右子树都不为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root,buildTree(leftInorder,leftPostorder),buildTree(rightInorder,rightPostorder));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-26"   >
          <a href="#提交成功-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-26" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-26"   >
          <a href="#题解-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：因为中序是左中右，而后序是左右中。所以我们可以通过中结点的位置来切割左右区间，左右区间获得了就能知道左右子树的中序和后序，然后递归调用即可创建树</p>
<p><strong>实现</strong></p>
<ul>
<li><p>先确定中结点位置，因为后序是<strong>左右中</strong>，所以后序数组的最后一个结点就一定是根结点</p>
</li>
<li><p>通过根结点的数值可以去遍历中序数组找到根节点位置，中序数组根结点前的就是左子树结果，根结点后的是右子树中序结果</p>
</li>
<li><p>通过左子树区间长度可以去切割后序数组，后序数组前面左子树区间个数就是左子树的后序结果，然后剩下就是右子树区间以及根节点</p>
</li>
<li><p>递归条件的参数和返回值</p>
<ul>
<li>参数inorder数组：中序数组</li>
<li>参数postorder数组：后序数组</li>
<li>返回值TreeNode：构建的树</li>
</ul>
</li>
<li><p>递归的结束条件</p>
<p>当postorder数组或者inorder数组长度为0 说明是空结点返回null</p>
</li>
<li><p>单层递归的逻辑</p>
</li>
<li><ul>
<li>找到根结点位置</li>
<li>切割中序数组，获取左子树和右子树区间</li>
<li>切割后序数组，通过左子树区间长度可以找到后序数组中左区间个数，获取左右区间</li>
<li>返回结点</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意点</p>
</blockquote>
<p><em>1.数组都是合法的，也即中序和后序遍历的长度一致</em></p>
<p><em>2.当后序数组长度为1，那么说明是根节点也是叶子结点 可以直接返回root没有左右子树</em></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inAndPostbuild(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inAndPostbuild</span><span class="params">(<span class="type">int</span>[] inorder,<span class="type">int</span>[] postorder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后序确定根节点</span></span><br><span class="line">        <span class="type">int</span> rootVal=postorder[postorder.length-<span class="number">1</span>];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">//根节点是叶子结点 则直接返回根节点(没有左右子树)</span></span><br><span class="line">        <span class="keyword">if</span>(inorder.length==<span class="number">1</span>||postorder.length==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;inorder.length;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index]==rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//运行到这里说明有左子树或者右子树或者左右子树</span></span><br><span class="line">        <span class="comment">//左孩子的中序和后序</span></span><br><span class="line">        <span class="type">int</span>[] leftIn=<span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] leftPost=<span class="keyword">new</span> <span class="title class_">int</span>[leftIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;index;j++)&#123;</span><br><span class="line">            leftIn[j]=inorder[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;j&lt;leftPost.length;j++)&#123;</span><br><span class="line">            leftPost[j]=postorder[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右孩子的中序和后序</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] rightIn=<span class="keyword">new</span> <span class="title class_">int</span>[inorder.length-<span class="number">1</span>-index];</span><br><span class="line">        <span class="type">int</span>[] rightPost=<span class="keyword">new</span> <span class="title class_">int</span>[rightIn.length];</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightIn.length;i++,index++)&#123;</span><br><span class="line">            rightIn[i]=inorder[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightPost.length;i++)&#123;</span><br><span class="line">            rightPost[i]=postorder[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left=inAndPostbuild(leftIn,leftPost);</span><br><span class="line">        root.right=inAndPostbuild(rightIn,rightPost);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <p>我自己在做这道题目的时候，在切割中序的左孩子右孩子以及切割后序的左区间和右区间的思维较为混乱，切割后序的左区间可以通过中序切出来的左子树区间大小来切割。</p>
<p>并且在递归的结束条件我写的比较混乱，但总体来说是思维没错的。</p>
<p>总体来说可以通过根节点的位置来切割左右区间，而切割中序的时候是用根节点位置，切割后序的时候是通过左孩子区间的大小切割</p>
<p>递归结束为:当后序数组为空或者中序数组为空则代表空节点直接返回null </p>

        <h2 id="105-从前序与中序遍历序列构造二叉树"   >
          <a href="#105-从前序与中序遍历序列构造二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h2>
      <p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >Leetcode.105题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-25"   >
          <a href="#第一次做-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-25" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;03</p>

        <h4 id="第一次代码-27"   >
          <a href="#第一次代码-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-27" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prexAndinBuild(preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">prexAndinBuild</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span> ||inorder.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> rootVal=preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//运行到这里说明起码有左子树或者右子树或者左右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;inorder.length;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index]==rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] leftIn=<span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] leftPrex=<span class="keyword">new</span> <span class="title class_">int</span>[leftIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            leftIn[i]=inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,i=<span class="number">0</span>;i&lt;leftPrex.length;i++,j++)&#123;</span><br><span class="line">            leftPrex[i]=preorder[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] rightIn=<span class="keyword">new</span> <span class="title class_">int</span>[inorder.length-index-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightPrex=<span class="keyword">new</span> <span class="title class_">int</span>[rightIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightIn.length;i++,index++)&#123;</span><br><span class="line">            rightIn[i]=inorder[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=leftIn.length+<span class="number">1</span>,i=<span class="number">0</span>;j&lt;rightPrex.length;i++,j++)&#123;</span><br><span class="line">            rightPrex[i]=preorder[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left=prexAndinBuild(leftPrex,leftIn);</span><br><span class="line">        root.right=prexAndinBuild(rightPrex,rightIn);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-15"   >
          <a href="#提交失败-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-15" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:preorder&#x3D;[3,9,20,15,7] inorder&#x3D;[9,3,15,20,7] 输出[3,9,20,null,null,0,0] 预期输出[3,9,20,null,null,15,7]</p>
<p>原因是右子树的前序的时候循环条件写错了，应该是i&lt;rightPrex.length 改了就好了</p>

        <h4 id="第二次代码-9"   >
          <a href="#第二次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-9" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prexAndinBuild(preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">prexAndinBuild</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span> ||inorder.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> rootVal=preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//运行到这里说明起码有左子树或者右子树或者左右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;inorder.length;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index]==rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] leftIn=<span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] leftPrex=<span class="keyword">new</span> <span class="title class_">int</span>[leftIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            leftIn[i]=inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,i=<span class="number">0</span>;i&lt;leftPrex.length;i++,j++)&#123;</span><br><span class="line">            leftPrex[i]=preorder[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] rightIn=<span class="keyword">new</span> <span class="title class_">int</span>[inorder.length-index-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightPrex=<span class="keyword">new</span> <span class="title class_">int</span>[rightIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightIn.length;i++,index++)&#123;</span><br><span class="line">            rightIn[i]=inorder[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=leftIn.length+<span class="number">1</span>,i=<span class="number">0</span>;i&lt;rightPrex.length;i++,j++)&#123;</span><br><span class="line">            rightPrex[i]=preorder[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left=prexAndinBuild(leftPrex,leftIn);</span><br><span class="line">        root.right=prexAndinBuild(rightPrex,rightIn);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-27"   >
          <a href="#提交成功-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-27" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-27"   >
          <a href="#题解-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和上面中序后序确认二叉树一样，主要是找到中结点的位置，然后切割前序和中序数组，分别获取左区间和右区间</p>
<p><strong>实现</strong></p>
<ul>
<li><p>先确定中结点位置，因为前序是<strong>中左右</strong>，所以前序数组的第一个结点就一定是根结点</p>
</li>
<li><p>通过根结点的数值可以去遍历中序数组找到根节点位置，中序数组根结点前的就是左子树结果，根结点后的是右子树中序结果</p>
</li>
<li><p>通过左子树区间长度可以去切割前序数组，前序数组从索引1开始<del>(因为索引0是根节点)</del>前面左子树区间个数就是左子树的前序结果，然后剩下就是右子树区间</p>
</li>
<li><p>递归条件的参数和返回值</p>
<ul>
<li>参数inorder数组：中序数组</li>
<li>参数preorder数组：前序数组</li>
<li>返回值TreeNode：构建的树</li>
</ul>
</li>
<li><p>递归的结束条件</p>
<p>当preorder数组或者inorder数组长度为0 说明是空结点返回null</p>
</li>
<li><p>单层递归的逻辑</p>
</li>
<li><ul>
<li>找到根结点位置</li>
<li>切割中序数组，获取左子树和右子树区间</li>
<li>切割前序数组，通过左子树区间长度可以找到前序数组中左区间个数，获取左右区间</li>
<li>返回结点</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意点</p>
</blockquote>
<p><em>1.数组都是合法的，也即前序和中序遍历的长度一致</em></p>
<p><em>2.当前序数组长度为1，那么说明是根节点也是叶子结点 可以直接返回root没有左右子树</em></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prexAndinBuild(preorder,inorder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">prexAndinBuild</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">0</span> ||inorder.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> rootVal=preorder[<span class="number">0</span>];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果前序数组长度只有1说明根节点是叶子结点</span></span><br><span class="line">        <span class="keyword">if</span>(preorder.length==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//运行到这里说明起码有左子树或者右子树或者左右子树</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;index&lt;inorder.length;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[index]==rootVal) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取左子树的前序和中序数组</span></span><br><span class="line">        <span class="type">int</span>[] leftIn=<span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="type">int</span>[] leftPrex=<span class="keyword">new</span> <span class="title class_">int</span>[leftIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            leftIn[i]=inorder[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>,i=<span class="number">0</span>;i&lt;leftPrex.length;i++,j++)&#123;</span><br><span class="line">            leftPrex[i]=preorder[j];</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取右子树的前序和中序数组</span></span><br><span class="line">        <span class="type">int</span>[] rightIn=<span class="keyword">new</span> <span class="title class_">int</span>[inorder.length-index-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] rightPrex=<span class="keyword">new</span> <span class="title class_">int</span>[rightIn.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightIn.length;i++,index++)&#123;</span><br><span class="line">            rightIn[i]=inorder[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=leftIn.length+<span class="number">1</span>,i=<span class="number">0</span>;i&lt;rightPrex.length;i++,j++)&#123;</span><br><span class="line">            rightPrex[i]=preorder[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left=prexAndinBuild(leftPrex,leftIn);</span><br><span class="line">        root.right=prexAndinBuild(rightPrex,rightIn);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="最大二叉树"   >
          <a href="#最大二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h1>
      <p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的</em> <em><strong>最大二叉树</strong></em> 。</p>

        <h2 id="654-最大二叉树"   >
          <a href="#654-最大二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#654-最大二叉树" class="headerlink" title="654.最大二叉树"></a>654.最大二叉树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/description/" >Leetcode.654(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-26"   >
          <a href="#第一次做-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-26" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;03</p>

        <h4 id="第一次代码-28"   >
          <a href="#第一次代码-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-28" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> findMax(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)&#123;</span><br><span class="line">                max=nums[i];</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(max);</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">		</span><br><span class="line">        <span class="type">int</span>[] leftNums=<span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            leftNums[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] rightNums=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-<span class="number">1</span>-index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightNums.length;i++,index++)&#123;</span><br><span class="line">            rightNums[i]=nums[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left=findMax(leftNums);</span><br><span class="line">        root.right=findMax(rightNums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-28"   >
          <a href="#提交成功-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-28" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-28"   >
          <a href="#题解-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：前序递归(中左右)构造最大二叉树，先构造中结点，再构造左子树然后构造右子树</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>参数nums：整数数组</li>
<li>返回值TreeNode：构造出来的最大二叉树</li>
</ul>
</li>
<li><p>递归的终止条件</p>
<ul>
<li>当nums.length&#x3D;&#x3D;0 说明空数组是空结点，所以返回null</li>
<li>当nums.length&#x3D;&#x3D;1 说明是叶子结点,构造TreeNode(nums[0])返回</li>
</ul>
</li>
<li><p>单层递归的逻辑</p>
<ul>
<li>定义一个max和index 用于标记数组中最大值的值和位置<ul>
<li>遍历nums获取max和index</li>
<li>max标记数组中最大值</li>
<li>index标记数组中最大值的索引下标</li>
</ul>
</li>
<li>获取左子树的nums，递归调用函数构造左子树 <em>左子树nums为数组中index左边部分</em></li>
<li>获取右子树的nums，递归调用函数构造右子树 <em>右子树nums为数组中index右边部分</em></li>
<li>返回构建出的TreeNode结点</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> findMax(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到最大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)&#123;</span><br><span class="line">                max=nums[i];</span><br><span class="line">                index=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(max);</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//运行到这里是非叶子结点</span></span><br><span class="line">        <span class="type">int</span>[] leftNums=<span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++)&#123;</span><br><span class="line">            leftNums[i]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] rightNums=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-<span class="number">1</span>-index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;rightNums.length;i++,index++)&#123;</span><br><span class="line">            rightNums[i]=nums[index+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left=findMax(leftNums);</span><br><span class="line">        root.right=findMax(rightNums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="合并二叉树"   >
          <a href="#合并二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h1>
      <p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>

        <h2 id="617-合并二叉树"   >
          <a href="#617-合并二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#617-合并二叉树" class="headerlink" title="617.合并二叉树"></a>617.合并二叉树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/" >Leetcode.617题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-27"   >
          <a href="#第一次做-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-27" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;03 (因为04号上午因部分原因没能完成当日任务，所以于03号晚上提前完成)</p>

        <h4 id="第一次代码-29"   >
          <a href="#第一次代码-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-29" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeBuild(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeBuild</span><span class="params">(TreeNode root1,TreeNode root2)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">null</span> &amp;&amp; root2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> rootVal=root1.val+root2.val;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">        root.left=mergeBuild(root1.left,root2.left);</span><br><span class="line">        root.right=mergeBuild(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-29"   >
          <a href="#提交成功-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-29" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-29"   >
          <a href="#题解-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：用前序遍历同步地遍历两个二叉树，将二叉树的根节点的数值相加，然后左右子树进行合并</p>
<p><strong>实现</strong></p>
<ul>
<li>递归的参数和返回值<ul>
<li>参数root1:第一颗二叉树</li>
<li>参数root2:第二颗二叉树</li>
<li>返回值TreeNode:二叉树的根节点</li>
</ul>
</li>
<li>递归的结束条件<ul>
<li>当root1为空root2不为空，则合并后的二叉树为root2，直接返回root2</li>
<li>当root1不为空root2为空，则合并后的二叉树为root1，直接返回root1</li>
<li>当root1为空且root2为空，则合并后的二叉树就是空结点，返回null</li>
</ul>
</li>
<li>单层递归的执行逻辑<ul>
<li>获取当前遍历的两个结点的值，相加成为新结点的数值</li>
<li>构造左子树，向左遍历root1和root2</li>
<li>构造右子树，向右遍历root1和root2</li>
<li>返回新的二叉树root</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mergeBuild(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeBuild</span><span class="params">(TreeNode root1,TreeNode root2)</span>&#123;</span><br><span class="line">		<span class="comment">//如果root1为空root2不为空则传回root2</span></span><br><span class="line">        <span class="comment">//如果root1不为空root2为空则传回root1</span></span><br><span class="line">        <span class="comment">//如果roo1和root2都为空 则返回null;</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="literal">null</span> &amp;&amp; root2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> rootVal=root1.val+root2.val;</span><br><span class="line">        <span class="comment">//定义一个新的二叉树</span></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">		<span class="comment">//向左遍历构造左子树</span></span><br><span class="line">        root.left=mergeBuild(root1.left,root2.left);</span><br><span class="line">        <span class="comment">//向右遍历构造右子树</span></span><br><span class="line">        root.right=mergeBuild(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉搜索树中的搜索"   >
          <a href="#二叉搜索树中的搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h1>
      <p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>

        <h2 id="700-二叉搜索树中的搜索"   >
          <a href="#700-二叉搜索树中的搜索" class="heading-link"><i class="fas fa-link"></i></a><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700.二叉搜索树中的搜索"></a>700.二叉搜索树中的搜索</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" >Leetcode.700题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-28"   >
          <a href="#第一次做-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-28" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;03(上同，因为04号无法完成日常任务)</p>

        <h4 id="第一次代码-30"   >
          <a href="#第一次代码-30" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-30" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> searchTree(root,val);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">searchTree</span><span class="params">(TreeNode root,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(root.val==val)&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">           <span class="keyword">return</span> searchTree(root.left,val);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> searchTree(root.right,val);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-30"   >
          <a href="#提交成功-30" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-30" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-30"   >
          <a href="#题解-30" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="递归法"   >
          <a href="#递归法" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4>
      <p>思路：因为二叉搜索树的特性，所以我们可以确认搜索的方向，所以这里不用在乎是前中后序</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归的返回值和参数</p>
<ul>
<li>参数root：二叉搜索树</li>
<li>参数val：搜索的目标值</li>
<li>返回值TreeNode：目标结点，如果没有找到则为null</li>
</ul>
</li>
<li><p>递归的结束条件：</p>
<ul>
<li>当root为空，则为空结点直接返回null</li>
<li>当root不为空<ul>
<li>root.val&#x3D;&#x3D;val：说明当前root是我们要搜索的目标结点，返回root</li>
<li>root.val&gt;val：说明当前结点值比目标结点值大，需要向左子树搜索</li>
<li>root.val&lt;val：说明当前结点值比目标结点小，需要向右子树搜索</li>
</ul>
</li>
</ul>
</li>
<li><p>单层递归的逻辑：</p>
<p>判断当前值和目标值的大小，确认搜索方向搜索</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchTree(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchTree</span><span class="params">(TreeNode root,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val==val)&#123;</span><br><span class="line">            <span class="comment">//找到搜索结点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            <span class="comment">//传入的数比根节点数小，向左子树搜索</span></span><br><span class="line">            <span class="keyword">return</span> searchTree(root.left,val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//传入的数比根结点大，向右子树搜索</span></span><br><span class="line">            <span class="keyword">return</span> searchTree(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="迭代法"   >
          <a href="#迭代法" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4>
      <p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    	<span class="comment">//循环的条件为root不为空，说明二叉树还没有搜索完</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//当目标值和当前值相等，说明找到了结点，直接返回</span></span><br><span class="line">            <span class="keyword">if</span>(root.val==val) <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">                <span class="comment">//当根节点比目标值大，向左子树搜索</span></span><br><span class="line">                root=root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">                <span class="comment">//当根节点数比目标值小，向右子树搜索</span></span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//root==null 说明二叉树中没有这个结点返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="验证二叉搜索树"   >
          <a href="#验证二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1>
      <p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>

        <h2 id="98-验证二叉搜索树"   >
          <a href="#98-验证二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/" >Leetcode.98题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-29"   >
          <a href="#第一次做-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-29" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;04</p>

        <h4 id="第一次代码-31"   >
          <a href="#第一次代码-31" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-31" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> leftTree=checkTree(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!leftTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> rightTree=checkTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(!rightTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left.val&gt;root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span> &amp;&amp; root.right.val&lt;root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-16"   >
          <a href="#提交失败-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-16" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: root&#x3D;[2,2,2] 输出true 预期输出false</p>
<p>原因是左右子树的值应该小于和大于根节点的值，我判断中结点条件的时候没有将“等于”算在内</p>

        <h4 id="第二次代码-10"   >
          <a href="#第二次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-10" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> leftTree=checkTree(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!leftTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> rightTree=checkTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(!rightTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left.val&gt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span> &amp;&amp; root.right.val&lt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-17"   >
          <a href="#提交失败-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-17" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:[5,4,6,null,null,3,7] 输出true，预期输出false</p>
<p>原因是右子树的3超过了根节点的值 ，我判断了根节点和左右子树是否分别是搜索二叉树</p>

        <h4 id="第三次代码-3"   >
          <a href="#第三次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-3" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> leftTree=checkTree(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!leftTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> rightTree=checkTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(!rightTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左子树不为空搜索左子树中的最大值(向左子树的右子树的外侧搜索)，如果最大值都大于等于根结点则不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> max=root.left.val;</span><br><span class="line">            TreeNode left=root.left;</span><br><span class="line">            <span class="keyword">while</span>(left.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                max=left.right.val;</span><br><span class="line">                left=left.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右子树不为空搜索右子树中的最小值(向右子树的左子树的外侧搜索)，如果最小值都小于等于根结点值则根结点不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> min=root.right.val;</span><br><span class="line">            TreeNode right=root.right;</span><br><span class="line">            <span class="keyword">while</span>(right.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                min=right.left.val;</span><br><span class="line">                right=right.left;              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min&lt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-31"   >
          <a href="#提交成功-31" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-31" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-31"   >
          <a href="#题解-31" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="后序遍历-3"   >
          <a href="#后序遍历-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#后序遍历-3" class="headerlink" title="后序遍历"></a>后序遍历</h4>
      <p>思路：利用后序遍历(左右中)验证左右子树是否是二叉搜索树再验证根节点是否是二叉搜索树。在验证根节点的时候利用二叉搜索树的特性找到左子树的最大值和右子树的最小值与根节点数值进行比较。</p>
<p><strong>实现</strong></p>
<ul>
<li>递归遍历的参数和返回值<ul>
<li>参数root:要验证是否是二叉搜索树的根节点</li>
<li>返回值：true表示是二叉搜索树，false表示不是二叉搜索树</li>
</ul>
</li>
<li>递归的结束条件<ul>
<li>如果root&#x3D;&#x3D;null，说明是空结点则返回true</li>
<li>如果root.left&#x3D;&#x3D;null &amp;&amp; root.right&#x3D;&#x3D;null结点则返回true</li>
<li>如果左右子树有一个不是二叉搜索树，那么整个树都不会是二叉搜索树，返回false</li>
</ul>
</li>
<li>单层递归的逻辑<ul>
<li>验证左子树是否是二叉搜索树，如果左子树不是二叉搜索树返回false</li>
<li>验证右子树是否是二叉搜索树，如果右子树不是二叉搜索树返回false</li>
<li>验证根节点是否是二叉搜索树<ul>
<li>如果左子树不为空搜索左子树的最大值，利用二叉搜索树的特性，搜索左子树的右子树外侧的值，最右边的值就是最大值</li>
<li>如果右子树不为空搜索右子树的最小值，利用二叉搜索树的特性，搜索右子树的左子树外侧的值，最左边的值就是最小值</li>
<li>判断最大值是否都小于根结点的值，判断最小值是否都大于根结点的值</li>
<li>如果符合二叉搜索树返回true</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> checkTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//空结点和叶子结点是二叉搜索树，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//验证左子树是否是二叉搜索树，下同验证右子树</span></span><br><span class="line">        <span class="type">boolean</span> leftTree=checkTree(root.left);</span><br><span class="line">        <span class="keyword">if</span>(!leftTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> rightTree=checkTree(root.right);</span><br><span class="line">        <span class="keyword">if</span>(!rightTree) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当左子树不为空搜索左子树中的最大值(向左子树的右子树的外侧搜索)，如果最大值都大于等于根结点则不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> max=root.left.val;</span><br><span class="line">            TreeNode left=root.left;</span><br><span class="line">            <span class="keyword">while</span>(left.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                max=left.right.val;</span><br><span class="line">                left=left.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右子树不为空搜索右子树中的最小值(向右子树的左子树的外侧搜索)，如果最小值都小于等于根结点值则根结点不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> min=root.right.val;</span><br><span class="line">            TreeNode right=root.right;</span><br><span class="line">            <span class="keyword">while</span>(right.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                min=right.left.val;</span><br><span class="line">                right=right.left;              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min&lt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="中序遍历-3"   >
          <a href="#中序遍历-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#中序遍历-3" class="headerlink" title="中序遍历"></a>中序遍历</h4>
      <p>利用二叉搜索树的特性，利用中序遍历(左中右)就可以获得二叉树搜索的结点序列，如果序列是单调递增的那么就是二叉搜索树</p>
<blockquote>
<p>二叉搜索树的中序遍历会将所有结点单调升序输出，这是二叉搜索树有序性的体现之一</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230904091829189.png"  alt="二叉搜索树的中序遍历">
      </p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>参数root:判断是否是搜索二叉树的根节点</li>
<li>返回值：如果是搜索二叉树返回true，反之返回false</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li>当root&#x3D;&#x3D;null 也即root为空结点返回true，是二叉搜索树</li>
<li>当前一个结点的值大于等于当前结点的值，说明不是单调递增，返回false，不是二叉搜索树</li>
<li>当左右搜索结果有一个不是二叉搜索树返回false</li>
</ul>
</li>
<li><p>单层递归逻辑</p>
<ul>
<li>判断左子树是否是二叉搜索树</li>
<li>判断当前结点和前一个结点的值，如果当前结点的值小于等于前一个结点的值则不适合搜索二叉树<ul>
<li>当pre&#x3D;&#x3D;null，说明没有前一个结点，当前结点是第一个叶子结点不会进入判断，而是将pre设为当前结点返回true</li>
<li>当pre!&#x3D;null，则判断root和pre的val数值，如果root.val&lt;&#x3D;pre.val 返回false</li>
</ul>
</li>
<li>将pre指向当前结点，为了准备遍历右子树</li>
<li>判断右子树是否是二叉搜索树</li>
</ul>
<blockquote>
<p>因为中序遍历的时候符合二叉搜索树的单调递增，所以前一个结点pre就指向当前结点的升序序列的前一个结点</p>
</blockquote>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;	</span><br><span class="line">	TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pre=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> checkTree(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//如果是空结点则是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左子树判断是否是搜索二叉树</span></span><br><span class="line">        <span class="type">boolean</span> left=checkTree(root.left);</span><br><span class="line">        <span class="comment">//当前结点值大于等于当前结点值 则不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span> &amp;&amp; pre.val&gt;=root.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre=root;</span><br><span class="line">		<span class="comment">//向右子树判断是否是搜索二叉树</span></span><br><span class="line">        <span class="type">boolean</span> right=checkTree(root.right);</span><br><span class="line">        <span class="comment">//如果左子树或者右子树有一个不是搜索二叉树则整棵树不是搜索二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉搜索树的最小绝对差"   >
          <a href="#二叉搜索树的最小绝对差" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1>
      <p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>

        <h2 id="530-二叉搜索树的最小绝对差"   >
          <a href="#530-二叉搜索树的最小绝对差" class="heading-link"><i class="fas fa-link"></i></a><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530.二叉搜索树的最小绝对差"></a>530.二叉搜索树的最小绝对差</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/" >Leetcode.530题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-30"   >
          <a href="#第一次做-30" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-30" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;04</p>

        <h4 id="第一次代码-32"   >
          <a href="#第一次代码-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-32" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       getMinDistinct(root);</span><br><span class="line">       <span class="keyword">return</span> min;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinDistinct</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">       getMinDistinct(root.left);</span><br><span class="line">       <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="type">int</span> distinct=root.val-root.left.val &lt;<span class="number">0</span>? root.left.val-root.val : root.val-root.left.val;</span><br><span class="line">           <span class="keyword">if</span>(distinct&lt;=min) min=distinct;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="type">int</span> distinct=root.val-root.right.val &lt;<span class="number">0</span> ? root.right.val-root.val: root.val-root.right.val;</span><br><span class="line">           <span class="keyword">if</span>(distinct&lt;=min) min=distinct;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       getMinDistinct(root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-18"   >
          <a href="#提交失败-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-18" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次代码-11"   >
          <a href="#第二次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-11" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pre=<span class="literal">null</span>;</span><br><span class="line">        getMinDistinct(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getMinDistinct</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        getMinDistinct(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> distinct=root.val-pre.val&gt;<span class="number">0</span>?root.val-pre.val :pre.val-root.val;</span><br><span class="line">            <span class="keyword">if</span>(distinct&lt;min) min=distinct;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        getMinDistinct(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-32"   >
          <a href="#提交成功-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-32" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-32"   >
          <a href="#题解-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong>：我们中序遍历，然后用双指针，以及一个全局变量最小值以此获取最小绝对值</p>
<blockquote>
<p>搜索二叉树的中序遍历可以将全部结点以升序的方式输出</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>定义一个pre，用于指向当前遍历的前一个结点</li>
<li>定义一个min，用于表示整个遍历过程的最小绝对差。初始化为Intger.MAX_VALUE，最大值</li>
<li>递归函数的参数和返回值<ul>
<li>参数root：要获取距离差最小值的二叉树根节点</li>
<li>返回值：void</li>
</ul>
</li>
<li>递归的结束条件<ul>
<li>当root&#x3D;&#x3D;null：为空节点直接结束</li>
<li>当左右子树遍历完即可结束</li>
</ul>
</li>
<li>单层递归实现逻辑<ul>
<li>遍历左子树，获取左子树的最小绝对差</li>
<li>判断前一个结点和当前结点的绝对差<ul>
<li>如果pre为空，说明这是二叉树的第一个结点，将pre指向当前结点然后结束即可</li>
<li>如果pre不为空，获取pre的值和root的值差值，如果差值小于min。则将min更新成当前差值</li>
</ul>
</li>
<li>将pre指向当前结点，为了准备遍历右子树</li>
<li>遍历右子树</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pre=<span class="literal">null</span>;</span><br><span class="line">        getMinDistinct(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMinDistinct</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        getMinDistinct(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> distinct=root.val-pre.val&gt;<span class="number">0</span>?root.val-pre.val :pre.val-root.val;</span><br><span class="line">            <span class="keyword">if</span>(distinct&lt;min) min=distinct;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        getMinDistinct(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉搜索树中的众数"   >
          <a href="#二叉搜索树中的众数" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h1>
      <p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796" >众数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>
<p>假定 BST 满足如下定义：</p>
<ul>
<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>
<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>

        <h2 id="501-二叉搜索树中的众数"   >
          <a href="#501-二叉搜索树中的众数" class="heading-link"><i class="fas fa-link"></i></a><a href="#501-二叉搜索树中的众数" class="headerlink" title="501.二叉搜索树中的众数"></a>501.二叉搜索树中的众数</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" >Leetcode.501题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-31"   >
          <a href="#第一次做-31" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-31" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;05</p>

        <h4 id="第一次代码-33"   >
          <a href="#第一次代码-33" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-33" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="type">int</span> max=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        findMaxValue(root);</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[map.size()];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> key=entry.getKey();</span><br><span class="line">            <span class="type">int</span> value=entry.getValue();</span><br><span class="line">            arr[i++]=value;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;max)&#123;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                list.clear();</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value==max)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            result[j]=list.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findMaxValue</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        findMaxValue(root.left);</span><br><span class="line">        map.put(root.val,map.getOrDefault(root.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        findMaxValue(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-19"   >
          <a href="#提交失败-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-19" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root&#x3D;[1,null,2] 输出[2] 预期输出[1,2]</p>

        <h4 id="第二次代码-12"   >
          <a href="#第二次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-12" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map;</span><br><span class="line">    <span class="type">int</span> max=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        findMaxValue(root);</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[map.size()];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> key=entry.getKey();</span><br><span class="line">            <span class="type">int</span> value=entry.getValue();</span><br><span class="line">            arr[i++]=value;</span><br><span class="line">            <span class="keyword">if</span>(value&gt;max)&#123;</span><br><span class="line">                num=<span class="number">1</span>;</span><br><span class="line">                max=value;</span><br><span class="line">                list.clear();</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value==max)&#123;</span><br><span class="line">                num++;</span><br><span class="line">                list.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;num;j++)&#123;</span><br><span class="line">            result[j]=list.get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findMaxValue</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        findMaxValue(root.left);</span><br><span class="line">        map.put(root.val,map.getOrDefault(root.val,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        findMaxValue(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-33"   >
          <a href="#提交成功-33" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-33" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-33"   >
          <a href="#题解-33" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>双指针</strong></p>
<p>BF解法思路是：遍历一遍二叉搜索树，得到元素出现的最高频率，然后再遍历一遍二叉搜索树，将频率相等的元素放进结果集中</p>
<p><strong>双指针</strong>的思路：只需遍历一遍二叉树，动态更新结果集合最高频率</p>
<p><strong>实现</strong></p>
<ul>
<li><p>我们这里要用中序遍历，因为二叉搜索树的中序遍历有序性，所有结点会以单调不减的序列输出</p>
</li>
<li><p>定义全局变量</p>
<ul>
<li>pre:用于指向前一个结点，双指针中前面的指针</li>
<li>count:用于统计两个指针之间元素出现的个数</li>
<li>maxCount:用于统计整个二叉搜索树的最大出现次数</li>
<li>list:用于收获结果集，存放最大次数的结点值</li>
</ul>
</li>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>返回值：void</li>
<li>参数cur：根节点root，双指针中后面的指针</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当cur&#x3D;&#x3D;null，说明当前结点遍历到空结点也即二叉树最右下角的结点，遍历结束直接return</p>
</li>
<li><p>递归函数的单层逻辑</p>
<ul>
<li><p>遍历左子树。统计左子树中的众数</p>
</li>
<li><p>处理中结点逻辑</p>
<ul>
<li>判断前一个结点和当前结点的状态<ul>
<li>pre&#x3D;&#x3D;null，说明cur是第一个结点。count&#x3D;1(出现一次)</li>
<li>pre!&#x3D;null并且pre.val&#x3D;&#x3D;cur.val，说明前后结点值相同。count++</li>
<li>pre!&#x3D;null并且pre.val !&#x3D; cur.val，说明前后结点值不同，重新计数，count&#x3D;1</li>
</ul>
</li>
<li>pre指向当前结点cur</li>
<li>判断count和maxCount的值<ul>
<li>如果count&#x3D;&#x3D;maxCount，说明当前结点也是众数，list.add(cur.val)</li>
<li>如果count&gt;maxCount，说明当前结点才是众数，要清空原来的list(list.clear())，将当前结点值加入集合list.add(cur.val)</li>
</ul>
</li>
</ul>
</li>
<li><p>遍历右子树。统计右子树中的众数</p>
</li>
</ul>
</li>
<li><p>将list集合转换成数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//指向前一个结点</span></span><br><span class="line">    TreeNode pre=<span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxCount=<span class="number">0</span>;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        terversal(root);</span><br><span class="line">        <span class="comment">//集合转化成数组</span></span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            result[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">terversal</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        terversal(cur.left);</span><br><span class="line">        <span class="comment">//统计频率</span></span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="literal">null</span>) count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pre!=<span class="literal">null</span> &amp;&amp; cur.val==pre.val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val!=pre.val) count=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//移动指针</span></span><br><span class="line">        pre=cur;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//收获结果集</span></span><br><span class="line">        <span class="keyword">if</span>(count==maxCount)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count&gt;maxCount)&#123;</span><br><span class="line">            maxCount=count;</span><br><span class="line">            list.clear();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        terversal(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉树的最近公共祖先"   >
          <a href="#二叉树的最近公共祖先" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1>
      <p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" >百度百科</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。“</p>

        <h2 id="236-二叉树的最近公共祖先"   >
          <a href="#236-二叉树的最近公共祖先" class="heading-link"><i class="fas fa-link"></i></a><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236.二叉树的最近公共祖先"></a>236.二叉树的最近公共祖先</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" >Leetcode.236题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-32"   >
          <a href="#第一次做-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-32" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;05</p>

        <h4 id="第一次代码-34"   >
          <a href="#第一次代码-34" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-34" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findDepthFather(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findDepthFather</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==p || root==q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(findNode(root.left,p)&amp;&amp;findNode(root.left,q))&#123;</span><br><span class="line">                <span class="keyword">return</span> findDepthFather(root.left,p,q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((findNode(root.right,p)&amp;&amp; findNode(root.right,q)))&#123;</span><br><span class="line">                <span class="keyword">return</span> findDepthFather(root.right,p,q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNode</span><span class="params">(TreeNode root,TreeNode target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> left=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> right=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            left=findNode(root.left,target);</span><br><span class="line">            <span class="keyword">if</span>(left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right=findNode(root.right,target);</span><br><span class="line">            <span class="keyword">if</span>(right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-20"   >
          <a href="#提交失败-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-20" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>root&#x3D;[3,5,1,6,2,0,8,null,null,7,4]，p&#x3D;5，q&#x3D;4 输出 3 预期输出5</p>
<p>找结点的时候忘了处理中结点逻辑</p>

        <h4 id="第二次代码-13"   >
          <a href="#第二次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-13" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findDepthFather(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findDepthFather</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val==p.val || root.val==q.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//当左子树非空向左找最深的共同祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(findNode(root.left,p)&amp;&amp;findNode(root.left,q))&#123;</span><br><span class="line">                <span class="keyword">return</span> findDepthFather(root.left,p,q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右子树非空向右找最深的共同祖先</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((findNode(root.right,p)&amp;&amp; findNode(root.right,q)))&#123;</span><br><span class="line">                <span class="keyword">return</span> findDepthFather(root.right,p,q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右都没找到就当前节点是最深共同祖先</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNode</span><span class="params">(TreeNode root,TreeNode target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val==target.val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> left=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> right=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//当左结点非空判断左子树是否含有target</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">            left=findNode(root.left,target);</span><br><span class="line">            <span class="keyword">if</span>(left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右结点非空判断右子树是否含有target</span></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">            right=findNode(root.right,target);</span><br><span class="line">            <span class="keyword">if</span>(right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中结点值和target相等则返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root.val==target.val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-34"   >
          <a href="#提交成功-34" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-34" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-34"   >
          <a href="#题解-34" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong>：利用后序遍历来判断最近公共祖先，通过左右子树的最近公共祖先结果来一层层地向根节点返回，虽然是从上往下遍历，但是处理过程是从下往上，这个部分需要用到回溯的思想</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>返回值：TreeNode，共同祖先，如果为空则没有找到。</li>
<li>参数root：树的根节点</li>
<li>参数p：要搜索的结点之一</li>
<li>参数q：要搜索的结点之一</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li>当root&#x3D;&#x3D;null，即遇到空节点返回空，没有公共祖先</li>
<li>当root&#x3D;&#x3D;p或者root&#x3D;&#x3D;q，说明公共祖先就是root，或者遍历中找到了p或者q</li>
</ul>
</li>
<li><p>单层递归的处理逻辑</p>
<ul>
<li><p>向左搜索结点，记录为left</p>
</li>
<li><p>向右搜索结点，记录为right</p>
</li>
<li><p>处理中结点的逻辑</p>
<ul>
<li>当left为空且right为空，说明没有找到公共祖先，返回null</li>
<li>当left不为空且right不为空，说明left包含q和p之一，right也包含p和q之一【题目说明不会重复，所以left和right包含的结点不会是同一个结点】</li>
<li>当left为空且right不为空说明左子树中找到了结点，所以返回left</li>
<li>当left不为空且right为空说明右子树中找打了结点，所以返回right</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findDepthFather(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findDepthFather</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//如果当前结点是p或者q即根节点就是最近祖先 返回root</span></span><br><span class="line">        <span class="keyword">if</span>(root==p || root== q) <span class="keyword">return</span> root;</span><br><span class="line">		<span class="comment">//向左搜索左结点</span></span><br><span class="line">        TreeNode left= findDepthFather(root.left,p,q);</span><br><span class="line">        <span class="comment">//向右搜索右结点</span></span><br><span class="line">        TreeNode right=findDepthFather(root.right,p,q);</span><br><span class="line">		<span class="comment">//左右不为空找到祖先为root，左不为空右为空向上返回左结点，左为空右不为空向上返回右结点，左右都为空则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp;right!=<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp;right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉搜索树的最近公共祖先"   >
          <a href="#二叉搜索树的最近公共祖先" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉搜索树的最近公共祖先" class="headerlink" title="二叉搜索树的最近公共祖先"></a>二叉搜索树的最近公共祖先</h1>
      <p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" >百度百科</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>

        <h2 id="235-二叉搜索树的最近公共祖先"   >
          <a href="#235-二叉搜索树的最近公共祖先" class="heading-link"><i class="fas fa-link"></i></a><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235.二叉搜索树的最近公共祖先"></a>235.二叉搜索树的最近公共祖先</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" >Leetcode.235题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-33"   >
          <a href="#第一次做-33" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-33" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;06</p>

        <h4 id="第一次代码-35"   >
          <a href="#第一次代码-35" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-35" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> tervalse(root,p,q);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(root==p  || root==q) <span class="keyword">return</span> root;</span><br><span class="line">       <span class="keyword">if</span>(root.val&gt;=p.val &amp;&amp; root.val&gt;=q.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> tervalse(root.left,p,q);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;=p.val &amp;&amp; root.val&lt;=q.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> tervalse(root.right,p,q);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           TreeNode left=tervalse(root.left,p,q);</span><br><span class="line">           TreeNode right=tervalse(root.right,p,q);</span><br><span class="line">           <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right ==<span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>) <span class="keyword">return</span> root; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-35"   >
          <a href="#提交成功-35" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-35" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-35"   >
          <a href="#题解-35" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="递归法-1"   >
          <a href="#递归法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4>
      <p>思想：因为二叉搜索树的特性，我们可以判断pq的值与root的值确定搜索方向，当root在pq中间的时候，说明root就是最近公共祖先</p>
<p><strong>实现</strong></p>
<ul>
<li>递归函数的参数和返回值<ul>
<li>参数root：用于搜索的结点</li>
<li>参数p：要搜索的两个结点之一</li>
<li>参数q：要搜索的两个结点之一</li>
</ul>
</li>
<li>递归参数的结束条件<ul>
<li>当root为空，说明空结点返回为空</li>
<li>当root&#x3D;&#x3D;p或者root&#x3D;&#x3D;q，说明找到两个结点之一，或者这个结点就是这两个结点的公共祖先，返回root</li>
</ul>
</li>
<li>单层递归的处理逻辑<ul>
<li>如果root.val&gt;&#x3D;p.val &amp;&amp; root.val&gt;&#x3D;q.val 也即<strong>中间结点值比两个结点都大</strong>，所以pq一定在root的左子树中，递归向左子树搜索最近公共祖先</li>
<li>如果root.val&lt;&#x3D;p.val &amp;&amp; root.val&lt;&#x3D;q.val 也即<strong>中间结点值比两个结点都小</strong>，所以pq一定在root的右子树中，递归向右子树搜索最近公共祖先</li>
<li>如果不符合上面两个条件，说明p和q分别在root左右，也即<strong>中间结点值处于两个结点之间</strong>，所以最近公共祖先也即root</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root==p  || root==q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;=p.val &amp;&amp; root.val&gt;=q.val)&#123;</span><br><span class="line">            <span class="comment">//根节点值比两个结点都大，所以最近公共祖先在根结点的左子树中，也即pq都在root左子树</span></span><br><span class="line">            <span class="keyword">return</span> tervalse(root.left,p,q);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;=p.val &amp;&amp; root.val&lt;=q.val)&#123;</span><br><span class="line">           	<span class="comment">//根节点值比两个结点都小，所以最近公共祖先在根结点的右子树中，也即pq都在root右子树</span></span><br><span class="line">            <span class="keyword">return</span> tervalse(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//root在pq中间，所以root也即最近公共祖先</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="迭代法-1"   >
          <a href="#迭代法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4>
      <p>思路：因为二叉搜索树的特性，所以搜索方向能够确定，迭代法的题解就变得比较简单</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">       <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">     	   <span class="comment">//如果根结点值比两个结点都大(不能等于)，向左子树搜索  		</span></span><br><span class="line">           <span class="keyword">if</span>(root.val&gt;p.val &amp;&amp; root.val&gt;q.val) &#123;</span><br><span class="line">               root=root.left;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;p.val &amp;&amp; root.val&lt;q.val)&#123;</span><br><span class="line">               <span class="comment">//如果根结点值比两个结点都小(不能等于)，向右子树搜索</span></span><br><span class="line">               root=root.right;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//反之root一定在pq之间，或者root是pq之一</span></span><br><span class="line">               <span class="keyword">return</span> root;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="二叉搜索树中的插入操作"   >
          <a href="#二叉搜索树中的插入操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h1>
      <p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>

        <h2 id="701-二叉搜索树中的插入操作"   >
          <a href="#701-二叉搜索树中的插入操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701.二叉搜索树中的插入操作"></a>701.二叉搜索树中的插入操作</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" >Leetcode.701题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-34"   >
          <a href="#第一次做-34" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-34" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;06</p>

        <h4 id="第一次代码-36"   >
          <a href="#第一次代码-36" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-36" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tervalse(root.left,val);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//root.val&lt;val</span></span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> tervalse(root.right,val);</span><br><span class="line">			</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-21"   >
          <a href="#提交失败-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-21" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root&#x3D;[4,2,7,1,3],val&#x3D;5,返回[5]，预期返回[4,2,7,1,3,5] </p>
<p>我只返回了新结点，而没有把整棵树返回回来，所以对左右子树判断返回的数据</p>

        <h4 id="第二次代码-14"   >
          <a href="#第二次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-14" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.left=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tervalse(root.left,val);</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//root.val&lt;val</span></span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tervalse(root.right,val);</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-22"   >
          <a href="#提交失败-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-22" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：root &#x3D;[5,null,14,10,77,null,null,null,95,null,null]，val&#x3D;4，输出[4]，预期输出[5,4,14,null,null,10,77,null,null,null,95]</p>
<p>原因：当左右子树为空的时候应该插入新数据进入左右子树，然后返回整棵树，我只返回了这个结点</p>

        <h4 id="第三次代码-4"   >
          <a href="#第三次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-4" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                root.left=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tervalse(root.left,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//root.val&lt;val</span></span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tervalse(root.right,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-36"   >
          <a href="#提交成功-36" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-36" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h4 id="迭代法-2"   >
          <a href="#迭代法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">       	<span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">               <span class="keyword">if</span>(root.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                   root.left=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                   <span class="keyword">return</span> cur;</span><br><span class="line">               &#125;<span class="keyword">else</span> root=root.left;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">               <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                   root.right=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                   <span class="keyword">return</span> cur;</span><br><span class="line">               &#125;<span class="keyword">else</span> root=root.right;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-37"   >
          <a href="#提交成功-37" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-37" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-36"   >
          <a href="#题解-36" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="递归法-2"   >
          <a href="#递归法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h4>
      <p>思路：我们在叶子结点进行插入，不对整棵树的原始结构进行改变</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>返回值：二叉树的根节点</li>
<li>参数root：用于搜索的二叉树结点</li>
<li>参数val：要插入的结点大小</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li>当root&#x3D;&#x3D;null，也即用于搜索的二叉树为空，则返回新结点作为树的根节点</li>
</ul>
</li>
<li><p>单层递归的逻辑</p>
<ul>
<li><p>当root.val&gt;val，也即当前结点值比要插入的结点大，应该插入左子树中</p>
<ul>
<li>如果左子树为空，则插入新结点作为当前结点左子树</li>
<li>如果左子树不为空，那么向左子树继续搜索要插入位置</li>
</ul>
</li>
<li><p>当root.val&lt;val，也即当前结点值要比插入的结点小，应该插入右子树中</p>
<ul>
<li>如果右子树为空，则插入新结点作为当前结点右子树</li>
<li>如果右子树不为空，那么向右子树继续搜索要插入的位置</li>
</ul>
</li>
<li><p>返回root，用于搜索的二叉树（也即插入之后的新的二叉树根节点）</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;val)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span>)&#123;</span><br><span class="line">              	<span class="comment">//如果左子树为空插入新结点于左子树中</span></span><br><span class="line">                root.left=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//不为空则向左搜索</span></span><br><span class="line">                tervalse(root.left,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//root.val&lt;val</span></span><br><span class="line">            <span class="keyword">if</span>(root.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//如果右子树为空插入新结点于右子树中</span></span><br><span class="line">                root.right=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//不为空则向右搜索</span></span><br><span class="line">                tervalse(root.right,val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="迭代法-3"   >
          <a href="#迭代法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代法-3" class="headerlink" title="迭代法"></a>迭代法</h4>
      <p>思路：利用二叉树的特性搜索左右子树，然后在叶子结点插入新结点</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">//定义cur来移动结点</span></span><br><span class="line">    	TreeNode cur=root;</span><br><span class="line">       	<span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur.val&gt;val)&#123;</span><br><span class="line">               <span class="comment">//如果左子树为空则直接插入新结点</span></span><br><span class="line">               <span class="keyword">if</span>(cur.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                   cur.left=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                   <span class="comment">//插入完返回树的根节点</span></span><br><span class="line">                   <span class="keyword">return</span> root;</span><br><span class="line">               &#125;<span class="keyword">else</span> cur=cur.left; <span class="comment">//反之左子树不为空向左搜索</span></span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val&lt;val)&#123;</span><br><span class="line">               <span class="comment">//如果右子树为空则直接插入新结点</span></span><br><span class="line">               <span class="keyword">if</span>(cur.right==<span class="literal">null</span>)&#123;</span><br><span class="line">                   cur.right=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">                   <span class="comment">//插入完返回树的根节点</span></span><br><span class="line">                   <span class="keyword">return</span> root;</span><br><span class="line">               &#125;<span class="keyword">else</span> cur=cur.right; <span class="comment">//反之右子树不为空向右搜索</span></span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="删除二叉搜索树中的节点"   >
          <a href="#删除二叉搜索树中的节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h1>
      <p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>

        <h2 id="450-删除二叉搜索树中的节点"   >
          <a href="#450-删除二叉搜索树中的节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450.删除二叉搜索树中的节点"></a>450.删除二叉搜索树中的节点</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/" >Leetcode.450题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-35"   >
          <a href="#第一次做-35" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-35" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;06</p>

        <h4 id="第一次代码-37"   >
          <a href="#第一次代码-37" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-37" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.left=tervalse(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                tervalse(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right.left=root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-23"   >
          <a href="#提交失败-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-23" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root&#x3D;[5,3,6,2,4,null,7] key&#x3D;7，输出[5,3,6,2,4,null,7] 预期输出[5,3,6,2,4]</p>
<p>原因是未对右子树做删除处理</p>

        <h4 id="第二次代码-15"   >
          <a href="#第二次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-15" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.left=tervalse(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right=tervalse(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right.left=root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-24"   >
          <a href="#提交失败-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-24" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root &#x3D;[50,30,70,null,40,60,80]，key&#x3D;50，输出[70,30,80,null,40]，预期输出[60,30,70,null,40,null,80]</p>
<p>原因：当左右子树非空的时候我直接将左子树接到右子树的左子树，造成了数据丢失。</p>

        <h4 id="第三次代码-5"   >
          <a href="#第三次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-5" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.left=tervalse(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right=tervalse(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                TreeNode cur=root.right;</span><br><span class="line">                <span class="keyword">if</span>(cur.left==<span class="literal">null</span>)&#123;</span><br><span class="line">                    root.left=root.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                        cur=cur.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left=root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-38"   >
          <a href="#提交成功-38" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-38" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-37"   >
          <a href="#题解-37" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：利用二叉搜索树的特性来搜索要删除的结点位置确认方向，如果没能找到要删除的结点则不作处理，如果找到了要删除的结点则要对左右子树做一个处理，维持删除之后搜索二叉树的特性</p>
<p><strong>实现</strong></p>
<ul>
<li>递归参数的返回值和参数<ul>
<li>参数root：根结点</li>
<li>参数key：要删除的结点值大小</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当root&#x3D;&#x3D;null，说明没有找到结点，返回null</li>
<li>当找到要删除的结点，将其删除结点就可以结束递归了。而要删除结点时有四种情况要考虑，而返回值会在单层递归中将其接住<ul>
<li>左为空右不为空（是叶子结点），直接返回null即可</li>
<li>左不为空右为空，返回左子树</li>
<li>左为空右不为空，返回右子树</li>
<li>左不为空且右为空，将左右子树做拼接处理<ul>
<li>找到右子树的<strong>最左下角结点</strong>，因为最左下角值是最接近左子树最大值的结点，所以将左子树接在最左下角结点的左子树</li>
<li>返回根节点的右子树</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>单层递归的处理逻辑<ul>
<li>当根节点值小于目标值，搜索右子树，且将根节点的右子树设置为删除之后新的右子树（如果没找到会返回原来一样的右子树）</li>
<li>当根节点值大于目标值，搜索左子树，且将根节点的左子树设置为删除之后新的左子树（如果没找到会返回原来一样的左子树）</li>
<li>当根节点值等于目标值，说明找到了要删除的结点，走判断删除结点逻辑。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tervalse(root,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">tervalse</span><span class="params">(TreeNode root,<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root.val&gt;key)&#123;</span><br><span class="line">            <span class="comment">//当根节点比key大，说明在左子树中搜索左子树</span></span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将当前根节点的左子树设置为删除之后新的左子树</span></span><br><span class="line">                root.left=tervalse(root.left,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&lt;key)&#123;</span><br><span class="line">            <span class="comment">//当根节点值比key小，说明在右子树中搜索右子树</span></span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//将当前根节点的右子树设置为删除之后新的右子树</span></span><br><span class="line">                root.right=tervalse(root.right,key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val==key)&#123;</span><br><span class="line">            <span class="comment">//找到要删除的结点，有四种场景</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//①如果是叶子结点则返回空结点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span>) <span class="keyword">return</span> root.left;<span class="comment">//②左不空右为空 </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>) <span class="keyword">return</span> root.right;<span class="comment">//③左为空右不为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.left!=<span class="literal">null</span> &amp;&amp; root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//④左不为空右为空</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                TreeNode cur=root.right;</span><br><span class="line">                <span class="comment">//当cur指向右子树的最左下角结点 也即cur.left==null</span></span><br><span class="line">                <span class="keyword">while</span>(cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                   cur=cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将root左子树接在cur的左子树中</span></span><br><span class="line">                cur.left=root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="修剪二叉搜索树"   >
          <a href="#修剪二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h1>
      <p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>

        <h2 id="669-修剪二叉搜索树"   >
          <a href="#669-修剪二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#669-修剪二叉搜索树" class="headerlink" title="669.修剪二叉搜索树"></a>669.修剪二叉搜索树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/" >Leetcode.669题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-36"   >
          <a href="#第一次做-36" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-36" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;07</p>

        <h4 id="第一次代码-38"   >
          <a href="#第一次代码-38" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-38" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> changeTree(root,low,high);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    [low,high]</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">changeTree</span><span class="params">(TreeNode root,<span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;low)&#123;</span><br><span class="line">            <span class="keyword">return</span> changeTree(root.right,low,high);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;high)&#123;</span><br><span class="line">            <span class="keyword">return</span> changeTree(root.left,low,high);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;=low &amp;&amp; root.val&lt;=high)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.left=changeTree(root.left,low,high);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                root.right=changeTree(root.right,low,high);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-39"   >
          <a href="#提交成功-39" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-39" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-38"   >
          <a href="#题解-38" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-38" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和前面删除结点不同，需要改变树的结构。不能直接将左右子树拼接上去，而需要将符合条件的子树修剪之后更新</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>参数root：需要修剪的根节点</li>
<li>参数low：左区间</li>
<li>参数high：右区间</li>
<li>返回值TreeNode：修建之后的根节点</li>
</ul>
</li>
<li><p>递归的结束条件</p>
<ul>
<li>root&#x3D;&#x3D;null：说明是空节点，返回空间点</li>
<li>判断root.val和low与high的值<ul>
<li>root.val&lt;low :说明根节点是需要删除的结点，向右子树遍历修剪右子树，然后返回修剪后的右子树（返回值在单层递归中接住）</li>
<li>root.val&gt;high:说明根节点是需要删除的结点，向左子树遍历修剪左子树，然后返回修剪后的左子树（返回值在单层递归中接住）</li>
</ul>
</li>
</ul>
</li>
<li><p>单层递归的处理逻辑</p>
<p><em>low&lt;&#x3D;root.val&lt;&#x3D;high</em></p>
<ul>
<li>判断是否有左子树，如果有左子树则更新根节点的左子树(root.left)，在这里接住递归之后的返回值</li>
<li>判断是否有右子树，如果有右子树则更新根节点的右子树(root.right)，在这里接住递归之后的返回值</li>
</ul>
</li>
<li><p>返回修枝之后的根节点</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> changeTree(root,low,high);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//    [low,high]</span></span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">changeTree</span><span class="params">(TreeNode root,<span class="type">int</span> low, <span class="type">int</span> high)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//如果当前结点值比左区间小，删除本结点</span></span><br><span class="line">       <span class="keyword">if</span>(root.val&lt;low)&#123;</span><br><span class="line">           <span class="comment">//向本结点的右子树修剪，返回修剪后的右子树</span></span><br><span class="line">           <span class="keyword">return</span> changeTree(root.right,low,high);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;high)&#123;</span><br><span class="line">           <span class="comment">//如果当前值比右区间大，删除本结点</span></span><br><span class="line">           <span class="comment">//向本结点的左子树修剪，返回修剪后的左子树</span></span><br><span class="line">           <span class="keyword">return</span> changeTree(root.left,low,high);</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val&gt;=low &amp;&amp; root.val&lt;=high)&#123;</span><br><span class="line">           <span class="comment">//如果有左子树，修剪左子树</span></span><br><span class="line">           <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//单层递归中接住返回值，更新左子树</span></span><br><span class="line">               root.left=changeTree(root.left,low,high);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//如果有右子树，修剪右子树</span></span><br><span class="line">           <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//单层递归中接住右子树，更新右子树</span></span><br><span class="line">               root.right=changeTree(root.right,low,high);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回修剪后的根节点</span></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="将有序数组转换为二叉搜索树"   >
          <a href="#将有序数组转换为二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h1>
      <p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>

        <h2 id="108-将有序数组转换为二叉搜索树"   >
          <a href="#108-将有序数组转换为二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" >Leetcode.108题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-37"   >
          <a href="#第一次做-37" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-37" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;07</p>

        <h4 id="第一次代码-39"   >
          <a href="#第一次代码-39" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-39" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=nums.length/<span class="number">2</span>;</span><br><span class="line">        root.val=nums[num];</span><br><span class="line"></span><br><span class="line">        root.left=addTree(nums,<span class="number">0</span>,num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">        root.right=addTree(nums,num+<span class="number">1</span>,nums.length);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[start]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">            node.left=addTree(nums,start+<span class="number">1</span>,end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-7"   >
          <a href="#提交错误-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-7" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:nums&#x3D;[-10,-3,0,5,9]，输出[0,-10,5,-3,null,9]  预期输出[0,-3,9,-10,null,5]</p>

        <h4 id="第二次代码-16"   >
          <a href="#第二次代码-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-16" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=nums.length/<span class="number">2</span>;</span><br><span class="line">        root.val=nums[num];</span><br><span class="line"></span><br><span class="line">        root.left=addTree(nums,<span class="number">0</span>,num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">        root.right=addTree(nums,num+<span class="number">1</span>,nums.length);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[end-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=end-<span class="number">1</span>;i&gt;=start;i--)&#123;</span><br><span class="line">            node.left=addTree(nums,start,end-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交错误-8"   >
          <a href="#提交错误-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-8" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:root&#x3D;[0,1,2,3,4,5] ，输出[3,2,5,1,null,4,null,0]，预期输出[3,1,5,0,2,4]</p>
<p>原因：这样保证了根节点的左右子树高度差不超过1，可以其他结点的子树左右子树高度差超过了1，空子树也算高度0，不能单方向的一直接</p>

        <h4 id="第三次代码-6"   >
          <a href="#第三次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-6" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> addTree(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=(start+end)/<span class="number">2</span>;</span><br><span class="line">        root.val=nums[num];</span><br><span class="line"></span><br><span class="line">        root.left=addTree(nums,<span class="number">0</span>,num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;end-<span class="number">1</span>)&#123;</span><br><span class="line">        root.right=addTree(nums,num+<span class="number">1</span>,end);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-9"   >
          <a href="#提交错误-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-9" class="headerlink" title="提交错误"></a>提交错误</h5>
      
        <h4 id="第四次代码-2"   >
          <a href="#第四次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-2" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addTree(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=(start+end)/<span class="number">2</span>;</span><br><span class="line">        root.val=nums[num];</span><br><span class="line">        </span><br><span class="line">        root.left=addTree(nums,start,num);</span><br><span class="line">        <span class="keyword">if</span>(num&lt;end-<span class="number">1</span>)&#123;</span><br><span class="line">        root.right=addTree(nums,num+<span class="number">1</span>,end);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-40"   >
          <a href="#提交成功-40" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-40" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-39"   >
          <a href="#题解-39" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-39" class="headerlink" title="题解"></a>题解</h3>
      <p>思路:构造平衡搜索二叉树，先构造根节点，然后根据关系切割数组构造左子树，切割数组构造右子树</p>
<p><strong>实现</strong></p>
<ul>
<li>递归函数的参数和返回值<ul>
<li>返回值TreeNode：构造出的二叉搜索树根节点</li>
<li>参数nums：升序数组</li>
<li>参数start：左区间</li>
<li>参数end：右区间</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当start和end合法，也即start&lt;&#x3D;end；当start&#x3D;&#x3D;end时返回null</li>
</ul>
</li>
<li>单层递归的逻辑<ul>
<li>取得升序数组区间中的中间元素：mid&#x3D;(start+end)&#x2F;2</li>
<li>构造左子树：区间为[start，mid) 左闭右开构建</li>
<li>构造右子树：区间为[mid+1,end)左闭右开构建</li>
</ul>
</li>
<li>返回构建出的二叉树root</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">   	<span class="comment">//左闭右开，所以传入0和nums.length</span></span><br><span class="line">       <span class="keyword">return</span> addTree(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> TreeNode <span class="title function_">addTree</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(start==end) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(end==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">       TreeNode root=<span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">       </span><br><span class="line">       root.val=nums[mid];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//构造左子树，区间在[start,mid)</span></span><br><span class="line">       root.left=addTree(nums,start,mid);</span><br><span class="line">    	<span class="comment">//构造右子树，区间在[mid+1,end)</span></span><br><span class="line">       <span class="keyword">if</span>(mid&lt;end-<span class="number">1</span>)&#123;</span><br><span class="line">       root.right=addTree(nums,mid+<span class="number">1</span>,end);&#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="把二叉搜索树转换为累加树"   >
          <a href="#把二叉搜索树转换为累加树" class="heading-link"><i class="fas fa-link"></i></a><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h1>
      <p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>注意：</strong>本题和 1038: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/" >https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 相同</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/" >1038. 从二叉搜索树到更大和树</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="538-把二叉搜索树转换为累加树"   >
          <a href="#538-把二叉搜索树转换为累加树" class="heading-link"><i class="fas fa-link"></i></a><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538.把二叉搜索树转换为累加树"></a>538.把二叉搜索树转换为累加树</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" >Leetcode.538题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-38"   >
          <a href="#第一次做-38" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-38" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;07</p>

        <h4 id="第一次代码-40"   >
          <a href="#第一次代码-40" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-40" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pre=<span class="literal">null</span>;</span><br><span class="line">        changeBST(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeBST</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        changeBST(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.val=root.val+pre.val;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        changeBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-25"   >
          <a href="#提交失败-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-25" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:root&#x3D;[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]，输出[10,1,21,0,3,15,28,null,null,null,6,null,null,null,36]，预期输出[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>

        <h4 id="第二次代码-17"   >
          <a href="#第二次代码-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-17" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pre=<span class="literal">null</span>;</span><br><span class="line">        changeBST(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeBST</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先遍历右子树</span></span><br><span class="line">        changeBST(root.right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.val=root.val+pre.val;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        <span class="comment">//再遍历左子树</span></span><br><span class="line">        changeBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-41"   >
          <a href="#提交成功-41" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-41" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-40"   >
          <a href="#题解-40" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-40" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：通过分析这道题的示例，我们知道这个累加数换成数组就是从后遍历然后记录和的最大值。</p>
<p>也即我们可以通过<strong>右中左的遍历顺序</strong>，来改变每个结点的数值，我们这里用<strong>双指针</strong>来实现这道题会是比较简单的</p>
<p><strong>实现</strong></p>
<blockquote>
<p>二叉搜索树是中序(左中右)是升序数组，所以我们用(右中左)就是降序数组</p>
</blockquote>
<ul>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>无返回值，整个递归过程处理完逻辑</li>
<li>参数root：要用于转换的二叉树根节点</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当root为空，说明遍历到最后一个结点下的空结点，结束递归</p>
</li>
<li><p>递归函数的单层逻辑</p>
<ul>
<li>先遍历右子树</li>
<li>pre不为空的时候，root.val&#x3D;&#x3D;root.val+pre.val（当前结点数值为当前节点值+上一结点值）</li>
<li>pre&#x3D;root：移动pre指针使其保证一直在root前一个结点</li>
<li>再遍历左子树</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       	<span class="comment">//初始化pre</span></span><br><span class="line">        pre=<span class="literal">null</span>;</span><br><span class="line">        changeBST(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeBST</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//先遍历右子树</span></span><br><span class="line">        changeBST(root.right);</span><br><span class="line">        <span class="comment">//pre为空说明root是第一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            root.val=root.val+pre.val;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=root;</span><br><span class="line">        <span class="comment">//再遍历左子树</span></span><br><span class="line">        changeBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1>
      <p>到这里二叉树也算这部分结束了，从这篇中我们可以学习到</p>
<ul>
<li><p>二叉树的种类如<strong>二叉搜索树、完全二叉树、满二叉树、平衡二叉树</strong></p>
</li>
<li><p>二叉树的搜索方式如<strong>深度优先搜索、广度优先搜索</strong></p>
<ul>
<li>深度优先搜索<ul>
<li>递归遍历：<strong>前序遍历、中序遍历、后序遍历</strong></li>
<li>非递归遍历：<strong>迭代法</strong>遍历（统一迭代法）</li>
</ul>
</li>
<li>广度 优先搜索<ul>
<li>层序遍历</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的特性</p>
<ul>
<li>二叉搜索树的<strong>中序遍历</strong>输出是一个有序数组</li>
<li>平衡二叉树的每一个结点高度差不能超过1</li>
<li>树的深度是从根节点往叶子结点数</li>
<li>树的高度是从叶子结点向根节点数</li>
</ul>
</li>
</ul>
<p>我们也能从中学习到<strong>回溯</strong>的思想，从搜索二叉树中学习到<strong>双指针</strong>的思路</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/23/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B4%5D/">深入剖析并发编程-JUC篇[4]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-23</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">0</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/20/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B5.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%5D/">死之前要做完的算法手册-[5.栈和队列]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">48分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>栈和队列基础知识</strong></p>
<p>栈：栈是一个先进后出的数据结构也即最后一个进来的数据第一个出去(LIFO)</p>
<p>如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230821082237006.png"  alt="栈">
      </p>
<p>队列：队列是一个先进先出的数据结构也即第一个进来的数据第一个出去(FIFO)</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230821082527464.png"  alt="队列">
      </p>
<p>我们可以用你可以使用 list 或者 deque（双端队列）来模拟一个栈或者队列</p>

        <h1 id="用栈实现队列"   >
          <a href="#用栈实现队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h1>
      <p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>

        <h2 id="232-用栈实现队列"   >
          <a href="#232-用栈实现队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/" >Leetcode.232题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;21</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">//第二个栈用于模拟出队的转移数据的使用</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; removeStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        removeStack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stack.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=stack.size()-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            removeStack.add(stack.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result=stack.get(<span class="number">0</span>);</span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=removeStack.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            stack.add(removeStack.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        removeStack.clear();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检验队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p>在模拟出队的时候，对双栈的操作不一样会导致其他方法的不一样</p>
<p><strong>辅助栈(只在出队的时候使用)</strong></p>
<p>思路：一个栈stack就认为是队列，当入队、获取队首、以及判断队列是否为空只要直接操作stack即可，而当要出队的时候，将除队首的元素以此出栈到辅助栈helpStack中，然后获取队首元素并清空stack，再将helpStack的元素以此再出栈到stack中，最后清空辅助栈helpStack</p>
<p>代码：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">//辅助栈(只在出队有用)</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; helpStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        stack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helpStack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        stack.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//将除队首元素以此出栈再入辅助栈中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=stack.size()-<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           helpStack.add(stack.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取队首元素</span></span><br><span class="line">        <span class="type">int</span> result=stack.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//清空栈</span></span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="comment">//依次将辅助栈的元素入到stack栈中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=helpStack.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            stack.add(helpStack.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空辅助栈</span></span><br><span class="line">        helpStack.clear();</span><br><span class="line">        <span class="comment">//返回队首元素</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//返回队首元素</span></span><br><span class="line">        <span class="keyword">return</span> stack.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> stack.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230821091110421.png"  alt="辅助栈图解">
      </p>
<p><strong>in栈和out栈(双栈分别控制入栈和出栈)</strong></p>
<p>思路：入栈数据正常入in栈，出栈出out栈数据，获取队首元素也从out栈中获取，判断队列是否为空即in栈和out栈都为空</p>
<p>代码:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="comment">//in栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; inStack;</span><br><span class="line">    <span class="comment">//out栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        inStack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        outStack=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//入in栈</span></span><br><span class="line">        inStack.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果out栈为空 那么将in栈中的数据全部放到out栈中，并且清空in栈</span></span><br><span class="line">        <span class="comment">//如果out栈不为空，那么直接从out栈获取数据不需要in栈操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//out栈为空</span></span><br><span class="line">        <span class="keyword">if</span>(outStack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=inStack.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                outStack.add(inStack.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            inStack.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取最后一个数据 也就是栈顶的位置</span></span><br><span class="line">        <span class="type">int</span> result=outStack.get(outStack.size()-<span class="number">1</span>);</span><br><span class="line"> 		<span class="comment">//将out栈的栈顶元素弹出</span></span><br><span class="line">        outStack.remove(outStack.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取栈顶元素 因为pop会出栈，所以需要将result压回outStack栈中</span></span><br><span class="line">        <span class="type">int</span> result=<span class="built_in">this</span>.pop();</span><br><span class="line">        outStack.add(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//当in栈为空且out栈为空说明队列为空</span></span><br><span class="line">        <span class="keyword">return</span> inStack.size()==<span class="number">0</span>&amp;&amp; outStack.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B5.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%5D/image-20230821093459437.png"  alt="in栈和out栈">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B5.%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%5D/image-20230821093715611.png"  alt="in栈和out栈(2)">
      </p>

        <h1 id="用队列实现栈"   >
          <a href="#用队列实现栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h1>
      <p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>

        <h2 id="225-用队列实现栈"   >
          <a href="#225-用队列实现栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/" >LeetCode.225题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;21</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个队列</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        list.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//出栈的逻辑我是这样实现的:</span></span><br><span class="line">        <span class="comment">//	将队首的元素以此出队然后重新以此入队</span></span><br><span class="line">        <span class="comment">//  这样保证了原来队尾的数据到了队首的位置，然后将这个队首元素获取之后出队即可</span></span><br><span class="line">        <span class="type">int</span> length=list.size();</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">			<span class="comment">//非队尾元素重新入队</span></span><br><span class="line">            <span class="keyword">if</span>(i!=length-<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="type">int</span> temp=list.get(<span class="number">0</span>);</span><br><span class="line">               list.remove(<span class="number">0</span>);</span><br><span class="line">               list.add(temp);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//运行到这里 队首是原来队尾元素</span></span><br><span class="line">           result=list.get(<span class="number">0</span>);</span><br><span class="line">           list.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//根据队列长度判断栈顶指针位置，以便直接获取栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> list.get(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列为空则栈为空</span></span><br><span class="line">        <span class="keyword">return</span> list.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题的题解和我第一次自己做的代码是一致的，用<strong>一个队列来实现栈</strong></p>
<p><strong>用一个队列实现栈</strong></p>
<p>思路:入栈、获取栈顶元素、判断栈是否为空都是比较简单就能理解的，而最主要的区别在于出栈的过程，因为队列先进先出而栈是后进先出</p>
<ul>
<li>push:入队和入栈是一样的，</li>
<li>top:获取栈顶元素只要我们获取到队列的末尾元素即可</li>
<li>empty:判断队列是否为空即可</li>
<li>pop: 这里将队尾之前的数据出队再重新入队，使得原来队尾的元素排到了队首，再将这个元素出队即可</li>
</ul>
<p>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="comment">//队列 用于模拟栈</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        queue=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取队列的长度</span></span><br><span class="line">        <span class="type">int</span> length=queue.size();</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将非队尾的元素以此出队之后重新入队，使其队首是原先队尾的元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="comment">//非队尾元素出队再重新入队</span></span><br><span class="line">            <span class="keyword">if</span>(i!=length-<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="type">int</span> temp=queue.get(<span class="number">0</span>);</span><br><span class="line">               queue.remove(<span class="number">0</span>);</span><br><span class="line">               queue.add(temp);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//运行到这里队首元素是原先队尾元素  将获取其值再出队即完成出栈操作</span></span><br><span class="line">           result=queue.get(<span class="number">0</span>);</span><br><span class="line">           queue.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//获取栈顶元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.get(queue.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="有效的括号"   >
          <a href="#有效的括号" class="heading-link"><i class="fas fa-link"></i></a><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1>
      <p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>

        <h2 id="20-有效的括号"   >
          <a href="#20-有效的括号" class="heading-link"><i class="fas fa-link"></i></a><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/" >Leetcode.20题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;22</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="comment">//左括号为进栈又括号为出栈</span></span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>||c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//c==&#x27;&#125;&#x27;||c==&#x27;)&#x27;||c==&#x27;]&#x27;</span></span><br><span class="line">            <span class="keyword">if</span>(stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(c!=stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入s&#x3D;”()” 输出false 预期输出true</p>

        <h5 id="原因"   >
          <a href="#原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因" class="headerlink" title="原因"></a>原因</h5>
      <p>在pop的时候是( 而c为) 左右括号当然不相同啊，所以会返回false ，这里是逻辑上的一点点小问题</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//左括号为进栈又括号为出栈</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>||c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//c==&#x27;&#125;&#x27;||c==&#x27;)&#x27;||c==&#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Character pop=stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>&amp;&amp;pop!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;]&#x27;</span> &amp;&amp; pop!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; pop!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//说明左括号没有用完 左括号数量不等于右括号数量</span></span><br><span class="line">        <span class="keyword">if</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题用栈来做就是一件很简单的题目，具体思路如下</p>
<p>​	①当遇到左括号的时候就将其加入栈中</p>
<p>​	②当遇到右括号时，先判断栈是否为空</p>
<p>​				如果为空则返回false</p>
<p>​				如果不为空要对栈顶元素进行弹出并且其比较是否是对应的左括号，如果是则继续循环，如果不是则返回false</p>
<p>​	③结束循环判断栈是否为空，如果栈不为空说明左括号数量多于右括号数量 返回false</p>
<p>​	④以上都没有结束方法且栈为空说明是符合条件的字符串，返回True</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//左括号为进栈右括号为出栈</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//左括号进栈</span></span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27;&#123;&#x27;</span>||c==<span class="string">&#x27;(&#x27;</span>||c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//c==&#x27;&#125;&#x27;||c==&#x27;)&#x27;||c==&#x27;]&#x27;</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//判断栈是否为空，如果为空且当前是右括号需要出栈则代表左括号少了</span></span><br><span class="line">                <span class="keyword">if</span>(stack.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">					</span><br><span class="line">                <span class="comment">//栈顶元素出栈 对其类型进行比较</span></span><br><span class="line">                Character pop=stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;)&#x27;</span>&amp;&amp;pop!=<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;]&#x27;</span> &amp;&amp; pop!=<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;&#125;&#x27;</span>&amp;&amp; pop!=<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//说明左括号没有用完 左括号数量不等于右括号数量</span></span><br><span class="line">        <span class="keyword">if</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="删除字符串中的所有相邻重复项"   >
          <a href="#删除字符串中的所有相邻重复项" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h1>
      <p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>

        <h2 id="1047-删除字符串中的所有相邻重复项"   >
          <a href="#1047-删除字符串中的所有相邻重复项" class="heading-link"><i class="fas fa-link"></i></a><a href="#1047-删除字符串中的所有相邻重复项" class="headerlink" title="1047.删除字符串中的所有相邻重复项"></a>1047.删除字符串中的所有相邻重复项</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" >Leetcode.1047题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;22</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.peek()!=c)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:stack)</span><br><span class="line">    &#123;</span><br><span class="line">        str+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p>我们可以用栈来对这个字母消除的功能，每一次添加元素的时候和栈顶元素比较，不相等则添加，相等则消除</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">    	<span class="comment">//当栈不为空且栈顶元素不相同时入栈</span></span><br><span class="line">        <span class="keyword">if</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.peek()!=c)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            	<span class="comment">//反之相同元素，消除出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拼接结果进行返回</span></span><br><span class="line">    String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:stack)</span><br><span class="line">    &#123;</span><br><span class="line">        str+=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="逆波兰表达式求值"   >
          <a href="#逆波兰表达式求值" class="heading-link"><i class="fas fa-link"></i></a><a href="#逆波兰表达式求值" class="headerlink" title="逆波兰表达式求值"></a>逆波兰表达式求值</h1>
      <p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" >逆波兰表示法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>

        <h2 id="150-逆波兰表达式求值"   >
          <a href="#150-逆波兰表达式求值" class="heading-link"><i class="fas fa-link"></i></a><a href="#150-逆波兰表达式求值" class="headerlink" title="150.逆波兰表达式求值"></a>150.逆波兰表达式求值</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" >Leetcode.150(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;23</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s: tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>)||s.equals(<span class="string">&quot;-&quot;</span>)||s.equals(<span class="string">&quot;/&quot;</span>)||s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> a1=stack.pop();</span><br><span class="line">                <span class="type">int</span> a2=stack.pop();</span><br><span class="line">                <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    result=a1+a2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    result=a1*a2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    result=a1/a2;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result=a1-a2;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：tokens &#x3D;[“4”,”13”,”5”,”&#x2F;“,”+”] 输出4 预期输出6</p>
<p>原因是在做除法的时候先弹出的数应该是被除数，而我把它放在除数的位置上面了</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s: tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>)||s.equals(<span class="string">&quot;-&quot;</span>)||s.equals(<span class="string">&quot;/&quot;</span>)||s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> a1=stack.pop();</span><br><span class="line">                <span class="type">int</span> a2=stack.pop();</span><br><span class="line">                <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    result=a2+a1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    result=a2*a1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    result=a2/a1;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result=a2-a1;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题用栈来解决是一个非常好的，当遇见运算符的时候把栈顶的两个元素做一个运算操作再把结果存入栈中，遇到数字直接加入栈中即可</p>
<p><em>踩坑点</em>：在做减法和除法的时候要注意被除数与除数之间的关系，先弹出的应该是被除数(减数)，后弹出的应该是除数(被减数)</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack =<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s: tokens)&#123;</span><br><span class="line">            <span class="comment">//遇见运算符，将栈顶两个数字进行运算操作</span></span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>)||s.equals(<span class="string">&quot;-&quot;</span>)||s.equals(<span class="string">&quot;/&quot;</span>)||s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                <span class="type">int</span> a1=stack.pop();</span><br><span class="line">                <span class="type">int</span> a2=stack.pop();</span><br><span class="line">                <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    result=a2+a1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    result=a2*a1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    result=a2/a1;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    result=a2-a1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//运算结果存入栈中</span></span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//数字直接加入栈中</span></span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="扩展-逆波兰表达式"   >
          <a href="#扩展-逆波兰表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#扩展-逆波兰表达式" class="headerlink" title="扩展(逆波兰表达式)"></a>扩展(逆波兰表达式)</h3>
      <p>逆波兰表达式：逆波兰表达式就是运算的后缀表达式，是便于计算机对运算的一种处理</p>
<div class="table-container"><table>
<thead>
<tr>
<th>正常表达式</th>
<th>逆波兰表达式</th>
</tr>
</thead>
<tbody><tr>
<td>1+2</td>
<td>12+</td>
</tr>
<tr>
<td>(1+2)*3</td>
<td>12+3*</td>
</tr>
<tr>
<td>(1+2)*(3+4)</td>
<td>12+34+*</td>
</tr>
</tbody></table></div>
<p>我们将正常表达式转化成二叉树之后，将运算符作为父结点，数据作为叶子子结点</p>
<p>那么就如图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230823094253033.png"  alt="逆波兰表达式">
      </p>
<p>所以逆波兰表达式本质上就是正常表达式二叉树的后序遍历</p>

        <h1 id="滑动窗口最大值"   >
          <a href="#滑动窗口最大值" class="heading-link"><i class="fas fa-link"></i></a><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1>
      <p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>

        <h2 id="239-滑动窗口最大值"   >
          <a href="#239-滑动窗口最大值" class="heading-link"><i class="fas fa-link"></i></a><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/" >Leetcode.239题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;24</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> length=nums.length-k+<span class="number">1</span> &lt;<span class="number">1</span>?<span class="number">1</span>:nums.length-k+<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">       Queue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==nums.length-<span class="number">1</span>||len==k)&#123;</span><br><span class="line">                <span class="comment">//移动到最后一个元素了</span></span><br><span class="line">                <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> temp=i;temp&lt;=j;temp++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[temp]&gt;=max) max=nums[temp];</span><br><span class="line">                &#125;</span><br><span class="line">                result[i++]=max;</span><br><span class="line">                j++;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;k)&#123;</span><br><span class="line">                queue.add(nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：nums&#x3D;[1,-1] k&#x3D;1 输出[1,0] 预期输出[1,-1]</p>
<p>原因在max的初始化，我初始化为0，而nums[i]是有可能小于0的</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> length=nums.length-k+<span class="number">1</span> &lt;<span class="number">1</span>?<span class="number">1</span>:nums.length-k+<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">       Queue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==nums.length-<span class="number">1</span>||len==k)&#123;</span><br><span class="line">                <span class="comment">//移动到最后一个元素了</span></span><br><span class="line">                <span class="type">int</span> max=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> temp=i;temp&lt;=j;temp++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[temp]&gt;=max) max=nums[temp];</span><br><span class="line">                &#125;</span><br><span class="line">                result[i++]=max;</span><br><span class="line">                j++;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len&lt;k)&#123;</span><br><span class="line">                queue.add(nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超出时间限制，测试用例耗时过长，我判断是每次获取滑动数组这块循环太浪费时间</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> length=nums.length-k+<span class="number">1</span> &lt;<span class="number">1</span>?<span class="number">1</span>:nums.length-k+<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">       Queue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j==nums.length-<span class="number">1</span>||len==k)&#123;</span><br><span class="line">                queue.add(nums[j]);</span><br><span class="line">                <span class="type">int</span> max;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    max=nums[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> temp=i;temp&lt;=j;temp++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[temp]&gt;=max) max=nums[temp];</span><br><span class="line">                        &#125;</span><br><span class="line">                    result[i++]=max;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    max=result[i-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nums[j]&gt;=max)&#123;</span><br><span class="line">                        result[i++]=nums[j];</span><br><span class="line">                        queue.poll();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        max=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> temp=i;temp&lt;=j;temp++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[temp]&gt;=max) max=nums[temp];</span><br><span class="line">                        &#125;</span><br><span class="line">                        result[i++]=max;</span><br><span class="line">                        queue.poll();  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(len&lt;k)&#123;</span><br><span class="line">                queue.add(nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>测试用例超出时间限制，测试是成功的提交是失败的，就是再后面最大值判断的时候超了时间</p>
<p>这道题没能在规定时间内做出来</p>

        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：最简单能想到的就是，当滑动到指定位置，然后遍历滑动窗口中的数据找到最大值，这就是<strong>暴力法</strong>，时间复杂度就是n*k，k为指定的元素个数，在LeetCode上面暴力法不能作为题解做出来</p>
<p><strong>单调递减队列(用队列求解)</strong></p>
<p>我们可以定义一个队列，然后自定义规则，我们只<strong>要维护可能成为最大数的数据即可</strong></p>
<p><em>也即队列中的数据一定是单调递减的，入队时要将比入队数据小的pop出去</em></p>
<p>例如在-1,3,2,5 </p>
<p>那么遍历到-1队列数据为-1 </p>
<p>而当遍历到3的时候队列就要将比3小的数据pop出去，那么队列中就是3</p>
<p>而遍历到2的时候，因为2比3小，但是在3后面所以可以正常入队 那么队列中为3 ，2</p>
<p>当遍历到5的时候，因为队列中的3,2都比5小，所以都要被pop出去，然后5入队</p>
<p>我们就主要要维护三个方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">getMaxValue()  </span><br><span class="line">获取队首数据，此时队列中最大数就是队首数据</span><br><span class="line"></span><br><span class="line">push(<span class="type">int</span> val)</span><br><span class="line">push数据的时候从队尾开始进行元素判断，将数值小于val的数据都出队淘汰出去</span><br><span class="line">例如 队列中为<span class="number">3</span>，-<span class="number">1</span>  入队为 <span class="number">2</span> 那么就要将小于<span class="number">2</span>的数据淘汰出去再将<span class="number">2</span>入队 最后队列数据为<span class="number">3</span>,<span class="number">2</span></span><br><span class="line">	队列中为<span class="number">3</span>   入队为<span class="number">5</span>，那么将<span class="number">3</span>淘汰，<span class="number">5</span>入队 也即队列数据为<span class="number">5</span></span><br><span class="line"></span><br><span class="line">pop(<span class="type">int</span> val)</span><br><span class="line">pop数据传入一个参数val 我们要判断队首元素与val的值</span><br><span class="line">如果队首元素值比val大 那么就什么都不做</span><br><span class="line">如果队首元素值等于val 那么就将队首元素出队</span><br></pre></td></tr></table></div></figure>



<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    	<span class="comment">//用于接收结果集</span></span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];</span><br><span class="line">        MyQueue queue=<span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">    	<span class="comment">//i表示滑动窗口的起始位置 j表示滑动窗口的结束位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;j&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> len=j-i+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//入队nums[j]</span></span><br><span class="line">            <span class="keyword">if</span>(len&lt;=k)&#123;</span><br><span class="line">                queue.push(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j==nums.length-<span class="number">1</span>||len==k)&#123;</span><br><span class="line">                <span class="comment">//获取滑动窗口最大值</span></span><br><span class="line">                result[i]=queue.getMaxValue();</span><br><span class="line">            	<span class="comment">//淘汰滑动窗口起始位置的元素  如果nums[i]&lt;队首元素数据那么什么都不做</span></span><br><span class="line">                queue.pop(nums[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; queue;</span><br><span class="line">        MyQueue()&#123;</span><br><span class="line">            queue=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size()!=<span class="number">0</span>&amp;&amp;queue.peek()&gt;val)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.poll();</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>&amp;&amp;queue.peekLast()&lt;val)&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="前-K-个高频元素"   >
          <a href="#前-K-个高频元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h1>
      <p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>

        <h2 id="347-前K个高频元素"   >
          <a href="#347-前K个高频元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#347-前K个高频元素" class="headerlink" title="347.前K个高频元素"></a>347.前K个高频元素</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/" >Leetcode.347题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;25</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int[] topKFrequent(int[] nums, int k) &#123;</span><br><span class="line">        int[] result=new int[k];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();</span><br><span class="line">        for(int i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] arr=new int[map.size()];</span><br><span class="line">        int i=0;</span><br><span class="line">        for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            int v=entry.getValue();</span><br><span class="line">            arr[i++]=v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        </span><br><span class="line">        for(int j=0;j&lt;k;j++)&#123;</span><br><span class="line">            i=arr.length-j-1;</span><br><span class="line">            for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            if(entry.getValue().equals(arr[i]))&#123;</span><br><span class="line">                result[j]=entry.getKey();</span><br><span class="line">                i--;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[1,2] k&#x3D;2 输出[1,1] 预期输出[1,2]</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BF</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[map.size()];</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> v=entry.getValue();</span><br><span class="line">            arr[i++]=v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            i=arr.length-j-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue().equals(arr[i]))&#123;</span><br><span class="line">                result[j]=entry.getKey();</span><br><span class="line">                map.put(result[j],<span class="number">0</span>);</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <p>利用<strong>优先级队列小顶堆</strong>求解</p>
<p>思路：</p>
<p>​		1.用一个HashMap来统计每个数字出现的次数</p>
<p>​		2.利用一个小顶堆，我们这里用优先级队列实现，传入比较器将由频率次数的小到大排列形成的二叉树</p>
<p>​		3.遍历数组维护一个数量为k的小顶堆，一旦数量超过k个则先传入数据按照频率维护好堆，再pop出根元素，也即最小频率元素</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    	<span class="comment">//遍历nums 统计每个元素出现的次数</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//利用优先级队列维护堆，这里我们传入的比较器是我们要生成小顶堆</span></span><br><span class="line">         PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">            (o1,o2)-&gt;&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(o1)-map.get(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">		<span class="comment">//遍历数组，维护数量为k的小顶堆，每次pop出根元素也即频率最小的元素</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(queue.size()&lt;k)&#123;</span><br><span class="line">                queue.add(entry.getKey());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                </span><br><span class="line">                queue.add(entry.getKey());</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//将小顶堆的数据取出输出</span></span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            result[j]=queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="拓展-大顶堆和小顶堆"   >
          <a href="#拓展-大顶堆和小顶堆" class="heading-link"><i class="fas fa-link"></i></a><a href="#拓展-大顶堆和小顶堆" class="headerlink" title="拓展(大顶堆和小顶堆)"></a>拓展(大顶堆和小顶堆)</h3>
      <p>堆是一种非线性的数据结构，是<strong>基于完全二叉树</strong>的结构的一维数组</p>
<p>大顶堆：即每个结点的值都大于其左右子结点的值</p>
<p>小顶堆：即每个结点的值都小于其左右子结点的值</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230826080613631.png"  alt="大顶堆和小顶堆">
      </p>
<p>我们可以用<strong>优先级队列</strong>来维护响应的大顶堆和小顶堆</p>
<p><strong>代码</strong></p>
<p>根据比较器的规则不同可以维护不同的堆</p>
<p>大顶堆</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">           (o1,o2)-&gt;&#123;</span><br><span class="line">               <span class="keyword">return</span> map.get(o2)-map.get(o1);</span><br><span class="line">           &#125;</span><br><span class="line">       );</span><br></pre></td></tr></table></div></figure>

<p>小顶堆</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; queue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(</span><br><span class="line">           (o1,o2)-&gt;&#123;</span><br><span class="line">               <span class="keyword">return</span> map.get(o1)-map.get(o2);</span><br><span class="line">           &#125;</span><br><span class="line">       );</span><br></pre></td></tr></table></div></figure>




        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>到这里队列和栈已经告一段落，从这章中我们可以复习<strong>队列和栈</strong>的数据结构，队列是FIFO的数据结构而栈是LIFO的数据结构，同时我们可以学习到<strong>优先级队列</strong>来维护<strong>大顶堆、小顶堆</strong>以及单调队列</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/19/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%AD%A6%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95-%5BKMP%E7%AE%97%E6%B3%95%5D/">死之前要学完的算法-[KMP算法]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">18分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>KMP算法</strong></p>
<p>KMP是字符串匹配算法，而还有一种算法是BF算法(Brute Force)也即暴力算法 我们先用暴力算法看看怎么匹配字符串的过程，易于理解</p>

        <h1 id="BF"   >
          <a href="#BF" class="heading-link"><i class="fas fa-link"></i></a><a href="#BF" class="headerlink" title="BF"></a>BF</h1>
      <p>假设有一个模拟字符串 s1&#x3D;”aabaaccde”和一个比较串s2&#x3D;”aac”</p>
<p>最容易想到的方法是双层循环，第一层遍历模拟串，第二层来进行匹配比较串是否是子串</p>

        <h2 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h2>
      <ul>
<li>先对s1和s2做一个判断 如果模拟串s1长度比比较串s2更短就不可能是子串</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s1.length&lt;s2.length)&#123;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<ul>
<li>第一层遍历模拟串s1，用i表示正在匹配的字符是否是比较串s2中的起始位置</li>
</ul>
<p>如果s1.charAt(i)&#x3D;&#x3D;s2.charAt(0) 那么进行判断i是否是比较串的起始位置</p>
<p>如果s1.charAt(i)!&#x3D;s2.charAt(0) 那么进入下一个位置继续遍历</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s1.length();)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s1.charAt(i)==s2.charAt(j))&#123;</span><br><span class="line">        <span class="comment">//第二层循环 判断是否是子串</span></span><br><span class="line">			<span class="comment">//具体判断代码....</span></span><br><span class="line">                <span class="comment">//如果是子串 则返回当前索引下标 return i;</span></span><br><span class="line">                <span class="comment">//如果不是子串 则将j置为0 等待下一次判断</span></span><br><span class="line">                <span class="comment">//i++;j=0;</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s1.charAt(i)!=s2.charAt(j))&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>第二层遍历判断比较串是否在模拟串中</li>
</ul>
<p>如果每一个字符都对应的上那么就是子串，返回当前索引i</p>
<p>如果有一个字符对应不上则break，将j置为0等待下一次比较</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二层循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> index=i;j&lt;s2.length()&amp;&amp;index&lt;s1.length();)&#123;</span><br><span class="line">    <span class="comment">//判断字符是否相同</span></span><br><span class="line">   <span class="keyword">if</span>(s1.charAt(index)==s2.charAt(j))&#123;</span><br><span class="line">      <span class="comment">//如果j指向了比较串s2的最后一个位置 且字符相同</span></span><br><span class="line">       <span class="keyword">if</span>(j==s2.length()-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//反之没有指向最后一个元素 则两个位置都++</span></span><br><span class="line">       index++;</span><br><span class="line">       j++;</span><br><span class="line"> 	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="comment">//如果有一个字符不相同 那么就不是子串 将j置为0,i++然后跳出循环</span></span><br><span class="line">       j=<span class="number">0</span>;</span><br><span class="line">       i++;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="匹配子串流程图"   >
          <a href="#匹配子串流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配子串流程图" class="headerlink" title="匹配子串流程图"></a>匹配子串流程图</h2>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230820035249818.png"  alt="匹配子串流程图(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230820035207219.png"  alt="匹配子串流程图(2)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230820035609512.png"  alt="匹配子串流程图(3)">
      </p>

        <h2 id="完整代码"   >
          <a href="#完整代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对s1和s2长度判断</span></span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;Narr.length)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外层循环遍历模拟串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]!=Narr[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//内层循环匹配比较串</span></span><br><span class="line">            <span class="comment">//arr[i]==Narr[j]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> index=i;j&lt;Narr.length&amp;&amp;index&lt;arr.length;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[index]==Narr[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    index++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    j=<span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="KMP"   >
          <a href="#KMP" class="heading-link"><i class="fas fa-link"></i></a><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1>
      <p>我们可以通过模拟子串匹配的过程发现，每一次匹配之后都会有一部分位置可以确认不会匹配上，而暴力法就浪费了这一部分的信息，</p>
<p>KMP可以通过回溯指针到最长相同前后缀位置来以便进行下一次子串的匹配</p>

        <h2 id="前缀"   >
          <a href="#前缀" class="heading-link"><i class="fas fa-link"></i></a><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h2>
      <p>前缀：字符串除了最后一个字符，剩下的字符有前到后的所有组合</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如: 字符串&quot;aaabbbc&quot;</span><br><span class="line">那么前缀有: </span><br><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aaa</span><br><span class="line">aaab</span><br><span class="line">aaabb</span><br><span class="line">aaabbb</span><br></pre></td></tr></table></div></figure>


        <h2 id="后缀"   >
          <a href="#后缀" class="heading-link"><i class="fas fa-link"></i></a><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2>
      <p>后缀：字符串除了首字符,剩下的字符由尾到前的所有组合</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如:字符串&quot;aaabbbc&quot;</span><br><span class="line">那么后缀有:</span><br><span class="line">c</span><br><span class="line">bc</span><br><span class="line">bbc</span><br><span class="line">bbbc</span><br><span class="line">abbbc</span><br><span class="line">aabbbc</span><br></pre></td></tr></table></div></figure>


        <h2 id="最长相同前后缀"   >
          <a href="#最长相同前后缀" class="heading-link"><i class="fas fa-link"></i></a><a href="#最长相同前后缀" class="headerlink" title="最长相同前后缀"></a>最长相同前后缀</h2>
      <p>例如:s&#x3D;”aabaa”，那么这个字符的最长公共前后缀就是”aa”</p>

        <h2 id="KMP实现思路"   >
          <a href="#KMP实现思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#KMP实现思路" class="headerlink" title="KMP实现思路"></a>KMP实现思路</h2>
      <p>字符串比较思路是一样的，然后KMP相较于BF的是在<strong>失配</strong>情况下移动比较串的过程</p>
<p>当失配情况下，当前i位置不变移动比较字符串的j索引，而移动j索引则需要用到next数组，查看到当前j之前的next数组就能知道移动后比较串j的新位置</p>

        <h2 id="NEXT数组"   >
          <a href="#NEXT数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#NEXT数组" class="headerlink" title="NEXT数组"></a>NEXT数组</h2>
      <p>next数组用于装比较串的每个子串的最大相同前后缀的长度</p>
<p><strong>例1</strong></p>
<p>S&#x3D;”aabaa” ,那么求得next数组就为[0,1,0,1,2]</p>
<p>具体步骤如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">子串a  	那么前后缀都是0 	所以next[0]==0</span><br><span class="line">子串aa 	那么有一个相同a	所以Next[1]==1</span><br><span class="line">子串aab 	所以没有相同前后缀  所以Next[2]=0</span><br><span class="line">子串aaba 	有一个相同a		 所以Next[3]==1</span><br><span class="line">子串aabaa 有两个相同aa		 所以Next[4]==2</span><br><span class="line">也即</span><br><span class="line">子串	  有几个相同</span><br><span class="line">a 		0</span><br><span class="line">aa 		1</span><br><span class="line">aab 	0</span><br><span class="line">aaba	1</span><br><span class="line">aabaa	2</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><strong>例2</strong></p>
<p>s&#x3D;”ababa” 那么求得next数组就为[0,0,1,2,3]</p>
<p>具体步骤如下：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">子串a 	那么前后缀都是0 		next[0]==0</span><br><span class="line">子串ab 	那么没有相同前后缀 	   next[1]==0</span><br><span class="line">子串aba 	那么有一个相同前后缀a	  next[2]==1</span><br><span class="line">子串abab 	那么有两个相同前后缀ab  next[3]==2</span><br><span class="line">子串ababa 那么有三个相同前后缀aba next[4]==3</span><br><span class="line">也即</span><br><span class="line">a		0</span><br><span class="line">ab  	0</span><br><span class="line">aba 	1</span><br><span class="line">abab	2</span><br><span class="line">ababa 	3</span><br></pre></td></tr></table></div></figure>


        <h3 id="代码获取Next数组"   >
          <a href="#代码获取Next数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码获取Next数组" class="headerlink" title="代码获取Next数组"></a>代码获取Next数组</h3>
      <p>1.定义一个i用于当前要获取的子串的位置，定义一个j用于表示最长前缀的尾部</p>
<p>2.先初始化next[0]&#x3D;0 然后j指向0的位置</p>
<p>3.当前后字符相同的时候 next[i]&#x3D;j+1;j++;i++;</p>
<p>4.当前后字符不相同的时候，循环回溯j的位置，每次都是往前查一位j&#x3D;next[j-1]</p>
<p>5.当j&#x3D;&#x3D;0的时候判断当前j字符和i字符是否相同如果相同则next[i]&#x3D;++j;</p>
<p>6.如果当前j字符和i字符不相同则next[i]&#x3D;0，表示没有相同前后缀</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取next数组</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">       <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">           <span class="comment">//初始化i==0的位置</span></span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">               i++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//当前后缀相同的时候</span></span><br><span class="line">           <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">               <span class="comment">//将当前j+1放到当前索引下标  i和j都++</span></span><br><span class="line">               next[i]=j+<span class="number">1</span>;</span><br><span class="line">               j++;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//当前后缀不相同的时候进行回溯</span></span><br><span class="line">               <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                   <span class="comment">//回溯要找前一个位置的下标</span></span><br><span class="line">                   j=next[j-<span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果j==0 那么j已经指向最初的位置</span></span><br><span class="line">               <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//判断第一个字符是否和当前字符一样</span></span><br><span class="line">                   <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                       <span class="comment">//是的话就将1赋值给当前位置</span></span><br><span class="line">                       next[i]=++j;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="comment">//反之则不一样下一次要从0开始找</span></span><br><span class="line">                       next[i]=<span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">              	</span><br><span class="line">                   <span class="comment">//当前位置也判断过 所以i++</span></span><br><span class="line">                   i++;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> next;    </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="匹配子串过程"   >
          <a href="#匹配子串过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#匹配子串过程" class="headerlink" title="匹配子串过程"></a>匹配子串过程</h2>
      <p>1.遍历模拟串，然后比较当前位置和比较串的j位置是否相同</p>
<p>2.如果相同，那么说明这个字符是匹配上的，判断j位置是不是比较串末尾 如果是则说明找到子串，返回i-needle.length()+1，如果不是末尾，则i++,j++往后继续匹配</p>
<p>3.如果匹配字符失配了，移动比较字符数组j索引，如果j&gt;0查询next[j-1]的数据将j移动到那个数值的索引位置即可，如果j&#x3D;&#x3D;0那么说明已经从头比较了，所以直接i++</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">		<span class="comment">//获取next数组 用于回溯指针</span></span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="comment">//获取模拟串的字符数组</span></span><br><span class="line">        <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">        <span class="comment">//获取比较串的字符数组</span></span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//遍历arr数组 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果遍历的字符相等 则两个指针向后移动</span></span><br><span class="line">            <span class="keyword">if</span>(Narr[j]==arr[i]&amp;&amp;j&lt;Narr.length)&#123;</span><br><span class="line">                <span class="comment">//判断此时是不是比较串末尾 如果是则直接返回i-Narr.length+1</span></span><br><span class="line">                <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i-Narr.length+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//Narr[j]!=arr[i]</span></span><br><span class="line">                <span class="comment">//模拟串数组的滑动 本质上改变下标j的位置</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//找前一个位置的下标  移动到那个位置</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;j=next[j-<span class="number">1</span>]; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="comment">//如果j已经为0了说明要从头开始遍历</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                   i++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="代码"   >
          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">		<span class="comment">//获取next数组 用于回溯指针</span></span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="comment">//获取比较串的字符数组</span></span><br><span class="line">        <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">        <span class="comment">//获取模拟串的字符数组</span></span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//遍历arr数组 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果遍历的字符相等 则两个指针向后移动</span></span><br><span class="line">            <span class="keyword">if</span>(Narr[j]==arr[i]&amp;&amp;j&lt;Narr.length)&#123;</span><br><span class="line">                <span class="comment">//判断此时是不是模拟串末尾 如果是则直接返回i-Narr.length+1</span></span><br><span class="line">                <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i-Narr.length+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//Narr[j]!=arr[i]</span></span><br><span class="line">                <span class="comment">//模拟串数组的滑动 本质上改变下标j的位置</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//找前一个位置的下标  移动到那个位置</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;j=next[j-<span class="number">1</span>]; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="comment">//如果j已经为0了说明要从头开始遍历</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                   i++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取next数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="comment">//初始化i==0的位置</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前后缀相同的时候</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                <span class="comment">//将当前j+1放到当前索引下标  i和j都++</span></span><br><span class="line">                next[i]=j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当前后缀不相同的时候进行回溯</span></span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                    <span class="comment">//回溯要找前一个位置的下标</span></span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果j==0 那么j已经指向最初的位置</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//判断第一个字符是否和当前字符一样</span></span><br><span class="line">                    <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                        <span class="comment">//是的话就将1赋值给当前位置</span></span><br><span class="line">                        next[i]=++j;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//反之则不一样下一次要从0开始找</span></span><br><span class="line">                        next[i]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">               	</span><br><span class="line">                    <span class="comment">//当前位置也判断过 所以i++</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/16/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B4.%E5%AD%97%E7%AC%A6%E4%B8%B2%5D/">死之前要做完的算法手册-[4.字符串]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-16</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">6.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">61分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="反转字符串"   >
          <a href="#反转字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1>
      <p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须**<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" >原地</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>

        <h2 id="344-反转字符串"   >
          <a href="#344-反转字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/" >Leetcode.344题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;17 </p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=s.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> temp=s[left];</span><br><span class="line">            s[left]=s[right];</span><br><span class="line">            s[right]=temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>双指针法</strong></p>
<p>思想是一个指针指向s的起始位置，一个指针指向s的结束位置，然后交换之后分别移动指针 直到左指针大于等于右指针</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">     	<span class="comment">//左指针从0开始 右指针在数组s的结束位置</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=s.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//当左指针小于右指针的时候交换数据</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> temp=s[left];</span><br><span class="line">            s[left]=s[right];</span><br><span class="line">            s[right]=temp;</span><br><span class="line">    		<span class="comment">//左指针向后移动 右指针向前移动</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="541-反转字符串II"   >
          <a href="#541-反转字符串II" class="heading-link"><i class="fas fa-link"></i></a><a href="#541-反转字符串II" class="headerlink" title="541.反转字符串II"></a>541.反转字符串II</h2>
      <p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/" >Leetcode.541题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;17</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=k-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">2</span>*k-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length=s.length();</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(length&lt;<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="comment">//全部反转</span></span><br><span class="line">            right=length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=s.charAt(left);</span><br><span class="line">                arr[left]=s.charAt(right);</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//length&gt;=2k</span></span><br><span class="line">            right=mid;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=s.charAt(left);</span><br><span class="line">                arr[left]=s.charAt(right);</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line">     <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">         sb.append(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE：s &#x3D;”abcdefg” ，k &#x3D;2 ，输出 “bacdefg”， 预期结果”bacdfeg”</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=k-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length=s.length();</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转前k个元素</span></span><br><span class="line">        <span class="keyword">if</span>(length&lt;=k)&#123;</span><br><span class="line">            right=length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(length&lt;=<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="comment">//k&lt;length&lt;=2k </span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//length&gt;2k</span></span><br><span class="line">            <span class="type">int</span> gap=length-<span class="number">2</span>*k;</span><br><span class="line">            <span class="comment">//反转前2k中k个元素</span></span><br><span class="line">            <span class="comment">//k&lt;length&lt;=2k </span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(gap&lt;k)&#123;</span><br><span class="line">                left=<span class="number">2</span>*k;</span><br><span class="line">                right=length-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">char</span> temp=arr[left];</span><br><span class="line">                    arr[left]=arr[right];</span><br><span class="line">                    arr[right]=temp;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gap&lt;<span class="number">2</span>*k)&#123;</span><br><span class="line">                left=<span class="number">2</span>*k;</span><br><span class="line">                right=<span class="number">3</span>*k-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">char</span> temp=arr[left];</span><br><span class="line">                    arr[left]=arr[right];</span><br><span class="line">                    arr[right]=temp;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">            sb.append(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-1"   >
          <a href="#提交错误-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-1" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE：s &#x3D;”krmyfshbspcgtesxnnljhfursyissjnsocgdhgfxubewllxzqhpasguvlrxtkgatzfybprfmmfithphckksnvjkcvnsqgsgosfxc” ，k &#x3D;20 ，输出 “jlnnxsetgcpsbhsfymrkhfursyissjnsocgdhgfxubewllxzqhpasguvlrxtkgatzfybprfmmfithphckksnvjkcvnsqgsgosfxc”， 预期结果”jlnnxsetgcpsbhsfymrkhfursyissjnsocgdhgfxtxrlvugsaphqzxllwebukgatzfybprfmmfithphccxfsogsgqsnvckjvnskk”</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left;</span><br><span class="line">        <span class="type">int</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length=s.length();</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">int</span> cor=<span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cor&lt;=length)&#123;</span><br><span class="line">            <span class="comment">//每次反转前K个元素</span></span><br><span class="line">             right=cor-k-<span class="number">1</span>;</span><br><span class="line">             left=right-k&lt;<span class="number">0</span>?<span class="number">0</span>:right-k;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cor==length)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cor+=<span class="number">2</span>*k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一次反转 cor&gt;length</span></span><br><span class="line">        <span class="type">int</span> gap=length-cor+<span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(gap&gt;<span class="number">0</span>&amp;&amp;gap&lt;k)&#123;</span><br><span class="line">             left=cor-<span class="number">2</span>*k&lt;<span class="number">0</span>?<span class="number">0</span>:cor-<span class="number">2</span>*k;</span><br><span class="line">             right=length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gap==<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="comment">//反转完了</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gap&gt;=k)&#123;</span><br><span class="line">            left=cor-<span class="number">2</span>*k&lt;<span class="number">0</span>?<span class="number">0</span>:cor-<span class="number">2</span>*k;</span><br><span class="line">            right=left+k-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">            sb.append(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-2"   >
          <a href="#提交错误-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-2" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE：s &#x3D;”krmyfshbspcgtesxnnljhfursyissjnsocgdhgfxubewllxzqhpasguvlrxtkgatzfybprfmmfithphckksnvjkcvnsqgsgosfxc” ，k &#x3D;2 ，输出 “rkmsfyhpsbcetgsnnxlfhjuysrijssncosgghdfbuxellwxhqzpgsaurlvxgktafztyrpbffmmiphthkkcsjvnknvcssgqgfsoxc”， 预期结果””rkmysfhbpscgetsxnnljfhurysisjsnscogdghfxbuewllxzhqpagsuvrlxtgkatfzybrpfmfmitphhckksnjvkcnvsqsggofsxc”</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left;</span><br><span class="line">        <span class="type">int</span> right;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> length=s.length();</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">    	<span class="comment">//游标 每次锁定2k个元素</span></span><br><span class="line">        <span class="type">int</span> cor=<span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">while</span>(cor&lt;=length)&#123;</span><br><span class="line">            <span class="comment">//每次反转前K个元素</span></span><br><span class="line">            left=cor-<span class="number">2</span>*k&lt;<span class="number">0</span>?<span class="number">0</span>:cor-<span class="number">2</span>*k;</span><br><span class="line">            right=left+k-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//游标移动2k个位置</span></span><br><span class="line">            cor+=<span class="number">2</span>*k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一次反转 cor&gt;length gap为剩余的字符个数</span></span><br><span class="line">        <span class="type">int</span> gap=length-cor+<span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(gap&gt;<span class="number">0</span>&amp;&amp;gap&lt;k)&#123;</span><br><span class="line">            <span class="comment">//剩余在0~k之间 反转全部剩余字符</span></span><br><span class="line">             left=cor-<span class="number">2</span>*k&lt;<span class="number">0</span>?<span class="number">0</span>:cor-<span class="number">2</span>*k;</span><br><span class="line">             right=length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gap==<span class="number">2</span>*k)&#123;</span><br><span class="line">            <span class="comment">//gap==2k 正好全部反转完了 </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(gap&gt;=k)&#123;</span><br><span class="line">            <span class="comment">//gap&lt;2k &amp;&amp; gap&gt;k 反转前k个元素</span></span><br><span class="line">            left=cor-<span class="number">2</span>*k&lt;<span class="number">0</span>?<span class="number">0</span>:cor-<span class="number">2</span>*k;</span><br><span class="line">            right=left+k-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> temp=arr[left];</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">                arr[right]=temp;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">            sb.append(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题不涉及到算法的过程，只是我们要模拟这个每2k个字符串进行反转然后对尾部字符串判断 1.如果不足k个则全部反转 如果不足2k个则反转前k个</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">       StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">	<span class="comment">//获取字符数组</span></span><br><span class="line">       <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//每次遍历2k个元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">           <span class="comment">//如果此次循环能够找到k个元素进行反转</span></span><br><span class="line">           <span class="keyword">if</span>(i+k&lt;arr.length)&#123;</span><br><span class="line">               <span class="comment">//能够反转前k个元素</span></span><br><span class="line">               <span class="type">int</span> left=i;</span><br><span class="line">               <span class="type">int</span> right=i+k-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                   <span class="type">char</span> temp=arr[left];</span><br><span class="line">                   arr[left++]=arr[right];</span><br><span class="line">                   arr[right--]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//反转完进行下一次判断 </span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//最后不够反转k个元素</span></span><br><span class="line">           <span class="type">int</span> left=i;</span><br><span class="line">           <span class="type">int</span> right=arr.length-<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                   <span class="type">char</span> temp=arr[left];</span><br><span class="line">                   arr[left++]=arr[right];</span><br><span class="line">                   arr[right--]=temp;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">char</span> c:arr) sb.append(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>思路</strong></p>
<p>把最后不足2k个元素当成一次循环来看，如果够k个元素就认为也是一次2k个元素的前k元素反转，如果不够k个元素那么就反转当前索引i到数组末尾的元素。如果不清楚可以看第一次做中第四次代码中对末尾元素个数的处理</p>

        <h1 id="替换空格"   >
          <a href="#替换空格" class="heading-link"><i class="fas fa-link"></i></a><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1>
      <p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;We are happy.&quot;</span></span><br><span class="line">输出：<span class="string">&quot;We%20are%20happy.&quot;</span></span><br></pre></td></tr></table></div></figure>


        <h2 id="剑指-Offer-05-替换空格"   >
          <a href="#剑指-Offer-05-替换空格" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/" >剑指 Offer 05(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;18</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(c+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>利用StringBuilder直接替换空格字符</strong></p>
<p>思路是直接遍历s，如果s索引i的字符是空格字符则替换成%20再添加到StringBuilder中，否则直接添加原字符到StringBuilder中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">     		<span class="comment">//如果是空格</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//反之不是空格</span></span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>双指针法</strong></p>
<p><strong>思路</strong> </p>
<p>1.先统计有多少个空格字符，然后算出要替换之后的数组长度</p>
<p>2.创建一个数组，数组长度为替换之后的数组长度，然后将数组初始化</p>
<p>3.数组初始化是将s每个字符添加到新数组的位置去</p>
<p>4.定义一个right指针指向新数组的尾部  一个left指向s字符串的最后一个位置</p>
<p>5.当left大于等于0并且左指针小于等于右指针的时候循环  ，循环判断这个字符是不是空格字符</p>
<p>6.如果是空格字符那么右指针添加三个数据后再移动三格，左指针移动一格</p>
<p>7.如果不是空格字符那么就将当前位置的数据添加到right位置，然后左右指针都向前移动一格</p>
<p>8.返回新字符串</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//count用于统计有多少个空格字符</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//新数组 新数组长度为老字符串长度+要替换之后多出来的长度</span></span><br><span class="line">        <span class="type">char</span>[] result=<span class="keyword">new</span> <span class="title class_">char</span>[s.length()+<span class="number">2</span>*count];</span><br><span class="line">		<span class="comment">//新数组初始化数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            result[i]=s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//定义一个右指针一个左指针  右指针指向新数组的尾部，左指针指向老字符串的最后一位</span></span><br><span class="line">        <span class="type">int</span> right=result.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=s.length()-<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//当左指针大于等于0 并且左指针小于等于右指针的时候循环</span></span><br><span class="line">        <span class="keyword">while</span>(left&gt;=<span class="number">0</span>&amp;&amp;left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//如果是空格字符</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                result[right]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                result[right-<span class="number">1</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                result[right-<span class="number">2</span>]=<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                right-=<span class="number">3</span>;</span><br><span class="line">                left--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是空格字符 </span></span><br><span class="line">            result[right--]=s.charAt(left--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回新字符串</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result);</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p><strong>双指针法</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230818091650084.png"  alt="双指针法(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230818092035372.png"  alt="双指针法(2)">
      </p>

        <h1 id="翻转字符串里的单词"   >
          <a href="#翻转字符串里的单词" class="heading-link"><i class="fas fa-link"></i></a><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h1>
      <p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>

        <h2 id="151-反转字符串中的单词"   >
          <a href="#151-反转字符串中的单词" class="heading-link"><i class="fas fa-link"></i></a><a href="#151-反转字符串中的单词" class="headerlink" title="151.反转字符串中的单词"></a>151.反转字符串中的单词</h2>
      <p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/" >Leetcode.151题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;18</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strArr=s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        StringBuilder sb= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=strArr.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(strArr[i].equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(strArr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(strArr[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String result=sb.toString();</span><br><span class="line">        <span class="keyword">if</span>(result.charAt(result.length()-<span class="number">1</span>)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            result=result.substring(<span class="number">0</span>,result.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题不用内置库中的分割字符串、移除空白空格，我们自己来对字符串删除前后空格、反转字符串、反转单词</p>
<p><strong>过程</strong> </p>
<p>例如s为” hello  world “ 前后各有一个空格，中间有两个空格</p>
<p>1.删除前后空格以及多余的中间空格，这步结束之后s为 “hello world”</p>
<p>2.反转字符串s，这步结束之后s为”dlrow olleh” </p>
<p>3.反转字符串中每个单词，这步结束之后s为”world hello”</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//删除前后空格以及中间多余空格</span></span><br><span class="line">        s=trimBlack(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转字符串</span></span><br><span class="line">        s=reserveString(s);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反转每个单词</span></span><br><span class="line">        s=reserverWorld(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//移除多余空格</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">trimBlack</span><span class="params">(String s)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果起始位置是空格则left++ 如果终止位置是空格则right-- </span></span><br><span class="line">        <span class="keyword">while</span>(s.charAt(left)==<span class="string">&#x27; &#x27;</span>) left++;</span><br><span class="line">        <span class="keyword">while</span>(s.charAt(right)==<span class="string">&#x27; &#x27;</span>)right--;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//运行到这里说明left和right指向的都是非空格字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除中间多余空格 </span></span><br><span class="line">        <span class="comment">//				1.如果不是空格则直接添加 </span></span><br><span class="line">        <span class="comment">//				2.如果是空格下一个字符不是空格 那么保留空格 </span></span><br><span class="line">        <span class="comment">//				3.如果是空格且下一个字符也是空格则直接舍去</span></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left)!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(s.charAt(left++));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(left)==<span class="string">&#x27; &#x27;</span>&amp;&amp;s.charAt(left+<span class="number">1</span>)!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27; &#x27;</span>); left++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reserveString</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//反转每个单词</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reserverWorld</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">//获取字符数组</span></span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="comment">//定义左指针left 游标cor</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cor=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环 遍历字符数组</span></span><br><span class="line">        <span class="keyword">for</span>(;cor&lt;arr.length;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果游标位置不为空格 且游标位置不是数组最后一位</span></span><br><span class="line">            <span class="keyword">if</span>(arr[cor]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;cor!=arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//游标向后移动 表示当前left到cor这是一个连续的单词</span></span><br><span class="line">                cor++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//arr[cor]==&#x27; &#x27; || cor=arr.length-1</span></span><br><span class="line">                <span class="keyword">if</span>(cor==arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">//这是最后一个单词</span></span><br><span class="line">                    <span class="comment">//获取右指针 右指针的位置为游标位置</span></span><br><span class="line">                    <span class="type">int</span> right=cor;</span><br><span class="line">                    <span class="comment">//反转每个字符</span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                        <span class="type">char</span> temp=arr[left];</span><br><span class="line">                        arr[left++]=arr[right];</span><br><span class="line">                        arr[right--]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//arr[cor]==&#x27; &#x27; 也即cor位置指向空格 那么left到cor-1就是一个完整的单词</span></span><br><span class="line">                    <span class="comment">//这是字符串中的单词，不是最后一个单词</span></span><br><span class="line">                    <span class="type">int</span> right=cor-<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                        <span class="type">char</span> temp=arr[left];</span><br><span class="line">                        arr[left++]=arr[right];</span><br><span class="line">                        arr[right--]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//游标向后移动  ，左指针指向游标位置，等待下一个要反转的单词搜索完毕</span></span><br><span class="line">                    cor++;</span><br><span class="line">                    left=cor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="左旋转字符串"   >
          <a href="#左旋转字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h1>
      <p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>

        <h2 id="剑指-Offer-58-II-左旋转字符串"   >
          <a href="#剑指-Offer-58-II-左旋转字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指-Offer-58-II-左旋转字符串" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串"></a>剑指 Offer 58 - II. 左旋转字符串</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/" >剑指 Offer 58(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;19 </p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=n-<span class="number">1</span>;n&lt;s.length();n++)&#123;</span><br><span class="line">            sb.append(s.charAt(n));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            sb.append(s.charAt(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>如果只在本字符串上进行一个左旋转操作，可以先进行一个<strong>局部反转</strong>，然后再<strong>整体反转</strong>，这也是一种解题的方向</p>
<p>例如 </p>
<ul>
<li>s&#x3D;”abcdefg” n&#x3D;2</li>
<li>先将n左右两边的子字符串进行一个局部反转  结果是 s&#x3D;”bagfedc”;</li>
<li>然后再对整个s进行一个反转 结果为s&#x3D;”cdefgab” 也即我们需要的结果</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//先反转n之前的子字符串</span></span><br><span class="line">    	<span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> temp=arr[left];</span><br><span class="line">            arr[left++]=arr[right];</span><br><span class="line">            arr[right--]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//再反转n开始的子字符串</span></span><br><span class="line">        left=n;</span><br><span class="line">        right=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> temp=arr[left];</span><br><span class="line">            arr[left++]=arr[right];</span><br><span class="line">            arr[right--]=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//最后再反转整个字符数组</span></span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        right=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> temp=arr[left];</span><br><span class="line">            arr[left++]=arr[right];</span><br><span class="line">            arr[right--]=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>暴力法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=n-<span class="number">1</span>;n&lt;s.length();n++)&#123;</span><br><span class="line">            sb.append(s.charAt(n));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            sb.append(s.charAt(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="实现-strStr"   >
          <a href="#实现-strStr" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现-strStr" class="headerlink" title="实现 strStr()"></a>实现 strStr()</h1>
      <p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>

        <h2 id="28-找出字符串中第一个匹配项的下标"   >
          <a href="#28-找出字符串中第一个匹配项的下标" class="heading-link"><i class="fas fa-link"></i></a><a href="#28-找出字符串中第一个匹配项的下标" class="headerlink" title="28.找出字符串中第一个匹配项的下标"></a>28.找出字符串中第一个匹配项的下标</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" >Leetcode.28题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;19</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=needle.length();</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)!=needle.charAt(j))</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> temp=i;temp&lt;i+n;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(haystack.charAt(temp++)==needle.charAt(j++))</span><br><span class="line">                        <span class="keyword">if</span>(temp==i+n-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> i;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(haystack.charAt(temp)!=needle.charAt(j++))&#123;</span><br><span class="line">                        j=<span class="number">0</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                      </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=needle.length();</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tempI=i+<span class="number">1</span>,j=<span class="number">1</span>;j&lt;Narr.length;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[tempI]==Narr[j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> i;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tempI++;</span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i=tempI;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：超出时间限制，输入haystack&#x3D;”a”,needle&#x3D;”a”</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(haystack.length()&lt;needle.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=needle.length();</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(Narr.length==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tempI=i+<span class="number">1</span>,j=<span class="number">1</span>;j&lt;Narr.length;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[tempI]==Narr[j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> i;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tempI++;</span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i=tempI;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次代码-1"   >
          <a href="#第四次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-1" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(haystack.length()&lt;needle.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> index=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n=needle.length();</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(Narr.length==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr.length-i&lt;Narr.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> tempI=i+<span class="number">1</span>,j=<span class="number">1</span>;j&lt;Narr.length&amp;&amp;tempI&lt;arr.length;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[tempI]==Narr[j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">return</span> i;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tempI++;</span><br><span class="line">                        j++;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题要用KMP算法来求解</p>
<p>具体KMP思路可以看我另一篇:死之前要学完的算法-[KMP算法]，这里不会详细说</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="type">char</span>[] arr=haystack.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(Narr[j]==arr[i]&amp;&amp;j&lt;Narr.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i-Narr.length+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//Narr[j]!=arr[i]</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)&#123;j=next[j-<span class="number">1</span>]; <span class="keyword">continue</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                   i++; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//求得next数组 next中存放的是回溯下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                next[i]=j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                        next[i]=++j;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        next[i]=<span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="重复的子字符串"   >
          <a href="#重复的子字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h1>
      <p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>

        <h2 id="459-重复的子字符串"   >
          <a href="#459-重复的子字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#459-重复的子字符串" class="headerlink" title="459.重复的子字符串"></a>459.重复的子字符串</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/" >Leetcode.459(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;20</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                hash[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                sb.append((<span class="type">char</span>)(i+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String needle=sb.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断比较串是否能完全包含s</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==next.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                next[i]=j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                        next[i]=j++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        next[i]=<span class="number">0</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：输入”abaababaab” 输出flase 预期输出true   </p>
<p>该字符串可以由abaab这个子串连续组成</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            hash[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                max=hash[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hash[c-<span class="string">&#x27;a&#x27;</span>]!=max)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：输入”abaababaab” 输出flase 预期输出true   </p>
<p>该字符串可以由abaab这个子串连续组成</p>

        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        StringBuilder lsb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span>(s.length()%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数个 所以子串一定也是奇数个</span></span><br><span class="line">            <span class="type">int</span> len=(<span class="type">int</span>)Math.sqrt(s.length());</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(hash[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    hash[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hash[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                    sb.append((<span class="type">char</span>)(i+<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="comment">//最长子串</span></span><br><span class="line">            <span class="type">int</span> len=s.length()/count;</span><br><span class="line">            <span class="comment">//遍历前len个元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                lsb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        String needle=sb.toString();</span><br><span class="line">        String lsbNeedle=lsb.toString();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lsbNeedle==<span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">            <span class="comment">//奇数</span></span><br><span class="line">            <span class="keyword">return</span> tryRespeat(needle,s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> minflag=tryRespeat(needle,s);</span><br><span class="line">        <span class="type">boolean</span> maxflag=tryRespeat(lsbNeedle,s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minflag||maxflag;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRespeat</span><span class="params">(String needle,String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==next.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                next[i]=j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                        next[i]=j++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        next[i]=<span class="number">0</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:”aaaaaaaaaaaaaaaaa” 输出false 预期输出true</p>
<p>当字符串长度为奇数的时候还是取子串取错了</p>

        <h4 id="第四次代码-2"   >
          <a href="#第四次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-2" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                sb.append(s.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> result=tryRespeat(sb.toString(),s);</span><br><span class="line">            <span class="keyword">if</span>(result)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRespeat</span><span class="params">(String needle,String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==next.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                next[i]=j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                        next[i]=j++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        next[i]=<span class="number">0</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:超出时间限制，因为这次获取子串的方式是枚举也即全暴力获取，然后给出的字符串s很长就超出时间限制了</p>

        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="暴力法"   >
          <a href="#暴力法" class="heading-link"><i class="fas fa-link"></i></a><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4>
      <p>暴力法就是双层循环 第一层循环i从1开始 用来记录子串的结束位置</p>
<p>第二层循环j从0开始 获取从j到i的所有子串 然后和主串比较</p>
<p>这里不做暴力法的详细做法</p>

        <h4 id="移动数组"   >
          <a href="#移动数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#移动数组" class="headerlink" title="移动数组"></a>移动数组</h4>
      <p>思路：一个字符串s 如果s是由重复子串构成的话，那么前半个部分和后半个部分会相同，我们将字符串扩展到原来的两倍并且去掉首位元素，来判断原来的字符串s是否在新的扩展后的字符串中出现 如果是那么则说明是重复子串构成的</p>
<p>例如</p>
<p>字符串s为”abcabc” ,那么将s扩展一倍为字符串ss为”abcabcabcabc”</p>
<p>s的前半部分”abc”和后半部分”abc”相等 所以我们判断原字符串的后半部分和原字符串的前半部分组成的字符串是不是原来的字符串</p>
<p><em>注意</em></p>
<p>字符串ss要去掉首尾字母，然后再进行是否出现子串的判断<del>是否出现子串用了KMP算法实现</del></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230820101419616.png"  alt="移动数组(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230820101734419.png"  alt="移动数组(2)">
      </p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//扩展一倍</span></span><br><span class="line">        String ss=s+s;</span><br><span class="line">    	<span class="comment">//截去首尾字符</span></span><br><span class="line">        String newStr=ss.substring(<span class="number">1</span>,ss.length()-<span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//判断s是否在newStr中出现</span></span><br><span class="line">        <span class="keyword">return</span> tryRespeat(s,newStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断原来的字符串是否出现在扩展后的字符串中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRespeat</span><span class="params">(String needle,String s)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==Narr[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==Narr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[i]!=Narr[j])&#123;</span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i]==Narr[j])&#123;</span><br><span class="line">                        j++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取next数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">        <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                next[i]=j+<span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                    j=next[j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                        next[i]=j++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        next[i]=<span class="number">0</span>;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="KMP算法实现"   >
          <a href="#KMP算法实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h4>
      <p>思路:利用KMP算出字符串s的最小重复子串</p>
<p><strong>s的最小重复子串长度是字符串长度减去最长相同前后缀长度</strong></p>
<p>这个观点很重要，举个例子说说为什么会是这个</p>
<p>例如字符串s为”abcabcabc” 那么next数组也即[0,0,0,1,2,3,4,5,6]</p>
<p>那么最长相同前后缀长度也即next[next.length-1]，也即等于6</p>
<p>字符串长度为9，所以最小重复子串长度就为9-6&#x3D;3，也即最小子串为s.substring(0,3);</p>
<p>然后获得了最小子串，判断这个最小子串能不能组成字符s即可</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取最小子串长度</span></span><br><span class="line">    	<span class="type">int</span> len=s.length()-getNext(s)[s.length()-<span class="number">1</span>];</span><br><span class="line">    	<span class="comment">//如果没有最小重复子串则返回false</span></span><br><span class="line">       <span class="keyword">if</span>(len==s.length())&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="comment">//获取最小子串needle</span></span><br><span class="line">       String needle=s.substring(<span class="number">0</span>,len);</span><br><span class="line">       <span class="keyword">return</span> tryRespeat(needle,s);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//判断这个子串是否能完成组成字符s</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryRespeat</span><span class="params">(String needle,String s)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[] next=getNext(needle);</span><br><span class="line">       <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">       <span class="type">char</span>[] Narr=needle.toCharArray();</span><br><span class="line">       <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[i]==Narr[j])&#123;</span><br><span class="line">               <span class="keyword">if</span>(j==next.length-<span class="number">1</span>)&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   j=<span class="number">0</span>;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               i++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取next数组</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] getNext(String s)&#123;</span><br><span class="line">       <span class="type">int</span>[] next=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">       <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">       next[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;)&#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">               next[i]=j+<span class="number">1</span>;</span><br><span class="line">               j++;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//回溯</span></span><br><span class="line">               <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;arr[j]!=arr[i])&#123;</span><br><span class="line">                   j=next[j-<span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(arr[j]==arr[i])&#123;</span><br><span class="line">                       next[i]=j++;</span><br><span class="line">                       i++;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       next[i]=<span class="number">0</span>;</span><br><span class="line">                       i++;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> next;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>字符串这章也算是走到这里暂时结束了，我们从这章可以学到极其抽象的<strong>KMP算法</strong>来判断子串是否在主串中出现过，也能学到旋转字符串、删除空白字符等操作。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/13/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B3.%E5%93%88%E5%B8%8C%E8%A1%A8%5D/">死之前要做完的算法手册-[3.哈希表]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">69分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="哈希表基础"   >
          <a href="#哈希表基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈希表基础" class="headerlink" title="哈希表基础"></a>哈希表基础</h1>
      <p>哈希表也称散列表，是根据Key直接访问地址的数据类型</p>
<p><strong>哈希函数</strong></p>
<p>利用函数将元素的数据取得一个哈希值，这个哈希值也即要存放的地址</p>
<p><strong>哈希碰撞</strong></p>
<p>当存放的地址已经有值的时候就发生了哈希碰撞，处理哈希碰撞有以下几种方法</p>
<ul>
<li>线性探测法：从当前位置往下遍历找到一个空位置将数据存进去</li>
<li>链式寻址法：链式寻址法也即<strong>拉链法</strong>，插入到位置结点的下一个结点中，形成链表</li>
<li>再哈希法：用另外的哈希函数计算一个新的哈希值</li>
</ul>

        <h1 id="有效的字母异位词"   >
          <a href="#有效的字母异位词" class="heading-link"><i class="fas fa-link"></i></a><a href="#有效的字母异位词" class="headerlink" title="有效的字母异位词"></a>有效的字母异位词</h1>
      <p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p>
<p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p>

        <h2 id="242-有效的字母异位词"   >
          <a href="#242-有效的字母异位词" class="heading-link"><i class="fas fa-link"></i></a><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/" >Leetcode.242题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;13</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; Smap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; Tmap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            Smap.put(c,Smap.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            Tmap.put(c,Tmap.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Tmap.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Smap.get(c)!=Tmap.get(c))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入”a” ,”ab” 输出true，预期输出false</p>

        <h5 id="原因"   >
          <a href="#原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因" class="headerlink" title="原因"></a>原因</h5>
      <p>我只对s中的元素对t中的个数判断，实际上如果两个字符串长度都不同的话就不可能是有效的，所以我对两个map长度进行一个判断</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; Smap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; Tmap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            Smap.put(c,Smap.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            Tmap.put(c,Tmap.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Tmap.size()!=Smap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Tmap.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Smap.get(c)!=Tmap.get(c))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-1"   >
          <a href="#提交错误-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-1" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>case：最后一个测试用例不通过</p>

        <h5 id="原因-1"   >
          <a href="#原因-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5>
      <p>我这个时候意识到了之前在数组篇的时候map.get()获取到的数据是Integer类型的，就如这个 if(Smap.get(c)!&#x3D;Tmap.get(c)) 如果数据超过127那么比较地址值之后就会返回false，所以我们这里要用eqauls()方法进行比较</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; Smap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; Tmap =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            Smap.put(c,Smap.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">            Tmap.put(c,Tmap.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Tmap.size()!=Smap.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Tmap.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!Smap.get(c).equals(Tmap.get(c)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p>我第一次做的时候是利用暴力法将两个字符串出现次数统计 然后遍历做对比</p>
<p>我们可以用<strong>哈希法</strong>，利用一个数组来做这个题</p>
<p><strong>思路</strong></p>
<p>因为有效字母异位词说明这个字符串里面只能出现a-z，那么我们可以用26位的数组 hash来承接这个a-z，例如a对应下标为0，z对应下标为25</p>
<p>然后数组初始化为0，数组中的数据代表出现的次数</p>
<p><strong>第一次循环</strong>，我们统计s字符串出现过的字符次数</p>
<p><strong>第二次循环</strong>，我们遍历t字符串，将每一次出现的字符在hash中做减减操作</p>
<p><strong>第三次循环</strong>，我们遍历hash数组 判断这个数组中每个元素是否为0，如果都为0说明s字符串的字符都在t中出现过相同次数</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一个hash数组，索引0-25代表a-z,数组中的数据代表这个字母出现的次数</span></span><br><span class="line">        <span class="type">int</span>[] hash=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//第一次循环，我们遍历字符串s</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">        	<span class="comment">//将获取到的每一个字符-&#x27;a&#x27; 获取一个映射</span></span><br><span class="line">        	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        		如果c==&#x27;a&#x27;, 那么c-&#x27;a&#x27;==0 也即a映射到索引为0的位置</span></span><br><span class="line"><span class="comment">        		如果c==&#x27;b&#x27;, c-&#x27;b&#x27;==1 也即b代表索引1的位置</span></span><br><span class="line"><span class="comment">        		然后出现次数++，数组中的数据代表这个字母出现多少次</span></span><br><span class="line"><span class="comment">        	</span></span><br><span class="line"><span class="comment">        	*/</span></span><br><span class="line">            hash[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//第二次循环，我们遍历字符串t</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:t.toCharArray())&#123;</span><br><span class="line">        	<span class="comment">//将对应出现的次数--</span></span><br><span class="line">            hash[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//第三次遍历，我们遍历hash数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:hash)&#123;</span><br><span class="line">        	<span class="comment">//如果数据不为0那么说明s中的这个字母在t中出现的次数不对</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//运行到这里说明hash数组中的数据都是0，那么也就是s是t的有效字母异位词</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p><strong>哈希法(数组)</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230813074212630.png"  alt="哈希数组(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230813074507361.png"  alt="哈希数组(2)">
      </p>
<p>第三次遍历hash数组 </p>
<ul>
<li><p>如果有一个元素不为0那么说明s和t中出现次数不一样直接返回false </p>
</li>
<li><p>如果遍历结束那么就返回true，说明数组中的元素都是0</p>
</li>
</ul>

        <h1 id="两个数组的交集"   >
          <a href="#两个数组的交集" class="heading-link"><i class="fas fa-link"></i></a><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h1>
      <p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>

        <h2 id="349-两个数组的交集"   >
          <a href="#349-两个数组的交集" class="heading-link"><i class="fas fa-link"></i></a><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/" >Leetcode.349题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;14</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums1.length&lt;nums2.length)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                    map.put(i,map.get(i)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                    map.put(i,map.get(i)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">            ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; e:map.entrySet())&#123;</span><br><span class="line">                <span class="keyword">if</span>(e.getValue()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    list.add(e.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                result[i]=list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h3>
      <p>这道题可以利用set的去重原理，然后先获取到数组一个哈希表</p>
<p>然后遍历另一个数组判断是否出现过，出现过将它放到要返回的数组中</p>

        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>哈希表是Set</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//获取一个set哈希表</span></span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个reSet哈希表用于存放交集，这里需要去重</span></span><br><span class="line">        HashSet&lt;Integer&gt; reset =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//如果nums1的数量更小，那么将小的数组做哈希表的数据</span></span><br><span class="line">        <span class="keyword">if</span>(nums1.length&lt;nums2.length)&#123;</span><br><span class="line">            <span class="comment">//遍历nums1,存到set中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历nums2，找到交集</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(i))&#123;</span><br><span class="line">                    reset.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//遍历nums2,存到set中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历nums1，找到交集</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(i))&#123;</span><br><span class="line">                    reset.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//定义一个数组用于返回交集</span></span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[reset.size()];</span><br><span class="line">    	<span class="comment">//从索引为0开始存数据</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//遍历交集set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : reset)&#123;</span><br><span class="line">            result[i++]=num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//返回result</span></span><br><span class="line">        <span class="keyword">return</span> result;        </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>哈希表是数组</strong></p>
<p><del>因为这道题的背景中nums1和nums2的数据一定是1到1000之间，所以我们可以不考虑数据较大而不能确定数组大小的情况</del></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//定义一个数组用于做哈希表</span></span><br><span class="line">   		<span class="type">int</span>[] hashTable=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1024</span>];</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义一个set 用于去重交集元素</span></span><br><span class="line">        HashSet&lt;Integer&gt; reset=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//遍历nums1 将nums1的元素都在哈希表置为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">             hashTable[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//遍历nums2 判断nums2的元素是否在nums1中出现</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">            <span class="comment">//如果hashTable[i]==1 说明出现在nums1中</span></span><br><span class="line">            <span class="keyword">if</span>( hashTable[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//添加到去重集合reset中</span></span><br><span class="line">                 reset.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//定义一个集合用于返回交集</span></span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[reset.size()];</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//遍历reset 将元素添加到交集数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:reset)&#123;</span><br><span class="line">            result[j++]=i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>







<p><strong>哈希表是map</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    	<span class="comment">//定义一个map ，用于做哈希表</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//如果nums1的个数比nums2小 说明交集大小最多为num1的大小</span></span><br><span class="line">        <span class="keyword">if</span>(nums1.length&lt;nums2.length)&#123;</span><br><span class="line">            <span class="comment">//遍历nums1 将其存入map中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历nums2 如果map中存在这个数 则将其自减</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                    map.put(i,map.get(i)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//遍历nums2 将其存入map中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums2)&#123;</span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历nums1 如果map中存在这个数 则将其自减</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(i))&#123;</span><br><span class="line">                    map.put(i,map.get(i)-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        	<span class="comment">//定义一个list，用于存放去重之后的交集元素</span></span><br><span class="line">            ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    		<span class="comment">//遍历map</span></span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; e:map.entrySet())&#123;</span><br><span class="line">                <span class="comment">//如果Entry的value不为1 那么则说明是交集元素</span></span><br><span class="line">                <span class="keyword">if</span>(e.getValue()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//将key放入list中</span></span><br><span class="line">                    list.add(e.getKey());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//定义一个数组用于返回交集</span></span><br><span class="line">            <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">    		<span class="comment">//遍历list 将其数据放入result数组中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">                result[i]=list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="快乐数"   >
          <a href="#快乐数" class="heading-link"><i class="fas fa-link"></i></a><a href="#快乐数" class="headerlink" title="快乐数"></a>快乐数</h1>
      <p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
<p> <strong>示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></table></div></figure>




        <h2 id="202-快乐数"   >
          <a href="#202-快乐数" class="heading-link"><i class="fas fa-link"></i></a><a href="#202-快乐数" class="headerlink" title="202.快乐数"></a>202.快乐数</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/" >Leetcode.202题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;14</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">10</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            arr[n%<span class="number">10</span>]++;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                count+=arr[i]*i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">5</span>==<span class="number">0</span>||count==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-2"   >
          <a href="#提交错误-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-2" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入5 输出true 预期输出false</p>

        <h5 id="原因-2"   >
          <a href="#原因-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5>
      <p>我错判认为5的倍数也能是快乐数，重新算了一下发现5也是不行的</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">10</span>==<span class="number">0</span>&amp;&amp;n/<span class="number">10</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">10</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            arr[n%<span class="number">10</span>]++;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                count+=arr[i]*i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">10</span>==<span class="number">0</span>||count==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-3"   >
          <a href="#提交错误-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-3" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE：输入7 输出false 预期输出true</p>

        <h5 id="原因-3"   >
          <a href="#原因-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-3" class="headerlink" title="原因"></a>原因</h5>
      <p>我对快乐数的判断出现了严重性错误</p>
<p>这个题没能第一次做出来</p>

        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>分析</strong></p>
<p>因为n在2的32次方-1之间，假设有一个5位的数，那么它最大是99999，那么它变化的数是9²+9²+9²+9²+9²&#x3D;81*5&#x3D;405</p>
<p>也即99999这个数在替换成平方和的时候只能在[0,405]这个区间</p>
<p>如果这个数是一个快乐数那么会变换成1最后跳出循环</p>
<p>如果这个数不是一个快乐数那么会一直循环，也即产生了环</p>
<p>我们只要判断替换平方和这个数是否出现过，如果出现过说明陷入了循环中</p>
<p><strong>集合法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">      <span class="comment">//定义一个set集合用来承接替换成平方和的数</span></span><br><span class="line">      HashSet&lt;Integer&gt; reset=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span>(n!=<span class="number">1</span>)&#123;  </span><br><span class="line">           reset.add(n);        </span><br><span class="line">           n=getNumber(n);</span><br><span class="line">			<span class="comment">//如果reset中包含n 说明进入了循环</span></span><br><span class="line">           <span class="keyword">if</span>(reset.contains(n))&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="comment">//当n==1的时候跳出循环 返回true是快乐数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//定义一个方法来转换平方和</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">       <span class="comment">//定义res用来接收平方和</span></span><br><span class="line">       <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(n%<span class="number">10</span>!=<span class="number">0</span> || n/<span class="number">10</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="comment">//s为该位数</span></span><br><span class="line">           <span class="type">int</span> s=n%<span class="number">10</span>;</span><br><span class="line">           <span class="comment">//res=res+s²</span></span><br><span class="line">           res+=s*s;</span><br><span class="line">           n/=<span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 返回平方和</span></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>





<p><strong>快慢指针法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义慢指针和快指针 从n开始</span></span><br><span class="line">        <span class="type">int</span> slow=n;</span><br><span class="line">        <span class="type">int</span> fast=n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//slow每次变化一次，fast每次变化两次  </span></span><br><span class="line">            <span class="comment">//如果n==1的话第一次之后就会跳出循环，不等于1的话说明第一个结点不为1 开始找环</span></span><br><span class="line">            slow=getNumber(slow);</span><br><span class="line">            fast=getNumber(fast);</span><br><span class="line">            fast=getNumber(fast);</span><br><span class="line">        &#125;<span class="keyword">while</span>(fast!=slow);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//判断环的入口是否是1 </span></span><br><span class="line">        <span class="keyword">return</span> slow==<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//定义res用来返回变化后的平方和</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp=n%<span class="number">10</span>;</span><br><span class="line">            res+=temp*temp;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230814111826990.png"  alt="快慢指针参考图(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com//image-20230814112115719.png"  alt="双指针参考图(2)">
      </p>

        <h1 id="两数之和"   >
          <a href="#两数之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1>
      <p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>

        <h2 id="1-两数之和"   >
          <a href="#1-两数之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/" >Leecode.1(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;15</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; gap=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            result[<span class="number">0</span>]=i;</span><br><span class="line">            gap.add(target-nums[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(gap.contains(nums[j]))&#123;</span><br><span class="line">                    result[<span class="number">1</span>]=j;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong></p>
<p>这道题可以用map来处理，因为我们要返回下标，所以我们的map可以key是值，value是索引</p>
<p>遍历数组，然后判断相加的值是否在map中出现过，如果出现过则返回这两个值的value 如果没有出现过就添加到map中</p>
<p><strong>map是用来存放已经遍历过的数据 key&#x3D;数值 value&#x3D;索引下标</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    	<span class="comment">//定义一个数组用于返回下标</span></span><br><span class="line">        <span class="type">int</span>[] result=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">		<span class="comment">//定义一个哈希map用于存放已经遍历过的元素</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//需要相加的数值</span></span><br><span class="line">            <span class="type">int</span> gap=target-nums[i];</span><br><span class="line">            <span class="comment">//如果map中存在这个数据</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(gap))&#123;</span><br><span class="line">                <span class="comment">//将下标返回</span></span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=map.get(gap);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//map中不存在差值元素，将当前数据添加到map中</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="四数相加II"   >
          <a href="#四数相加II" class="heading-link"><i class="fas fa-link"></i></a><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h1>
      <p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>

        <h2 id="454-四数相加II"   >
          <a href="#454-四数相加II" class="heading-link"><i class="fas fa-link"></i></a><a href="#454-四数相加II" class="headerlink" title="454.四数相加II"></a>454.四数相加II</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/" >Leecode.454题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;15</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1.length==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[<span class="number">0</span>]+nums2[<span class="number">0</span>]+nums3[<span class="number">0</span>]+nums4[<span class="number">0</span>]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将四数相加变成两数相加</span></span><br><span class="line">            <span class="type">int</span> sum1[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> sum2[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums1.length;j++)&#123;</span><br><span class="line">                    sum1[index]=nums1[i]+nums2[j];</span><br><span class="line">                    sum2[index]=nums3[i]+nums4[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sum1.length;i++)&#123;</span><br><span class="line">                map.put(sum1[i],i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sum2.length;i++)&#123;</span><br><span class="line">                <span class="type">int</span> gap=<span class="number">0</span>-sum2[i];</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(gap))&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-4"   >
          <a href="#提交错误-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-4" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE: 输入[-1,1],[1,-1],[-1,1],[-1,-1] 输出3 预期输出6</p>

        <h5 id="原因-4"   >
          <a href="#原因-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-4" class="headerlink" title="原因"></a>原因</h5>
      <p>当添加元素到map中的时候，如果出现相同的会覆盖，而后面判断有没有这个元素的时候就等于是少了前面几次的判断，所以我将map的含义做了改变，Key&#x3D;值，value&#x3D;出现的次数 ，然后count+&#x3D;value即可</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1.length==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[<span class="number">0</span>]+nums2[<span class="number">0</span>]+nums3[<span class="number">0</span>]+nums4[<span class="number">0</span>]==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将四数相加变成两数相加</span></span><br><span class="line">            <span class="type">int</span> sum1[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> sum2[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums1.length;j++)&#123;</span><br><span class="line">                    sum1[index]=nums1[i]+nums2[j];</span><br><span class="line">                    sum2[index]=nums3[i]+nums4[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:sum1)&#123;</span><br><span class="line">                map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sum2.length;i++)&#123;</span><br><span class="line">                <span class="type">int</span> gap=<span class="number">0</span>-sum2[i];</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(gap))&#123;</span><br><span class="line">                    count+=map.get(gap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-5"   >
          <a href="#提交错误-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-5" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>索引越界异常   Index 6 out of bounds for length 6</p>

        <h5 id="原因-5"   >
          <a href="#原因-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-5" class="headerlink" title="原因"></a>原因</h5>
      <p>我把两个数组之和的结果个数设置为原来数组的两倍，实际上笛卡尔积是乘积的关系，所以应该将新数组的长度设为原来的平方</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//将四数相加变成两数相加</span></span><br><span class="line">            <span class="type">int</span> sum1[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*nums1.length];</span><br><span class="line">            <span class="type">int</span> sum2[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*nums1.length];</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums1.length;j++)&#123;</span><br><span class="line">                    sum1[index]=nums1[i]+nums2[j];</span><br><span class="line">                    sum2[index]=nums3[i]+nums4[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:sum1)&#123;</span><br><span class="line">                map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sum2.length;i++)&#123;</span><br><span class="line">                <span class="type">int</span> gap=<span class="number">0</span>-sum2[i];</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(gap))&#123;</span><br><span class="line">                    count+=map.get(gap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>①先遍历a+b 得到a+b的所有组合 然后放到map中 </p>
<p>②map中的key代表的是a+b中的数  value代表是出现了多少次</p>
<p>③再遍历c+d，得到c+d的所有组合 然后求得target&#x3D;0-(c+d)</p>
<p>④判断target是否在map中出现，如果出现count+&#x3D;map.value(target)</p>
<p>⑤返回count</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//将四数相加变成两数相加</span></span><br><span class="line">    		<span class="comment">//定义sum1用来存放a+b的所有组合 定义sum2用来存放c+d的所有组合</span></span><br><span class="line">            <span class="type">int</span> sum1[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*nums1.length];</span><br><span class="line">            <span class="type">int</span> sum2[]=<span class="keyword">new</span> <span class="title class_">int</span>[nums1.length*nums1.length];</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//从0开始添加到sum中</span></span><br><span class="line">            <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums1.length;j++)&#123;</span><br><span class="line">                    <span class="comment">//sum1[index]=a[i]+b[j]</span></span><br><span class="line">                    <span class="comment">//sum2[index]=c[i]+d[j]</span></span><br><span class="line">                    sum1[index]=nums1[i]+nums2[j];</span><br><span class="line">                    sum2[index]=nums3[i]+nums4[j];</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    		<span class="comment">//统计符合条件的四元组个数</span></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    		<span class="comment">//定义map用于存放a+b中的数据 value为出现的次数</span></span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:sum1)&#123;</span><br><span class="line">                <span class="comment">//map添加数据</span></span><br><span class="line">                map.put(i,map.getOrDefault(i,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">    		<span class="comment">//遍历c+d的数据</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sum2.length;i++)&#123;</span><br><span class="line">                <span class="comment">//获取target</span></span><br><span class="line">                <span class="type">int</span> gap=<span class="number">0</span>-sum2[i];</span><br><span class="line">                <span class="comment">//如果map中出现了 那么count+=map.get(target)</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(gap))&#123;</span><br><span class="line">                    count+=map.get(gap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//返回count</span></span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>也即</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Integer,Integer&gt; map =<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			<span class="comment">//遍历a+b</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j:nums2)&#123;</span><br><span class="line">                    map.put(i+j,map.getOrDefault(i+j,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//遍历c+d</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums3)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j:nums4)&#123;</span><br><span class="line">                    <span class="type">int</span> gap=<span class="number">0</span>-i-j;</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(gap))&#123;</span><br><span class="line">                        count+=map.get(gap);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="赎金信"   >
          <a href="#赎金信" class="heading-link"><i class="fas fa-link"></i></a><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h1>
      <p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>

        <h2 id="383-赎金信"   >
          <a href="#383-赎金信" class="heading-link"><i class="fas fa-link"></i></a><a href="#383-赎金信" class="headerlink" title="383.赎金信"></a>383.赎金信</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/" >Leetcode.383题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;16</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hashTable=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:magazine.toCharArray())&#123;</span><br><span class="line">            hashTable[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:ransomNote.toCharArray())&#123;</span><br><span class="line">            hashTable[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:hashTable)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong></p>
<p>magazine和ransomNote的字符规定为小写字母，所以我们可以用一个hashTable做一个字母的映射</p>
<p>第一个循环 将magazize中的字符出现次数++</p>
<p>第二个循环将ransomNote中的字符在哈希表的出现次数–</p>
<p>第三个循环判断这个哈希表中是否有小于0的字符 如果有则说明这个字符在ransomNote中的个数比Magazine的个数多</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义一个hash表 0-a  1-b ... 25-z</span></span><br><span class="line">        <span class="type">int</span>[] hashTable=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    	<span class="comment">//第一次遍历magazine 统计每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:magazine.toCharArray())&#123;</span><br><span class="line">            hashTable[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//第二次遍历ransomNote 减去对应的字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:ransomNote.toCharArray())&#123;</span><br><span class="line">            hashTable[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//第三次遍历hash表，判断是否有小于0的元素，如果有则说明在ransomNote的个数比magazine的个数多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:hashTable)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//运行到这里说明hash表的每个元素都大于等于0  返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="三数之和"   >
          <a href="#三数之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1>
      <p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>

        <h2 id="15-三数之和"   >
          <a href="#15-三数之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/" >Leetcode.15题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;16 </p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="type">int</span> target=<span class="number">0</span>-nums[i]-nums[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> z=j+<span class="number">1</span>;z&lt;nums.length;z++)</span><br><span class="line">                <span class="keyword">if</span>(nums[z]==target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; hsset=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    hsset.add(nums[i]);</span><br><span class="line">                    hsset.add(nums[j]);</span><br><span class="line">                    hsset.add(nums[z]);</span><br><span class="line"></span><br><span class="line">                    list.add(hsset);</span><br><span class="line">                    <span class="keyword">break</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-6"   >
          <a href="#提交错误-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-6" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE：输入nums &#x3D;[-1,0,1,2,-1,-4] 输出 [[-1,0,1],[-1,2,-1],[0,1,-1]] 预期结果 [[-1,-1,2],[-1,0,1]]</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       List&lt;Integer&gt; hsset=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length-<span class="number">1</span>;j++)&#123;</span><br><span class="line">               <span class="type">int</span> target=<span class="number">0</span>-nums[i]-nums[j];</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> z=j+<span class="number">1</span>;z&lt;nums.length;z++)</span><br><span class="line">               <span class="keyword">if</span>(nums[z]==target)&#123;</span><br><span class="line">                   hsset.add(nums[i]);</span><br><span class="line">                   hsset.add(nums[j]);</span><br><span class="line">                   hsset.add(nums[z]);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">break</span>;   </span><br><span class="line">           &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       HashSet&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hsset.size()-<span class="number">2</span>;)&#123;</span><br><span class="line">            </span><br><span class="line">           <span class="keyword">if</span>(set.contains(hsset.get(i))&amp;&amp; set.contains(hsset.get(i+<span class="number">1</span>))&amp;&amp; set.contains(hsset.get(i+<span class="number">2</span>)))&#123;</span><br><span class="line">               i+=<span class="number">3</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           ArrayList&lt;Integer&gt; array=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           set.add(hsset.get(i));</span><br><span class="line">           set.add(hsset.get(i+<span class="number">1</span>));</span><br><span class="line">           set.add(hsset.get(i+<span class="number">2</span>));</span><br><span class="line">           array.add(hsset.get(i));</span><br><span class="line">           array.add(hsset.get(i+<span class="number">1</span>));</span><br><span class="line">           array.add(hsset.get(i+<span class="number">2</span>));</span><br><span class="line">           list.add(array);</span><br><span class="line">           i+=<span class="number">3</span>;     </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-7"   >
          <a href="#提交错误-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-7" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE: nums[-1,0,1,2,-1,-4,-2,-3,3,0,4] 输出[[-1,0,1],[-1,2,-1],[-1,-2,3],[-1,-3,4],[0,-4,4]] 预期输出[[-4,0,4],[-4,1,3],[-3,-1,4],[-3,0,3],[-3,1,2],[-2,-1,3],[-2,0,2],[-1,-1,2],[-1,0,1]]</p>
<p>我用hashset去重判断了，好像有点过头了</p>
<p>这道题没能做出来，主要是去重的逻辑不好考虑</p>

        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题用<strong>双指针法</strong>，因为哈希法对去重的逻辑麻烦不好理解，而双指针比较下更易于做去重的操作</p>
<p><strong>思路</strong></p>
<p>a+b+c&#x3D;&#x3D;0</p>
<p><strong>首先，先对数组进行排序，这样能保证顺序是有序的方便做去重</strong></p>
<p>1.对数组排序</p>
<p>2.用一层for循环,i从0开始 来找到第一个元素nums[i] 如果nums[i]&gt;0 那么就可以return 因为a&gt;0 排序后就不会有a+b+c&#x3D;&#x3D;0</p>
<p>3.用left指针和right指针分别表示第二个元素和第三个元素，初始化left&#x3D;i+1,right&#x3D;nums.length-1;</p>
<p>4.考虑a元素去重，如果i&gt;0 &amp;&amp; nums[i]&#x3D;&#x3D;nums[i-1] 那么continue </p>
<p> <em>为什么不是nums[i]&#x3D;&#x3D;nums[i+1]</em></p>
<p><del>原因是这个nums[i]&#x3D;&#x3D;nums[i+1]判断的是结果集的不可重复，而元素如果为 -1 -1 2 第一个元素和第二个元素是可以相同的 相反，如果是判断和前一个元素相同因为b和c没变，a移动之后还是相同的元素，所以这个结果集不能算在内</del> </p>
<p>5.判断a+b+c?0   如果＞则移动right– 如果&lt;则移动left++如果为&#x3D; 则添加到result中</p>
<p>6.添加完之后移动指针，这里考虑b和c的去重 如果nums[left]&#x3D;&#x3D;nums[left+1] 持续left++ 如果nums[right]&#x3D;&#x3D;nums[right-1] 持续right–</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个结果集 用于返回结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//对nums进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果a大于0 那么结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果前一个元素和当前元素值相同那么这个结果集是相同的 continue</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当左指针小于右指针的时候循环</span></span><br><span class="line">            <span class="comment">//left==right 也即b==c的时候是指向同一个元素 所以不能进入循环</span></span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="comment">//sum为a+b+c 的值</span></span><br><span class="line">                <span class="type">int</span> sum=nums[i]+nums[left]+nums[right];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果三数之和大于0说明大了 right需要减减 移动右指针</span></span><br><span class="line">                <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//同理sum小了 移动左指针</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// sum==0</span></span><br><span class="line">                    result.add(Arrays.asList(nums[i],nums[left],nums[right]));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对b和c去重 保证left&lt;right </span></span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//移动left找下一个结果集</span></span><br><span class="line">                    left++;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>注意</strong></p>
<p>对b和c去重移动right和left指针的时候要对left&lt;right做判断 要持续让left&lt;right 如果不符合就要跳出循环</p>

        <h1 id="四数之和"   >
          <a href="#四数之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h1>
      <p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>

        <h2 id="18-四数之和"   >
          <a href="#18-四数之和" class="heading-link"><i class="fas fa-link"></i></a><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/" >Leetcode.18题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;16</p>

        <h4 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">int</span> sum=target-nums[i]-nums[j]-nums[left]-nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.add(Arrays.asList(</span><br><span class="line">                            nums[i],</span><br><span class="line">                            nums[j],</span><br><span class="line">                            nums[left],</span><br><span class="line">                            nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums &#x3D;[-2,-1,-1,1,1,2,2] target&#x3D;0  输出[-2,-1,1,2] 预期输出[[-2,-1,1,2],[-1,-1,1,1]]</p>

        <h4 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">int</span> sum=target-nums[i]-nums[j]-nums[left]-nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.add(Arrays.asList(</span><br><span class="line">                            nums[i],</span><br><span class="line">                            nums[j],</span><br><span class="line">                            nums[left],</span><br><span class="line">                            nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:[-1,-2,-5,-4,-3,3,3,5] target&#x3D;-11  输出[] 预期输出[[-5,-4,-3,1]]</p>

        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">int</span> sum=target-nums[i]-nums[j]-nums[left]-nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.add(Arrays.asList(</span><br><span class="line">                            nums[i],</span><br><span class="line">                            nums[j],</span><br><span class="line">                            nums[left],</span><br><span class="line">                            nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入nums &#x3D;[1000000000,1000000000,1000000000,1000000000] target &#x3D;-294967296 输出[[1000000000,1000000000,1000000000,1000000000]] 预期输出[]</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span> &amp;&amp; nums[i]&gt;=<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="type">int</span> sum=nums[i]+nums[j]+nums[left]+nums[right]&gt;Integer.MAX_VALUE? Integer.MAX_VALUE : nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.add(Arrays.asList(</span><br><span class="line">                            nums[i],</span><br><span class="line">                            nums[j],</span><br><span class="line">                            nums[left],</span><br><span class="line">                            nums[right]));</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题的逻辑和三数之和的逻辑是一样的，只不过三数之和的时候是确认一个下标i获得一个元素a</p>
<p>而这个是确认下标i和j确认两个元素a和b</p>
<p>然后去通过<strong>双指针</strong>获取c和d</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">/*剪枝 </span></span><br><span class="line"><span class="comment">            当target&lt;nums[i] 并且nums[i] &gt;0 则不满足要求 </span></span><br><span class="line"><span class="comment">            如果target&lt;0 并且nums[i]&lt;0 则还有可能是满足的结果集 </span></span><br><span class="line"><span class="comment">            例如 target=-5  结果集 -4 -2 0 1 </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[i]&amp;&amp; nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//去重a </span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="comment">//二级减枝 原因上同</span></span><br><span class="line">                <span class="keyword">if</span>(target&lt;nums[i]+nums[j]&amp;&amp; nums[i]+nums[j]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//去重b</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left=j+<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="comment">//获取四数之和 a+b+c+d</span></span><br><span class="line">                    <span class="type">int</span> sum=nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                        <span class="comment">//sum小了 所以左指针向右移</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        <span class="comment">//sum大了 所以右指针向左移</span></span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result.add(Arrays.asList(</span><br><span class="line">                            nums[i],</span><br><span class="line">                            nums[j],</span><br><span class="line">                            nums[left],</span><br><span class="line">                            nums[right]));</span><br><span class="line">						<span class="comment">//去重c和d</span></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]==nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//开始找下一个结果集</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>踩坑点</strong></p>
<p>① 在剪枝的时候可能认为nums[i]&gt;targer就break 实际上负数相加可能会更小 比如a&#x3D;-4 b&#x3D;-2 c&#x3D;0 d&#x3D;-1 target&#x3D;-5 仍然是满足条件的结果集</p>
<p>②去重的时候 当前索引要和前一位比较，如果<strong>和后一位比较就是结果集内不能有相同元素</strong> </p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>哈希表一节也算是暂时告一段落，我们从哈希表这一章里面学到了 如果<strong>判断某个元素是否出现过可以用哈希表做映射</strong>，如果去重的操作不好执行可以用双指针来进行去重</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/09/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B2.%E9%93%BE%E8%A1%A8%E7%AF%87%5D/">死之前要做完的算法手册-[2.链表篇]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-09</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">7.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">57分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>链表基础</strong></p>
<p>1、单向链表</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230810162248140.png"  alt="单向链表模型">
      </p>
<p>2.双向链表</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230813075644341.png"  alt="双向链表">
      </p>
<p>3.环形链表</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230813075915350.png"  alt="环形链表">
      </p>

        <h1 id="移除链表元素"   >
          <a href="#移除链表元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#移除链表元素" class="headerlink" title="移除链表元素"></a>移除链表元素</h1>
      <p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>

        <h2 id="203-移除链表元素"   >
          <a href="#203-移除链表元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/" >Leetcode.203题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;10</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">       ListNode tempNode=head;</span><br><span class="line">       <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">               <span class="keyword">if</span>(head.next!=<span class="literal">null</span>)</span><br><span class="line">               head.next=head.next.next;</span><br><span class="line">               head=head.next;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">           <span class="keyword">if</span>(node.val==val)&#123;</span><br><span class="line">               head.next=node.next;</span><br><span class="line">           &#125;</span><br><span class="line">           head=node;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> tempNode;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE: 输入[7,7,7,7] val&#x3D;7 返回[7,7] 预期返回[]</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    ListNode tempNode=head;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tempNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempNode.val==val)&#123;</span><br><span class="line">                tempNode=tempNode.next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.val==val)&#123;</span><br><span class="line">            head.next=node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-1"   >
          <a href="#提交错误-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-1" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入[1,2,2,1] val&#x3D;2 返回[1,2,1] 预期返回[]</p>

        <h5 id="原因"   >
          <a href="#原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因" class="headerlink" title="原因"></a>原因</h5>
      <p>我只判断了一次当头结点为val的时候将头部指针指向后面一个，但是后面移动的时候当连续得出现要删除的元素时候没办法处理了</p>
<p>也即我没判断当前结点为val的时候的删除元素操作</p>

        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>虚拟头结点法</strong></p>
<p>定义一个虚拟头结点 将原本的头结点插入到虚拟头结点之后 这样就不用判断是否为头结点元素的删除</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个虚拟的头结点</span></span><br><span class="line">    	ListNode VirHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    	<span class="comment">//将虚拟头指向原先头结点</span></span><br><span class="line">        VirHead.next=head;</span><br><span class="line">    	<span class="comment">//获取一个当前结点指针 循环用当前指针操作</span></span><br><span class="line">        ListNode curNode=VirHead;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//循环条件是curNode.next!=null 意图是操作当前结点的下一个结点，而不是操作当前结点 因为删除和添加结点都需要前后结点</span></span><br><span class="line">        <span class="keyword">while</span>(curNode.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果下一个结点元素值为目标值</span></span><br><span class="line">            <span class="keyword">if</span>(curNode.next.val==val)&#123;</span><br><span class="line">                <span class="comment">//将当前结点指向下一个结点的下一个结点 然后再循环判断移动之后的下一个结点是不是要删除的结点</span></span><br><span class="line">                curNode.next=curNode.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//否则下一个结点不是要移除的元素，将当前结点移动到下一结点</span></span><br><span class="line">                curNode=curNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> VirHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>当前头结点操作</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    	<span class="comment">//判断头结点是不是要删除的元素   </span></span><br><span class="line">       <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(head.val==val)&#123;</span><br><span class="line">               <span class="comment">//是要删除的元素则将head往后移动一位</span></span><br><span class="line">               head=head.next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//否则说明头结点不是要删除的结点 跳出循环</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="comment">//获取一个node指针来指向头结点的位置  这个node是用来循环操作的</span></span><br><span class="line">       ListNode node=head;</span><br><span class="line">       <span class="comment">//运行到这里头结点已经不可能是目标值了</span></span><br><span class="line">	</span><br><span class="line">    	<span class="comment">//判断当前位置不为空并且下一个结点不为空</span></span><br><span class="line">       <span class="keyword">while</span>(node!=<span class="literal">null</span>&amp;&amp;node.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(node.next.val==val)&#123;</span><br><span class="line">               node.next=node.next.next;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               node=node.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="comment">//返回头结点</span></span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <p>通过代码随想录的视频学习了这道题的做法，我发现我自己在第一次做的时候无论是移动头结点的位置和非头结点的位置 我都是将当前结点指向要删除的元素的下一个结点 并且移动指针到下一个结点，而忽略了对连续元素的判断</p>
<p>我们移除结点需要注意的点：</p>
<p>① 我们要删除结点需要获取<strong>目标上一个节点、目标结点、下一个结点</strong>，如果目标是头结点则将头结点指向头结点下一个结点即可</p>
<p>②我们要删除非头结点，正因为删除结点需要获取目标上一个节点、目标结点下一个结点所以我们直接从<strong>当前结点</strong>来判断下一个结点是不是要删除的元素</p>
<p>②移动当前指针的条件：下一个结点不是要删除的元素，反之如果是则本次循环<strong>仅将当前结点指向目标结点的下一个结点，而不移动当前结点指针</strong></p>
<p>我推荐是用<strong>虚拟头结点</strong>来做这道题，这样我们就少了对是否头结点的判断，我们只要做好删除非头结点的逻辑处理，然后返回的结点为虚拟头结点的下一个结点即可</p>

        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p><strong>虚拟头结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230810160723221.png"  alt="虚拟头结点(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230810161243007.png"  alt="虚拟头结点(2)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230810161427054.png"  alt="虚拟头结点(3)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230810161712465.png"  alt="虚拟头结点(4)">
      </p>

        <h1 id="设计链表"   >
          <a href="#设计链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h1>
      <p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>

        <h2 id="707-设计链表"   >
          <a href="#707-设计链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#707-设计链表" class="headerlink" title="707.设计链表"></a>707.设计链表</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/" >Leetcode.707题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;10</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来记录链表索引下标</span></span><br><span class="line">    <span class="type">int</span> count=-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    MyLinkedList next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//空参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到链表头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        MyLinkedList node= <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        node.val=val;</span><br><span class="line">        node.next=<span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">this</span>.next=node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        MyLinkedList node=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        node.val=val;</span><br><span class="line">        node.next=<span class="literal">null</span>;</span><br><span class="line">        cur.next=node;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==count+<span class="number">1</span>)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        MyLinkedList node=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line">        node.val=val;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index-<span class="number">1</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到前一个元素</span></span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        cur.next=node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        MyLinkedList node=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index-<span class="number">1</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到下标为index的前一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next=cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-2"   >
          <a href="#提交错误-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-2" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>​	CASE： 超出时间限制</p>

        <h5 id="原因-1"   >
          <a href="#原因-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5>
      <p>我添加头结点的时候将新结点指向this。this的next指向了新结点 这就造成了一个双向的指向效果达成死锁</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来记录链表索引下标</span></span><br><span class="line">    <span class="type">int</span> count=-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    MyLinkedList next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//空参构造</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;index)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加到链表头部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        MyLinkedList node= <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        node.val=val;</span><br><span class="line">        node.next=<span class="built_in">this</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        MyLinkedList node=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        node.val=val;</span><br><span class="line">        node.next=<span class="literal">null</span>;</span><br><span class="line">        cur.next=node;</span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==count+<span class="number">1</span>)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        MyLinkedList node=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line">        node.val=val;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index-<span class="number">1</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到前一个元素</span></span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        cur.next=node;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;count)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        MyLinkedList node=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        MyLinkedList cur=<span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">        cur=<span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;index-<span class="number">1</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到下标为index的前一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next=cur.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next=<span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-3"   >
          <a href="#提交错误-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-3" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:Cannot read field “next” because “<local4>.next” is null  at line 82, MyLinkedList.deleteAtIndex</p>
<p>输入[“MyLinkedList”,”addAtHead”,”addAtHead”,”addAtHead”,”addAtIndex”,”deleteAtIndex”,”addAtHead”,”addAtTail”,”get”,”addAtHead”,”addAtIndex”,”addAtHead”]</p>
<p>[[],[7],[2],[1],[3,0],[2],[6],[4],[4],[4],[5,0],[6]]</p>

        <h5 id="原因-2"   >
          <a href="#原因-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5>
      <p>添加和删除索引下标为index结点的时候遍历忘了加i++导致死循环最后挑不出来，而cur&#x3D;&#x3D;null就正好报错</p>
<p>这道题花了好久的时间才做出来</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    LinkNode next;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    LinkNode head=<span class="keyword">new</span> <span class="title class_">LinkNode</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">       size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        LinkNode node=<span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line">        </span><br><span class="line">        node.next=head.next;</span><br><span class="line">        head.next=node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        LinkNode cur=<span class="keyword">new</span> <span class="title class_">LinkNode</span>();</span><br><span class="line">        LinkNode node=<span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line"></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到尾结点</span></span><br><span class="line">        cur.next=node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==size)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode cur=<span class="keyword">new</span> <span class="title class_">LinkNode</span>();</span><br><span class="line">        LinkNode node=<span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line"></span><br><span class="line">        cur=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到index前一个元素</span></span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        cur.next=node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode cur=<span class="keyword">new</span> <span class="title class_">LinkNode</span>();</span><br><span class="line"></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">            head=head.next;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next=cur.next.next;</span><br><span class="line">        </span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="comment">//val用于存放数据</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">//next指向下一个结点</span></span><br><span class="line">    LinkNode next;</span><br><span class="line">    <span class="comment">//空参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//用于表示链表长度</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//虚拟头结点head，不存放数据</span></span><br><span class="line">    LinkNode head=<span class="keyword">new</span> <span class="title class_">LinkNode</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//初始化长度为0</span></span><br><span class="line">       size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//检验index的合法性</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//定义一个当前结点指针用于遍历</span></span><br><span class="line">        LinkNode cur=head;</span><br><span class="line">        <span class="comment">//遍历找到index前一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回数据  cur现在指向index-1的位置</span></span><br><span class="line">        <span class="keyword">return</span> cur.next.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        LinkNode node=<span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line">        <span class="comment">//将虚拟头结点后的下一个结点给node</span></span><br><span class="line">        node.next=head.next;</span><br><span class="line">        <span class="comment">//将虚拟头结点指向node</span></span><br><span class="line">        head.next=node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cur用于遍历</span></span><br><span class="line">        LinkNode cur=head;</span><br><span class="line">        LinkNode node=<span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当cur.next==null 也即cur是最后一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到尾结点</span></span><br><span class="line">        cur.next=node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//如果index&lt;=0 说明插入头结点</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            addAtHead(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果index==size说明插入尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(index==size)&#123;</span><br><span class="line">            addAtTail(val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//index&gt;size不合法</span></span><br><span class="line">        <span class="keyword">if</span>(index&gt;size)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode cur=head;</span><br><span class="line">        LinkNode node=<span class="keyword">new</span> <span class="title class_">LinkNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历链表，找到目标结点的前一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到index前一个元素</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将当前结点的下一个结点给node  当前结点指向node</span></span><br><span class="line">        node.next=cur.next;</span><br><span class="line">        cur.next=node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkNode cur=head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到要删除的结点的前一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将目标结点的下一个结点由cur.next保存</span></span><br><span class="line">        cur.next=cur.next.next;</span><br><span class="line">        </span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3>
      <p>这道题做了我很久，一来是我通过看视频然后知道用虚拟头结点的做法，我第一开始做的时候不知道哪里是当前位置，哪里是头结点</p>
<p>二来是一个问题卡了我很久，就是一直有一个val&#x3D;0的数据存在，后面我才知道我把head当成一个结点存放进链表中了，而这个<strong>head应该就是虚拟头结点</strong></p>
<p>三是小问题的卡，有的地方size++没写有的地方size–没写导致一直编译报错</p>

        <h3 id="踩坑点"   >
          <a href="#踩坑点" class="heading-link"><i class="fas fa-link"></i></a><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h3>
      <p>这里定义的head就是虚拟头结点，不用自己在创建一个虚拟头结点指向head</p>

        <h1 id="反转链表"   >
          <a href="#反转链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1>
      <p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>

        <h2 id="26-反转链表"   >
          <a href="#26-反转链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#26-反转链表" class="headerlink" title="26.反转链表"></a>26.反转链表</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/" >LeetCode.26题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;11</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dumpHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dumpHead.next=head;</span><br><span class="line"></span><br><span class="line">        ListNode cur=dumpHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录有多少个结点</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将cur重置到头结点的位置</span></span><br><span class="line">        cur=dumpHead.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            cur.val=list.get(i);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-4"   >
          <a href="#提交错误-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-4" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入[1,2,3,4,5] 输出[0,1,2,3,4] 预期输出[5,4,3,2,1]</p>

        <h5 id="原因-3"   >
          <a href="#原因-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-3" class="headerlink" title="原因"></a>原因</h5>
      <p>注意到这里输出了一个0 然后顺序是正的 接着我就知道我哪里出现了问题</p>
<p>1.我这个cur起始位置是虚拟头结点的位置，放入list中数据应该是从虚拟头结点之后的头结点开始</p>
<p>2.第二次反转数据的时候遍历应该是倒着遍历的，我正着遍历就没有意义了，我目的是将结点的数据调换而不是整个结点的指向反转</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dumpHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dumpHead.next=head;</span><br><span class="line"></span><br><span class="line">        ListNode cur=dumpHead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录有多少个结点</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            list.add(cur.next.val);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            count++;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将cur重置到头结点的位置</span></span><br><span class="line">        cur=dumpHead.next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=list.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            cur.val=list.get(i);</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dumpHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>双指针法</strong></p>
<p>定义一个指针pre用来代表cur的前一个结点,一个指针cur表示当前操作的结点，当前结点的指向应该指向前一个结点(cur.next&#x3D;pre)</p>
<p>然后循环直到cur&#x3D;&#x3D;null 也即pre是最后一个结点，此时将pre当成新的头结点返回</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义一个指针操作当前结点</span></span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="comment">//定义一个指针指向cur前一个   定义为NULL是因为头结点反转后变成尾结点所以指向null</span></span><br><span class="line">        ListNode pre=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环条件结束 cur==null 也即pre指向原来尾结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//定义一个指针用于记录当前结点的下一个结点，为了防止丢失结点</span></span><br><span class="line">            ListNode temp=cur.next;</span><br><span class="line">            <span class="comment">//将当前结点指向前一个结点</span></span><br><span class="line">            cur.next=pre;</span><br><span class="line">            <span class="comment">//前一个结点向后移动</span></span><br><span class="line">            pre=cur;</span><br><span class="line">            <span class="comment">//当前结点向后移动</span></span><br><span class="line">            cur=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回pre也即尾结点作为新的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>指向关系</strong></p>
<p>未反转前</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811205325163.png"  alt="未反转前">
      </p>
<p>反转过程</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811205522760.png"  alt="反转过程">
      </p>
<p>反转之后</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811205801449.png"  alt="反转之后">
      </p>
<p><strong>递归法</strong></p>
<p>我们用双指针的思路改造递归就行</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传入参数 将cur初始化为head pre初始化为null</span></span><br><span class="line">        <span class="keyword">return</span> reverse(head,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode cur,ListNode pre)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归结束条件 如果cur==null说明pre为尾结点</span></span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="literal">null</span>) </span><br><span class="line">            <span class="comment">//返回pre 作为新的头结点</span></span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取cur的下一个结点，防止丢失结点</span></span><br><span class="line">        ListNode temp=cur.next;</span><br><span class="line">        <span class="comment">//将cur的next指向前一个结点</span></span><br><span class="line">        cur.next=pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将递归，将下一个temp结点作为cur，将当前cur作为pre，当递归结束返回一个pre也即新的头结点</span></span><br><span class="line">        ListNode newHead=reverse(temp,cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回新的头结点</span></span><br><span class="line">        <span class="keyword">return</span> newHead; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="两两交换链表中的节点"   >
          <a href="#两两交换链表中的节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1>
      <p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>实例 :</p>
<p>1-&gt;2-&gt;3&gt;4</p>
<p>交换后</p>
<p>2-&gt;1&gt;4&gt;3    </p>
<p>必须是交换结点，而不能仅仅交换数据</p>

        <h2 id="24-两两交换链表中的节点"   >
          <a href="#24-两两交换链表中的节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/" >Leecode.24题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;11</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ListNode pre=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        pre.next=cur;</span><br><span class="line"></span><br><span class="line">        ListNode next=<span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            next=cur.next;        </span><br><span class="line">            <span class="keyword">if</span>(next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//存在下一个结点</span></span><br><span class="line">                <span class="comment">//存放下下结点</span></span><br><span class="line">                ListNode temp=next.next;  </span><br><span class="line">                next.next=cur;</span><br><span class="line">                cur.next=temp;</span><br><span class="line">                pre.next=next;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cur==head)&#123;</span><br><span class="line">                 head=next;   </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                pre=cur;</span><br><span class="line">                cur=temp;</span><br><span class="line">             </span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//cur为尾结点</span></span><br><span class="line">                <span class="comment">//不做处理</span></span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>直接一次性提交成功了，虽然提交测试代码的时候有一点点犯错，一是忘记移动头结点的指针，然后我对cur&#x3D;&#x3D;head判断了，如果cur是头结点那么头结点应该指向下一个结点，然后第二个是指针移动的时候 目标是cur&#x3D;cur.next.next;  pre&#x3D;cur.next; 然后我先写移动cur指针后移动pre指针造成了一个循环的错误</p>

        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>直接操控原链表</strong></p>
<p>我这里保留了我第一次做的方法 利用了三个指针 pre,cur,next 分别指向结点的前一位，当前结点，下一个结点</p>
<p>①将cur指向当前头结点，pre.next&#x3D;cur，将pre操作到cur前一个结点，next&#x3D;null</p>
<p>②当cur不为空的时候进入循环判断，获取next&#x3D;cur.next，如果next为空则说明当前结点是尾结点，不为空则说明后面有结点</p>
<p>③cur.next有结点那么就应该和当前结点做一个交换 ，获取temp指向next.next</p>
<p>④将next.next&#x3D;cur,cur.next&#x3D;temp,pre.next&#x3D;next; 移动引用前一个结点指向后一个结点，后一个结点指向当前结点，当前结点指向后面第二个结点</p>
<p>⑤对cur此时的结点位置做一个判断，如果此时是一个头结点，那么将头结点head指向交换之后的next结点</p>
<p>⑥将pre移动到cur即反转之后的位置，将cur移动到temp 即后面第二个结点</p>
<p>⑦返回head头结点</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//定义前一个结点指针</span></span><br><span class="line">        ListNode pre=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    	<span class="comment">//定义当前结点指针</span></span><br><span class="line">        ListNode cur=head;</span><br><span class="line">    	<span class="comment">//将前一个结点指向当前结点</span></span><br><span class="line">        pre.next=cur;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//定义后一个结点指针</span></span><br><span class="line">        ListNode next=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//如果当前结点不为空则进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//获取下一个结点</span></span><br><span class="line">            next=cur.next;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//如果下一个结点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(next!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//存在下一个结点</span></span><br><span class="line">                <span class="comment">//存放下下结点 temp</span></span><br><span class="line">                ListNode temp=next.next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将next指向cur ,cur指向temp , pre指向next</span></span><br><span class="line">                next.next=cur;</span><br><span class="line">                cur.next=temp;</span><br><span class="line">                pre.next=next;</span><br><span class="line">                <span class="comment">//如果cur是头结点 那么将头结点指向next结点</span></span><br><span class="line">                <span class="keyword">if</span>(cur==head)&#123;</span><br><span class="line">                 head=next;   </span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//反转完成移动指针 将pre指向cur当前位置，cur指向temp位置</span></span><br><span class="line">                pre=cur;</span><br><span class="line">                cur=temp;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//cur为尾结点</span></span><br><span class="line">                <span class="comment">//不做处理</span></span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>虚拟头结点法</strong></p>
<p>虚拟头结点法主要是cur来对后面两个结点进行一个判断，他是交换后两个结点，如果后面结点个数小于两个就不进行交换，返回只需要返回虚拟头结点的下一个结点</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    	<span class="comment">//虚拟头结点    </span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dumpHead</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dumpHead.next=head;</span><br><span class="line">    	<span class="comment">//当前指针</span></span><br><span class="line">        ListNode cur=dumpHead;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	我们假设虚拟头结点是0  原链表是1 2 3 4</span></span><br><span class="line"><span class="comment">    	那么 可以看成是cur和dumphead指向0  cur.next指向1 ，即下面这种关系</span></span><br><span class="line"><span class="comment">    		dumphead</span></span><br><span class="line"><span class="comment">    			0		1		2		3		4</span></span><br><span class="line"><span class="comment">    		cur			head</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//当下一个结点和下第二个结点不为空的时候进行交换 即后两个结点不为空交换后两个结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>&amp;&amp; cur.next.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//记录后面两个结点指针</span></span><br><span class="line">            ListNode node=cur.next;</span><br><span class="line">            ListNode nodeNext=cur.next.next;</span><br><span class="line">            <span class="comment">//记录第三个结点指针</span></span><br><span class="line">            ListNode third=cur.next.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换过程</span></span><br><span class="line">            cur.next=cur.next.next;</span><br><span class="line">            nodeNext.next=node;</span><br><span class="line">            node.next=third;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	这个交换过程可以看成是 </span></span><br><span class="line"><span class="comment">            						（1）将0指向2</span></span><br><span class="line"><span class="comment">            						（2）将2指向1</span></span><br><span class="line"><span class="comment">            						（3）将1指向3</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//移动指针 </span></span><br><span class="line">            cur=cur.next.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	例如</span></span><br><span class="line"><span class="comment">            	交换1和2的时候 cur是在0的位置，那么要对3,4判断的时候cur应该在2的位置</span></span><br><span class="line"><span class="comment">            	无论交换之后的变化是怎么样只要cur往后移动两格就行</span></span><br><span class="line"><span class="comment">            	..</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回虚拟头结点的下一个结点</span></span><br><span class="line">        <span class="keyword">return</span> dumpHead.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="删除链表的倒数第N个节点"   >
          <a href="#删除链表的倒数第N个节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1>
      <p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>进阶：你能尝试使用一趟扫描实现吗？</p>

        <h2 id="19-删除链表的倒数第N个结点"   >
          <a href="#19-删除链表的倒数第N个结点" class="heading-link"><i class="fas fa-link"></i></a><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19.删除链表的倒数第N个结点"></a>19.删除链表的倒数第N个结点</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" >LeetCode.19题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;12</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    	<span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode dumpHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dumpHead.next=head;</span><br><span class="line">    	<span class="comment">//当前结点指针</span></span><br><span class="line">        ListNode cur=dumpHead;</span><br><span class="line">        <span class="comment">//用于统计链表长度</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//当cur不是尾结点 count++ 统计链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下标</span></span><br><span class="line">        <span class="type">int</span> index=count-n;</span><br><span class="line">    	<span class="comment">//将cur指向虚拟头结点</span></span><br><span class="line">        cur=dumpHead;</span><br><span class="line">        <span class="keyword">while</span>(index&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            index--;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要删除的目标元素的前一个元素</span></span><br><span class="line">        cur.next=cur.next.next;</span><br><span class="line">        <span class="keyword">return</span> dumpHead.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>我这里是用了两层循环 第一层来获取整个链表长度 然后来判断要删除的元素的索引值，找到目标结点前一个结点，将前一个结点指向目标结点的下一个结点</p>

        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>双指针+虚拟头结点</strong></p>
<p>这道题的关键在于怎么找到倒数第n个结点</p>
<p>我们可以先将快指针走n个位置 然后再一起移动快慢指针，那么快慢指针之间差距就为n，当快指针指向null的时候 那么慢指针就是指向倒数第n个结点</p>
<p>又因为 删除第n个结点需要知道倒数第n+1个结点，所以快指针要走n+1步</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//快指针、虚拟头结点、慢指针</span></span><br><span class="line">        ListNode dumpHead=<span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        dumpHead.next=head;</span><br><span class="line">        ListNode fast=dumpHead;</span><br><span class="line">        ListNode slow=dumpHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何找到第倒数n个结点呢?</span></span><br><span class="line">        <span class="comment">//先将fast移动n步 之后再一起移动fast和slow指针 </span></span><br><span class="line">        <span class="comment">//那么当fast==null的时候 slow就是倒数第n个结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//又因为要移除第n个结点，所以我们要将slow停留在倒数第n个结点前一个 也即倒数n+1个</span></span><br><span class="line">        <span class="comment">//那么fast就应该先移动n+1步</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">//先++一次 让快指针移动n+1步 因为怕移动n次之后fast==null再fast=fast.next造成空指针异常</span></span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">while</span>(n--&gt;<span class="number">0</span>&amp;&amp;fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到倒数第n+1个结点 删除倒数第n个结点</span></span><br><span class="line">        slow.next=slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dumpHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h1 id="链表相交"   >
          <a href="#链表相交" class="heading-link"><i class="fas fa-link"></i></a><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h1>
      <p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>

        <h2 id="面试题-02-07-链表相交"   >
          <a href="#面试题-02-07-链表相交" class="heading-link"><i class="fas fa-link"></i></a><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07.链表相交"></a>面试题 02.07.链表相交</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" >LeetCode.面试题02.07题目(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 也同样是第160题.相交链表  <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" >LeetCode.160题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>  </p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;12</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="comment">//最老套的一个结点一个结点判断</span></span><br><span class="line">        ListNode curA=headA;</span><br><span class="line">        ListNode curB=headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curB=headB;</span><br><span class="line">            <span class="keyword">while</span>(curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                    <span class="keyword">return</span> curB;</span><br><span class="line">                &#125;</span><br><span class="line">                curB=curB.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>双循环的代码可以说是获取所有结点的笛卡尔积，一个一个结点进行判断，如果相同则返回，双循环结束说明没有交点返回null</p>
<p>双循环太糙了，看看能不能自己改进改进</p>

        <h4 id="改进之后代码"   >
          <a href="#改进之后代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#改进之后代码" class="headerlink" title="改进之后代码"></a>改进之后代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义curA用于遍历A链表 curB用于遍历B链表</span></span><br><span class="line">        ListNode curA=headA;</span><br><span class="line">        ListNode curB=headB;</span><br><span class="line">    	<span class="comment">//countA记录A链表个数 countB记录链表B个数</span></span><br><span class="line">        <span class="type">int</span> countA=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> countB=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//遍历A链表 统计个数</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">            countA++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//遍历完将指针指回头结点</span></span><br><span class="line">        curA=headA;</span><br><span class="line">    	<span class="comment">//遍历B链表 统计个数</span></span><br><span class="line">        <span class="keyword">while</span>(curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">            countB++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//遍历完将指针指回头结点</span></span><br><span class="line">        curB=headB;</span><br><span class="line">    	<span class="comment">//获取A链表和B链表的长度差距   </span></span><br><span class="line">        <span class="type">int</span> n=countA-countB;</span><br><span class="line">    	<span class="comment">//如果n&gt;0 说明A链表更长</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//将curA移动n步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                curA=curA.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//b链表更长 将curB移动n步</span></span><br><span class="line">            n=-<span class="number">1</span>*n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                curB=curB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//遍历从curA和curB开始的链表</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span>&amp;&amp;curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果A结点等于B结点说明找到第一个交点 返回即可</span></span><br><span class="line">            <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//A和B往后移动</span></span><br><span class="line">            curA=curA.next;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p><strong>思路</strong></p>
<p>链表A和链表B如果有相交的部分的话，那么相交之后的结点应该都是相同的</p>
<p>那么我先获取两个链表的长度，如果极限状态就是一个链表都是另外一个链表的部分，那么相交的第一个结点就是子链表的第一个头结点</p>
<p>如果长度不相同，那么更长链表超出的部分一定不是相交的部分，于是移动n步使得链表A和链表B要遍历的长度相同</p>

        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong></p>
<p>链表A和链表B如果有相交的部分的话，那么相交之后的结点应该都是相同的</p>
<p>那么我先获取两个链表的长度，如果极限状态就是一个链表都是另外一个链表的部分，那么相交的第一个结点就是子链表的第一个头结点。</p>
<p>如果长度不相同，那么更长链表超出的部分一定不是相交的部分，于是移动n步使得<strong>链表A和链表B要遍历用于判断的长度相同</strong>，将其<strong>首末对其</strong></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义curA用于遍历A链表 curB用于遍历B链表</span></span><br><span class="line">        ListNode curA=headA;</span><br><span class="line">        ListNode curB=headB;</span><br><span class="line">    	<span class="comment">//countA记录A链表个数 countB记录链表B个数</span></span><br><span class="line">        <span class="type">int</span> countA=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> countB=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//遍历A链表 统计个数</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curA=curA.next;</span><br><span class="line">            countA++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//遍历完将指针指回头结点</span></span><br><span class="line">        curA=headA;</span><br><span class="line">    	<span class="comment">//遍历B链表 统计个数</span></span><br><span class="line">        <span class="keyword">while</span>(curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">            countB++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//遍历完将指针指回头结点</span></span><br><span class="line">        curB=headB;</span><br><span class="line">    	<span class="comment">//获取A链表和B链表的长度差距   </span></span><br><span class="line">        <span class="type">int</span> n=countA-countB;</span><br><span class="line">    	<span class="comment">//如果n&gt;0 说明A链表更长</span></span><br><span class="line">        <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//将curA移动n步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                curA=curA.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//b链表更长 将curB移动n步</span></span><br><span class="line">            n=-<span class="number">1</span>*n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                curB=curB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//遍历从curA和curB开始的链表</span></span><br><span class="line">        <span class="keyword">while</span>(curA!=<span class="literal">null</span>&amp;&amp;curB!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果A结点等于B结点说明找到第一个交点 返回即可</span></span><br><span class="line">            <span class="keyword">if</span>(curA==curB)&#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//A和B往后移动</span></span><br><span class="line">            curA=curA.next;</span><br><span class="line">            curB=curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="环形链表II"   >
          <a href="#环形链表II" class="heading-link"><i class="fas fa-link"></i></a><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1>
      <p>题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>

        <h2 id="142-环形链表II"   >
          <a href="#142-环形链表II" class="heading-link"><i class="fas fa-link"></i></a><a href="#142-环形链表II" class="headerlink" title="142.环形链表II"></a>142.环形链表II</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/" >LeetCode.142题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;13</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;ListNode,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(cur,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>我的做法是将链表中的结点存放到一个map中，因为map是不可重复的，所以我每个结点判断一下是否有这个SetEntry，如果有则说明当前结点就是第一个环节点</p>

        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>双指针法</strong></p>
<p>定义一个快指针一个慢指针，快指针每次移动两格，慢指针每次移动一格</p>
<ul>
<li><strong>判断链表是否有环</strong></li>
</ul>
<p>​	当快慢指针指向同一个结点就说明是有环</p>
<ul>
<li><strong>判断环结点的位置，也即环的入口</strong></li>
</ul>
<p>​	假设相遇的位置如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230813060827204.png"  alt="环形链表图(1)">
      </p>
<p>那么我们可以假设入口的距离为x，入口到相遇点的路径为y，相遇点过后再回到入口的距离为z</p>
<p>也即下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230813061538270.png"  alt="环形链表图(2)">
      </p>
<p>因为慢指针相遇的移动距离是x+y,快指针的移动距离是x+n(z+y)+y</p>
<p>又因为快指针每次是移动两格，慢指针是每次移动一格，那么只要同时出发<strong>快指针的距离一定是慢指针的两倍</strong></p>
<p>也即 x+n(z+y)+y&#x3D;2*(x+y)</p>
<p>因此我们可以获取到关于x的一个函数，毕竟入口是我们需要求得环的入口的距离  x&#x3D;n(z+y)-y 又因为n是快指针走的圈数，当相遇的时候快指针一定转过了一圈，那么<strong>n一定大于等于1</strong>，那这个函数可以变形 让出一圈的距离来判断x与正数之间的关系 x&#x3D;(n-1)(z+y)+z</p>
<p>如果只转一圈 那么就有<strong>x&#x3D;&#x3D;z</strong></p>
<p>无论最后快指针转了多少圈，那么当相遇点再移动到入口的距离z会等于head到入口的距离x</p>
<p><strong>x&#x3D;&#x3D;z</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230813062525148.png"  alt="环形链表(3)">
      </p>
<ul>
<li><p>求得x的值</p>
<p>将相遇点和头结点分别使用指针index1和index2，开始一格一格移动，当index1&#x3D;&#x3D;index2的时候说明找到了入口 返回index1即可</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义快指针和慢指针</span></span><br><span class="line">       ListNode fast=head;</span><br><span class="line">       ListNode slow=head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为fast每次移动两格 所以要判断后面两个结点是否为空</span></span><br><span class="line">       <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">           fast=fast.next.next;</span><br><span class="line">           <span class="comment">//慢指针移动一格</span></span><br><span class="line">           slow=slow.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果fast==slow说明相遇了</span></span><br><span class="line">           <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">               <span class="comment">//定义一个指针index1记录当前相遇结点</span></span><br><span class="line">               ListNode index1=fast;</span><br><span class="line">               <span class="comment">//定义一个指针index2从头结点出发</span></span><br><span class="line">               ListNode index2=head;</span><br><span class="line">               <span class="comment">//当index1==index2的时候说明找到入口</span></span><br><span class="line">               <span class="keyword">while</span>(index1!=index2)</span><br><span class="line">               &#123;</span><br><span class="line">                   index1=index1.next;</span><br><span class="line">                   index2=index2.next; </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//找到入口</span></span><br><span class="line">                   <span class="keyword">if</span>(index1==index2)&#123;</span><br><span class="line">                    <span class="keyword">return</span> index1;</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="comment">//没有环 所以循环能结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-2" class="headerlink" title="总结"></a>总结</h1>
      <p>这里链表篇也已经告一段落，下一章要进入哈希表的题型中，我们从链表中学到了<strong>虚拟头结点法、删除结点、反转链表、判断链表是否成环</strong></p>
<p>虚拟头结点是一个很好的方法将头结点当成普通的结点，这样就少了对头结点的判断和处理</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/04/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B1.%E6%95%B0%E7%BB%84%E7%AF%87%5D/">死之前要做完的算法手册-[1.数组篇]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">142分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>前言</strong></p>
<p>经过考虑之后决定按照代码随想录的训练路线来做一个算法的学习</p>
<p>然后下面是我做数组算法的时候踩的坑</p>
<p><strong>如果赶时间的话做法可以不用看，就主要看思路、总结、图解</strong></p>
<p><em>输是正常的，重要的是不要怕输</em></p>

        <h1 id="二分查找"   >
          <a href="#二分查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1>
      <p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p>
<p>题目是<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/" >LeetCode上704题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="704-二分查找"   >
          <a href="#704-二分查找" class="heading-link"><i class="fas fa-link"></i></a><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/" >LeetCode.704题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次单独做于23&#x2F;08&#x2F;04，说实话二分查找想起来很简单，但是一写就踩了不少坑</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length;</span><br><span class="line">        <span class="keyword">while</span>(low!=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE1:nums&#x3D;[-1,0,3,5,9,12],target&#x3D;9,输出-1,预计输出 4</p>
<p>CASE2:nums&#x3D;[-1,0,3,5,9,12],target&#x3D;2,输出-1,预计输出-1</p>
<p>这不是运行案例都没通过嘛?更别提提交测试了</p>

        <h5 id="原因"   >
          <a href="#原因" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因" class="headerlink" title="原因"></a>原因</h5>
      <p>下标我是从0开始，而上标是从数组的长度6开始，但是数组中存数的时候是0~5,所以这是第一个不对的地方，于是我进行了修正把上标的位置改成length-1</p>

        <h4 id="第二次源代码"   >
          <a href="#第二次源代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次源代码" class="headerlink" title="第二次源代码"></a>第二次源代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;   	</span><br><span class="line">		<span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low!=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-1"   >
          <a href="#提交错误-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-1" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:nums&#x3D;[5],target&#x3D;5,输出-1,预计输出0</p>

        <h5 id="原因-1"   >
          <a href="#原因-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-1" class="headerlink" title="原因"></a>原因</h5>
      <p>下标从0开始,上标也是0压根就没有进入循环判断，所以我又做了改正，将一个元素的数组进行了单独判断</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;   </span><br><span class="line">        <span class="comment">//如果nums只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target==nums[<span class="number">0</span>]? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low!=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>我当时觉得我简直就是天才，对数组长度为0的时候不会做判断，而数组只有一个元素的时候单独判断，返回执行时间还更快，但这又出了岔子</p>

        <h5 id="提交错误-2"   >
          <a href="#提交错误-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-2" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:nums&#x3D;[2,5],target&#x3D;5,输出-1,预计输出1</p>

        <h5 id="原因-2"   >
          <a href="#原因-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-2" class="headerlink" title="原因"></a>原因</h5>
      <p>不仅仅是nums[length-1]不能进行一个判断同时也是nums[0]没办法进行判断，也就是数组的边界都不能进行一个判断，问题出在了循环的时候当low&#x3D;&#x3D;high的时候就退出了循环 而边界的时候就没有判断到，所以我最后进行了改正</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果nums只有一个元素</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> target==nums[<span class="number">0</span>]? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid])&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target==nums[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>但是实际上有没有对一个元素数组的判断都能通过测试，问题就出在While循环中的判断条件，当low等于high的时候也应该进行一次判断，也就是Low&gt;high的时候结束循环</p>

        <h3 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h3>
      <p>看了视频学习之后才知道 <strong>二分法</strong>的两个重点，主要要取决于边界处理</p>
<p>主要有两个版本，1.是左闭右闭的区间</p>
<p>​							   2.是左闭右合的区间</p>
<p>为了防止搞混我主要学习的是左闭右闭的区间写法</p>

        <h4 id="while循环的条件判断"   >
          <a href="#while循环的条件判断" class="heading-link"><i class="fas fa-link"></i></a><a href="#while循环的条件判断" class="headerlink" title="while循环的条件判断"></a>while循环的条件判断</h4>
      <p>重点思想是low和high是不是一个合法的值在条件判断中，如果下标是1，上标是1，那么也应该做一个while循环判断</p>
<p>所以是while(low&lt;&#x3D;high)</p>

        <h4 id="low和high的赋值处理"   >
          <a href="#low和high的赋值处理" class="heading-link"><i class="fas fa-link"></i></a><a href="#low和high的赋值处理" class="headerlink" title="low和high的赋值处理"></a>low和high的赋值处理</h4>
      <p>上一次判断的时候nums[mid]&gt;target，所以明确的是mid这个索引值已经不等于我们的目标索引值</p>
<p>因此low&#x3D;mid+1，同理当nums[mid]&lt;target时high&#x3D;mid-1;</p>

        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230804122255989.png"  alt="二分法图解">
      </p>

        <h2 id="35-搜索插入位置"   >
          <a href="#35-搜索插入位置" class="heading-link"><i class="fas fa-link"></i></a><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/" >LeetCode.35题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;04，因为刚学完二分查找，所以找相似的题目巩固</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-3"   >
          <a href="#提交错误-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-3" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>Case1：nums[1,3,5,6] ,target&#x3D;5, 输出2 ，预期输出 2</p>
<p>Case2：nums[1,3,5,6] ,target&#x3D;2, 输出0，预期输出 1</p>
<p>Case3：nums[1,3,5,6] ,target&#x3D;7, 输出3 ，预期输出 2</p>

        <h5 id="原因-3"   >
          <a href="#原因-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-3" class="headerlink" title="原因"></a>原因</h5>
      <p>当元素中没有这个元素的时候，最后上标和下标会指向mid的位置，这个位置的索引值是有值的所以应该在当前索引+1就是要求到的索引值</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-4"   >
          <a href="#提交错误-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-4" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>Case1：nums[1,3,5,6] ,target&#x3D;0, 输出1 ，预期输出 0</p>

        <h5 id="原因-4"   >
          <a href="#原因-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-4" class="headerlink" title="原因"></a>原因</h5>
      <p>第一次错的改正思路不对，没有找到元素之后要插入元素的时候，最后low和high不会指向同一个索引值，一定是low＞high</p>
<p>要判断low和high与mid的关系 如果low&gt;mid，说明要插入的值比nums[mid]的值还要大，要插入在mid后面，反之如果high&lt;mid，说明当前值比插入的值要大，要插入在mid前面</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-5"   >
          <a href="#提交错误-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-5" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE1:nums[1,3,5,6], target&#x3D;0,输出-1,预期输出0</p>

        <h5 id="原因-5"   >
          <a href="#原因-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-5" class="headerlink" title="原因"></a>原因</h5>
      <p>在插入在当前mid索引值时多减了一位，如果这个数比mid值更小的话应该就是当前位置，而当前位置及以后的值应该往后移动</p>

        <h4 id="第四次代码-1"   >
          <a href="#第四次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-1" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 二分法</span></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low&gt;mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3>
      <p>先<strong>二分查找</strong>判断是否当前数组有这个值，如果有的话直接返回mid就是索引小标值</p>
<p>如果当前数组中没有这个值，就要判断插入在当前位置的前面还是后面</p>
<p>当low&gt;mid时就说明最后跳出循环前还进行了一次nums[mid]&lt;target判断 也就是说明mid索引的元素比插入元素更小，所以要插入在mid的后面</p>
<p>反之如果没有low&gt;mid说明当前值比mid值更小那么久应该插入当前元素位置，让当前元素及以后元素往后移</p>

        <h3 id="图解-1"   >
          <a href="#图解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3>
      
        <h4 id="找得到元素"   >
          <a href="#找得到元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#找得到元素" class="headerlink" title="找得到元素"></a>找得到元素</h4>
      <p>找得到元素就是普通的二分查找返回目标索引值，图解于704题图解所示</p>

        <h4 id="找不到元素，插入在前面"   >
          <a href="#找不到元素，插入在前面" class="heading-link"><i class="fas fa-link"></i></a><a href="#找不到元素，插入在前面" class="headerlink" title="找不到元素，插入在前面"></a>找不到元素，插入在前面</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230804151101834.png"  alt="插入在前面">
      </p>

        <h4 id="找不到元素，插入在后面"   >
          <a href="#找不到元素，插入在后面" class="heading-link"><i class="fas fa-link"></i></a><a href="#找不到元素，插入在后面" class="headerlink" title="找不到元素，插入在后面"></a>找不到元素，插入在后面</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230804150906559.png"  alt="插入在后面">
      </p>

        <h2 id="34-在排序数组中查找元素的第一个和最后一个位置"   >
          <a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="heading-link"><i class="fas fa-link"></i></a><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" >LeetCode.34题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>于23&#x2F;08&#x2F;04</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//二分法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;mid,mid&#125;;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//找到元素</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//结束循环判断mid值</span></span><br><span class="line">        <span class="keyword">if</span>(mid!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//则说明有元素</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&gt;=low;i--)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]==target)</span><br><span class="line">               &#123;</span><br><span class="line">                   low=i;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;=high;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                   high=i;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           arr[<span class="number">0</span>]=low;</span><br><span class="line">           arr[<span class="number">1</span>]=high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到元素</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-6"   >
          <a href="#提交错误-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-6" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>Case: nums[5,7,7,8,8,10],target&#x3D;8,输出[4，4]，预期输出[3,4]</p>

        <h5 id="原因-6"   >
          <a href="#原因-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-6" class="headerlink" title="原因"></a>原因</h5>
      <p>在结束循环判断的时候我将I设为Mid值，如果找到了元素那么nums[mid]&#x3D;&#x3D;target，那一定会执行将low和high的值改成mid，但是这是没有意义的，我的意图是找出mid前后两边和target相同的个数，因此我做了改正 将low判断的初始化值为mid-1即mid的前一位，high的判断index改为mid+1即mid的后一位</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">       <span class="comment">//二分法</span></span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> mid=-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[] arr=&#123;mid,mid&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">           mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">               high=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">           &#123;</span><br><span class="line">               low=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//找到元素</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> lowCount=<span class="number">0</span>; <span class="comment">//记录mid索引前面和target相同的个数</span></span><br><span class="line">       <span class="type">int</span> highCount=<span class="number">0</span>;<span class="comment">//记录mid索引后面和target相同的个数</span></span><br><span class="line">       <span class="comment">//结束循环判断mid值</span></span><br><span class="line">       <span class="keyword">if</span>(mid!=-<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="comment">//则说明有元素</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=mid-<span class="number">1</span>;i&gt;=low;i--)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]==target)</span><br><span class="line">               &#123;</span><br><span class="line">                   lowCount++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                   highCount++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           arr[<span class="number">0</span>]=mid-lowCount;</span><br><span class="line">           arr[<span class="number">1</span>]=mid+highCount;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//没有找到元素</span></span><br><span class="line">       <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-7"   >
          <a href="#提交错误-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-7" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>Case: nums[5,7,7,8,8,10],target&#x3D;6,输出[0，0]，预期输出[-1,-1]</p>

        <h5 id="原因-7"   >
          <a href="#原因-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-7" class="headerlink" title="原因"></a>原因</h5>
      <p>本次代码引入了计数器思想，就是在mid值前面的相同数量我计一个数，mid值后面相同的数量我也计一个数，最后给arr赋值的时候就只要加减Count就能代表有多少数据了</p>
<p>而问题又出现了，不存在的数据返回了[0,0]</p>
<p>通过Debug判断我才发现我有一个很严重的误区，就是无论有没有找到元素mid值一定不会等于-1，因为进入了第一个while循环判断中，如果没有找到值应该是一个mid值也会存在，所以第二个判断的起始条件有误导致后面赋值的时候mid值的错误导致整个问题出错</p>

        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//二分法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> midCount=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr=&#123;mid,mid&#125;;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)</span><br><span class="line">            &#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                midCount++;</span><br><span class="line">                <span class="comment">//找到元素</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> lowCount=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> highCount=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//结束循环判断mid值</span></span><br><span class="line">        <span class="keyword">if</span>(midCount!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//则说明有元素</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=mid-<span class="number">1</span>;i&gt;=low;i--)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]==target)</span><br><span class="line">               &#123;</span><br><span class="line">                   lowCount++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=mid+<span class="number">1</span>;i&lt;=high;i++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                   highCount++;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">        arr[<span class="number">0</span>]=mid-lowCount;</span><br><span class="line">        arr[<span class="number">1</span>]=mid+highCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到元素</span></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>我引入了一个MidCount计数器，如果找到元素时候MidCount++，这样判断找到元素的判断条件就能确定下来</p>

        <h3 id="总结和解题思路"   >
          <a href="#总结和解题思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结和解题思路" class="headerlink" title="总结和解题思路"></a>总结和解题思路</h3>
      <p>①定义MidCount&#x3D;0 用来记录是否找到元素，初始化一个数组arr[-1,-1]</p>
<p>②通过二分查找的方式，如果找到元素将MidCount++则跳出循环，同时low和high就是可以确认的目标值边界 也就是nums[low]和nums[high]之间能找到target目标值，mid索引位置也就是二分查找找到的目标值索引位置</p>
<p>③判断MidCount&#x3D;&#x3D;0  如果等于0说明二分查找没有找到元素直接返回数组arr ，如果不等于0则说明二分查找找到了元素</p>
<p>④MidCount1&#x3D;0，即找到了元素，定义两个计数器LowCount和HighCount用来记录Mid索引前后分别相同的元素个数</p>
<p>⑤从mid索引开始向前遍历，如果遍历没有找到相同元素则跳出遍历，如果找到了元素则LowCount++继续遍历</p>
<p>⑥从mid索引开始向后遍历，如果遍历没有找到相同元素则跳出遍历，如果找到了元素则HighCount++继续遍历</p>
<p>⑦mid-LowCount表示第一个target出现的索引值 赋值给arr[0]</p>
<p>⑧mid+highCount表示最后一个target出现的索引值 赋值给arr[1]</p>
<p>⑨返回arr</p>

        <h2 id="69-x的平方根"   >
          <a href="#69-x的平方根" class="heading-link"><i class="fas fa-link"></i></a><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sqrtx/" >LeetCode.69题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;05</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i*i&lt;=x;i++)&#123;</span><br><span class="line">           <span class="keyword">return</span> i;</span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-8"   >
          <a href="#提交错误-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-8" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入x&#x3D;4，输出0，预期2</p>

        <h5 id="原因-8"   >
          <a href="#原因-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-8" class="headerlink" title="原因"></a>原因</h5>
      <p>可能思路有点搞，一进来循环就返回i了，我的想法是找到i的平方大于x的时候就直接返回i,我觉得这下就是直接的整数</p>
<p>然而我改成int i放在循环外面 循环做一个空语句然后 返回i 依然是出错了， 当输入X为8的时候，输出3，预期2</p>
<p>我就大概知道我的思路出现问题了</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i*i&lt;x;i++)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出循环了判断一下i²和x的大小</span></span><br><span class="line">        <span class="keyword">if</span>(i*i&gt;x)&#123;</span><br><span class="line">            <span class="comment">//说明数在 i-1的²和i的²之间</span></span><br><span class="line">            <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-9"   >
          <a href="#提交错误-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-9" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>最后输入的值是2147483647，超出时间限度</p>

        <h5 id="原因-9"   >
          <a href="#原因-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-9" class="headerlink" title="原因"></a>原因</h5>
      <p>说明时间复杂度高了，具体应该是for循环的时候判断太多次了？又或者是死循环了，重新审一下题 x最大为2的32次方-1 那么判断循环跳出的时候i*i的数值已经超过了整数上限</p>

        <h4 id="第三次代码-3"   >
          <a href="#第三次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-3" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>((i*i&gt;Integer.MAX_VALUE?Integer.MAX_VALUE : i * i)&gt; x)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="comment">//出循环了判断一下i²和x的大小</span></span><br><span class="line">       <span class="keyword">if</span>(i*i&gt;x)&#123;</span><br><span class="line">           <span class="comment">//说明数在 i-1的²和i的²之间</span></span><br><span class="line">           <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-10"   >
          <a href="#提交错误-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-10" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>输入2147395600，输出289398，预期输出46340</p>

        <h5 id="原因-10"   >
          <a href="#原因-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-10" class="headerlink" title="原因"></a>原因</h5>
      <p>46340的平方为2147395600,46341的平方为2147488281，而2的32次方-1为2147483647 即 46340²&lt;2147483647&lt;46341²</p>
<p>也就是这个求平方根最大能输出的值就应该在46340</p>
<p>我在上面改正的代码的时候做了一个判断 当i×i的数值大于整数的上限的时候设置为整数上限 反之为i×i,应该就是这个地方出了问题</p>
<p>经过debug的时候就知道了 当相等的时候没有进行跳出循环 因为这算是找到了数据但是我依然让他进行了下一次判断 下一次判断的时候会因为超出上限造成数据错误  </p>

        <h4 id="第四次代码-2"   >
          <a href="#第四次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-2" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">46340</span>)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>((i*i&gt;Integer.MAX_VALUE?Integer.MAX_VALUE : i * i)&gt;=x)&#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="comment">//出循环了判断一下i²和x的大小</span></span><br><span class="line">       <span class="keyword">if</span>(i*i&gt;x)&#123;</span><br><span class="line">           <span class="comment">//说明数在 i-1的²和i的²之间</span></span><br><span class="line">           <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>我直接做了一个边界处理 就是因为最大的值就是46340，所以我直接当i为46340的时候返回，但是这样代码不太优雅，因为我是因为知道错误改正之后得出一个结论就是最大的就是46340，而这个数据不应该是这样做一个特殊处理的，这道题将会看网上的题解做出自己的总结</p>

        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p>这个题可以用到二分查找法，因为本质上就是求一个值一共有三种条件</p>
<ul>
<li>求的值的平方恰好等于所给值，就<strong>正好找到这个算术平方根</strong></li>
<li>求的值的平方大于所给值，就说明这个值<strong>一定不是要求到的算术平方根</strong></li>
<li>求的值的平方小于所给值，说明这个值<strong>可能是要求的算术平方根</strong></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span>x/<span class="number">2</span>;   </span><br><span class="line">	<span class="comment">//因为除了0和1之后的所有数的一半都是小于或者等于算术平方根 也即[0,X/2]这个区间中一定有一个算数平方根是要求到的 </span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//这里过滤掉0和1的特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span> || x==<span class="number">1</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mid==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(mid&gt;x/mid)&#123;</span><br><span class="line">            high=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid== x/mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//mid &lt; x/mid;</span></span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3>
      <p>①因为除了0和1之后的所有数的一半都是小于或者等于算术平方根 也即[0,X&#x2F;2]这个区间中一定有一个算数平方根是要求到的</p>
<p>②比较的时候采用 mid (&gt; | &#x3D;&#x3D; | &lt; )x &#x2F;mid的方式来替换掉mid × mid  (&gt; | &#x3D;&#x3D; | &lt; ) x  ，避免因为乘法导致的溢出问题</p>
<p>③因为采用了<strong>除法进行比较</strong>，所以 引入了一个判断IF(mid&#x3D;&#x3D;0) break; 来规避除数不能为0的问题</p>

        <h2 id="367-有效的完全平方数"   >
          <a href="#367-有效的完全平方数" class="heading-link"><i class="fas fa-link"></i></a><a href="#367-有效的完全平方数" class="headerlink" title="367.有效的完全平方数"></a>367.有效的完全平方数</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-perfect-square/" >LeetCode.367(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>于23&#x2F;08&#x2F;05</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> high=num/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">           <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(mid==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="comment">//也即low=0 , high =1  ==&gt; num=2 那么没有完全平方数直接返回false</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(mid&gt;num/mid)&#123;</span><br><span class="line">               high=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid&lt; num/mid)&#123;</span><br><span class="line">               low=mid+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//mid == num/mid</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-11"   >
          <a href="#提交错误-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-11" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入5 输出true ,预期输出false;</p>

        <h5 id="原因-11"   >
          <a href="#原因-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-11" class="headerlink" title="原因"></a>原因</h5>
      <p>做这道题的时候因为受到69题的影响 所以判断语句中用的除法，但是好像这道题是不适用的，因为num&#x2F;mid的时候是因为上面一道题求得是整数的平方根，那么在范围中间的数据做除法会进行一个末尾抛弃，对最后的结果并不造成影响而这道题的num是实实切切要进行判断的</p>

        <h5 id="分析场景"   >
          <a href="#分析场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析场景" class="headerlink" title="分析场景"></a>分析场景</h5>
      <p>当所求值的平方相等于目标值，那么说明找到了一个数据i，我们只要分析i-1,i,i+1这三个数的平方和x的关系即可</p>
<p>如果有一个是相等的那么说明，是有效的</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=num/<span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//也即low=0 , high =1  ==&gt; num=2 那么没有完全平方数直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;num/mid)&#123;</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid&lt; num/mid)&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//mid == num/mid</span></span><br><span class="line">                index=(<span class="type">long</span>)mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index*index==num|(index+<span class="number">1</span>)*(index+<span class="number">1</span>)==num|(index-<span class="number">1</span>*index-<span class="number">1</span>)==num)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>这次我引入了一个变量index，用于记录找到mid&#x3D;&#x3D;num&#x2F;mid的时候的mid值</p>

        <h3 id="总结-3"   >
          <a href="#总结-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3>
      <p>其实我是做完了这道题然后去看别人的题解，因为这道题没有说不能用内置库，所以他们做的时候有的用了Sqrt函数。</p>
<p>总之我先总结我自己这道题的思路</p>
<p>①将num&#x3D;&#x3D;1的特殊情况直接返回true，这也是沿用69题的思路，因为除了0和1之外其他的数的平方根都小于等于自己的一半</p>
<p>②利用<strong>二分查找</strong> 当mid&#x3D;&#x3D;num&#x2F;mid的时候跳出循环 并用index记录这个mid值</p>
<p>此时跳出循环可能是 1.mid的平方恰好等于num 那么直接返回true即可</p>
<p>​									2.mid的平方小于num，因为num&#x2F;mid是整除，所以可能num的平方根是小数，所以要判断mid+1和mid-1的平方和num的关系</p>
<p>③我引入了一个Long变量来记录index的平方，为了避免乘法的溢出，同时在跳出的时候将mid值进行强转</p>
<p>④最后判断一下mid-1,mid,mid+1的平方与num的关系，如果有一个相等则返回true，所以我这里用了逻辑或，只要有一个条件成立即可不用判断完</p>

        <h1 id="移除元素"   >
          <a href="#移除元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h1>
      <p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并<strong>原地</strong>修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 1: 给定 nums &#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例 2: 给定 nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</p>

        <h2 id="27-移除元素"   >
          <a href="#27-移除元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/" >Leetcode.27移除元素(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;05</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                <span class="comment">//当前位置的元素和数组前面的元素做一个交换</span></span><br><span class="line">                <span class="type">int</span> temp=nums[count];</span><br><span class="line">                nums[count]=val;</span><br><span class="line">                nums[i]=count;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这样循环结束前count元素都是要丢掉的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[i];</span><br><span class="line">            nums[i]=nums[nums.length-<span class="number">1</span>-i];</span><br><span class="line">            nums[nums.length-i-<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：输入nums[3，2，2，3]，val&#x3D;3 输出[3,2,2]，预期输出[2,2]</p>

        <h5 id="原因-12"   >
          <a href="#原因-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-12" class="headerlink" title="原因"></a>原因</h5>
      <p>1.通过debug的时候发现给nums[i]赋值的时候用的是count，而不是用temp交换</p>
<p>2.在第一个for循环的时候判断条件 i&lt;nums.length-1这样没有遍历到最后一个元素   </p>
<p><strong>这两个问题纯纯的低级错误中的低级错误</strong></p>

        <h4 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//当前位置的元素和数组前面的元素做一个交换</span></span><br><span class="line">                <span class="type">int</span> temp=nums[count];</span><br><span class="line">                nums[count]=val;</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                count++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这样循环结束前count元素都是要丢掉的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[i];</span><br><span class="line">            nums[i]=nums[nums.length-<span class="number">1</span>-i];</span><br><span class="line">            nums[nums.length-i-<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.length-count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结及思想"   >
          <a href="#总结及思想" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结及思想" class="headerlink" title="总结及思想"></a>总结及思想</h3>
      <p>通过学习代码随想录的视频，这个题可以由一种双指针的方法来实现删除元素的操作</p>
<p><strong>首先</strong></p>
<p>我们要明白数组的性质，数组是一串地址连续的元素序列，所以要删除元素只能是后面的元素对前面元素的覆盖，本质上数组还是相同的大小</p>

        <h4 id="双指针"   >
          <a href="#双指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4>
      <p>①定义一个Fast索引指针用来遍历老数组，定义一个Slow索引指针用来指向新数组</p>
<p>②For循环判断条件是Fast&lt;arr.length</p>
<p>③当指向一个元素的时候判断这个元素是不是我们要删除的，如果不是则将arr[slow]&#x3D;arr[fast]并将slow和fast指针++指向下一个元素 </p>
<p>也即新数组的元素确定</p>
<p>④如果是我们要删除的元素则将Fast指针指向下一个元素，而Slow指针不动表示这个位置元素需要被覆盖</p>
<p>⑤循环结束返回slow,sloiw的大小也是新数组的大小</p>

        <h4 id="双指针代码实现"   >
          <a href="#双指针代码实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#双指针代码实现" class="headerlink" title="双指针代码实现"></a>双指针代码实现</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=val)&#123;</span><br><span class="line">                <span class="comment">//是新数组需要的元素</span></span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="交换元素"   >
          <a href="#交换元素" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换元素" class="headerlink" title="交换元素"></a>交换元素</h4>
      <p>也就是我第一次做这道题的时候的思想</p>
<p>①先定义一个指针count，指向数组索引为0的位置</p>
<p>②for循环遍历，当找到我们不要的元素，将其放到数组前面</p>
<p>③这样第一次遍历结束 前面的元素都是我们不要的元素，并且我们得到了一个不要元素的数量计数器Count</p>
<p>④第二次循环的时候，将前count个元素和数组的后count个元素进行交换</p>
<p>⑤返回arr.length-count  也就是返回数组前面的元素，不要最后count个元素</p>
<p><strong>弊端</strong></p>
<p>这样是进行了两次for循环判断，这时间复杂度相较于双指针的方法实现更大</p>

        <h4 id="交换指针代码实现"   >
          <a href="#交换指针代码实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换指针代码实现" class="headerlink" title="交换指针代码实现"></a>交换指针代码实现</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==val)&#123;</span><br><span class="line">                <span class="comment">//当前位置的元素和数组前面的元素做一个交换</span></span><br><span class="line">                <span class="type">int</span> temp=nums[count];</span><br><span class="line">                nums[count]=val;</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这样循环结束前count元素都是要丢掉的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">            <span class="type">int</span> temp=nums[i];</span><br><span class="line">            nums[i]=nums[nums.length-<span class="number">1</span>-i];</span><br><span class="line">            nums[nums.length-i-<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-2"   >
          <a href="#图解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-2" class="headerlink" title="图解"></a>图解</h3>
      
        <h4 id="双指针图解"   >
          <a href="#双指针图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#双指针图解" class="headerlink" title="双指针图解"></a>双指针图解</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230805093305176.png"  alt="双指针图解【1】">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230805094005008.png"  alt="双指针图解【2】">
      </p>

        <h4 id="交换元素图解"   >
          <a href="#交换元素图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#交换元素图解" class="headerlink" title="交换元素图解"></a>交换元素图解</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230805094505082.png"  alt="交换元素图解">
      </p>

        <h2 id="26-删除排序数组中的重复项"   >
          <a href="#26-删除排序数组中的重复项" class="heading-link"><i class="fas fa-link"></i></a><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/" >Leetcode.26题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;06</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[fast-<span class="number">1</span>]!=nums[fast])&#123;</span><br><span class="line">                    nums[slow]=nums[fast];</span><br><span class="line">                    slow++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=nums[fast+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-12"   >
          <a href="#提交错误-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-12" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:数组索引越界异常 Index -1 out of bounds for length 1 发生在nums[fast-1]！&#x3D;nums[fast]中</p>

        <h5 id="原因-13"   >
          <a href="#原因-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-13" class="headerlink" title="原因"></a>原因</h5>
      <p>没有判断异常情况，当nums.length&#x3D;&#x3D;1的时候直接返回1就行了</p>

        <h4 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[fast-<span class="number">1</span>]!=nums[fast])&#123;</span><br><span class="line">                    nums[slow]=nums[fast];</span><br><span class="line">                    slow++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=nums[fast+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-13"   >
          <a href="#提交错误-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-13" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入[1,1] 输出[], 预期结果[1]</p>

        <h5 id="原因-14"   >
          <a href="#原因-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-14" class="headerlink" title="原因"></a>原因</h5>
      <p>出在fast&#x3D;&#x3D;nums.length-1的时候 我将最后一个元素和倒数第二个元素进行了对比，如果不相同的话才更新到新数组中，然而我等于是比了两次因为第一次的时候是倒数第二的元素和倒数第一的元素比较，如果相同的话倒数第二个元素不会进入到新数组中，而第二次比较导致最后一个元素也进不到新数组中</p>

        <h4 id="第三次代码-4"   >
          <a href="#第三次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-4" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    nums[slow]=nums[fast];</span><br><span class="line">                    slow++;    </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=nums[fast+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="总结-4"   >
          <a href="#总结-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3>
      <p>利用<strong>双指针</strong>的思想做出这题，然后要考虑到特殊情况，比较元素的时候要小心数组索引越界异常，踩坑就是这里</p>

        <h2 id="283-移动零"   >
          <a href="#283-移动零" class="heading-link"><i class="fas fa-link"></i></a><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/" >Leetcode.283题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次于23&#x2F;08&#x2F;06</p>

        <h4 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> fast=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast&gt;=<span class="number">0</span>;fast--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]==<span class="number">0</span>)&#123;</span><br><span class="line">                nums[slow]=<span class="number">0</span>;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-14"   >
          <a href="#提交错误-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-14" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入[0,1,0,3,12] 输出[0,1,0,0,0] 预期输出[1,3,12,0,0]</p>

        <h5 id="原因-15"   >
          <a href="#原因-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-15" class="headerlink" title="原因"></a>原因</h5>
      <p>我的意思是从后面开始遍历，然后当为0的时候更新慢指针的位置，把0记录在数组后面这样就不用做移动操作</p>
<p>实际上更新慢指针的时候将数据丢失了，导致非0的位置成了0而为0的位置没有变化，所以为了数据不丢失我将更新操作做了调整</p>

        <h4 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> fast=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast&gt;=<span class="number">0</span>;fast--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]==<span class="number">0</span>)&#123;</span><br><span class="line">                nums[fast]=nums[slow];</span><br><span class="line">                nums[slow]=<span class="number">0</span>;</span><br><span class="line">                slow--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入[0,1,0,3,12] 输出[3,1,12,0,0] 预期输出[1,3,12,0,0]</p>

        <h5 id="原因-16"   >
          <a href="#原因-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-16" class="headerlink" title="原因"></a>原因</h5>
      <p>因为我选择交换位置 而且我是从后面开始遍历的所以第一个0和3交换了位置 第二个0和12交换了位置，这样保证了数据不丢失，但是这样就影响了数据的次序，这是我没有考虑到的。我开始想是不是我的思路出现问题，就这样我改改提交了第三次代码</p>

        <h4 id="第三次代码-5"   >
          <a href="#第三次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-5" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast&lt;nums.length;fast++)&#123;</span><br><span class="line">            <span class="comment">//从头遍历 当元素不为0的时候更新到新数组中</span></span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[slow]=nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    		<span class="comment">//当循环结束新数组和老数组数量不同说明最后的元素需要更新成0</span></span><br><span class="line">        <span class="keyword">if</span>(slow!=fast)</span><br><span class="line">        <span class="keyword">for</span>(;slow&lt;fast;slow++)&#123;</span><br><span class="line">            nums[slow]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>我反思了一下顺序的丢失可能是因为从后面开始遍历的原因，所以我选择从头遍历，然后最后进行一个判断如果新老数组长度不相等，则更新最后几个元素，因为最后几个元素将0的位置填补掉了</p>

        <h3 id="总结-5"   >
          <a href="#总结-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3>
      <p><strong>双指针</strong>的时候更新元素只是覆盖，要注意数据丢失的问题以及数据次序的问题</p>

        <h2 id="844-比较含退格的字符串"   >
          <a href="#844-比较含退格的字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#844-比较含退格的字符串" class="headerlink" title="844.比较含退格的字符串"></a>844.比较含退格的字符串</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/backspace-string-compare/" >Leetcode.844题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次于23&#x2F;08&#x2F;06</p>

        <h4 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    	<span class="comment">//1.获取字符数组</span></span><br><span class="line">        <span class="type">char</span>[] c= s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] d= t.toCharArray();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//获取c数组的快慢指针</span></span><br><span class="line">        <span class="type">int</span> cslow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cFast=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//获取d数组的快慢指针</span></span><br><span class="line">        <span class="type">int</span> dslow=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dFast=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;cFast&lt;c.length;cFast++)&#123;</span><br><span class="line">            <span class="comment">//当c[cFast]!=&#x27;#&#x27;的时候进行更新新数组操作，当c[cFast]==&#x27;#&#x27;的时候进行一个退格覆盖</span></span><br><span class="line">            <span class="keyword">if</span>(c[cFast]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                c[cslow]=c[cFast];</span><br><span class="line">                cslow++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//c[cFast==&#x27;#&#x27;]</span></span><br><span class="line">                <span class="comment">//判断cslow的值 防止--slow的时候索引越界异常</span></span><br><span class="line">                <span class="keyword">if</span>(cslow==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                c[--cslow]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//下同</span></span><br><span class="line">        <span class="keyword">for</span>(;dFast&lt;d.length;dFast++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[dFast]!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                d[dslow]=d[dFast];</span><br><span class="line">                dslow++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//d[dFast==&#x27;#&#x27;]</span></span><br><span class="line">                <span class="keyword">if</span>(dslow==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                d[--dslow]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//拼接数组成字符串</span></span><br><span class="line">        String newSstr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        String newTstr=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cslow;i++)&#123;</span><br><span class="line">            newSstr=newSstr+c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;dslow;i++)&#123;</span><br><span class="line">            newTstr=newTstr+d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newSstr.equals(newTstr);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-7"   >
          <a href="#提交成功-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-7" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>但是好像有一点点不太优雅提交完这个答案，我总觉得有地方可以改进，并且相同代码有点太多了，而看了评论区大概就是抽取出一个方法然后返回一个String类型的值  主函数中用  return 方法1(s).eqauls(方法1(t)) 这样好像优雅一点</p>

        <h3 id="总结-6"   >
          <a href="#总结-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3>
      <p>利用<strong>双指针</strong>的思想</p>
<p>①先获取char类型的数组，方便使用双指针</p>
<p>②当nums[fast]!&#x3D;’#’的时候进行一个更新到新数组操作 即nums[slow++]&#x3D;nums[fast];</p>
<p>③当nums[fast]&#x3D;&#x3D;’#’的时候要进行一个退格操作 即nums[–slow]&#x3D;’#’  但是这里有一个坑 <strong>当slow为0的时候要注意–slow的索引越界</strong></p>
<p>所以我进行了一个判断  当slow&#x3D;&#x3D;0的时候直接continue;</p>
<p>④将字符数组返回成字符串 ，通过字符串的equasl方法比较并返回结果，我这里做的太不优雅了可以改进一点的</p>

        <h2 id="977-有序数组的平方"   >
          <a href="#977-有序数组的平方" class="heading-link"><i class="fas fa-link"></i></a><a href="#977-有序数组的平方" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/" >Leetcode.977题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;06</p>

        <h4 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//先平方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            nums[i]=nums[i]*nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">        	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            	<span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                	<span class="type">int</span> temp=nums[i+<span class="number">1</span>];</span><br><span class="line">                	nums[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">                	nums[i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-8"   >
          <a href="#提交成功-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-8" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>很显然这次是一个暴力解法，因为我有一点点不知道怎么用双指针来解这道题，并且还有一点很关键的是，暴力解法的暴力循环我用了最老套的双层嵌套，这是一个时间复杂度为O(n²)的方法</p>

        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      
        <h4 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h4>
      <p>依然是使用<strong>双指针</strong>的思想</p>
<p><strong>数组最左边或者最右边一定会产生最大的平方数</strong>，因此我们用两个指针一个指向最左边的一个指向最右边，然后来比较两者之间的最大值</p>
<p>然后将最大的写入新数组中，循环条件是左边的指针小于等于右边指针 (也就是左边指针不超过右边指针)，新数组用一个新的指针指向，并且要从后往前写这样保证了数据大的排在后面</p>
<p><strong>破局点</strong>：1.可以用新数组来承接老数组的数值，这样不会因为原地修改造成数据丢失</p>
<p>​				2.老数组的两边一定会产生这个数组中最大的平方数</p>
<p>​				3.新数组从后往前写保证了新数组的顺序</p>

        <h4 id="代码"   >
          <a href="#代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码" class="headerlink" title="代码"></a>代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="comment">// 双指针</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//指向最左边</span></span><br><span class="line">        <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//指向最右边 </span></span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//新数组的索引下标，从后往前写</span></span><br><span class="line">        <span class="type">int</span> write=nums.length-<span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//定义一个新数组</span></span><br><span class="line">        <span class="type">int</span>[] newArr=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//当左边指针不超过右边指针时候进入循环</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="comment">//如果左边产生的平方数比右边的平方大 将左边的平方写入新数组中然后指针移动</span></span><br><span class="line">            <span class="keyword">if</span>(nums[low]*nums[low]&gt;nums[high]*nums[high])&#123;</span><br><span class="line">                newArr[write]=nums[low]*nums[low];</span><br><span class="line">                low++;</span><br><span class="line">                write--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//反之将右边的平方数写入数组中然后指针移动</span></span><br><span class="line">                newArr[write]=nums[high]*nums[high];</span><br><span class="line">                high--;</span><br><span class="line">                write--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-3"   >
          <a href="#图解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-3" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230806111400239.png"  alt="977题双指针图解(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230806111548953.png"  alt="977题双指针图解(2)">
      </p>

        <h1 id="有序数组的平方"   >
          <a href="#有序数组的平方" class="heading-link"><i class="fas fa-link"></i></a><a href="#有序数组的平方" class="headerlink" title="有序数组的平方"></a>有序数组的平方</h1>
      <p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>

        <h2 id="977-有序数组的平方-1"   >
          <a href="#977-有序数组的平方-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#977-有序数组的平方-1" class="headerlink" title="977.有序数组的平方"></a>977.有序数组的平方</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/" >Leetcode.977题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>有点扯，这道题明明昨天刚做过 3&gt;3 就当无事发生再重新做一遍吧</p>

        <h3 id="代码-1"   >
          <a href="#代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    	<span class="comment">//定义双指针 low指向老数组最左边 high指向老数组最右边 write指向新数组的写入位置，从后往前写所以指向最后</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> write=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//创建一个新数组</span></span><br><span class="line">        <span class="type">int</span>[] newArr= <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//当low不超过high的时候进行循环</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">            <span class="comment">//左边的数平方比右边的数平方大</span></span><br><span class="line">            <span class="keyword">if</span>(nums[low]*nums[low]&gt;nums[high]*nums[high])&#123;</span><br><span class="line">                <span class="comment">//写入新数组中，low++,write--</span></span><br><span class="line">                newArr[write--]=nums[low]*nums[low];</span><br><span class="line">                low++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//反之右边的数的平方比左边的数大</span></span><br><span class="line">                <span class="comment">//写入新数组中，high--,write--</span></span><br><span class="line">                newArr[write--]=nums[high]*nums[high];</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回新数组</span></span><br><span class="line">        <span class="keyword">return</span> newArr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="图解-4"   >
          <a href="#图解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-4" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230806111400239.png"  alt="977题双指针图解(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230806111548953.png"  alt="977题双指针图解(2)">
      </p>

        <h1 id="长度最小的子数组"   >
          <a href="#长度最小的子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#长度最小的子数组" class="headerlink" title="长度最小的子数组"></a>长度最小的子数组</h1>
      <p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0</p>

        <h2 id="209-长度最小的子数组"   >
          <a href="#209-长度最小的子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/" >Leetcode.209题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><em>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0</em></p>

        <h3 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;07</p>

        <h4 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp=nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;slow&lt;nums.length;slow++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=slow;i&lt;nums.length;i++)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;=count)&#123;</span><br><span class="line">                        temp=count;</span><br><span class="line">                        flag=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入396893380 超出时间限制</p>

        <h5 id="原因-17"   >
          <a href="#原因-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-17" class="headerlink" title="原因"></a>原因</h5>
      <p>嵌套循环中每一次都需要从当前之后下一个元素开始，时间复杂度太高了，我在想是不是前N个才能sum&gt;&#x3D;target的情况下，那N-1个一定是sum&lt;target，我们只需要从第N+1个元素开始看下一次条件?</p>

        <h4 id="第二次代码-7"   >
          <a href="#第二次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-7" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp=nums.length;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;slow&lt;nums.length;)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=slow;i&lt;nums.length;i++)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span>(temp&gt;=count)&#123;</span><br><span class="line">                        temp=count;</span><br><span class="line">                        flag=<span class="literal">true</span>;</span><br><span class="line">                        slow=i+<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入11 [1,1,1,1,1,1,1,1] 超出时间限制</p>

        <h5 id="原因-18"   >
          <a href="#原因-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-18" class="headerlink" title="原因"></a>原因</h5>
      <p>第二个循环才能导致外循环的slow更改数据，如果一直找不到最小的数组则陷入了死循环中</p>

        <h4 id="第三次代码-6"   >
          <a href="#第三次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-6" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> slow=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp=nums.length;</span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(;slow&lt;nums.length;slow++)&#123;</span><br><span class="line">            sum+=nums[slow];</span><br><span class="line">            count++;</span><br><span class="line">           <span class="keyword">if</span>(sum&gt;=target)&#123;</span><br><span class="line">               sum=<span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span>(temp&gt;count)&#123;</span><br><span class="line">                   temp=count;</span><br><span class="line">                   count=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               flag=<span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入 11 [1,2,3,4,5] 输出5 预期输出3</p>

        <h5 id="原因-19"   >
          <a href="#原因-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-19" class="headerlink" title="原因"></a>原因</h5>
      <p>很显然是因为我第一次失败的错误思路，我假设前n个才能导致sum&gt;&#x3D;target，我认为n-1个时达不到sum&gt;&#x3D;target目标，所以我直接认为下一个子数组要从下一个也即n+1开始看</p>
<p>这道题我没能成功自己做出来</p>

        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题还是用<strong>滑动窗口</strong>的思路，如果用暴力解法会时间超出限制，所以暴力法就不行了。然后双指针主要是如何更新起始位置的指针是这道题的关键，我第一次做的时候第三次代码用了相似的思路，但是我没能成功移动起始索引</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    	<span class="comment">//定义left和right指针 一个用于表示起始位置，一个用于表示终止位置</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//定义sum用来比较数值，temp是用来记录最小长度的，temp的初始化只要比nums.length大就行</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.length;right++)&#123;</span><br><span class="line">            sum+=nums[right];</span><br><span class="line">            <span class="comment">//while循环来不断更新起始位置 ，当sum&lt;target中断循环说明启示位置更新到sum&lt;target的位置了</span></span><br><span class="line">            <span class="keyword">while</span>(sum&gt;=target)&#123;</span><br><span class="line">                <span class="comment">//获取数组最小长度  结束位置-起始位置+1是当前窗口的元素个数 </span></span><br><span class="line">                temp=Math.min(temp,right-left+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//减去启示位置的元素值 用来更新起始位置</span></span><br><span class="line">                sum-=nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//如果temp和初始化长度一样则说明没有最小数组，反之说明找到了最小数组，返回最小数组长度</span></span><br><span class="line">        <span class="keyword">return</span> temp==Integer.MAX_VALUE? <span class="number">0</span> :temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-7"   >
          <a href="#总结-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3>
      <p><strong>滑动窗口的思想</strong>重点在于怎么来更新起始位置的指针，这里用while循环来保证【起始位置，终止位置】这段数组中sum&lt;target，如果用if来进行条件判断则不能保证这个【起始位置，终止位置】这个区间中sum&lt;target</p>

        <h3 id="图解-5"   >
          <a href="#图解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-5" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230807105205073.png"  alt="滑动窗口图解(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230807105326262.png"  alt="滑动窗口图解(2)">
      </p>

        <h2 id="904-水果成篮"   >
          <a href="#904-水果成篮" class="heading-link"><i class="fas fa-link"></i></a><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/fruit-into-baskets/" >Leetcode.904题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。<br>你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。<br>一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。<br>给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>

        <h3 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;07</p>

        <h4 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> typeA=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> typeB=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;right&lt;fruits.length;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(typeA==Integer.MAX_VALUE)&#123;</span><br><span class="line">                typeA=fruits[right];</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(typeA!=fruits[right]&amp;&amp;typeB==Integer.MAX_VALUE)&#123;</span><br><span class="line">                typeB=fruits[right];</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right]==typeA||fruits[right]==typeB)&#123;</span><br><span class="line">                 count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fruits[right]!=typeA&amp;&amp;fruits[right]!=typeB)&#123;</span><br><span class="line">                max= max&gt;count?max:count;</span><br><span class="line">                count=<span class="number">0</span>; </span><br><span class="line">                <span class="keyword">while</span>(fruits[left]==typeA)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                typeA=typeB;</span><br><span class="line">                typeB=Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        max=max&gt;count?max:count;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入[0,1,2,2] 输出2 ，预期输出3</p>

        <h5 id="原因-20"   >
          <a href="#原因-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-20" class="headerlink" title="原因"></a>原因</h5>
      <p>因为把第三种水果判断的时候我将count置为0 但是实际上我还有一个篮子装有水果，我忽略了另一个篮子中的水果个数</p>

        <h4 id="第二次代码-8"   >
          <a href="#第二次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-8" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> typeA=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> typeB=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Acount=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Bcount=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(;right&lt;fruits.length;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(typeA==Integer.MAX_VALUE)&#123;</span><br><span class="line">                typeA=fruits[right];</span><br><span class="line">                Acount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(typeA!=fruits[right]&amp;&amp;typeB==Integer.MAX_VALUE)&#123;</span><br><span class="line">                typeB=fruits[right];</span><br><span class="line">                Bcount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right]==typeA)&#123;</span><br><span class="line">                Acount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fruits[right]==typeB)&#123;</span><br><span class="line">                Bcount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(fruits[right]!=typeA&amp;&amp;fruits[right]!=typeB)&#123;</span><br><span class="line">                max= max&gt;(Acount+Bcount)?max:(Acount+Bcount);</span><br><span class="line">                Acount=Bcount;</span><br><span class="line">                Bcount=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(fruits[left]==typeA)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                typeA=typeB;</span><br><span class="line">                typeB=fruits[right];</span><br><span class="line">                Bcount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         max= max&gt;(Acount+Bcount)?max:(Acount+Bcount);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-15"   >
          <a href="#提交错误-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-15" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:输入[1,0,1,4,1,4,1,2,3] 输出4 预期输出5</p>

        <h5 id="原因-21"   >
          <a href="#原因-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-21" class="headerlink" title="原因"></a>原因</h5>
      <p>逻辑错了滑动窗口下一个位置应该是下一个元素前面一个类型的起始个数</p>

        <h4 id="第三次代码-7"   >
          <a href="#第三次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-7" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">       <span class="type">int</span> typeA=Integer.MAX_VALUE;</span><br><span class="line">       <span class="type">int</span> typeB=Integer.MAX_VALUE;</span><br><span class="line">       <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> Acount=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> Bcount=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(;right&lt;fruits.length;right++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(typeA==Integer.MAX_VALUE)&#123;</span><br><span class="line">               typeA=fruits[right];</span><br><span class="line">               Acount++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(typeA!=fruits[right]&amp;&amp;typeB==Integer.MAX_VALUE)&#123;</span><br><span class="line">               typeB=fruits[right];</span><br><span class="line">               Bcount++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(fruits[right]==typeA)&#123;</span><br><span class="line">               Acount++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(fruits[right]==typeB)&#123;</span><br><span class="line">               Bcount++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(fruits[right]!=typeA&amp;&amp;fruits[right]!=typeB)&#123;</span><br><span class="line">               max= max&gt; (Acount+Bcount)?max:(Acount+Bcount);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span>(fruits[right-<span class="number">1</span>]==typeA)&#123;</span><br><span class="line">                   <span class="comment">//清空B篮子</span></span><br><span class="line">                   <span class="keyword">while</span>(Bcount!=<span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(fruits[left++]==typeB) Bcount--;</span><br><span class="line">                       <span class="keyword">else</span> Acount--;</span><br><span class="line">                   &#125;</span><br><span class="line">                  </span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(fruits[right-<span class="number">1</span>]==typeB)&#123;</span><br><span class="line">                   <span class="comment">//清空A篮子</span></span><br><span class="line">                   <span class="keyword">while</span>(Acount!=<span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">if</span>(fruits[left++]==typeA) Acount--;</span><br><span class="line">                       <span class="keyword">else</span> Bcount--;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//把B篮子给A篮子</span></span><br><span class="line">                   Acount=Bcount;</span><br><span class="line">                   typeA=typeB;</span><br><span class="line">                   Bcount=<span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">                typeB=fruits[right];</span><br><span class="line">                Bcount++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">         max= max&gt; (Acount+Bcount)?max:(Acount+Bcount);</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-9"   >
          <a href="#提交成功-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-9" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>我把左右两个篮子的个数分开算，当碰到第三种水果的时候判断前一种水果是什么让他成为种类A，索引应该移动到连续的种类A的第一个，然后把第三种水果装成种类B的篮子中</p>

        <h4 id="第四次代码-3"   >
          <a href="#第四次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-3" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map= <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;fruits.length;right++)&#123;</span><br><span class="line">            <span class="comment">//没有装满两种类型</span></span><br><span class="line">            <span class="keyword">if</span>(map.size()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(fruits[right]))&#123;</span><br><span class="line">                    <span class="type">int</span> count=map.get(fruits[right]);</span><br><span class="line">                    map.put(fruits[right],++count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(fruits[right],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">if</span>(map.containsKey(fruits[right]))&#123;</span><br><span class="line">                     <span class="comment">//是两种之一</span></span><br><span class="line">                    <span class="type">int</span> count=map.get(fruits[right]);</span><br><span class="line">                    map.put(fruits[right],++count);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第三种，需要清空其中一种</span></span><br><span class="line">                <span class="comment">//获取最长的长度</span></span><br><span class="line">                len=Math.max(len,right-left);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最靠近第三种水果的第二种水果种类 nums[right-1] 我们这一步的目标是清空种类1 保留连续的第二种水果</span></span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> bCount=right-left-map.get(fruits[right-<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">while</span>(bCount!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fruits[left]==fruits[right-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> count=map.get(fruits[right-<span class="number">1</span>]);</span><br><span class="line">                    map.put(fruits[right-<span class="number">1</span>],--count);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(fruits[left],--bCount);</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环结束移除第一种水果</span></span><br><span class="line">                map.remove(fruits[left-<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//将第三种水果添加进篮子中</span></span><br><span class="line">                map.put(fruits[right],<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len=Math.max(len,right-left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-10"   >
          <a href="#提交成功-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-10" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>利用集合写的，没想到不仅是时间和空间都比第三次代码花的多</p>

        <h3 id="总结-8"   >
          <a href="#总结-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3>
      <p>①利用<strong>滑动窗口</strong>的思想，用类型A和类型B代表两个篮子，同时用Acount和Bcount表示水果个数</p>
<p>②当碰到第三种水果的时候先判断上一个水果是类型A还是类型B 收集max &#x3D; MAX&gt;Acount+Bcount ? MAX ：Acount+ Bcount</p>
<p>③如果是类型A就把类型B的水果清空以及类型B以前的水果A要减去 如 0 1 0 1 0 0 3 要把倒数第二个0以前的0101都清空掉</p>
<p>④如果是类型B就把类型A的水果以及类型A以前的水果B都清空，然后将B水果放到A水果篮中，B个数为0</p>
<p>⑤把类型C放到类型B中，设置B果篮中的水果个数为1</p>
<p>⑥最后返回最大的水果个数</p>

        <h2 id="76-最小覆盖子串"   >
          <a href="#76-最小覆盖子串" class="heading-link"><i class="fas fa-link"></i></a><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/" >Leetcode.76题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>给你一个字符串 s、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。</p>

        <h3 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;08</p>

        <h4 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((t==<span class="literal">null</span> &amp;&amp; <span class="string">&quot;&quot;</span>.equals(t))||(s==<span class="literal">null</span> &amp;&amp; <span class="string">&quot;&quot;</span>.equals(s)))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] arr=t.toCharArray();</span><br><span class="line">    Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; tempMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> a:arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">            <span class="comment">//如果包含</span></span><br><span class="line">            <span class="type">int</span> count=map.get(a);</span><br><span class="line">            map.put(a,++count);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.put(a,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempMap=map;</span><br><span class="line">    <span class="type">char</span>[] sArr=s.toCharArray();</span><br><span class="line"></span><br><span class="line">    List&lt;Character&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">int</span> count=arr.length;</span><br><span class="line">    <span class="type">int</span> sCount=<span class="number">0</span>;</span><br><span class="line">    String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;right&lt;sArr.length;right++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tempMap.containsKey(sArr[right]))&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> temp=tempMap.get(sArr[right]);</span><br><span class="line">            temp--;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>)&#123;</span><br><span class="line">                tempMap.remove(sArr[right]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempMap.put(sArr[right],temp);</span><br><span class="line">            &#125;</span><br><span class="line">            sCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(sArr[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(sCount==count)&#123;</span><br><span class="line">            max= max&gt;list.toString().length()? max: list.toString().length();</span><br><span class="line">            result= list.toString().length()&gt;=max? list.toString():result;</span><br><span class="line">            <span class="keyword">if</span>(tempMap.containsKey(sArr[left]))&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="type">int</span> temp=tempMap.get(sArr[left]);</span><br><span class="line">                    tempMap.put(sArr[left],++temp);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tempMap.put(sArr[left],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            sCount--;</span><br><span class="line">            list.remove(left);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交错误-16"   >
          <a href="#提交错误-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-16" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE: s:”ADOBECODEBANC” t:”ABC”,输出”[D, O, B, E, C, O, D, E, B, A]”。预期输出”BANC”</p>

        <h5 id="原因-22"   >
          <a href="#原因-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-22" class="headerlink" title="原因"></a>原因</h5>
      <p>挺搞的一开始，我返回的是最长的字符串max&#x3D; max&gt;list.toString().length()? max: list.toString().length(); 其次输出的数组不是一个字符串所以我还要把这个数组变成字符串</p>

        <h4 id="第二次代码-9"   >
          <a href="#第二次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-9" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((t==<span class="literal">null</span> &amp;&amp; <span class="string">&quot;&quot;</span>.equals(t))||(s==<span class="literal">null</span> &amp;&amp; <span class="string">&quot;&quot;</span>.equals(s)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] arr=t.toCharArray();</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; tempMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> a:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">                <span class="comment">//如果包含</span></span><br><span class="line">                <span class="type">int</span> count=map.get(a);</span><br><span class="line">                map.put(a,++count);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(a,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempMap=map;</span><br><span class="line">        <span class="type">char</span>[] sArr=s.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;Character&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> count=arr.length;</span><br><span class="line">        <span class="type">int</span> sCount=<span class="number">0</span>;</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;sArr.length;right++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(tempMap.containsKey(sArr[right]))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> temp=tempMap.get(sArr[right]);</span><br><span class="line">                temp--;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">0</span>)&#123;</span><br><span class="line">                    tempMap.remove(sArr[right]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tempMap.put(sArr[right],temp);</span><br><span class="line">                &#125;</span><br><span class="line">                sCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sArr[right]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(sCount==count)&#123;</span><br><span class="line">                min=min&gt;list.toString().length()?list.toString().length():min;</span><br><span class="line">                result=list.toString().length()&lt;=min? Arrays.toString(list.toArray()) :result;</span><br><span class="line">                <span class="keyword">if</span>(tempMap.containsKey(sArr[left]))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> temp=tempMap.get(sArr[left]);</span><br><span class="line">                    tempMap.put(sArr[left],++temp);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tempMap.put(sArr[left],<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sCount--;</span><br><span class="line">                list.remove(left);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: s:”ADOBECODEBANC” t:”ABC”,输出”[A,D,O,B,E,C]”。预期输出”BANC”</p>

        <h5 id="原因-23"   >
          <a href="#原因-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-23" class="headerlink" title="原因"></a>原因</h5>
      <p>1.我还是没有解决数组变成字符串的问题</p>
<p>2.因为下标移动的时候没有从A移动到B，那么导致了list中存在DOBE…. 每次只删除了一个元素</p>

        <h4 id="第三次代码-8"   >
          <a href="#第三次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-8" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((t==<span class="literal">null</span> &amp;&amp; <span class="string">&quot;&quot;</span>.equals(t))||(s==<span class="literal">null</span> &amp;&amp; <span class="string">&quot;&quot;</span>.equals(s)))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] arr=t.toCharArray();</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Integer&gt; tempMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> a:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">                <span class="comment">//如果包含</span></span><br><span class="line">                <span class="type">int</span> count=map.get(a);</span><br><span class="line">                map.put(a,++count);</span><br><span class="line">                tempMap.put(a,++count);</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(a,<span class="number">1</span>);</span><br><span class="line">                tempMap.put(a,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] sArr=s.toCharArray();</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;Character&gt; list=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> count=arr.length;</span><br><span class="line">        <span class="type">int</span> sCount=<span class="number">0</span>;</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;sArr.length;right++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sArr[right]))&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> temp=map.get(sArr[right]);</span><br><span class="line">                temp--;</span><br><span class="line">                <span class="keyword">if</span>(temp==<span class="number">0</span>)&#123;</span><br><span class="line">                    tempMap.remove(sArr[right]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    tempMap.put(sArr[right],temp);</span><br><span class="line">                &#125;</span><br><span class="line">                sCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(sArr[right]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sCount&gt;=count)&#123;</span><br><span class="line">                min=min&gt;list.toArray().length?list.toArray().length:min;</span><br><span class="line">                result=list.toArray().length&lt;=min? Arrays.toString(list.toArray()) :result;</span><br><span class="line">                <span class="keyword">while</span>(tempMap.size()&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(sArr[left])) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(tempMap.containsKey(sArr[left]))&#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> tempMap.get(sArr[left]);</span><br><span class="line">                            tempMap.put(sArr[left], ++temp);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            tempMap.put(sArr[left], <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (tempMap.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                        sCount--;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    list.removeFirst();</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: s:”ADOBECODEBANC” t:”ABC”,输出”[A,D,O,B,E,C]”。预期输出”BANC”</p>

        <h5 id="原因-24"   >
          <a href="#原因-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-24" class="headerlink" title="原因"></a>原因</h5>
      <p>我没能找到正确的索引下标移动，我中期一度卡在删除list元素中，然后发现删除的顺序和我插入元素的顺序不太一样？我后面用了removeFirst方法来删除第一个元素</p>

        <h4 id="第四次代码-4"   >
          <a href="#第四次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-4" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入判断</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">null</span>||<span class="string">&quot;&quot;</span>.equals(s) ||t==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] sArr= s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tArr= t.toCharArray();</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//利用一个哈希map来记录目标子串的种类以及每个种类出现的次数</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : tArr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(c))&#123;</span><br><span class="line">                <span class="comment">//如果是重复的字符 则添加个数</span></span><br><span class="line">                <span class="type">int</span> count=map.get(c);</span><br><span class="line">                map.put(c,++count);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//是第一次的字符则放入 Key=c ,Value=1</span></span><br><span class="line">                map.put(c,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录一共有多少个目标子串</span></span><br><span class="line">        <span class="type">int</span> Type=map.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动指针的双指针 </span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用一个getCount来代表滑动窗口中已经有的种类个数</span></span><br><span class="line">        <span class="type">int</span> getCount=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义一个哈希map来承接出现的子串以及子串个数</span></span><br><span class="line">        HashMap&lt;Character,Integer&gt; hsmap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> hscount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;sArr.length;right++)&#123;</span><br><span class="line">            <span class="comment">//判断当前字符是不是在对照表map中</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(sArr[right]))&#123;</span><br><span class="line">                <span class="comment">//放入htmap中</span></span><br><span class="line">                <span class="keyword">if</span>(hsmap.containsKey(sArr[right]))&#123;</span><br><span class="line">                    <span class="comment">//如果有则更新个数</span></span><br><span class="line">                    <span class="type">int</span> count=hsmap.get(sArr[right]);</span><br><span class="line">                    hsmap.put(sArr[right],++count);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//没有则不更新htmap中个数，但是更新种类个数</span></span><br><span class="line">                    hsmap.put(sArr[right],<span class="number">1</span>);</span><br><span class="line">                    getCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                hscount++;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">while</span>(getCount==Type)&#123;</span><br><span class="line">                <span class="comment">//如果getCount==Type相等则说明滑动窗口已经覆盖了最小子串,移动左指针减去冗余个数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果这个元素是在t表中有的判断是否有冗余出现</span></span><br><span class="line">                <span class="keyword">if</span>(hsmap.containsKey(sArr[left]))&#123;</span><br><span class="line">                    <span class="comment">//如果left索引位置的元素在hsmap中的个数大于map中的个数说明多于了</span></span><br><span class="line">                    <span class="type">int</span> count=hsmap.get(sArr[left]);</span><br><span class="line">                    <span class="keyword">if</span>(hsmap.get(sArr[left])&gt;map.get(sArr[left]))&#123;</span><br><span class="line">                        count--;</span><br><span class="line">                        hsmap.put(sArr[left],count);</span><br><span class="line">                        left++;</span><br><span class="line">                        hscount--;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(count==map.get(sArr[left])) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(hscount&gt;=tArr.length)&#123;</span><br><span class="line">                            min = min &gt; (right - left + <span class="number">1</span>) ? right - left + <span class="number">1</span> : min;</span><br><span class="line">                            result = min &gt;= (right - left + <span class="number">1</span>) ? s.substring(left, right + <span class="number">1</span>) : result;</span><br><span class="line">                            <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">                                hsmap.remove(sArr[left]);</span><br><span class="line">                                getCount--;</span><br><span class="line">                                left++;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            count--;</span><br><span class="line">                            hsmap.put(sArr[left],count);</span><br><span class="line">                            hscount--;</span><br><span class="line">                            left++;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count&lt;map.get(sArr[left]))&#123;</span><br><span class="line">                        <span class="comment">//说明不符合规定,应该移动右指针</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//反之不在要求中的数据</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-17"   >
          <a href="#提交错误-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-17" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE：s:”aaaaaaaaaaaabbbbbcdd” t:”abcdd” 输出abbbbbcd 预期输出abbbbbcdd</p>

        <h5 id="原因-25"   >
          <a href="#原因-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-25" class="headerlink" title="原因"></a>原因</h5>
      <p>这里我还是看过视频之后写的，然后写了一两个小时改改停停还是改不出来，后面再看看其他用hashmap写的才知道自己哪里做错了</p>
<p>我这里Type就是当<strong>新的进来就直接认为是找到子串了实际上是不对的，要先类型有也要数量有</strong></p>

        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>代码</strong></p>
<p>这里还是用了<strong>双指针</strong>的<strong>滑动窗口</strong>思想</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">//最小子串起始索引</span></span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//最小子串长度</span></span><br><span class="line">        <span class="type">int</span> min=Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是目标t中需要的字符串种类以及个数</span></span><br><span class="line">        Map&lt;Character,Integer&gt; needs=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//这是滑动窗口用的hsmap</span></span><br><span class="line">        Map&lt;Character,Integer&gt; windows=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历t数组给needs赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch:t.toCharArray())&#123;</span><br><span class="line">            needs.put(ch,needs.getOrDefault(ch,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于记录符合个数且类型的个数</span></span><br><span class="line">        <span class="type">int</span> match=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环开始找子串</span></span><br><span class="line">        <span class="keyword">while</span>(right&lt;s.length())&#123;</span><br><span class="line">            <span class="comment">//先获取当前right位置的字符</span></span><br><span class="line">            <span class="type">char</span> c1=s.charAt(right);</span><br><span class="line">            <span class="comment">//判断needs中是否包含c1这个字符串,如果是说明是我们需要的</span></span><br><span class="line">            <span class="keyword">if</span>(needs.containsKey(c1))&#123;</span><br><span class="line">                <span class="comment">//needs中包含c1这个字符串</span></span><br><span class="line">                <span class="comment">//将其放入滑动窗口中 相同则累加个数</span></span><br><span class="line">                windows.put(c1,windows.getOrDefault(c1,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 判断滑动窗口中个数是否达到要求个数</span></span><br><span class="line">                <span class="keyword">if</span>(windows.get(c1).equals(needs.get(c1)))&#123;</span><br><span class="line">                    <span class="comment">//达到了则match++;</span></span><br><span class="line">                    match++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//右指针向右移动</span></span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内循环用于滑动左指针 ,count等于needs.size说明每个都符合条件了</span></span><br><span class="line">            <span class="keyword">while</span>(match==needs.size())&#123;</span><br><span class="line">                <span class="comment">// //记录当前的字符串长度</span></span><br><span class="line">                <span class="comment">// min= min&gt;=(right-left) ? right-left : min;</span></span><br><span class="line">                <span class="comment">// //记录最小子串的起始位置</span></span><br><span class="line">                <span class="comment">// start=(right-left)&lt;=min? left:start;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(right-left&lt;min)&#123;</span><br><span class="line">                    min=right-left;</span><br><span class="line">                    start=left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//滑动左指针</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//先获取当前left对应的字符</span></span><br><span class="line">                <span class="type">char</span> c2=s.charAt(left);</span><br><span class="line">                <span class="comment">//判断这个字符串是不是needs中的</span></span><br><span class="line">                <span class="keyword">if</span>(needs.containsKey(c2))&#123;</span><br><span class="line">                    <span class="comment">//将滑动窗口中的子串向右移动</span></span><br><span class="line">                    windows.put(c2,windows.get(c2)-<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//计数器--</span></span><br><span class="line">                    <span class="keyword">if</span>(windows.get(c2)&lt;needs.get(c2))&#123;</span><br><span class="line">                        match--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//左指针向右移动</span></span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==Integer.MAX_VALUE? <span class="string">&quot;&quot;</span>: s.substring(start,start+min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-9"   >
          <a href="#总结-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3>
      <p>这个题不愧是hard难度我只能说，从第一波自己写写了快两小时但是还是频繁出错，然后看官方答案我看不懂但是大概知道了思路，然后我想用hashmap把它写出来 一写就勾八写了一个多小时还没做错了 大概测试用例还有40多道，然后我去b站看了好几个视频，有C++的有Go的还有Java的 总算是差不多把自己心中想的和看得懂的写出来了，这道题真得多练练，不练真不会做</p>

        <h3 id="踩坑点"   >
          <a href="#踩坑点" class="heading-link"><i class="fas fa-link"></i></a><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h3>
      <p>①这个match值应该是<strong>种类要相同并且个数相同</strong>才能++，我自己做就因为种类相同就认为找到了最小子串</p>
<p>②<strong>windows.get(c1).equals(needs.get(c1))<strong>，这里不能写成windos(get(c1))&#x3D;&#x3D;windos(get(c2))。因为这里get出来的值是Integet类型，底部有-128，127的缓存数组，但是超过这个返回会new一个对象，所以</strong>&#x3D;&#x3D;比较的时候会比较地址值而不是比较数值</strong>测试用例不通过，得用equals方法才能测试通过</p>

        <h1 id="螺旋矩阵II"   >
          <a href="#螺旋矩阵II" class="heading-link"><i class="fas fa-link"></i></a><a href="#螺旋矩阵II" class="headerlink" title="螺旋矩阵II"></a>螺旋矩阵II</h1>
      <p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>

        <h2 id="59-螺旋矩阵-II"   >
          <a href="#59-螺旋矩阵-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#59-螺旋矩阵-II" class="headerlink" title="59.螺旋矩阵 II"></a>59.螺旋矩阵 II</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/" >leetCode.59题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>

        <h3 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;08</p>

        <h4 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        int number=1;</span><br><span class="line"></span><br><span class="line">        int[][] arr=new int[n][n];</span><br><span class="line">        int iIndex=0;</span><br><span class="line">        int jIndex=0;</span><br><span class="line">        </span><br><span class="line">            for(int i=0,j=0;i&lt;n/2;)&#123;</span><br><span class="line">                    i=iIndex++;</span><br><span class="line">                    j=jIndex++;</span><br><span class="line">                FullArr(number,iIndex,jIndex,n,arr,i,j);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            if(n%2==1)&#123;</span><br><span class="line">                arr[iIndex][jIndex]=n*n;</span><br><span class="line">            &#125;</span><br><span class="line">        return arr;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public void FullArr(int number,int iIndex,int jIndex,int n,int[][] arr,int i,int j)&#123;</span><br><span class="line">        //填完第一行</span><br><span class="line">            if(i==iIndex)&#123;</span><br><span class="line">                for(;j&lt;n-jIndex;j++)&#123;</span><br><span class="line">                    arr[i][j]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //循环结束后i==0;j==n</span><br><span class="line">            if(j==n-jIndex)&#123;</span><br><span class="line">                for(;++i&lt;n-iIndex;)&#123;</span><br><span class="line">                    arr[i][j]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //填完最后一列</span><br><span class="line">            //循环结束后i==j==n</span><br><span class="line">            if(i==n-iIndex)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                for(;--j&gt;=jIndex;)&#123;</span><br><span class="line">                    arr[i-1][j]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //填完最后一行</span><br><span class="line">            //循环结束后i==n,j==-1</span><br><span class="line">            if(j==jIndex)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                for(;--i&gt;iIndex;)&#123;</span><br><span class="line">                    arr[i][jIndex]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //循环完i==0,j==-1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>]]</span><br><span class="line">预期结果:[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></div></figure>


        <h5 id="原因-26"   >
          <a href="#原因-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-26" class="headerlink" title="原因"></a>原因</h5>
      <p>填外圈的时候先进行了iIndex和jindex++导致没有填到数据 而且因为这是第一次写的逻辑可能有点乱。填完外圈有点找不到iIndex和jIndex指向哪里</p>

        <h4 id="第二次代码-10"   >
          <a href="#第二次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-10" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> number=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> iIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> jIndex=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;)&#123;</span><br><span class="line">                number=FullArr(number,iIndex,jIndex,n,arr,i,j);</span><br><span class="line">                    i= ++iIndex;</span><br><span class="line">                    j= ++jIndex;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                arr[iIndex][jIndex]=n*n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">FullArr</span><span class="params">(<span class="type">int</span> number,<span class="type">int</span> iIndex,<span class="type">int</span> jIndex,<span class="type">int</span> n,<span class="type">int</span>[][] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        	<span class="comment">//填完第一行</span></span><br><span class="line">            <span class="keyword">if</span>(i==iIndex)&#123;</span><br><span class="line">                <span class="keyword">for</span>(;j&lt;n-jIndex;j++)&#123;</span><br><span class="line">                    arr[i][j]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环结束后i==0;j==n</span></span><br><span class="line">            <span class="keyword">if</span>(j==n-jIndex)&#123;</span><br><span class="line">                <span class="keyword">for</span>(;++i&lt;n-iIndex;)&#123;</span><br><span class="line">                    arr[i][j-<span class="number">1</span>]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填完最后一列</span></span><br><span class="line">            <span class="comment">//循环结束后i==j==n</span></span><br><span class="line">            <span class="keyword">if</span>(i==n-iIndex)&#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">for</span>(;--j&gt;=jIndex;)&#123;</span><br><span class="line">                    arr[i-<span class="number">1</span>][j]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//填完最后一行</span></span><br><span class="line">            <span class="comment">//循环结束后i==n,j==-1</span></span><br><span class="line">            <span class="keyword">if</span>(j==jIndex-<span class="number">1</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">for</span>(;--i&gt;iIndex;)&#123;</span><br><span class="line">                    arr[i][jIndex]=number++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环完i==0,j==-1</span></span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-11"   >
          <a href="#提交成功-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-11" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>从视频说这道题其实不涉及到算法，它只是一个模拟的转圈的过程，我们要遵循一个边界处理的不变量，这样才不会导致饶进循环里绕晕</p>
<p><strong>边界处理</strong></p>
<p>边界处理如果是左闭右开区间 那么每一条边都应该是左闭右开区间 也即每一条边只给左节点赋值右节点交给下一条边赋值</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个变量用于赋值</span></span><br><span class="line">        <span class="type">int</span> number=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//定义startx和starty作为每次绕圈赋值的起始坐标</span></span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span>[][] arr=<span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//定义一个变量用于维护边界处理的逻辑</span></span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//进行循环将圈赋值,循环结束条件由要转几圈来决定</span></span><br><span class="line">        <span class="comment">//如果n==3 则需要转一圈，n==4，则需要转两圈</span></span><br><span class="line">        <span class="comment">//如果n是奇数那么会留下中心的值没有赋值</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            假设n==3 那么这个循环结束arr会是</span></span><br><span class="line"><span class="comment">            1 2 3</span></span><br><span class="line"><span class="comment">            8 0 4</span></span><br><span class="line"><span class="comment">            7 6 5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> count=<span class="number">0</span>;count&lt;n/<span class="number">2</span>;count++)&#123;</span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="type">int</span> j=starty;</span><br><span class="line">            <span class="comment">//处理第一条边(上边) 遵循左闭右开原则 那么范围应该是[startx,n-offset)</span></span><br><span class="line">            <span class="keyword">for</span>(;j&lt;n-offset;j++) arr[startx][j]=number++;</span><br><span class="line">            <span class="comment">//处理第二条边(右边)</span></span><br><span class="line">            <span class="keyword">for</span>(;i&lt;n-offset;i++) arr[i][j]=number++;</span><br><span class="line">            <span class="comment">//处理第三条边(下边)</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;starty;j--) arr[i][j]=number++;</span><br><span class="line">            <span class="comment">//处理第四条边(左边)</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startx;i--) arr[i][starty]=number++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每条边都处理完了要给起始位置移动到下一圈的开头</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            <span class="comment">//移动边界处理的数 下一次要范围更小</span></span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断n是否是奇数</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//给中心值赋值</span></span><br><span class="line">            arr[startx][starty]=number;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-10"   >
          <a href="#总结-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3>
      <p>这道题要耐着性子做，不能急 他主要就是一个模仿转圈的一个过程，我们只要做好边界处理，遵循一个相同的边界处理逻辑就不容易搞错</p>
<p>总之这道题还是不难的主要是一个逻辑的问题</p>

        <h2 id="54-螺旋矩阵"   >
          <a href="#54-螺旋矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#54-螺旋矩阵" class="headerlink" title="54.螺旋矩阵"></a>54.螺旋矩阵</h2>
      <p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/" >Leetcode.54题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;08&#x2F;09</p>

        <h4 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先获取二维数组的M和N</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m=matrix.length;</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> min= m&lt;=n? m:n;</span><br><span class="line">        <span class="comment">//定义一维数组用于返回数据</span></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义每一次循环的起始点</span></span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int number=0;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(count&lt;min/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="type">int</span> j=starty;</span><br><span class="line">            <span class="comment">//遍历第一条边 左闭右开</span></span><br><span class="line">            <span class="keyword">for</span>(;j&lt;n-offset;j++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历第二条边</span></span><br><span class="line">            <span class="keyword">for</span>(;i&lt;m-offset;i++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历第三条边</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;starty;j--)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历第四条边</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startx;i--)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历完了 偏移量和下一次起始位置++</span></span><br><span class="line">            offset++;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历结束如果m&lt;n则会有一条边未填入到数据中</span></span><br><span class="line">        <span class="keyword">if</span>(m&lt;n)&#123;</span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=starty;j&lt;=n-offset;j++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">            <span class="comment">//如果m&gt;n会有一列没有遍历</span></span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=starty;i&lt;=m-offset;i++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==n&amp;&amp; m%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            list.add(matrix[startx][starty]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：输入[[2,5],[8,4],[0,-1]]  输出[2,5,4,-1,0,8,4] 预期输出[2,5,4,-1,0,8]</p>

        <h5 id="原因-27"   >
          <a href="#原因-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-27" class="headerlink" title="原因"></a>原因</h5>
      <p>无论如何如果二维数组个的i或者j为2的时候只要做一次循环就把数据添加完了而不用后面再做添加数据的判断</p>
<p>同时这还出现一个问题就是m&#x3D;&#x3D;1 || n&#x3D;&#x3D;1 以及 m&#x3D;&#x3D;n &amp;&amp; m&#x3D;&#x3D;1的情况</p>

        <h4 id="第二次代码-11"   >
          <a href="#第二次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-11" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">      <span class="comment">//先获取二维数组的M和N</span></span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> m=matrix.length;</span><br><span class="line">      <span class="type">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">if</span>(m==n&amp;&amp; m==<span class="number">1</span>)&#123;</span><br><span class="line">          List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">          list.add(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> min= m&lt;=n? m:n;</span><br><span class="line">      <span class="comment">//定义一维数组用于返回数据</span></span><br><span class="line">      <span class="comment">// int[] result=new int[m*n];</span></span><br><span class="line">      List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//定义每一次循环的起始点</span></span><br><span class="line">      <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// int number=0;</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(count&lt;min/<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="type">int</span> i=startx;</span><br><span class="line">          <span class="type">int</span> j=starty;</span><br><span class="line">          <span class="comment">//遍历第一条边 左闭右开</span></span><br><span class="line">          <span class="keyword">for</span>(;j&lt;n-offset;j++)&#123;</span><br><span class="line">              <span class="comment">// result[number++]=matrix[i][j];</span></span><br><span class="line">              list.add(matrix[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//遍历第二条边</span></span><br><span class="line">          <span class="keyword">for</span>(;i&lt;m-offset;i++)&#123;</span><br><span class="line">              <span class="comment">// result[number++]=matrix[i][j];</span></span><br><span class="line">              list.add(matrix[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//遍历第三条边</span></span><br><span class="line">          <span class="keyword">for</span>(;j&gt;starty;j--)&#123;</span><br><span class="line">              <span class="comment">// result[number++]=matrix[i][j];</span></span><br><span class="line">              list.add(matrix[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//遍历第四条边</span></span><br><span class="line">          <span class="keyword">for</span>(;i&gt;startx;i--)&#123;</span><br><span class="line">              <span class="comment">// result[number++]=matrix[i][j];</span></span><br><span class="line">              list.add(matrix[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//遍历完了 偏移量和下一次起始位置++</span></span><br><span class="line">          offset++;</span><br><span class="line">          startx++;</span><br><span class="line">          starty++;</span><br><span class="line">          count++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">              list.add(matrix[<span class="number">0</span>][i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">              list.add(matrix[i][<span class="number">0</span>]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(m&lt;=<span class="number">2</span>||n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//遍历结束如果m&lt;n则会有一条边未填入到数据中</span></span><br><span class="line">      <span class="keyword">if</span>(m&lt;n)&#123;</span><br><span class="line">          <span class="type">int</span> i=startx;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=starty;j&lt;=n-offset;j++)&#123;</span><br><span class="line">              <span class="comment">// result[number++]=matrix[i][j];</span></span><br><span class="line">              list.add(matrix[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m&gt;n)&#123;</span><br><span class="line">          <span class="comment">//如果m&gt;n会有一列没有遍历</span></span><br><span class="line">          <span class="type">int</span> i=startx;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=starty;i&lt;=m-offset;i++)&#123;</span><br><span class="line">              <span class="comment">// result[number++]=matrix[i][j];</span></span><br><span class="line">              list.add(matrix[i][j]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==n&amp;&amp; min%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">          list.add(matrix[startx][starty]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入[[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16],[17,18,19,20]]</p>
<p>​		  输出[1,2,3,4,8,12,16,20,19,18,17,13,9,5,6,7,11,15,14,10,11]</p>
<p>  预期输出[[1,2,3,4,8,12,16,20,19,18,17,13,9,5,6,7,11,15,14,10]]</p>

        <h5 id="原因-28"   >
          <a href="#原因-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-28" class="headerlink" title="原因"></a>原因</h5>
      <p>我太自以为是了，实际上这个两层循环结束数据就已经添加成功了，我决定修改最后再添加数据的逻辑</p>
<p>如果m！&#x3D;n &amp;&amp;min %2&#x3D;&#x3D;1 也就是一定有个奇数</p>
<p>如果m&#x3D;&#x3D;min 那么就说明循环结束还有一行数据没有添加</p>
<p>如果n&#x3D;&#x3D;min 那么久说明循环结束还有一列数据没有添加</p>
<p>如果m&#x3D;&#x3D;n &amp;&amp;min%2&#x3D;&#x3D;1 那么就说明循环结束最中间的数据没有添加进list中</p>

        <h4 id="第三次代码-9"   >
          <a href="#第三次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-9" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//先获取二维数组的M和N</span></span><br><span class="line">        <span class="type">int</span> m=matrix.length;</span><br><span class="line">        <span class="type">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(m==n&amp;&amp; m==<span class="number">1</span>)&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> min= m&lt;=n? m:n;</span><br><span class="line">        <span class="comment">//定义一维数组用于返回数据</span></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义每一次循环的起始点</span></span><br><span class="line">        <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(count&lt;min/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="type">int</span> j=starty;</span><br><span class="line">            <span class="comment">//遍历第一条边 左闭右开</span></span><br><span class="line">            <span class="keyword">for</span>(;j&lt;n-offset;j++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历第二条边</span></span><br><span class="line">            <span class="keyword">for</span>(;i&lt;m-offset;i++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历第三条边</span></span><br><span class="line">            <span class="keyword">for</span>(;j&gt;starty;j--)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历第四条边</span></span><br><span class="line">            <span class="keyword">for</span>(;i&gt;startx;i--)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历完了 偏移量和下一次起始位置++</span></span><br><span class="line">            offset++;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                list.add(matrix[<span class="number">0</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">                list.add(matrix[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">2</span>||n&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历结束如果m&lt;n则会有一条边未填入到数据中</span></span><br><span class="line">        <span class="keyword">if</span>(m!=n&amp;&amp;min==m&amp;&amp;min%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=starty;j&lt;=n-offset;j++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m!=n&amp;&amp;min==n&amp;&amp;min%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//如果m&gt;n会有一列没有遍历</span></span><br><span class="line">            <span class="type">int</span> i=startx;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=starty;i&lt;=m-offset;i++)&#123;</span><br><span class="line">                list.add(matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(m==n&amp;&amp; min%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            list.add(matrix[startx][starty]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-12"   >
          <a href="#提交成功-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-12" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="总结-11"   >
          <a href="#总结-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3>
      <p>这道题仍然是一个模拟转圈的过程，但是这个返回数据的时候和添加的数据的时候要注意</p>
<p>①如果m&#x3D;&#x3D;n &amp;&amp; m&#x3D;&#x3D;1那么就说明这个数组只有matrix[0][0]这个数据 把这个数据添加到list中返回即可</p>
<p>②如果m!&#x3D;n &amp;&amp;m&#x3D;&#x3D;1||n&#x3D;&#x3D;1 那么就说明是一行数据或者是一列数据 ,那么是无法进入循环中遍历外层数组的，那么直接把这一行或者这一列数据取出来即可 </p>
<p>③循环结束再进行是否有遗漏数据的判断</p>
<p>④如果m！&#x3D;n &amp;&amp;min %2&#x3D;&#x3D;1 也就是m和n一定有个奇数 </p>
<pre><code> -4.1 如果m==min 那么就说明循环结束还有一行数据没有添加
</code></pre>
<p>​	 -4.2 如果n&#x3D;&#x3D;min 那么久说明循环结束还有一列数据没有添加</p>
<p>⑤如果m&#x3D;&#x3D;n &amp;&amp;min%2&#x3D;&#x3D;1 那么就说明循环结束最中间的数据没有添加进list中</p>
<p>⑥如果m!&#x3D;n &amp;&amp; min%2&#x3D;&#x3D;0 那么说明最小的那位保证了循环一定能遍历完整个数组 </p>
<p>只要慢慢做就行了这道题 不要急一点点补全条件即可</p>

        <h1 id="剑指Offer-29-顺时针打印矩阵"   >
          <a href="#剑指Offer-29-顺时针打印矩阵" class="heading-link"><i class="fas fa-link"></i></a><a href="#剑指Offer-29-顺时针打印矩阵" class="headerlink" title="剑指Offer 29.顺时针打印矩阵"></a>剑指Offer 29.顺时针打印矩阵</h1>
      <p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/" >剑指 Offer 29(easy). 顺时针打印矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-15"   >
          <a href="#第一次做-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-15" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;8&#x2F;9</p>

        <h4 id="第一次代码-15"   >
          <a href="#第一次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-15" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取矩阵M和N</span></span><br><span class="line">            <span class="type">int</span> m=matrix.length;</span><br><span class="line">            <span class="type">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">            <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[m*n];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> min=m&lt;n?m:n;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//偏移量</span></span><br><span class="line">            <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count&lt;min/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> i=startx;</span><br><span class="line">                <span class="type">int</span> j=starty;</span><br><span class="line">                <span class="comment">//第一条边</span></span><br><span class="line">                <span class="keyword">for</span>(;j&lt;n-offset;j++) arr[number++]=matrix[i][j];</span><br><span class="line">                <span class="comment">//第二条边</span></span><br><span class="line">                <span class="keyword">for</span>(;i&lt;m-offset;i++) arr[number++]=matrix[i][j];</span><br><span class="line">                <span class="comment">// 第三条边</span></span><br><span class="line">                <span class="keyword">for</span>(;j&gt;starty;j--) arr[number++]=matrix[i][j];</span><br><span class="line">                <span class="comment">// 第四条边</span></span><br><span class="line">                <span class="keyword">for</span>(;i&gt;startx;i--) arr[number++]=matrix[i][j];</span><br><span class="line"></span><br><span class="line">                offset++;</span><br><span class="line">                count++;</span><br><span class="line">                startx++;</span><br><span class="line">                starty++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//说明只有一个元素 不能进入循环中</span></span><br><span class="line">            <span class="keyword">if</span>(m==n&amp;&amp;m==<span class="number">1</span>)&#123;</span><br><span class="line">                arr[number++]=matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//m==1说明只有一行数据</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) arr[number++]=matrix[<span class="number">0</span>][j];</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// n==1说明只有一列数据</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) arr[number++]=matrix[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> arr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(min%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//那么说明一定有个参数是奇数边</span></span><br><span class="line">                <span class="keyword">if</span>(m==n)&#123;</span><br><span class="line">                    <span class="comment">//那么最后一定剩下一个元素没有添加</span></span><br><span class="line">                    arr[number++]=matrix[startx][starty];</span><br><span class="line">                    <span class="keyword">return</span> arr;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(m==min)&#123;</span><br><span class="line">                    <span class="comment">//那么说明一定有一行数据没有添加进去</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=starty;j&lt;=n-offset;j++)&#123;</span><br><span class="line">                        arr[number++]=matrix[startx][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(n==min)&#123;</span><br><span class="line">                    <span class="comment">//那么说明有一列数据没加</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i=startx;i&lt;=m-offset;i++)&#123;</span><br><span class="line">                        arr[number++]=matrix[i][starty];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: 输入[] 抛出异常Index 0 out of bounds for length 0</p>

        <h5 id="原因-29"   >
          <a href="#原因-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#原因-29" class="headerlink" title="原因"></a>原因</h5>
      <p>如果matrix&#x3D;&#x3D;[];那么则在获取n的时候会出错因为没有matrix[0]这个数组</p>

        <h4 id="第二次代码-12"   >
          <a href="#第二次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-12" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">           <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//获取矩阵M和N</span></span><br><span class="line">           <span class="type">int</span> m=matrix.length;</span><br><span class="line">           <span class="type">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">           <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[m*n];</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> min=m&lt;n?m:n;</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="comment">//偏移量</span></span><br><span class="line">           <span class="type">int</span> offset=<span class="number">1</span>;</span><br><span class="line">           <span class="type">int</span> startx=<span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> starty=<span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> number=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(count&lt;min/<span class="number">2</span>)&#123;</span><br><span class="line">               <span class="type">int</span> i=startx;</span><br><span class="line">               <span class="type">int</span> j=starty;</span><br><span class="line">               <span class="comment">//第一条边</span></span><br><span class="line">               <span class="keyword">for</span>(;j&lt;n-offset;j++) arr[number++]=matrix[i][j];</span><br><span class="line">               <span class="comment">//第二条边</span></span><br><span class="line">               <span class="keyword">for</span>(;i&lt;m-offset;i++) arr[number++]=matrix[i][j];</span><br><span class="line">               <span class="comment">// 第三条边</span></span><br><span class="line">               <span class="keyword">for</span>(;j&gt;starty;j--) arr[number++]=matrix[i][j];</span><br><span class="line">               <span class="comment">// 第四条边</span></span><br><span class="line">               <span class="keyword">for</span>(;i&gt;startx;i--) arr[number++]=matrix[i][j];</span><br><span class="line"></span><br><span class="line">               offset++;</span><br><span class="line">               count++;</span><br><span class="line">               startx++;</span><br><span class="line">               starty++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//说明只有一个元素 不能进入循环中</span></span><br><span class="line">           <span class="keyword">if</span>(m==n&amp;&amp;m==<span class="number">1</span>)&#123;</span><br><span class="line">               arr[number++]=matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">return</span> arr;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//m==1说明只有一行数据</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) arr[number++]=matrix[<span class="number">0</span>][j];</span><br><span class="line">               <span class="keyword">return</span> arr;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">// n==1说明只有一列数据</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) arr[number++]=matrix[i][<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">return</span> arr;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(min%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">               <span class="comment">//那么说明一定有个参数是奇数边</span></span><br><span class="line">               <span class="keyword">if</span>(m==n)&#123;</span><br><span class="line">                   <span class="comment">//那么最后一定剩下一个元素没有添加</span></span><br><span class="line">                   arr[number++]=matrix[startx][starty];</span><br><span class="line">                   <span class="keyword">return</span> arr;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(m==min)&#123;</span><br><span class="line">                   <span class="comment">//那么说明一定有一行数据没有添加进去</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="type">int</span> j=starty;j&lt;=n-offset;j++)&#123;</span><br><span class="line">                       arr[number++]=matrix[startx][j];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span>(n==min)&#123;</span><br><span class="line">                   <span class="comment">//那么说明有一列数据没加</span></span><br><span class="line">                   <span class="keyword">for</span>(<span class="type">int</span> i=startx;i&lt;=m-offset;i++)&#123;</span><br><span class="line">                       arr[number++]=matrix[i][starty];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> arr;</span><br><span class="line">           </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-13"   >
          <a href="#提交成功-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-13" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="总结-12"   >
          <a href="#总结-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3>
      <p>这道题和54题有异曲同工之处，都是循环求出M*N的二维数组的顺时针顺序</p>
<p>我们只要模拟转圈就可以了</p>
<p><strong>掉坑点</strong></p>
<p>当martix&#x3D;{[]}时候，当求取n值的手会抛出索引越界异常</p>

        <h1 id="总结-13"   >
          <a href="#总结-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-13" class="headerlink" title="总结"></a>总结</h1>
      <p>算法-数组篇已经告一段落，我们从数组这一篇学到了<strong>二分查找</strong>、<strong>双指针思想</strong>、<strong>滑动窗口思想</strong>、<strong>模拟转圈</strong></p>
<p>这一篇章已经到此结束了 ，我们要进入第二篇-链表篇开始学习</p>
<p>、</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/04/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B3-CAS%E3%80%81Unsafe%E3%80%81ThreadLocal%5D/">深入剖析并发编程-JUC篇[3-CAS、Unsafe、LockSupport、ThreadLocal]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-04</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">5.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">42分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
</ul>
<hr>

        <h1 id="CAS机制"   >
          <a href="#CAS机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h1>
      <p>CAS也就是Compare And Swap  也即比较并且交换</p>
<p>乐观锁也常常用于CAS来实现，在并发量不高的时候用CAS可以减少锁的开销</p>
<p>而CAS是怎么实现的呢?</p>

        <h2 id="CAS原理"   >
          <a href="#CAS原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h2>
      <p>CAS也就是比较并交换</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CAS(V,E,N)</span><br></pre></td></tr></table></div></figure>

<p>V:要比较的内存地址值</p>
<p>E:要比较的值</p>
<p>N:要替换的新值</p>
<p>如果内存地址中的值和要比较的值相同则说明没有其他线程修改，则更新为新值</p>
<p>如果内存地址中的值和要比较的值不同则说明这个更新操作失败，不更新</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811185534370.png"  alt="CAS原理">
      </p>
<p>而我们要好奇一点 这个比较和交换这个过程难道不会出现问题吗？</p>
<p>而CAS最底层是通过cmpxchg指令来进行操作，说明<strong>这个CAS过程是一个原子性的过程</strong></p>

        <h2 id="CAS实现"   >
          <a href="#CAS实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#CAS实现" class="headerlink" title="CAS实现"></a>CAS实现</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">Atomic::cmpxchg</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> exchange_value,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>* dest, <span class="type">unsigned</span> <span class="type">int</span> compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) == <span class="built_in">sizeof</span>(jint), <span class="string">&quot;more work to do&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)Atomic::<span class="built_in">cmpxchg</span>((jint)exchange_value, (<span class="keyword">volatile</span> jint*)dest,</span><br><span class="line">                                       (jint)compare_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>底层操作</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> jint     <span class="title">Atomic::cmpxchg</span>    <span class="params">(jint exchange_value, <span class="keyword">volatile</span> jint* dest, jint compare_value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  	输入参数：</span></span><br><span class="line"><span class="comment">  		参数1：新值</span></span><br><span class="line"><span class="comment">  		参数2：目标地址值</span></span><br><span class="line"><span class="comment">  		参数3：比较值(旧值)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">//获取当前对象是不是一个volatile修饰</span></span><br><span class="line">  <span class="type">int</span> mp = os::<span class="built_in">is_MP</span>();</span><br><span class="line">   <span class="comment">//LOCK_IF_MP(%4) 如果当前对象是volatile修饰则加lock前缀锁住总线 				</span></span><br><span class="line">  <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(LOCK_IF_MP(%<span class="number">4</span>) <span class="string">&quot;cmpxchgl %1,(%3)&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;=a&quot;</span> (exchange_value)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;r&quot;</span> (exchange_value), <span class="string">&quot;a&quot;</span> (compare_value), <span class="string">&quot;r&quot;</span> (dest), <span class="string">&quot;r&quot;</span> (mp)</span></span></span><br><span class="line"><span class="params"><span class="function">                    : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个&quot;cmpchgl %1,(%3)&quot;中的占位符是下面语句中的</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	 : &quot;=a&quot; (exchange_value) //0</span></span><br><span class="line"><span class="comment">         : &quot;r&quot; (exchange_value)  //1, &quot;a&quot; (compare_value) //2, &quot;r&quot; (dest) //3, &quot;r&quot; (mp)//4</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">        指令获取2 compare_value和 3 dest中的数据进行一个比较</span></span><br><span class="line"><span class="comment">        然后相等则将旧值写入到exchange_value中  返回旧值</span></span><br><span class="line"><span class="comment">        如果不相等则将新值返回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="keyword">return</span> exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="底层实现图"   >
          <a href="#底层实现图" class="heading-link"><i class="fas fa-link"></i></a><a href="#底层实现图" class="headerlink" title="底层实现图"></a>底层实现图</h2>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811185534370.png"  alt="CAS底层实现">
      </p>
<p><strong>CAS机制带来的问题</strong></p>
<p>CAS机制带来了一种乐观锁的思想，而这个机制的也引入了一些问题</p>

        <h2 id="ABA问题"   >
          <a href="#ABA问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2>
      <p>假设有两个线程竞争同一个资源 k1&#x3D;1，使用CAS机制</p>
<p>线程T1获取了k1&#x3D;1，然后进行逻辑处理之后要将k1更新成100</p>
<p>线程T2也同时获取了k1&#x3D;1,然后线程T2先将 k1设置为2然后再设置为 1</p>
<p>当线程T1要进行更新操作的时候线程T2已经完成了一系列操作，它认为没有修改数据 这就是常说的ABA问题</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811185615416.png"  alt="ABA问题图">
      </p>
<p><strong>解决方案</strong></p>
<p>ABA问题的解决方案是使用版本号，当修改操作的时候会将版本更新，CAS的同时也要判断版本号是否相同</p>

        <h2 id="循环开销问题"   >
          <a href="#循环开销问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#循环开销问题" class="headerlink" title="循环开销问题"></a>循环开销问题</h2>
      <p>由上面分析可得，CAS实现的过程中并<strong>没有涉及到循环</strong>的过程，而这个循环开销问题又是从何而来呢？</p>
<p>通常是<strong>我们</strong>进行业务逻辑的时候进行的一个<strong>更新失败自旋</strong>的操作</p>
<p>而CAS本身并不会带来循环开销的问题</p>

        <h1 id="Unsafe魔法类"   >
          <a href="#Unsafe魔法类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Unsafe魔法类" class="headerlink" title="Unsafe魔法类"></a>Unsafe魔法类</h1>
      <p>Unsafe类位于sun.misc包下，这类似于C的指针一样可以操控内存，而我们通常是通过JVM来进行一个申请内存，而这个类能直接操控内存就意味着它能绕开JVM管理，这也是实质上的不安全</p>
<ul>
<li>调用这个类不受JVM管理，也就是不能被GC必须要和C一样自己申请内存空间、自己释放空间，如果操作不当很容易造成内存泄漏</li>
<li>这个类很多方法需要提供offset偏移量，目标地址，偏移量要通过自己计算，操作不当可能会导致JVM崩溃，导致整个程序崩溃</li>
</ul>

        <h2 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//私有化构造方法，说明我们不能直接new出这个对象</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="内存操作"   >
          <a href="#内存操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请内存空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">long</span> var1)</span>;</span><br><span class="line"><span class="comment">//申请重新分配内存空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">reallocateMemory</span><span class="params">(<span class="type">long</span> var1, <span class="type">long</span> var3)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...这里省略了一些方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">freeMemory</span><span class="params">(<span class="type">long</span> var1)</span>;</span><br></pre></td></tr></table></div></figure>




        <h2 id="屏障操作"   >
          <a href="#屏障操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#屏障操作" class="headerlink" title="屏障操作"></a>屏障操作</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读屏障</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">loadFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//写屏障</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">storeFence</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//全屏障</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">fullFence</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>




        <h2 id="CAS操作"   >
          <a href="#CAS操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CAS操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></div></figure>




        <h2 id="阻塞线程-park方法"   >
          <a href="#阻塞线程-park方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞线程-park方法" class="headerlink" title="阻塞线程(park方法)"></a>阻塞线程(park方法)</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">(<span class="type">boolean</span> var1, <span class="type">long</span> var2)</span>;</span><br></pre></td></tr></table></div></figure>


        <h2 id="唤醒线程-unpark方法"   >
          <a href="#唤醒线程-unpark方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#唤醒线程-unpark方法" class="headerlink" title="唤醒线程(unpark方法)"></a>唤醒线程(unpark方法)</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//唤醒线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object var1)</span>;</span><br></pre></td></tr></table></div></figure>




        <h2 id="获取unsafe对象-反射"   >
          <a href="#获取unsafe对象-反射" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取unsafe对象-反射" class="headerlink" title="获取unsafe对象(反射)"></a>获取unsafe对象(反射)</h2>
      <p><strong>代码说话</strong></p>
<p><strong>①错误方式</strong></p>
<p>1、试试直接new Unsafe对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Unsafe unsafe=<span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line"><span class="comment">//编译报错，因为构造方法是private修饰，不能直接new对象</span></span><br></pre></td></tr></table></div></figure>

<p>因为构造方法私有，所以我们不能直接new一个unsafe类来使用，那么我们又要用到unsafe类要怎么获取呢？</p>
<p>2、试试用Unsafe.getUnsafe()</p>
<p>我们发现有一个getUnsafe方法，那我们试试能不能直接通过这个方法来获取对象呢?</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>结果</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.SecurityException: Unsafe</span><br></pre></td></tr></table></div></figure>

<p>这里抛出了一个异常unsafe，那提供了这个方法又有什么用呢？我们跟进源码看看</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var0</span> <span class="operator">=</span> Reflection.getCallerClass();</span><br><span class="line">        <span class="comment">//判断是不是VM调用这个方法</span></span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">            <span class="comment">//不是虚拟机调用这个方法会抛出异常 异常信息为unsafe</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>②正确方式</strong></p>

        <h3 id="通过内部静态成员theUnsafe变量获取"   >
          <a href="#通过内部静态成员theUnsafe变量获取" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过内部静态成员theUnsafe变量获取" class="headerlink" title="通过内部静态成员theUnsafe变量获取"></a>通过内部静态成员theUnsafe变量获取</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个成员变量用来接收unsafe对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field= Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            <span class="comment">//修改权限</span></span><br><span class="line">            field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            </span><br><span class="line">            unsafe = (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>打印结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe@3b9a45b3</span><br></pre></td></tr></table></div></figure>

<p>有值则说明获取了这个unsafe对象</p>

        <h3 id="通过反射直接new一个unsafe对象"   >
          <a href="#通过反射直接new一个unsafe对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#通过反射直接new一个unsafe对象" class="headerlink" title="通过反射直接new一个unsafe对象"></a>通过反射直接new一个unsafe对象</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个成员变量用来接收unsafe对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor&lt;Unsafe&gt; constructor = Unsafe.class.getDeclaredConstructor();</span><br><span class="line">            constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(unsafe);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>打印结果</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Unsafe@3b9a45b3</span><br></pre></td></tr></table></div></figure>

<p>有值则说明获取了这个unsafe对象</p>

        <h1 id="LockSupport工具类"   >
          <a href="#LockSupport工具类" class="heading-link"><i class="fas fa-link"></i></a><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a>LockSupport工具类</h1>
      <p><em>LockSupport是一个线程阻塞类，我们可以用LockSupport中的方法来阻塞和唤醒线程</em></p>
<p><strong>LockSupport源码</strong></p>

        <h2 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Unsafe魔法类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> parkBlockerOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SEED;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> PROBE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> SECONDARY;</span><br></pre></td></tr></table></div></figure>


        <h2 id="park"   >
          <a href="#park" class="heading-link"><i class="fas fa-link"></i></a><a href="#park" class="headerlink" title="park"></a>park</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">park</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用Unsafe中的park方法</span></span><br><span class="line">    UNSAFE.park(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="unpark"   >
          <a href="#unpark" class="heading-link"><i class="fas fa-link"></i></a><a href="#unpark" class="headerlink" title="unpark"></a>unpark</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//调用Unsafe中的unpark方法</span></span><br><span class="line">        UNSAFE.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p>LockSupport底层就是封装了Unsafe魔法类，调用Unsafe中的park进行阻塞，unpark进行唤醒</p>

        <h1 id="ThreadLocal线程变量"   >
          <a href="#ThreadLocal线程变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal线程变量" class="headerlink" title="ThreadLocal线程变量"></a>ThreadLocal线程变量</h1>
      
        <h2 id="ThreadLocal概念"   >
          <a href="#ThreadLocal概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal概念" class="headerlink" title="ThreadLocal概念"></a>ThreadLocal概念</h2>
      
        <h3 id="ThreadLocal是什么"   >
          <a href="#ThreadLocal是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么?"></a>ThreadLocal是什么?</h3>
      <p>ThreadLocal是线程变量，也被叫做线程本地副本，当线程之间要进行数据隔离的时候我们可以用ThreadLocal来保证线程之间的数据隔离，线程可以获取自己线程中的变量而对于其他线程来说是隔离且封闭的</p>

        <h3 id="Thread、ThreadLocal和ThreadLocalMap的关系"   >
          <a href="#Thread、ThreadLocal和ThreadLocalMap的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#Thread、ThreadLocal和ThreadLocalMap的关系" class="headerlink" title="Thread、ThreadLocal和ThreadLocalMap的关系"></a>Thread、ThreadLocal和ThreadLocalMap的关系</h3>
      <p>Thread下有ThreadLocals这个成员变量 而ThreadLocals就是ThreadLocalMap，而ThreadLocal是一个线程下的变量副本</p>
<p>我们创建ThreadLocal然后调用方法都是调用ThreadLocalMap的方法，可以看成ThreadLocal是ThreadLocalMap的包装类，将其包装了一下</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811080956496.png"  alt="ThreadLocal概念">
      </p>

        <h3 id="ThreadLocalMap的Entry"   >
          <a href="#ThreadLocalMap的Entry" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap的Entry" class="headerlink" title="ThreadLocalMap的Entry"></a>ThreadLocalMap的Entry</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="built_in">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Entry继承了弱引用WeakReference</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="Java四大引用"   >
          <a href="#Java四大引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java四大引用" class="headerlink" title="Java四大引用"></a>Java四大引用</h3>
      <ul>
<li>强引用：强引用是最普遍的引用，一般把一个对象赋给一个引用变量。例如Student s &#x3D;new Student();</li>
<li>弱引用：软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference 类来实现。</li>
<li>软引用：弱引用的使用和软引用类似，只是关键字变成了 WeakReference，特点是无论内存是否足够只要GC一定会被回收</li>
<li>虚引用：虚引用在任何时候都可能会被垃圾回收器回收，虚引用需要java.lang.ref.PhantomReference 来实现：</li>
</ul>
<p>这里用一个表格简单说说这四个引用的特点</p>
<div class="table-container"><table>
<thead>
<tr>
<th>引用类型</th>
<th>GC回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从不</td>
<td>对象的一般状态</td>
<td>JVM停止运行时死亡</td>
</tr>
<tr>
<td>弱引用</td>
<td>内存不足时</td>
<td>对象缓存</td>
<td>内存不足后终止</td>
</tr>
<tr>
<td>软引用</td>
<td>GC时</td>
<td>对象缓存</td>
<td>GC后终止</td>
</tr>
<tr>
<td>虚引用</td>
<td>unknow</td>
<td>unknow</td>
<td>unknow</td>
</tr>
</tbody></table></div>

        <h2 id="ThreadLocal使用场景"   >
          <a href="#ThreadLocal使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h2>
      <ul>
<li>在对象跨层传递的时候，例如Controller层和Service层传递变量</li>
<li>线程间数据隔离，例如Spring中事务管理机制用到ThreadLocal来保证单个线程操控数据库用的是同一个数据库连接。</li>
<li>用于存储Session，例如Session在当前会话周期有效，会话结束就销毁，很适合用ThreadLocal</li>
</ul>

        <h2 id="ThreadLocal和synchronized的区别"   >
          <a href="#ThreadLocal和synchronized的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal和synchronized的区别" class="headerlink" title="ThreadLocal和synchronized的区别"></a>ThreadLocal和synchronized的区别</h2>
      <p>1.Synchronized是用于线程间的通信，用于共享变量。ThreadLocal是用于线程间的隔离，用于数据隔离</p>
<p>2.Synchronized是用锁来实现多线程的时候只有某一个线程来访问共享变量，而ThreadLocal是每个线程之间有一个内部的变量副本，这样每个线程获取的只是自己的变量副本中的数据</p>

        <h2 id="ThreadLocal源码"   >
          <a href="#ThreadLocal源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h2>
      <p><strong>成员变量</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private final int threadLocalHashCode = nextHashCode();</span><br><span class="line">private static AtomicInteger nextHashCode = new AtomicInteger();</span><br><span class="line">private static final int HASH_INCREMENT = 0x61c88647;</span><br></pre></td></tr></table></div></figure>


        <h3 id="get"   >
          <a href="#get" class="heading-link"><i class="fas fa-link"></i></a><a href="#get" class="headerlink" title="get"></a>get</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">   <span class="comment">// 调用getMap方法获取ThreadLocal</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//map是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//通过Map.getEntry传入获取entry</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果e不为空则返回e</span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//反之要么map为空要么enrty为空则调用setInitialValue() 初始化map</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="set"   >
          <a href="#set" class="heading-link"><i class="fas fa-link"></i></a><a href="#set" class="headerlink" title="set"></a>set</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line"> 	<span class="comment">//获取当前ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//判断map是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//不为空说明初始化过 将调用map.set方法</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//为空说明还没有初始化 调用createMap方法</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="remove"   >
          <a href="#remove" class="heading-link"><i class="fas fa-link"></i></a><a href="#remove" class="headerlink" title="remove"></a>remove</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程下的ThreadLocalMap</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//如果map不为空则调用map.remove方法</span></span><br><span class="line">        m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="getMap"   >
          <a href="#getMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#getMap" class="headerlink" title="getMap"></a>getMap</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="comment">//返回当前线程下的threadLocals作为ThreadLocalMap  也即threadLocals==ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="Entry"   >
          <a href="#Entry" class="heading-link"><i class="fas fa-link"></i></a><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Entry模型也即K,V键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="setInitialValue"   >
          <a href="#setInitialValue" class="heading-link"><i class="fas fa-link"></i></a><a href="#setInitialValue" class="headerlink" title="setInitialValue"></a>setInitialValue</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//初始化map</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">//判断map不为空</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将调用set方法设置值</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//反之map为空则创建map</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="createMap"   >
          <a href="#createMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#createMap" class="headerlink" title="createMap"></a>createMap</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="ThreadLocal流程图"   >
          <a href="#ThreadLocal流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal流程图" class="headerlink" title="ThreadLocal流程图"></a>ThreadLocal流程图</h3>
      <p><strong>get方法</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811083859493.png"  alt="ThreadLocal.get">
      </p>
<p><strong>set方法</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811083920601.png"  alt="ThreadLocal.set">
      </p>
<p><strong>remove</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811084052561.png"  alt="Thread.remove">
      </p>
<p><strong>综上</strong></p>
<p>这ThreadLocal无论是get方法、set方法还是remove方法都是调用ThreadLocalMap中的方法，所以我们的关注重点应该是ThreadLocalMap</p>

        <h2 id="ThreadLocalMap源码"   >
          <a href="#ThreadLocalMap源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap源码" class="headerlink" title="ThreadLocalMap源码"></a>ThreadLocalMap源码</h2>
      <p><strong>成员变量</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//Entry数组</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"><span class="comment">//记录table容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="getEntry"   >
          <a href="#getEntry" class="heading-link"><i class="fas fa-link"></i></a><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">//获取threadLocalHashCode 然后与上table.length-1 目的是获取一个索引值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//通过table索引i 获取一个Entry对象e  Entry对象是Kv键值对</span></span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="comment">//如果e非空 且 e的值正好等于当前ThreadLocal那么就说明找到了我们要的Entry</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="comment">//返回entry</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//走到这里说明e为空或者e.get！=key 说明不是我们找的Entry</span></span><br><span class="line">        <span class="comment">//进入getEntryAfterMiss方法</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>getEntryAfterMiss</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123; </span><br><span class="line">    <span class="comment">//获取一个临时tab</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">	<span class="comment">//这里做循环 如果e==null 则会停止循环</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取ThreadLocal </span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="comment">//如果k==传入的ThreadLocal说明找到了 直接结束 返回e</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果k==null</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//反之k有值且k！=key 则继续循环</span></span><br><span class="line">            <span class="comment">//走到nextIndex方法 目的是当前指针指向下一个元素</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//运行到这里说明当前这次循环没有找到元素  索引往后移动了</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当e==null的时候结束循环 也即返回了null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>nextIndex</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="comment">//这里做了一个三元运算符 如果i+1&lt;len说明没有到数组最后一位</span></span><br><span class="line">    <span class="comment">//如果当前是最后一位元素，那么下一次从i要0开始  类似于指向循环数组</span></span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>expungeStaleEntry</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用这个方法是Entry存在 但是Entry的Key为null   传入参数为槽位i</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">	<span class="comment">//获取tab</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//因为当前tab[i].key==null 所以将value也置为null 并且将这个槽位置为null意味着清除出tab中</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//开始遍历  将i初始化为当前槽位的下一个位置，当下一个位置不为空的时候进入循环，循环结束i向后移动;</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        <span class="comment">//这个循环结束条件为e=tab[i]==null;</span></span><br><span class="line">        <span class="comment">//获取key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果k==null 那么说明这个也要做这个清空槽位移除出tab中</span></span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之重新做一遍hash</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果h！=i 说明是发生过哈希碰撞导致存入元素向后移动了</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">//将目标槽位清空</span></span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//然后判断hash值这个位置是否为空 如果不为空则继续向后找</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                <span class="comment">//直到找到一个为空的位置将e插入进去</span></span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个循环过程也就是 如果key为null 那么就将这个Entry移除数组中，然后开始遍历找当前位置之后有没有空位置，如果有空位置就将空位置清空，如果没有空位置那么就重新计算哈希值 重新排放一下，直到下一个位置Entry也为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="set-1"   >
          <a href="#set-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#set-1" class="headerlink" title="set"></a>set</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Entry数组</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//循环 将e指向table[i] ，当e不为空的时候进行循环，循环下一次e为当前位置的下一个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">//获取key</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果table[i]的key和当前key相同，那么则替换value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果k==null 那么就走replaceStableEntry方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束循环 e为空  </span></span><br><span class="line">    <span class="comment">//new一个新的Entry 将他放到索引i位置下</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">//容量++</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先清空部分槽位然后再判断清空之后size是不是还是大于阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>replaceStaleEntry</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Back up to check for prior stale entry in current run.</span></span><br><span class="line">    <span class="comment">// We clean out whole runs at a time to avoid continual</span></span><br><span class="line">    <span class="comment">// incremental rehashing due to garbage collector freeing</span></span><br><span class="line">    <span class="comment">// up refs in bunches (i.e., whenever the collector runs).</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来记录要清空的槽位</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">//将i置为上一个元素，往前遍历,当table[i]==null的时候结束循环,每次循环结束将i指向上一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="comment">//如果e的key==null  将这个位置标记成要清空的槽位</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find either the key or trailing null slot of run, whichever</span></span><br><span class="line">    <span class="comment">// occurs first</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将i置为下一个位置，往后遍历，当table[i]==null的时候结束循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we find key, then we need to swap it</span></span><br><span class="line">        <span class="comment">// with the stale entry to maintain hash table order.</span></span><br><span class="line">        <span class="comment">// The newly stale slot, or any other stale slot</span></span><br><span class="line">        <span class="comment">// encountered above it, can then be sent to expungeStaleEntry</span></span><br><span class="line">        <span class="comment">// to remove or rehash all of the other entries in run.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果k==key 那么说明找到了要找的变量</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">//覆盖e的值</span></span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前位置和进入的staleSlot位置做交换?</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start expunge at preceding stale entry if it exists</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果要清空槽位==staleSlot找到e.get==null的元素</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                <span class="comment">//将slotToExpuge=i;</span></span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">//清空槽位 cleanSomeSlots</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="comment">//结束方法</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we didn&#x27;t find stale entry on backward scan, the</span></span><br><span class="line">        <span class="comment">// first stale entry seen while scanning for key is the</span></span><br><span class="line">        <span class="comment">// first still present in the run.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果我们发现了k==null的Entry,并且要清空槽位依然等于第一个进来的槽位则将slotToExpunge设置为i</span></span><br><span class="line">        <span class="comment">//然后继续循环 直到找到Entry==null</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key not found, put new entry in stale slot</span></span><br><span class="line">    <span class="comment">//走到这个已经找到一个Entry==null</span></span><br><span class="line">    <span class="comment">//将新结点设置进去</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are any other stale entries in run, expunge them</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        <span class="comment">//清空槽位</span></span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>prevIndex</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">prevIndex</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p> cleanSomeSlots</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    		<span class="comment">//循环 </span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">                <span class="comment">//如果e!=null 并且e的key==null</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//清空i位置元素</span></span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//循环条件 当n=n无符号右移一位即除以2不为0 </span></span><br><span class="line">                <span class="comment">//即循环次数为log2n </span></span><br><span class="line">            &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    		<span class="comment">//返回是否删除元素</span></span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="remove-1"   >
          <a href="#remove-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#remove-1" class="headerlink" title="remove"></a>remove</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//当e不为空的时候遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">         e != <span class="literal">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">//如果e.key==key 则说明找到了要删除的entry</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">//将e清除出去</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">//清空槽位i以及i之后为空的位置</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="rehash"   >
          <a href="#rehash" class="heading-link"><i class="fas fa-link"></i></a><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h3>
      <p><strong>前面</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line"><span class="comment">//而这个threshold阈值是多少呢?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认是0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold; <span class="comment">// Default to 0  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//传入参数时候len==16  阈值为16*2/3也即为10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setThreshold</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>rehash</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//扩容前清空一次元素</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="comment">//再判断如果size&gt;= threshold-threshold/4就去扩容 也即size&gt;=3/4*threshold去扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>resize</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获得老数组</span></span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLen</span> <span class="operator">=</span> oldTab.length;</span><br><span class="line">    <span class="comment">//新数组长度为老数组两倍</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newLen</span> <span class="operator">=</span> oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> <span class="title class_">Entry</span>[newLen];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">       <span class="comment">//循环老数组</span></span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果e不为空</span></span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            	<span class="comment">//判断e.key是否为空 key如果为空则将value置为null</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">                e.value = <span class="literal">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//反之这里e.key有值 则重新计算一次hash值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果新数组的h位置有人则往后走 直到找到空位置存入e</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新的阈值设置成新数组长度的2/3 ;</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="ThreadLocalMap流程图"   >
          <a href="#ThreadLocalMap流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalMap流程图" class="headerlink" title="ThreadLocalMap流程图"></a>ThreadLocalMap流程图</h3>
      <p><strong>getEntry</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811091252041.png"  alt="ThreadLocalMap.getEntry">
      </p>
<p><strong>Set</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811090547958.png"  alt="ThreadLocalMap.set">
      </p>
<p><strong>remove</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811085405099.png"  alt="ThreadLocal.remove">
      </p>
<p><strong>rehash</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811084815487.png"  alt="rehash扩容流程图">
      </p>

        <h2 id="ThreadLocal内存泄漏问题"   >
          <a href="#ThreadLocal内存泄漏问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocal内存泄漏问题" class="headerlink" title="ThreadLocal内存泄漏问题"></a>ThreadLocal内存泄漏问题</h2>
      <p><strong>内存泄漏</strong> ：表示就是我们申请了内存,但是该内存一直无法释放; </p>
<p>内存泄漏会导致内存溢出问题: 申请内存时,发现申请内存不足,就会报错 </p>

        <h3 id="内存泄漏场景"   >
          <a href="#内存泄漏场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存泄漏场景" class="headerlink" title="内存泄漏场景"></a>内存泄漏场景</h3>
      <p>而ThreadLocal中有内存泄漏的风险，我们用一张图来表示他们之间的引用关系</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811182543145.png"  alt="ThreadLocal使用的引用关系">
      </p>
<p>因为Entry的Key是一个<strong>弱引用</strong>的关系，所以只要是发生了GC那么将没有强引用的情况下会将ThreadLocal给回收也即以下场景</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811182934063.png"  alt="弱引用GC之后">
      </p>
<p>而内存泄漏出现在哪里呢？是Entry因为Key为NULL 但是存放了一个Value为Object 所以有以下一个强引用关系</p>
<p>CurrentThreadREF  -&gt; currentThread -&gt; ThreadLocalMap-&gt;entry[KEY:NULL,Value:Object]  这个Entry<strong>无法访问且无法释放</strong>，所以这就是一个内存泄漏，只要线程没有销毁那么就会一直存在内存泄漏装填</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811183529082.png"  alt="image-20230811183529082">
      </p>

        <h3 id="一定会造成内存泄漏吗？"   >
          <a href="#一定会造成内存泄漏吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#一定会造成内存泄漏吗？" class="headerlink" title="一定会造成内存泄漏吗？"></a>一定会造成内存泄漏吗？</h3>
      <p>当弱引用销毁之后那么会存在一条强引用关系，那么这条强引用关系那么在<strong>当前线程销毁</strong>的时候，就能释放这个Entry也即不会造成内存泄漏。<strong>但是</strong>，线程是一个很重要的资源，我们创建和销毁线程都会浪费资源，所以我们用<strong>线程池来进行回收线程</strong>，所以线程的生命周期增加了，也即ThreadLocalMap的线程生命周期增加了。所以这个过程可能会产生内存泄漏问题</p>

        <h3 id="为什么用弱引用不用强引用？"   >
          <a href="#为什么用弱引用不用强引用？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么用弱引用不用强引用？" class="headerlink" title="为什么用弱引用不用强引用？"></a>为什么用弱引用不用强引用？</h3>
      <p>我们用两个图来描述<strong>假设用强引用</strong>的状况</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811184249053.png"  alt="强引用场景(1)">
      </p>
<p>假设此时ThreadLocalRef&#x3D;null，那么ThreadLocal本应该被GC回收</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230811184358056.png"  alt="强引用场景(2)">
      </p>
<p>因为ThreadLocal存在一条ThreadLocalMap的强引用关系，所以这个ThreadLocal无法被GC，这导致这个ThreadLocal一直占用内存中，那么产生了一个内存泄漏的问题 因为无法访问到ThreadLocal</p>
<p>所以我们用弱引用当ThreadLocal的强引用关系不在的时候GC就能将其回收</p>

        <h3 id="解决方案"   >
          <a href="#解决方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3>
      <p>1.我们每次用ThreadLocal结束调用remove方法，来删除Entry</p>
<p>2.我们将ThreadLocalRef引用ThreadLocal设置修饰符Static  Final  扩大作用域防止ThreadLocalRef引用ThreadLocal的强引用结束，这样就能保证ThreadLocal能一直存在</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/08/03/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B2-JMM%E3%80%81Volatile%E3%80%81Synchronized%5D/">深入剖析并发编程-JUC篇[2-JMM、Volatile、Synchronized]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-08-03</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">171分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p> <strong>JMM、Volatile关键字、Synchronized锁详解</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
</ul>
<hr>

        <h1 id="JMM模型"   >
          <a href="#JMM模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h1>
      <p>JMM：即Java内存模型，JMM是JVM的一部分，JMM是一种抽象的概念</p>

        <h2 id="JMM的三大特性"   >
          <a href="#JMM的三大特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#JMM的三大特性" class="headerlink" title="JMM的三大特性"></a>JMM的三大特性</h2>
      
        <h3 id="①原子性"   >
          <a href="#①原子性" class="heading-link"><i class="fas fa-link"></i></a><a href="#①原子性" class="headerlink" title="①原子性"></a>①原子性</h3>
      <p>对共享变量的读取和写入是原子操作，Read和Load是一组原子操作，Store和Write是原子操作</p>

        <h3 id="②有序性"   >
          <a href="#②有序性" class="heading-link"><i class="fas fa-link"></i></a><a href="#②有序性" class="headerlink" title="②有序性"></a>②有序性</h3>
      <p>StoreBuffer的先进先出性质保证了有序性</p>

        <h3 id="③可见性"   >
          <a href="#③可见性" class="heading-link"><i class="fas fa-link"></i></a><a href="#③可见性" class="headerlink" title="③可见性"></a>③可见性</h3>
      <p>内存屏障保证了可见性</p>
<p>而JMM中用Volatile关键字可以导致数据可见、除此之外synchronized锁也能保证</p>
<p>八种交互模式</p>
<ul>
<li><p>Lock （锁定）：锁定，将主内存中的变量锁定成当前线程持有</p>
</li>
<li><p>Read（读取）：将内存中的数据刷到工作区中</p>
</li>
<li><p>Load（加载）：将工作区的变量放到工作区的副本变量中</p>
</li>
<li><p>use  （使用）：将工作区的变量放到CPU执行区域</p>
</li>
<li><p>Assian（赋值）：将修改后的数据赋值给工作区的副本变量中</p>
</li>
<li><p>Store（存储）：将工作内存的变量刷到主内存中</p>
</li>
<li><p>Write（写入）:  将Store刷出的值写到主内存中</p>
</li>
<li><p>Unlock（解锁）：解锁，将锁释放以便其他线程可以使用</p>
<p><em>JMM</em>工作流程</p>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801192534473.png"  alt="JMM工作流程">
      </p>
<p>要注意的是，在JMM模型中没有Invalidate Queues，所以没有Load Load问题，只有Store Load的问题，</p>
<p>接下来我们重点介绍Volatile关键字和Synchronized锁</p>

        <h1 id="volatile关键字"   >
          <a href="#volatile关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1>
      <p>Volatile关键字可以导致共享变量的可见性，而我们通过JUC并发编程基础那块分析得出，当JMM的共享变量的可见性只要保证StoreBuffer的数据能刷到Cache中，就会因为MESI协议和嗅探机制更新其他线程的数据</p>
<p>综上所述，Valatile关键字就是确保StoreBuffer的数据能刷到Cache中，其作用的就是添加了屏障，这里添加的是编译器屏障</p>
<p>抛开代码谈理论无异于耍流氓，我们从一个程序开始看起！</p>

        <h2 id="使用场景"   >
          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2>
      
        <h3 id="场景一：没有添加volatile关键字"   >
          <a href="#场景一：没有添加volatile关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#场景一：没有添加volatile关键字" class="headerlink" title="场景一：没有添加volatile关键字"></a>场景一：没有添加volatile关键字</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="comment">//定义一个变量a，不给a赋值，初始化之后a应该是0</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重写Run方法 当a不为0X1111的时候进入循环</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0x1111</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程然后执行run方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>().start();</span><br><span class="line">        <span class="comment">//线程睡一秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将a赋值为0X1111</span></span><br><span class="line">        a=<span class="number">0x1111</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>运行结果是该线程没有结束
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801211011188.png"  alt="场景一结果">
      </p>

        <h3 id="场景二：添加了Volatile关键字"   >
          <a href="#场景二：添加了Volatile关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#场景二：添加了Volatile关键字" class="headerlink" title="场景二：添加了Volatile关键字"></a>场景二：添加了Volatile关键字</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="comment">//给a添加Volatile使其可见</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0x1111</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>().start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        a=<span class="number">0x1111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行结果是线程已经结束</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801211221395.png"  alt="场景二结果">
      </p>

        <h3 id="场景三：没加Volatile但是禁止JIT优化"   >
          <a href="#场景三：没加Volatile但是禁止JIT优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#场景三：没加Volatile但是禁止JIT优化" class="headerlink" title="场景三：没加Volatile但是禁止JIT优化"></a>场景三：没加Volatile但是禁止JIT优化</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">添加VM参数：-Djava.compiler=NONE  <span class="comment">//禁止JIT优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> a;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0x1111</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>().start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        a=<span class="number">0x1111</span>;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></div></figure>

<p>运行结果是线程已经结束
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801213142690.png"  alt="场景三结果">
      </p>

        <h3 id="场景四-没加Volatile但是加了Unsafe-loadFence"   >
          <a href="#场景四-没加Volatile但是加了Unsafe-loadFence" class="heading-link"><i class="fas fa-link"></i></a><a href="#场景四-没加Volatile但是加了Unsafe-loadFence" class="headerlink" title="场景四:没加Volatile但是加了Unsafe.loadFence();"></a>场景四:没加Volatile但是加了Unsafe.loadFence();</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0x1111</span>)&#123;</span><br><span class="line">            UnsafeUtils.getUnsafe().loadFence();</span><br><span class="line">            <span class="comment">//利用UnsafeUtils.getUnsafe()获得Unsafe实例</span></span><br><span class="line">            <span class="comment">//调用loadFence()方法 也就是添加了编译器屏障</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //读屏障	</span></span><br><span class="line"><span class="comment">    public native void loadFence();</span></span><br><span class="line"><span class="comment">	//写屏障</span></span><br><span class="line"><span class="comment">    public native void storeFence();</span></span><br><span class="line"><span class="comment">	//全屏障</span></span><br><span class="line"><span class="comment">    public native void fullFence();</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>().start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        a=<span class="number">0x1111</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>运行结果是线程已经结束
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801213734565.png"  alt="image-20230801213734565">
      </p>

        <h2 id="分析"   >
          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h2>
      <p>只有第一种情况下没有结束进程，我们可以通过JVM调优的指令可以获取当前执行的线程验证。</p>

        <h3 id="①获取运行中线程"   >
          <a href="#①获取运行中线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#①获取运行中线程" class="headerlink" title="①获取运行中线程"></a>①获取运行中线程</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>常见指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>jps</td>
<td>用于获得系统中运行中的java进程</td>
</tr>
<tr>
<td>jinfo <pid></td>
<td>显示指定线程的详情信息</td>
</tr>
<tr>
<td>jstat -gc <pid> (ms)</td>
<td>获得JVM各区域详情 参数一:指定进程号 参数二:每xx毫秒刷新输出</td>
</tr>
<tr>
<td>jstack <pid></td>
<td>跟踪线程中的堆栈信息</td>
</tr>
<tr>
<td>jmap -histo <pid></td>
<td>获得指定线程中实例对象个数和所占字节数<br/>#!!</td>
</tr>
</tbody></table></div>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801214538319.png"  alt="image-20230801214538319">
      </p>
<p>我们可以清楚看出TestThread线程Thread-0正在运行</p>

        <h3 id="②打印汇编语言"   >
          <a href="#②打印汇编语言" class="heading-link"><i class="fas fa-link"></i></a><a href="#②打印汇编语言" class="headerlink" title="②打印汇编语言"></a>②打印汇编语言</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly <span class="comment">//开启控制台输出汇编语言</span></span><br></pre></td></tr></table></div></figure>

<p>我们可以在打印出的汇编记录中，可以查找数据，看个大概就是先比较之后然后经过多次跳转之后，A指向B地址，B之后跳转会指向A地址，造成一个死循环</p>
<p>这是JIT在对热点代码的优化</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们的热点代码</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(a!=<span class="number">0x1111</span>)&#123;</span><br><span class="line"><span class="comment">//            UnsafeUtils.getUnsafe().loadFence();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//经过优化之后大概变成</span></span><br><span class="line">	<span class="keyword">do</span>(a!=<span class="number">0x1111</span>)&#123;</span><br><span class="line">		<span class="comment">//只做一次判断然后进入死循环</span></span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></div></figure>

<p>而加入Volatile关键字就是防止编译器对代码进行优化，且通过屏障将变量刷到Cache中</p>
<p><em>即Volatile&#x3D;&#x3D;UnsafeUtils.getUnsafe().loadFence()</em></p>
<p>我们可以从源代码这块开始看，首先获取字节码指令</p>

        <h3 id="③打印字节码指令"   >
          <a href="#③打印字节码指令" class="heading-link"><i class="fas fa-link"></i></a><a href="#③打印字节码指令" class="headerlink" title="③打印字节码指令"></a>③打印字节码指令</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用javaP -c 来输出字节码指令</span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230801235858520.png"  alt="image-20230801235858520">
      </p>
<p>可以知道调用的getstatic方法是主要关注的</p>
<p>我们打开HotSprot的源码查找getstatic方法</p>
<p>不过不会C++，只能看英文和上下文一点一点理解</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">CASE</span>(_getstatic):</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获得一个索引值</span></span><br><span class="line">      u2 index;</span><br><span class="line">        <span class="comment">//获取一个Cache</span></span><br><span class="line">      ConstantPoolCacheEntry* cache;</span><br><span class="line">        <span class="comment">//在这里看到了PC+1，所以合理猜测这个是index是程序计数器，然后计数器+1</span></span><br><span class="line">      index = Bytes::<span class="built_in">get_native_u2</span>(pc+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// QQQ Need to make this as inlined as possible. Probably need to</span></span><br><span class="line">      <span class="comment">// split all the bytecode cases out so c++ compiler has a chance</span></span><br><span class="line">      <span class="comment">// for constant prop to fold everything possible away.</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment">//从cp中获取一个entry放到Cache中</span></span><br><span class="line">      cache = cp-&gt;<span class="built_in">entry_at</span>(index);</span><br><span class="line">        <span class="comment">//如果这个没有被解析过 那就给他解析下</span></span><br><span class="line">      <span class="keyword">if</span> (!cache-&gt;<span class="built_in">is_resolved</span>((Bytecodes::Code)opcode)) &#123;</span><br><span class="line">        <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">resolve_get_put</span>(THREAD, (Bytecodes::Code)opcode),</span><br><span class="line">                handle_exception);</span><br><span class="line">        cache = cp-&gt;<span class="built_in">entry_at</span>(index);</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//总之走到这里Cache拿了一个值</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> VM_JVMTI</span></span><br><span class="line">        <span class="comment">//判断这个是不是一个中断事件，我们这里没有产生中断，所以不进这个IF语句</span></span><br><span class="line">          <span class="keyword">if</span> (_jvmti_interp_events) &#123;</span><br><span class="line">            <span class="type">int</span> *count_addr;</span><br><span class="line">            oop obj;</span><br><span class="line">            <span class="comment">// Check to see if a field modification watch has been set</span></span><br><span class="line">            <span class="comment">// before we take the time to call into the VM.</span></span><br><span class="line">            count_addr = (<span class="type">int</span> *)JvmtiExport::<span class="built_in">get_field_access_count_addr</span>();</span><br><span class="line">            <span class="keyword">if</span> ( *count_addr &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">              <span class="keyword">if</span> ((Bytecodes::Code)opcode == Bytecodes::_getstatic) &#123;</span><br><span class="line">                obj = (oop)<span class="literal">NULL</span>;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                obj = (oop) <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">VERIFY_OOP</span>(obj);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">post_field_access</span>(THREAD,</span><br><span class="line">                                          obj,</span><br><span class="line">                                          cache),</span><br><span class="line">                                          handle_exception);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* VM_JVMTI */</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得一个Object对象</span></span><br><span class="line">          oop obj;</span><br><span class="line">        <span class="comment">//如果这个是个静态对象那么就应该从静态区获取对象</span></span><br><span class="line">          <span class="keyword">if</span> ((Bytecodes::Code)opcode == Bytecodes::_getstatic) &#123;</span><br><span class="line">              <span class="comment">//获取了一个Klass ，理解成Class模板</span></span><br><span class="line">            Klass* k = cache-&gt;<span class="built_in">f1_as_klass</span>();</span><br><span class="line">              <span class="comment">//将k的指向的静态对象给obj</span></span><br><span class="line">            obj = k-&gt;<span class="built_in">java_mirror</span>();</span><br><span class="line">            <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);  <span class="comment">// Assume single slot push</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//反之这个是个实例对象，那么从Stack栈中的对象引用到堆里的对象取出给obj</span></span><br><span class="line">            obj = (oop) <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">              <span class="comment">//检查这个OBJ是否为空</span></span><br><span class="line">            <span class="built_in">CHECK_NULL</span>(obj);</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//上面这块步骤主要是拿到一个OBJ对象</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 现在存结果在这个栈中</span></span><br><span class="line">          <span class="comment">// Now store the result on the stack</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得了一个状态</span></span><br><span class="line">          TosState tos_type = cache-&gt;<span class="built_in">flag_state</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得一个偏移量</span></span><br><span class="line">          <span class="type">int</span> field_offset = cache-&gt;<span class="built_in">f2_as_index</span>();</span><br><span class="line">        <span class="comment">//如果这个cache是volatile修饰的</span></span><br><span class="line">          <span class="keyword">if</span> (cache-&gt;<span class="built_in">is_volatile</span>()) &#123;</span><br><span class="line">              <span class="comment">//CPU_NOT_MULTIPLE_COPY_ATOMIC  现在是单原子的就执行Fence() 即屏障</span></span><br><span class="line">            <span class="keyword">if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) &#123;</span><br><span class="line">              OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//判断现在是个什么类型 我们现在传入的是Int类型数据 所以直接进入int_field_acquire</span></span><br><span class="line">            <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">              <span class="built_in">VERIFY_OOP</span>(obj-&gt;<span class="built_in">obj_field_acquire</span>(field_offset));</span><br><span class="line">              <span class="built_in">SET_STACK_OBJECT</span>(obj-&gt;<span class="built_in">obj_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">                <span class="comment">//我们要进入这个分支</span></span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">int_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ltos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_LONG</span>(obj-&gt;<span class="built_in">long_field_acquire</span>(field_offset), <span class="number">0</span>);</span><br><span class="line">              <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == btos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">byte_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ctos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">char_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == stos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">short_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ftos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_FLOAT</span>(obj-&gt;<span class="built_in">float_field_acquire</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_DOUBLE</span>(obj-&gt;<span class="built_in">double_field_acquire</span>(field_offset), <span class="number">0</span>);</span><br><span class="line">              <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//走到这里即说明这个类型不是被volatile修饰</span></span><br><span class="line">            <span class="keyword">if</span> (tos_type == atos) &#123;</span><br><span class="line">              <span class="built_in">VERIFY_OOP</span>(obj-&gt;<span class="built_in">obj_field</span>(field_offset));</span><br><span class="line">              <span class="built_in">SET_STACK_OBJECT</span>(obj-&gt;<span class="built_in">obj_field</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == itos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">int_field</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ltos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_LONG</span>(obj-&gt;<span class="built_in">long_field</span>(field_offset), <span class="number">0</span>);</span><br><span class="line">              <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == btos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">byte_field</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ctos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">char_field</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == stos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_INT</span>(obj-&gt;<span class="built_in">short_field</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tos_type == ftos) &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_FLOAT</span>(obj-&gt;<span class="built_in">float_field</span>(field_offset), <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">SET_STACK_DOUBLE</span>(obj-&gt;<span class="built_in">double_field</span>(field_offset), <span class="number">0</span>);</span><br><span class="line">              <span class="built_in">MORE_STACK</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新计数器然后继续</span></span><br><span class="line">          <span class="built_in">UPDATE_PC_AND_CONTINUE</span>(<span class="number">3</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们要走到int_field_acquire方法的实现</span></span><br><span class="line"><span class="comment">//而int_field_acquire底层调用了Load_acquire方法</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>这里可能是因为我的原因导致这一块代码找不到，我选择从网上找了一下老版本的代码 不过实现思路应该是一样的</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">compiler_barrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;&quot;</span> : : : <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::loadload</span><span class="params">()</span>   </span>&#123; <span class="built_in">compiler_barrier</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::storestore</span><span class="params">()</span> </span>&#123;<span class="built_in">compiler_barrier</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::loadstore</span><span class="params">()</span>  </span>&#123; <span class="built_in">compiler_barrier</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::storeload</span><span class="params">()</span>  </span>&#123; <span class="built_in">fence</span>();            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::acquire</span><span class="params">()</span>    </span>&#123; <span class="built_in">compiler_barrier</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::release</span><span class="params">()</span>    </span>&#123; <span class="built_in">compiler_barrier</span>(); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">OrderAccess::fence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(os::<span class="built_in">is_MP</span>()) &#123;</span><br><span class="line">    <span class="comment">//always use locked addl since mfence is sometimes expensive</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AMD64</span></span><br><span class="line">   <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%rsp)&quot;</span> : : :<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">   <span class="function">__asm__ <span class="title">volatile</span> <span class="params">(<span class="string">&quot;lock; addl $0,0(%%esp)&quot;</span> : : :<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in">compiler_barrier</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/w329636271/article/details/54616543/" >后面这块代码来源于CSDN博主</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>在底层是通过加屏障的方式实现这个数据的可见性</p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      <p>Volatile关键字实现数据的可见性主要是依靠了加编译器屏障，防止JIT对其优化。最终可以导致数据的</p>

        <h1 id="Synchronized锁"   >
          <a href="#Synchronized锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#Synchronized锁" class="headerlink" title="Synchronized锁"></a>Synchronized锁</h1>
      <p>首先我们得先明白对象的构成，以及Synchronized锁的类型</p>

        <h2 id="Object对象以及锁的级别"   >
          <a href="#Object对象以及锁的级别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Object对象以及锁的级别" class="headerlink" title="Object对象以及锁的级别"></a>Object对象以及锁的级别</h2>
      <p>Object对象在存储的时候有<strong>对象头信息</strong>、<strong>数据</strong>、对齐填充信息</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230802160057306.png"  alt="Object对象">
      </p>
<p>而对象头信息 我们可以从源码中获取得知对象头信息是怎么组成的，我们这里主要关注64位的</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  32 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//             hash:25 ------------&gt;| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//             size:32 ------------------------------------------&gt;| (CMS free block)</span></span><br><span class="line"><span class="comment">//             PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  64 bits:</span></span><br><span class="line"><span class="comment">//  --------</span></span><br><span class="line"><span class="comment">//  unused:25 hash:31 --&gt;| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class="line"><span class="comment">//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class="line"><span class="comment">//  PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span></span><br><span class="line"><span class="comment">//  size:64 -----------------------------------------------------&gt;| (CMS free block)</span></span><br></pre></td></tr></table></div></figure>

<p>共六十四位</p>
<ul>
<li><p>25位无使用位</p>
</li>
<li><p>31位哈希</p>
</li>
<li><p>1位是否被使用标记</p>
</li>
<li><p>4位age</p>
</li>
<li><p>1位是否为偏向锁</p>
</li>
<li><p>2位锁状态</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230802162051207.png"  alt="对象头">
      </p>
</li>
</ul>
<p>接下来就是synchronized锁的级别</p>
<p>一共有四个状态 ，而对象头中有3位来表示锁的信息 一位偏向锁标志位，两位表示锁状态</p>
<ul>
<li>无锁：在对象头信息为0 01</li>
<li>偏向锁：在对象头信息为 1 01，偏向锁是当锁没有竞争压力的时候并且多次由同一个线程获取，为了减少多次CAS的操作就引入了偏向锁，偏向锁会偏向获得它的第一个线程，类似于初恋。</li>
<li>轻量级锁：在对象头信息为 0 00，轻量级锁是获得锁的时候一开始就会获得一个轻量级锁，升级为轻量级锁的时候会撤销偏向锁，当获取轻量级锁失败之后会自旋(自适应自旋)，如果CAS失败会走轻量级锁升级的过程</li>
<li>重量级锁：在对象头信息为 1 10，重量级锁是经过锁升级之后也就是我们常说的锁，重量级锁是竞争激烈的锁，重量级锁中有一个cxq阻塞队列，当线程获取锁失败后会进阻塞队列等待</li>
</ul>
<div class="table-container"><table>
<thead>
<tr>
<th>锁级别</th>
<th>是否为偏向锁</th>
<th>锁状态</th>
</tr>
</thead>
<tbody><tr>
<td>无锁态</td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td></td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td></td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>11</td>
</tr>
</tbody></table></div>
<p>接下来我们要从代码开始分析了</p>
<p>一个很简单的程序，主要是添加了Synchronzied锁，这样的话就能从字节码文件中获取信息</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThread</span> <span class="keyword">extends</span>  <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TestThread</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>用JavaP -C反编译获得字节码信息</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用javaP -c 来输出字节码指令</span><br></pre></td></tr></table></div></figure>

<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void run();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #3                  // String hello</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      12: aload_1</span><br><span class="line">      13: monitorexit</span><br><span class="line">      14: goto          22</span><br><span class="line">      17: astore_2</span><br><span class="line">      18: aload_1</span><br><span class="line">      19: monitorexit</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: athrow</span><br><span class="line">      22: return</span><br></pre></td></tr></table></div></figure>

<p>而重点要关注的是monitorenter和monitorexit</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3: monitorenter</span><br><span class="line">13: monitorexit</span><br><span class="line">19: monitorexit</span><br></pre></td></tr></table></div></figure>

<p>一次Monitorenter怎么会出现两次monitorexit呢？</p>
<p>原因是第二个monitorexit在finally代码块中，防止出现异常导致没有到达第一个monitorexit</p>
<p>而接下来我们要先进去看monitorenter方法</p>

        <h2 id="monitorenter"   >
          <a href="#monitorenter" class="heading-link"><i class="fas fa-link"></i></a><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">CASE</span>(_monitorenter): &#123;</span><br><span class="line">     <span class="comment">//1.从栈中获取一个对象lockee</span></span><br><span class="line">        oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// derefing&#x27;s lockee ought to provoke implicit null check</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">//检查这个lockee是否为空</span></span><br><span class="line">        <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">        <span class="comment">// find a free monitor or one already allocated for this object</span></span><br><span class="line">        <span class="comment">// if we find a matching object then we need a new monitor</span></span><br><span class="line">        <span class="comment">// since this is recursive enter</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//获取BasicObjectLock指针 指向的是线程内所有的monitor</span></span><br><span class="line">     <span class="comment">//limit 指向栈顶 ， most_recent指的是栈底 entry用来存放找到的monitor对象</span></span><br><span class="line">        BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">        BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">        BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     <span class="comment">//当limit和most_recent不指向同一个Monitor的时候进入循环</span></span><br><span class="line">     <span class="comment">//这个循环目的是找到一个可用的monitor或者发现这个锁被一个monitor监视了</span></span><br><span class="line">        <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">            <span class="comment">//判断monitor的obj是否为空 如果是空则把它放到entry中</span></span><br><span class="line">          <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == lockee) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果monitor的obj不为空且obj为lockee时跳出循环</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//否则没有找到一个可用的monitor，栈尾指针向栈顶移动</span></span><br><span class="line">          most_recent++;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//如果循环结束 entry不为空的话则说明找到了一个可用的monitor</span></span><br><span class="line">        <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//这里是找到了一个monitor</span></span><br><span class="line">            <span class="comment">//将entry指向lockee</span></span><br><span class="line">          entry-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">            </span><br><span class="line">          <span class="type">int</span> success = <span class="literal">false</span>;</span><br><span class="line">          <span class="type">uintptr_t</span> epoch_mask_in_place = (<span class="type">uintptr_t</span>)markOopDesc::epoch_mask_in_place;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录lockee的头信息</span></span><br><span class="line">          markOop mark = lockee-&gt;<span class="built_in">mark</span>();</span><br><span class="line">            <span class="comment">//获得一个hash值</span></span><br><span class="line">          <span class="type">intptr_t</span> hash = (<span class="type">intptr_t</span>) markOopDesc::no_hash;</span><br><span class="line">          <span class="comment">// implies UseBiasedLocking</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断头信息中是否有bias_pattern 即是否是偏向锁  如果是偏向锁那么进入下面[1]过程，反之进入[2]过程</span></span><br><span class="line">          <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">              <span class="comment">/*[1]过程：现在是一个偏向锁*/</span></span><br><span class="line">              <span class="comment">/*进入这个语句中说明已经是偏向锁状态:</span></span><br><span class="line"><span class="comment">              有四种情况：</span></span><br><span class="line"><span class="comment">              		①：偏向本线程</span></span><br><span class="line"><span class="comment">              		②：要撤销偏向锁(可能变成轻量级锁或者重量级锁)</span></span><br><span class="line"><span class="comment">              		③：不偏向本线程，要重偏向到本线程</span></span><br><span class="line"><span class="comment">              		④：是匿名偏向锁</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">              <span class="comment">//声明变量线程id</span></span><br><span class="line">            <span class="type">uintptr_t</span> thread_ident;</span><br><span class="line">            <span class="type">uintptr_t</span> anticipated_bias_locking_value;</span><br><span class="line">              <span class="comment">//将线程id记录下来</span></span><br><span class="line">            thread_ident = (<span class="type">uintptr_t</span>)istate-&gt;<span class="built_in">thread</span>();</span><br><span class="line">              </span><br><span class="line">              <span class="comment">//通过计算获得一个偏向锁的值</span></span><br><span class="line">            anticipated_bias_locking_value =</span><br><span class="line">              (((<span class="type">uintptr_t</span>)lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | thread_ident) ^ (<span class="type">uintptr_t</span>)mark) &amp;</span><br><span class="line">              ~((<span class="type">uintptr_t</span>) markOopDesc::age_mask_in_place);</span><br><span class="line">	</span><br><span class="line">    		<span class="comment">/*情况①偏向本线程*/</span> </span><br><span class="line">              </span><br><span class="line">              <span class="comment">//这个值==0的话那么就认为是已经偏向本线程  那就什么都不做 将success设置为true返回</span></span><br><span class="line">              <span class="comment">//可以理解成偏向锁的重入</span></span><br><span class="line">            <span class="keyword">if</span>  (anticipated_bias_locking_value == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// already biased towards this thread, nothing to do</span></span><br><span class="line">              <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">                (* BiasedLocking::<span class="built_in">biased_lock_entry_count_addr</span>())++;</span><br><span class="line">              &#125;</span><br><span class="line">              success = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">/*情况②要撤销偏向锁*/</span> </span><br><span class="line">              </span><br><span class="line">            <span class="comment">//反之，判断是否要撤销偏向，说明这个锁很可能是变成了轻量级锁或者重量级锁</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//尝试撤销偏向</span></span><br><span class="line">              <span class="comment">// try revoke bias</span></span><br><span class="line">                <span class="comment">//通过klass模板找到一个纯净的头信息</span></span><br><span class="line">              markOop header = lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">                </span><br><span class="line">              <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">                  <span class="comment">//给header设置一个hash值</span></span><br><span class="line">                header = header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">              &#125;</span><br><span class="line">                <span class="comment">//cas操作，撤销偏向</span></span><br><span class="line">              <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">                  <span class="comment">//撤销偏向成功</span></span><br><span class="line">                <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">                  (*BiasedLocking::<span class="built_in">revoked_lock_entry_count_addr</span>())++;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">/*③：不偏向本线程，要重偏向到本线程*/</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">//不是偏向本线程，那判断是否要重新偏向</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=<span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//尝试重新偏向</span></span><br><span class="line">              <span class="comment">// try rebias</span></span><br><span class="line">                <span class="comment">//获得一个头信息给新头</span></span><br><span class="line">              markOop new_header = (markOop) ( (<span class="type">intptr_t</span>) lockee-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>() | thread_ident);</span><br><span class="line">              <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">                  <span class="comment">//给新头设置哈希值</span></span><br><span class="line">                new_header = new_header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">              &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//CAS操作 ，重新偏向</span></span><br><span class="line">              <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="type">void</span>*)new_header, lockee-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">                  <span class="comment">//CAS成功，已经偏向本线程</span></span><br><span class="line">                <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">                  (* BiasedLocking::<span class="built_in">rebiased_lock_entry_count_addr</span>())++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//反之没有重偏向成功，进入锁膨胀方法</span></span><br><span class="line">                <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">              &#125;</span><br><span class="line">                <span class="comment">//加锁成功</span></span><br><span class="line">              success = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*④：是匿名偏向锁*/</span></span><br><span class="line">                </span><br><span class="line">              <span class="comment">// try to bias towards thread in case object is anonymously biased</span></span><br><span class="line">              markOop header = (markOop) ((<span class="type">uintptr_t</span>) mark &amp; ((<span class="type">uintptr_t</span>)markOopDesc::biased_lock_mask_in_place |(<span class="type">uintptr_t</span>)markOopDesc::age_mask_in_place |</span><br><span class="line">epoch_mask_in_place));</span><br><span class="line">                <span class="comment">//获得一个头信息 ，然后判断是否给头信息设置hash值</span></span><br><span class="line">              <span class="keyword">if</span> (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">                header = header-&gt;<span class="built_in">copy_set_hash</span>(hash);</span><br><span class="line">              &#125;</span><br><span class="line">                <span class="comment">//将头信息与线程id异或之后给new_header</span></span><br><span class="line">              markOop new_header = (markOop) ((<span class="type">uintptr_t</span>) header | thread_ident);</span><br><span class="line">              <span class="comment">// debugging hint</span></span><br><span class="line">              <span class="built_in">DEBUG_ONLY</span>(entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>((markOop) (<span class="type">uintptr_t</span>) <span class="number">0xdeaddead</span>);)</span><br><span class="line">                  <span class="comment">//CAS操作 将匿名偏向锁偏向本线程</span></span><br><span class="line">              <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span>((<span class="type">void</span>*)new_header, lockee-&gt;<span class="built_in">mark_addr</span>(), header) == header) &#123;</span><br><span class="line">                  <span class="comment">//加锁成功也就是匿名偏向锁偏向本线程</span></span><br><span class="line">                <span class="keyword">if</span> (PrintBiasedLockingStatistics)</span><br><span class="line">                  (* BiasedLocking::<span class="built_in">anonymously_biased_lock_entry_count_addr</span>())++;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">//反之尝试匿名偏向锁加锁失败，说明有竞争需要进行锁膨胀</span></span><br><span class="line">                <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">              &#125;</span><br><span class="line">              success = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">		<span class="comment">/*下面是[2]过程，说明这个锁不是偏向锁*/</span>  </span><br><span class="line">          <span class="comment">// traditional lightweight locking</span></span><br><span class="line">            <span class="comment">//只能是轻量级锁或者是重量级锁</span></span><br><span class="line">          <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">              <span class="comment">//将lockee设置成无锁状态</span></span><br><span class="line">            markOop displaced = lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">set_unlocked</span>();</span><br><span class="line">              <span class="comment">//将entry的lock也设置成无锁 </span></span><br><span class="line">            entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(displaced);</span><br><span class="line">              <span class="comment">//是否使用重量级锁(即不用轻量级锁和偏向锁，默认为Flase)，如果禁用了则Call_vm为true</span></span><br><span class="line">            <span class="type">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">            <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(entry, lockee-&gt;<span class="built_in">mark_addr</span>(), displaced) != displaced) &#123;</span><br><span class="line">                <span class="comment">/*场景1：禁用了轻量级锁，那么进入下面的判断 ！call_vm为false 直接走到else中 进行一个升级到重量级锁</span></span><br><span class="line"><span class="comment">               	  场景2:如果是默认则Call_vm为false ，那么会进行一个轻量级锁加锁CAS过程， 如果加锁失败会进行锁膨胀升级到重量级锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">              <span class="comment">// Is it simple recursive case?</span></span><br><span class="line">                <span class="comment">//判断是否这个锁是轻量级锁重入，如果是把Lock设置为null</span></span><br><span class="line">              <span class="keyword">if</span> (!call_vm &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) displaced-&gt;<span class="built_in">clear_lock_bits</span>())) &#123;</span><br><span class="line">                entry-&gt;<span class="built_in">lock</span>()-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorenter</span>(THREAD, entry), handle_exception);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          istate-&gt;<span class="built_in">set_msg</span>(more_monitors);</span><br><span class="line">          <span class="built_in">UPDATE_PC_AND_RETURN</span>(<span class="number">0</span>); <span class="comment">// Re-execute</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></div></figure>

<p>这里是上面没有详细说到的东西</p>

        <h3 id="①basicObjectLock-记录了锁和持有锁的对象"   >
          <a href="#①basicObjectLock-记录了锁和持有锁的对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#①basicObjectLock-记录了锁和持有锁的对象" class="headerlink" title="①basicObjectLock:记录了锁和持有锁的对象"></a>①basicObjectLock:记录了锁和持有锁的对象</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicObjectLock</span> VALUE_OBJ_CLASS_SPEC &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BasicLock _lock;                                    <span class="comment">// the lock, must be double word aligned</span></span><br><span class="line">  oop       _obj;                                     <span class="comment">// object holds the lock;</span></span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230802193545800.png"  alt="BasicObjectLock">
      </p>

        <h3 id="②Atomic-cmpxchg-ptr-exchange-value-dest-compare-value"   >
          <a href="#②Atomic-cmpxchg-ptr-exchange-value-dest-compare-value" class="heading-link"><i class="fas fa-link"></i></a><a href="#②Atomic-cmpxchg-ptr-exchange-value-dest-compare-value" class="headerlink" title="②Atomic::cmpxchg_ptr(exchange_value,  dest, compare_value)"></a>②Atomic::cmpxchg_ptr(exchange_value,  dest, compare_value)</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CAS操作 参数1:想要改变的值</span><br><span class="line">	    参数2:目的地址</span><br><span class="line">	    参数3:用于比较的旧值</span><br><span class="line">返回结果如果CAS成功则返回期望值(参数3)</span><br><span class="line">		  CAS失败则返回要改变的值(参数1)</span><br></pre></td></tr></table></div></figure>


        <h3 id="③匿名偏向锁"   >
          <a href="#③匿名偏向锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#③匿名偏向锁" class="headerlink" title="③匿名偏向锁"></a>③匿名偏向锁</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230802211243380.png"  alt="匿名偏向锁">
      </p>

        <h3 id="④轻量级锁"   >
          <a href="#④轻量级锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#④轻量级锁" class="headerlink" title="④轻量级锁"></a>④轻量级锁</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230802211843053.png"  alt="轻量级锁">
      </p>

        <h3 id="⑤偏向锁加锁流程图"   >
          <a href="#⑤偏向锁加锁流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#⑤偏向锁加锁流程图" class="headerlink" title="⑤偏向锁加锁流程图"></a>⑤偏向锁加锁流程图</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230802203659004.png"  alt="偏向锁加锁流程">
      </p>

        <h2 id="锁膨胀-InterpreterRuntime-monitorenter"   >
          <a href="#锁膨胀-InterpreterRuntime-monitorenter" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁膨胀-InterpreterRuntime-monitorenter" class="headerlink" title="锁膨胀(InterpreterRuntime::monitorenter)"></a>锁膨胀(InterpreterRuntime::monitorenter)</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//------------------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Synchronization</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The interpreter&#x27;s synchronization code is factored out so that it can</span></span><br><span class="line"><span class="comment">// be shared by method invocation and synchronized blocks.</span></span><br><span class="line"><span class="comment">//%note synchronization_3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//%note monitor_1</span></span><br><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="type">void</span>, InterpreterRuntime::<span class="built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::<span class="built_in">inc</span>(BiasedLocking::<span class="built_in">slow_path_entry_count_addr</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 将thread和 BasicObjectLock封装到h_obj中</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否使用了偏向锁</span></span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">      <span class="comment">//是使用了偏向锁，所以要撤销偏向锁，走到fast_entry中</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//没有使用偏向锁，进入Slow_enter</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(elem-&gt;<span class="built_in">obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">IRT_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="fast-entry"   >
          <a href="#fast-entry" class="heading-link"><i class="fas fa-link"></i></a><a href="#fast-entry" class="headerlink" title="fast_entry"></a>fast_entry</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	传入参数1：obj ：(封装有线程ID和BasicObjectLock)</span></span><br><span class="line"><span class="comment">	    参数2：lock ：BaiscObjectLock中的Lock</span></span><br><span class="line"><span class="comment">		参数3：attempt_rebias : True,先不用管</span></span><br><span class="line"><span class="comment">		参数4：TRAPS: check</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//是否用了偏向锁</span></span><br><span class="line">    <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    	<span class="comment">//用了偏向锁，是否到达线程安全点</span></span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">        <span class="comment">//没到达线程安全点，调用方法revoke_and_rebias撤销锁并且重偏向</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">          <span class="comment">//如果撤销锁了并且重偏向了直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//到达了线程安全点</span></span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">        <span class="comment">//线程安全点撤销偏向锁</span></span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//进入Slow_enter方法</span></span><br><span class="line"> <span class="built_in">slow_enter</span> (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="revoke-and-rebias"   >
          <a href="#revoke-and-rebias" class="heading-link"><i class="fas fa-link"></i></a><a href="#revoke-and-rebias" class="headerlink" title="revoke_and_rebias"></a>revoke_and_rebias</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数1：obj ：封装有线程ID和BasicObjectLock)</span></span><br><span class="line"><span class="comment">	参数2：attempt_rebias，传入的True</span></span><br><span class="line"><span class="comment">	参数3：TRAPS: check</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must not be called while at safepoint&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We can revoke the biases of anonymously-biased objects</span></span><br><span class="line">  <span class="comment">// efficiently enough that we should not cause these revocations to</span></span><br><span class="line">  <span class="comment">// update the heuristics because doing so may cause unwanted bulk</span></span><br><span class="line">  <span class="comment">// revocations (which are expensive) to occur.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得头信息</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">    <span class="comment">//因为attempt_rebias==true，所以这个判断可以不走</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">      <span class="comment">//判断这个锁是否是匿名偏向，如果是匿名偏向且不需要重偏向则撤销偏向锁</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// We are probably trying to revoke the bias of this object due to</span></span><br><span class="line">    <span class="comment">// an identity hash code computation. Try to revoke the bias</span></span><br><span class="line">    <span class="comment">// without a safepoint. This is possible if we can successfully</span></span><br><span class="line">    <span class="comment">// compare-and-exchange an unbiased header into the mark word of</span></span><br><span class="line">    <span class="comment">// the object, meaning that no other thread has raced to acquire</span></span><br><span class="line">    <span class="comment">// the bias of the object.</span></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">    markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//直接进入下面的判断中，判断是否是偏向锁</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="comment">//是偏向锁</span></span><br><span class="line">      <span class="comment">//取到Klass 为k</span></span><br><span class="line">      <span class="comment">//k取到纯净的头信息</span></span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">        <span class="comment">//如果原始的头是不是偏向锁</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// This object has a stale bias from before the bulk revocation</span></span><br><span class="line">      <span class="comment">// for this data type occurred. It&#x27;s pointless to update the</span></span><br><span class="line">      <span class="comment">// heuristics at this point so simply update the header with a</span></span><br><span class="line">      <span class="comment">// CAS. If we fail this race, the object&#x27;s bias has been revoked</span></span><br><span class="line">      <span class="comment">// by another thread so we simply return and let the caller deal</span></span><br><span class="line">      <span class="comment">// with it.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将锁头Lock改成无锁状态，然后返回BIAS_REVOKED状态(已经撤销偏向)</span></span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(prototype_header, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">      <span class="built_in">assert</span>(!(*(obj-&gt;<span class="built_in">mark_addr</span>()))-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;even if we raced, should still be revoked&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">        <span class="comment">//判断这个Epoch数据，判断是否被其他线程修改过，如果修改过那么这个偏向锁无效(过期)</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">// The epoch of this biasing has expired indicating that the</span></span><br><span class="line">      <span class="comment">// object is effectively unbiased. Depending on whether we need</span></span><br><span class="line">      <span class="comment">// to rebias or revoke the bias of this object we can do it</span></span><br><span class="line">      <span class="comment">// efficiently enough with a CAS that we shouldn&#x27;t update the</span></span><br><span class="line">      <span class="comment">// heuristics. This is normally done in the assembly code but we</span></span><br><span class="line">      <span class="comment">// can reach this point due to various points in the runtime</span></span><br><span class="line">      <span class="comment">// needing to revoke biases.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否需要重偏向，我们这传入的数据是true所以需要重偏向</span></span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//CAS操作将锁重新偏向</span></span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(rebiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">            <span class="comment">//撤销后且重新偏向成功 返回BIAS_REVOKED_AND_REBIASED</span></span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//这不需要重新偏向</span></span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">          <span class="comment">//CAS将头信息设置为无锁状态</span></span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">            <span class="comment">//将锁头Lock改成无锁状态，然后返回BIAS_REVOKED状态(已经撤销偏向)</span></span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//走到这里说明不是匿名偏向、偏向锁撤销且重偏向撤销失败、偏向锁撤销失败</span></span><br><span class="line"> HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断这个锁是否是偏向状态</span></span><br><span class="line">  <span class="keyword">if</span> (heuristics == HR_NOT_BIASED) &#123;</span><br><span class="line">      <span class="comment">//这个锁不是偏向状态</span></span><br><span class="line">    <span class="keyword">return</span> NOT_BIASED;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">      <span class="comment">//反之 这个锁是个偏向锁，判断是否单例撤销</span></span><br><span class="line">    Klass *k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">biased_locker</span>() == THREAD &amp;&amp;</span><br><span class="line">        prototype_header-&gt;<span class="built_in">bias_epoch</span>() == mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="comment">// A thread is trying to revoke the bias of an object biased</span></span><br><span class="line">      <span class="comment">// toward it, again likely due to an identity hash code</span></span><br><span class="line">      <span class="comment">// computation. We can again avoid a safepoint in this case</span></span><br><span class="line">      <span class="comment">// since we are only going to walk our own stack. There are no</span></span><br><span class="line">      <span class="comment">// races with revocations occurring in other threads because we</span></span><br><span class="line">      <span class="comment">// reach no safepoints in the revocation path.</span></span><br><span class="line">      <span class="comment">// Also check the epoch because even if threads match, another thread</span></span><br><span class="line">      <span class="comment">// can come in with a CAS to steal the bias of an object that has a</span></span><br><span class="line">      <span class="comment">// stale epoch.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断是否是当前持锁线程进行锁撤销</span></span><br><span class="line">      ResourceMark rm;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias by walking my own stack:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用revoke_bias方法进行撤销锁 返回一个cond(撤销的状态字)</span></span><br><span class="line">      BiasedLocking::Condition cond = <span class="built_in">revoke_bias</span>(<span class="built_in">obj</span>(), <span class="literal">false</span>, <span class="literal">false</span>, (JavaThread*) THREAD);</span><br><span class="line">      ((JavaThread*) THREAD)-&gt;<span class="built_in">set_cached_monitor_info</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">assert</span>(cond == BIAS_REVOKED, <span class="string">&quot;why not?&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cond;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//当前线程已经死了</span></span><br><span class="line">        <span class="comment">//交给虚拟机去进行一个锁撤销</span></span><br><span class="line">      VM_RevokeBias <span class="built_in">revoke</span>(&amp;obj, (JavaThread*) THREAD);</span><br><span class="line">      VMThread::<span class="built_in">execute</span>(&amp;revoke);</span><br><span class="line">      <span class="keyword">return</span> revoke.<span class="built_in">status_code</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//走到这里说明需要进行一个批量撤销</span></span><br><span class="line">  <span class="built_in">assert</span>((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">  <span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line">  VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br><span class="line">  <span class="keyword">return</span> bulk_revoke.<span class="built_in">status_code</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="revoke-bias"   >
          <a href="#revoke-bias" class="heading-link"><i class="fas fa-link"></i></a><a href="#revoke-bias" class="headerlink" title="revoke_bias"></a>revoke_bias</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	传入 参数1：obj ：(封装有线程ID和BasicObjectLock)</span></span><br><span class="line"><span class="comment">		参数2：是否允  许重偏向，False</span></span><br><span class="line"><span class="comment">		参数3：是否是批处理，False</span></span><br><span class="line"><span class="comment">		参数4：线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> BiasedLocking::Condition <span class="title">revoke_bias</span><span class="params">(oop obj, <span class="type">bool</span> allow_rebias, <span class="type">bool</span> is_bulk, JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得对象头信息</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否是偏向状态</span></span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果允许跟踪偏向锁 我们默认是false就不走这个</span></span><br><span class="line">    <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">      ResourceMark rm;</span><br><span class="line">      tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;  (Skipping revocation of object of type %s because it&#x27;s no longer biased)&quot;</span>,</span><br><span class="line">                    obj-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//到这里说明没有偏向直接返回NOT_BIASED</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//获得锁的年龄</span></span><br><span class="line">  uint age = mark-&gt;<span class="built_in">age</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得一个锁的对象头</span></span><br><span class="line">  markOop   biased_prototype = markOopDesc::<span class="built_in">biased_locking_prototype</span>()-&gt;<span class="built_in">set_age</span>(age);</span><br><span class="line">    <span class="comment">//获得一个无锁的对象头</span></span><br><span class="line">  markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上默认不允许跟踪偏向锁</span></span><br><span class="line">  <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; (Verbose || !is_bulk)) &#123;</span><br><span class="line">    ResourceMark rm;</span><br><span class="line">    tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias of object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s , prototype header &quot;</span> INTPTR_FORMAT <span class="string">&quot; , allow rebias %d , requesting thread &quot;</span> INTPTR_FORMAT,</span><br><span class="line">                  <span class="built_in">p2i</span>((<span class="type">void</span> *)obj), (<span class="type">intptr_t</span>) mark, obj-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>(), (<span class="type">intptr_t</span>) obj-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">prototype_header</span>(), (allow_rebias ? <span class="number">1</span> : <span class="number">0</span>), (<span class="type">intptr_t</span>) requesting_thread);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象头的偏向线程</span></span><br><span class="line">  JavaThread* biased_thread = mark-&gt;<span class="built_in">biased_locker</span>();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//如果偏向线程为空说明是一个匿名偏向锁</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Object is anonymously biased. We can get here if, for</span></span><br><span class="line">    <span class="comment">// example, we revoke the bias due to an identity hash code</span></span><br><span class="line">    <span class="comment">// being computed for an object.</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;</span><br><span class="line">        <span class="comment">//如果不允许重偏向，则设置为无锁状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//默认不进</span></span><br><span class="line">    <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; (Verbose || !is_bulk)) &#123;</span><br><span class="line">      tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;  Revoked bias of anonymously-biased object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//返回已经撤销偏向</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle case where the thread toward which the object was biased has exited</span></span><br><span class="line">    <span class="comment">//设置一个状态 记录持锁线程是否还活着</span></span><br><span class="line">  <span class="type">bool</span> thread_is_alive = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">      <span class="comment">//如果请求线程和偏向线程相等则说明持锁线程还活着</span></span><br><span class="line">    thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//遍历线程 然后找到持锁线程，如果持锁线程还存在 则将状态置为True</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* cur_thread = Threads::<span class="built_in">first</span>(); cur_thread != <span class="literal">NULL</span>; cur_thread = cur_thread-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//运行到这 Thread_is_alive依然是false 说明持锁线程已经死了</span></span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">        <span class="comment">//如果允许重偏向则设置为匿名偏向锁状态，我们传入的是False</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之设为无锁状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; (Verbose || !is_bulk)) &#123;</span><br><span class="line">      tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;  Revoked bias of object biased toward dead thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//返回已经撤销偏向</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Thread owning bias is alive.</span></span><br><span class="line">  <span class="comment">// Check to see whether it currently owns the lock and, if so,</span></span><br><span class="line">  <span class="comment">// write down the needed displaced headers to the thread&#x27;s stack.</span></span><br><span class="line">  <span class="comment">// Otherwise, restore the object&#x27;s header either to the unlocked</span></span><br><span class="line">  <span class="comment">// or unbiased state.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断锁偏向线程是否还在，检查他是否拥有锁，如果有则写入线程堆栈中反之解锁或者解除偏向</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取一个Monitor列表</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//遍历列表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">    <span class="keyword">if</span> (mon_info-&gt;<span class="built_in">owner</span>() == obj) &#123;</span><br><span class="line">        <span class="comment">//这个owner指向的是不是当前的锁(重入的时候只有第一个进来的持有锁的地址)</span></span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; Verbose) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;   mon_info-&gt;owner (&quot;</span> PTR_FORMAT <span class="string">&quot;) == obj (&quot;</span> PTR_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                      <span class="built_in">p2i</span>((<span class="type">void</span> *) mon_info-&gt;<span class="built_in">owner</span>()),</span><br><span class="line">                      <span class="built_in">p2i</span>((<span class="type">void</span> *) obj));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Assume recursive case and fix up highest lock later</span></span><br><span class="line">        <span class="comment">//获取一个NULL 设置为mark</span></span><br><span class="line">      markOop mark = markOopDesc::<span class="built_in">encode</span>((BasicLock*) <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//将Highest指向这个锁对象</span></span><br><span class="line">      highest_lock = mon_info-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//将obj的Mark设为Null</span></span><br><span class="line">      highest_lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; Verbose) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;   mon_info-&gt;owner (&quot;</span> PTR_FORMAT <span class="string">&quot;) != obj (&quot;</span> PTR_FORMAT <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                      <span class="built_in">p2i</span>((<span class="type">void</span> *) mon_info-&gt;<span class="built_in">owner</span>()),</span><br><span class="line">                      <span class="built_in">p2i</span>((<span class="type">void</span> *) obj));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (highest_lock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//遍历结束之后Highest不为空说明找到了可重入锁的第一个锁头</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Fix up highest lock to contain displaced header and point</span></span><br><span class="line">    <span class="comment">// object at it</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将表头设置为无锁状态</span></span><br><span class="line">    highest_lock-&gt;<span class="built_in">set_displaced_header</span>(unbiased_prototype);</span><br><span class="line">    <span class="comment">// Reset object header to point to displaced mark.</span></span><br><span class="line">    <span class="comment">// Must release storing the lock address for platforms without TSO</span></span><br><span class="line">    <span class="comment">// ordering (e.g. ppc).</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将Obj的信息指向了高位锁，就是形成了一个轻量级锁</span></span><br><span class="line">    obj-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(highest_lock));</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;illegal mark state: stack lock used bias bit&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; (Verbose || !is_bulk)) &#123;</span><br><span class="line">      tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;  Revoked bias of currently-locked object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//反之Highest为空则说明没有线程持有锁</span></span><br><span class="line">    <span class="keyword">if</span> (TraceBiasedLocking &amp;&amp; (Verbose || !is_bulk)) &#123;</span><br><span class="line">      tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;  Revoked bias of currently-unlocked object&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">        <span class="comment">//如果可以偏向则重新偏向 我们传入的是false</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Store the unlocked value into the object&#x27;s header.</span></span><br><span class="line">        <span class="comment">//将锁设为无锁状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回已经撤销锁信号</span></span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="slow-enter"   >
          <a href="#slow-enter" class="heading-link"><i class="fas fa-link"></i></a><a href="#slow-enter" class="headerlink" title="slow_enter"></a>slow_enter</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得头信息</span></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">      <span class="comment">//如果记录是一个无锁状态</span></span><br><span class="line">    <span class="comment">// Anticipate successful CAS -- the ST of the displaced mark must</span></span><br><span class="line">    <span class="comment">// be visible &lt;= the ST performed by the CAS.</span></span><br><span class="line">      <span class="comment">//将锁设置成头信息</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">      <span class="comment">//CAS操作，成功即是轻量级锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">TEVENT</span> (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fall through to inflate() ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">      <span class="comment">//反之锁已经有拥有者了，判断当前线程是否是持锁线程</span></span><br><span class="line">    <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">      <span class="comment">//如果是说明是轻量级锁的重入,将下一个Lock的头设为Null</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">// The following optimization isn&#x27;t particularly useful.</span></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>() &amp;&amp; mark-&gt;<span class="built_in">monitor</span>()-&gt;<span class="built_in">is_entered</span>(THREAD)) &#123; </span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The object header will never be displaced to this lock,</span></span><br><span class="line">  <span class="comment">// so it does not matter what the value is, except that it</span></span><br><span class="line">  <span class="comment">// must be non-zero to avoid looking like a re-entrant lock,</span></span><br><span class="line">  <span class="comment">// and must not look locked either.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以上是轻量级锁的膨胀过程，下面是重量级锁的过程</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markOopDesc::<span class="built_in">unused_mark</span>());</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里是上面没有详细说到的东西</p>

        <h3 id="①轻量级锁重入"   >
          <a href="#①轻量级锁重入" class="heading-link"><i class="fas fa-link"></i></a><a href="#①轻量级锁重入" class="headerlink" title="①轻量级锁重入"></a>①轻量级锁重入</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803012321008.png"  alt="轻量级锁重入">
      </p>

        <h3 id="②线程安全点"   >
          <a href="#②线程安全点" class="heading-link"><i class="fas fa-link"></i></a><a href="#②线程安全点" class="headerlink" title="②线程安全点"></a>②线程安全点</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803014810909.png"  alt="线程安全点">
      </p>

        <h3 id="③轻量级锁膨胀流程图"   >
          <a href="#③轻量级锁膨胀流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#③轻量级锁膨胀流程图" class="headerlink" title="③轻量级锁膨胀流程图"></a>③轻量级锁膨胀流程图</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803015339537.png"  alt="轻量级锁膨胀流程图">
      </p>

        <h3 id="④撤销偏向锁流程图"   >
          <a href="#④撤销偏向锁流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#④撤销偏向锁流程图" class="headerlink" title="④撤销偏向锁流程图"></a>④撤销偏向锁流程图</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803022234477.png"  alt="撤销偏向锁(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803022147767.png"  alt="撤销偏向锁(2)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803023201645.png"  alt="撤销偏向锁(3)">
      </p>

        <h2 id="重量级锁-ObjectSynchronizer-inflate"   >
          <a href="#重量级锁-ObjectSynchronizer-inflate" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁-ObjectSynchronizer-inflate" class="headerlink" title="重量级锁(ObjectSynchronizer::inflate)"></a>重量级锁(ObjectSynchronizer::inflate)</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ObjectMonitor * ATTR <span class="title">ObjectSynchronizer::inflate</span> <span class="params">(Thread * Self, oop object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参数一：线程</span></span><br><span class="line"><span class="comment">    参数二：持锁线程和BasicObjectLock</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Inflate mutates the heap ...</span></span><br><span class="line">  <span class="comment">// Relaxing assertion for bug 6320749.</span></span><br><span class="line">  <span class="built_in">assert</span> (Universe::<span class="built_in">verify_in_progress</span>() ||</span><br><span class="line">          !SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//死循环(自旋)</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="comment">//获得头信息</span></span><br><span class="line">      <span class="type">const</span> markOop mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">      <span class="built_in">assert</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The mark can be in one of the following states:</span></span><br><span class="line">      <span class="comment">// *  Inflated     - just return</span></span><br><span class="line">      <span class="comment">// *  Stack-locked - coerce it to inflated</span></span><br><span class="line">      <span class="comment">// *  INFLATING    - busy wait for conversion to complete</span></span><br><span class="line">      <span class="comment">// *  Neutral      - aggressively inflate the object.</span></span><br><span class="line">      <span class="comment">// *  BIASED       - Illegal.  We should never see this</span></span><br><span class="line">		</span><br><span class="line">      <span class="comment">//情况1：已经是一个重量级锁</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// CASE: inflated</span></span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">          <span class="comment">//has_monitor方法调用之后如果有的话返回True 说明这把锁已经是重量级锁 </span></span><br><span class="line">          ObjectMonitor * inf = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">          <span class="built_in">assert</span> (inf-&gt;<span class="built_in">header</span>()-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">          <span class="built_in">assert</span> (inf-&gt;<span class="built_in">object</span>() == object, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">assert</span> (ObjectSynchronizer::<span class="built_in">verify_objmon_isinpool</span>(inf), <span class="string">&quot;monitor is invalid&quot;</span>);</span><br><span class="line">          <span class="comment">//将monitor返回</span></span><br><span class="line">          <span class="keyword">return</span> inf ;</span><br><span class="line">      &#125;</span><br><span class="line">	</span><br><span class="line">      <span class="comment">//情况2:这把锁处于一个轻量级锁膨胀到重量级的中间态(正在膨胀没有完成)</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// CASE: inflation in progress - inflating over a stack-lock.</span></span><br><span class="line">      <span class="comment">// Some other thread is converting from stack-locked to inflated.</span></span><br><span class="line">      <span class="comment">// Only that thread can complete inflation -- other threads must wait.</span></span><br><span class="line">      <span class="comment">// The INFLATING value is transient.</span></span><br><span class="line">      <span class="comment">// Currently, we spin/yield/park and poll the markword, waiting for inflation to finish.</span></span><br><span class="line">      <span class="comment">// We could always eliminate polling by parking the thread on some auxiliary list.</span></span><br><span class="line">      <span class="keyword">if</span> (mark == markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果是中间态就让出CPU 然后continue重新判断是否处于中间状态</span></span><br><span class="line">          </span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflate: spin <span class="keyword">while</span> INFLATING) ;</span><br><span class="line">         <span class="built_in">ReadStableMark</span>(object) ;</span><br><span class="line">         <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: stack-locked</span></span><br><span class="line">      <span class="comment">// Could be stack-locked either by this thread or by some other thread.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Note that we allocate the objectmonitor speculatively, _before_ attempting</span></span><br><span class="line">      <span class="comment">// to install INFLATING into the mark word.  We originally installed INFLATING,</span></span><br><span class="line">      <span class="comment">// allocated the objectmonitor, and then finally STed the address of the</span></span><br><span class="line">      <span class="comment">// objectmonitor into the mark.  This was correct, but artificially lengthened</span></span><br><span class="line">      <span class="comment">// the interval in which INFLATED appeared in the mark, thus increasing</span></span><br><span class="line">      <span class="comment">// the odds of inflation contention.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We now use per-thread private objectmonitor free lists.</span></span><br><span class="line">      <span class="comment">// These list are reprovisioned from the global free list outside the</span></span><br><span class="line">      <span class="comment">// critical INFLATING...ST interval.  A thread can transfer</span></span><br><span class="line">      <span class="comment">// multiple objectmonitors en-mass from the global free list to its local free list.</span></span><br><span class="line">      <span class="comment">// This reduces coherency traffic and lock contention on the global free list.</span></span><br><span class="line">      <span class="comment">// Using such local free lists, it doesn&#x27;t matter if the omAlloc() call appears</span></span><br><span class="line">      <span class="comment">// before or after the CAS(INFLATING) operation.</span></span><br><span class="line">      <span class="comment">// See the comments in omAlloc().</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//情况3：目前这把锁是一把轻量级锁，轻量级锁要膨胀到重量级锁</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>()) &#123;</span><br><span class="line">          <span class="comment">//omalloc申请一个monitor m</span></span><br><span class="line">          </span><br><span class="line">          ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">          <span class="comment">// Optimistically prepare the objectmonitor - anticipate successful CAS</span></span><br><span class="line">          <span class="comment">// We do this before the CAS in order to minimize the length of time</span></span><br><span class="line">          <span class="comment">// in which INFLATING appears in the mark.</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//m的初始化</span></span><br><span class="line">          </span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">          m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;   <span class="comment">// Consider: maintain by type/class</span></span><br><span class="line">		</span><br><span class="line">          <span class="comment">//CAS将这个监视器的信息设置为正在膨胀的中间态(情况2)</span></span><br><span class="line">          markOop cmp = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">INFLATING</span>(), object-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//判断CAS操作是否成功</span></span><br><span class="line">          <span class="keyword">if</span> (cmp != mark) &#123;</span><br><span class="line">              <span class="comment">//CAS失败 释放监控器，然后continue重试</span></span><br><span class="line">             <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">             <span class="keyword">continue</span> ;       <span class="comment">// Interference -- just retry</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// We&#x27;ve successfully installed INFLATING (0) into the mark-word.</span></span><br><span class="line">          <span class="comment">// This is the only case where 0 will appear in a mark-work.</span></span><br><span class="line">          <span class="comment">// Only the singular thread that successfully swings the mark-word</span></span><br><span class="line">          <span class="comment">// to 0 can perform (or more precisely, complete) inflation.</span></span><br><span class="line">          <span class="comment">//</span></span><br><span class="line">          <span class="comment">// Why do we CAS a 0 into the mark-word instead of just CASing the</span></span><br><span class="line">          <span class="comment">// mark-word from the stack-locked value directly to the new inflated state?</span></span><br><span class="line">          <span class="comment">// Consider what happens when a thread unlocks a stack-locked object.</span></span><br><span class="line">          <span class="comment">// It attempts to use CAS to swing the displaced header value from the</span></span><br><span class="line">          <span class="comment">// on-stack basiclock back into the object header.  Recall also that the</span></span><br><span class="line">          <span class="comment">// header value (hashcode, etc) can reside in (a) the object header, or</span></span><br><span class="line">          <span class="comment">// (b) a displaced header associated with the stack-lock, or (c) a displaced</span></span><br><span class="line">          <span class="comment">// header in an objectMonitor.  The inflate() routine must copy the header</span></span><br><span class="line">          <span class="comment">// value from the basiclock on the owner&#x27;s stack to the objectMonitor, all</span></span><br><span class="line">          <span class="comment">// the while preserving the hashCode stability invariants.  If the owner</span></span><br><span class="line">          <span class="comment">// decides to release the lock while the value is 0, the unlock will fail</span></span><br><span class="line">          <span class="comment">// and control will eventually pass from slow_exit() to inflate.  The owner</span></span><br><span class="line">          <span class="comment">// will then spin, waiting for the 0 value to disappear.   Put another way,</span></span><br><span class="line">          <span class="comment">// the 0 causes the owner to stall if the owner happens to try to</span></span><br><span class="line">          <span class="comment">// drop the lock (restoring the header from the basiclock to the object)</span></span><br><span class="line">          <span class="comment">// while inflation is in-progress.  This protocol avoids races that might</span></span><br><span class="line">          <span class="comment">// would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.</span></span><br><span class="line">          <span class="comment">// Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span></span><br><span class="line">          <span class="comment">// 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">          <span class="comment">// fetch the displaced mark from the owner&#x27;s stack.</span></span><br><span class="line">          <span class="comment">// The owner can&#x27;t die or unwind past the lock while our INFLATING</span></span><br><span class="line">          <span class="comment">// object is in the mark.  Furthermore the owner can&#x27;t complete</span></span><br><span class="line">          <span class="comment">// an unlock on the object, either.</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="comment">//运行到这里锁是轻量级锁，并且已经将头信息标记成正在膨胀的状态 并且cas成功</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//获取头信息</span></span><br><span class="line">          markOop dmw = mark-&gt;<span class="built_in">displaced_mark_helper</span>() ;</span><br><span class="line">          <span class="built_in">assert</span> (dmw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Setup monitor fields to proper values -- prepare the monitor</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//将监控器的头信息更新</span></span><br><span class="line">          m-&gt;<span class="built_in">set_header</span>(dmw) ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Optimization: if the mark-&gt;locker stack address is associated</span></span><br><span class="line">          <span class="comment">// with this thread we could simply set m-&gt;_owner = Self and</span></span><br><span class="line">          <span class="comment">// m-&gt;OwnerIsThread = 1. Note that a thread can inflate an object</span></span><br><span class="line">          <span class="comment">// that it has stack-locked -- as might happen in wait() -- directly</span></span><br><span class="line">          <span class="comment">// with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//监视器的owner指向头信息中的locker</span></span><br><span class="line">          </span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>(mark-&gt;<span class="built_in">locker</span>());</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//监视器的object设置成当前object</span></span><br><span class="line">          </span><br><span class="line">          m-&gt;<span class="built_in">set_object</span>(object);</span><br><span class="line">          <span class="comment">// TODO-<span class="doctag">FIXME:</span> assert BasicLock-&gt;dhw != 0.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Must preserve store ordering. The monitor state must</span></span><br><span class="line">          <span class="comment">// be stable at the time of publishing the monitor address.</span></span><br><span class="line">          <span class="built_in">guarantee</span> (object-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">INFLATING</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//更新object中的信息</span></span><br><span class="line">          object-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(m));</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Hopefully the performance counters are allocated on distinct cache lines</span></span><br><span class="line">          <span class="comment">// to avoid false sharing on MP systems ...</span></span><br><span class="line">          <span class="comment">//将计数器分布到不同的缓存行中???</span></span><br><span class="line">          <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">          <span class="built_in">TEVENT</span>(Inflate: overwrite stacklock) ;</span><br><span class="line">          <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">            <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">              ResourceMark rm;</span><br><span class="line">              tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">                (<span class="type">void</span> *) object, (<span class="type">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">                object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//返回监视器</span></span><br><span class="line">          <span class="keyword">return</span> m ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// CASE: neutral</span></span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> for entry we currently inflate and then try to CAS _owner.</span></span><br><span class="line">      <span class="comment">// If we know we&#x27;re inflating for entry it&#x27;s better to inflate by swinging a</span></span><br><span class="line">      <span class="comment">// pre-locked objectMonitor pointer into the object header.   A successful</span></span><br><span class="line">      <span class="comment">// CAS inflates the object *and* confers ownership to the inflating thread.</span></span><br><span class="line">      <span class="comment">// In the current implementation we use a 2-step mechanism where we CAS()</span></span><br><span class="line">      <span class="comment">// to inflate and then CAS() again to try to swing _owner from NULL to Self.</span></span><br><span class="line">      <span class="comment">// An inflateTry() method that we could call from fast_enter() and slow_enter()</span></span><br><span class="line">      <span class="comment">// would be useful.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//情况4：现在状态是个无锁状态</span></span><br><span class="line">      </span><br><span class="line">      <span class="built_in">assert</span> (mark-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//申请一个监视器</span></span><br><span class="line">      ObjectMonitor * m = <span class="built_in">omAlloc</span> (Self) ;</span><br><span class="line">      <span class="comment">// prepare m for installation - set monitor to initial state</span></span><br><span class="line">      m-&gt;<span class="built_in">Recycle</span>();</span><br><span class="line">      m-&gt;<span class="built_in">set_header</span>(mark);</span><br><span class="line">      m-&gt;<span class="built_in">set_owner</span>(<span class="literal">NULL</span>);</span><br><span class="line">      m-&gt;<span class="built_in">set_object</span>(object);  <span class="comment">//监视器监视当前Object</span></span><br><span class="line">      m-&gt;OwnerIsThread = <span class="number">1</span> ;  <span class="comment">//锁持有者设置为1</span></span><br><span class="line">      m-&gt;_recursions   = <span class="number">0</span> ;</span><br><span class="line">      m-&gt;_Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">      m-&gt;_SpinDuration = ObjectMonitor::Knob_SpinLimit ;       <span class="comment">// consider: keep metastats by type/class</span></span><br><span class="line">	</span><br><span class="line">      <span class="comment">//CAS操作更新监视器信息</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (markOopDesc::<span class="built_in">encode</span>(m), object-&gt;<span class="built_in">mark_addr</span>(), mark) != mark) &#123;</span><br><span class="line">          <span class="comment">//如果更新，说明有竞争，然后释放当前监视器，重新循环</span></span><br><span class="line">          </span><br><span class="line">          m-&gt;<span class="built_in">set_object</span> (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;<span class="built_in">set_owner</span>  (<span class="literal">NULL</span>) ;</span><br><span class="line">          m-&gt;OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">          m-&gt;<span class="built_in">Recycle</span>() ;</span><br><span class="line">          <span class="built_in">omRelease</span> (Self, m, <span class="literal">true</span>) ;</span><br><span class="line">          m = <span class="literal">NULL</span> ;</span><br><span class="line">          <span class="keyword">continue</span> ;</span><br><span class="line">          <span class="comment">// interference - the markword changed - just retry.</span></span><br><span class="line">          <span class="comment">// The state-transitions are one-way, so there&#x27;s no chance of</span></span><br><span class="line">          <span class="comment">// live-lock -- &quot;Inflated&quot; is an absorbing state.</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Hopefully the performance counters are allocated on distinct</span></span><br><span class="line">      <span class="comment">// cache lines to avoid false sharing on MP systems ...</span></span><br><span class="line">      <span class="keyword">if</span> (ObjectMonitor::_sync_Inflations != <span class="literal">NULL</span>) ObjectMonitor::_sync_Inflations-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">      <span class="built_in">TEVENT</span>(Inflate: overwrite neutral) ;</span><br><span class="line">      <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">          ResourceMark rm;</span><br><span class="line">          tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Inflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">            (<span class="type">void</span> *) object, (<span class="type">intptr_t</span>) object-&gt;<span class="built_in">mark</span>(),</span><br><span class="line">            object-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> m ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//膨胀过程本质上就是获取监视器，而具体的加锁要在Entry方法中</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="重量级锁加锁流程图-膨胀"   >
          <a href="#重量级锁加锁流程图-膨胀" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁加锁流程图-膨胀" class="headerlink" title="重量级锁加锁流程图(膨胀)"></a>重量级锁加锁流程图(膨胀)</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803172249972.png"  alt="重量级锁加锁流程图(膨胀)">
      </p>
<p><em><strong>膨胀过程本质上就是获取一个监视器</strong>，返回监视器，而具体加锁在监视器中的Entry方法中</em></p>
<p><em>过程就是判断是否有可用的Monitor，如果没有创建一个公共可用的Monitor数组(1024个)，然后将指向的监视器放到当前线程下可用的监视器中，然后公共可用的Monitor减少一个，具体代码如下</em></p>

        <h3 id="申请监视器"   >
          <a href="#申请监视器" class="heading-link"><i class="fas fa-link"></i></a><a href="#申请监视器" class="headerlink" title="申请监视器"></a>申请监视器</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor * ATTR ObjectSynchronizer::omAlloc (Thread * Self) &#123;</span><br><span class="line">    <span class="comment">// A large MAXPRIVATE value reduces both list lock contention</span></span><br><span class="line">    <span class="comment">// and list coherency traffic, but also tends to increase the</span></span><br><span class="line">    <span class="comment">// number of objectMonitors in circulation as well as the STW</span></span><br><span class="line">    <span class="comment">// scavenge costs.  As usual, we lean toward time in space-time</span></span><br><span class="line">    <span class="comment">// tradeoffs.</span></span><br><span class="line">    const <span class="type">int</span> <span class="variable">MAXPRIVATE</span> <span class="operator">=</span> <span class="number">1024</span> ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ObjectMonitor * m ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1: try to allocate from the thread&#x27;s local omFreeList.</span></span><br><span class="line">        <span class="comment">// Threads will attempt to allocate first from their local list, then</span></span><br><span class="line">        <span class="comment">// from the global list, and only after those attempts fail will the thread</span></span><br><span class="line">        <span class="comment">// attempt to instantiate new monitors.   Thread-local free lists take</span></span><br><span class="line">        <span class="comment">// heat off the ListLock and improve allocation latency, as well as reducing</span></span><br><span class="line">        <span class="comment">// coherency traffic on the shared global list.</span></span><br><span class="line">        m = Self-&gt;omFreeList ;</span><br><span class="line">        <span class="keyword">if</span> (m != NULL) &#123;</span><br><span class="line">           Self-&gt;omFreeList = m-&gt;FreeNext ;</span><br><span class="line">           Self-&gt;omFreeCount -- ;</span><br><span class="line">           <span class="comment">// CONSIDER: set m-&gt;FreeNext = BAD -- diagnostic hygiene</span></span><br><span class="line">           guarantee (m-&gt;object() == NULL, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">           <span class="keyword">if</span> (MonitorInUseLists) &#123;</span><br><span class="line">             m-&gt;FreeNext = Self-&gt;omInUseList;</span><br><span class="line">             Self-&gt;omInUseList = m;</span><br><span class="line">             Self-&gt;omInUseCount ++;</span><br><span class="line">             <span class="comment">// verifyInUse(Self);</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             m-&gt;FreeNext = NULL;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> m ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2: try to allocate from the global gFreeList</span></span><br><span class="line">        <span class="comment">// CONSIDER: use muxTry() instead of muxAcquire().</span></span><br><span class="line">        <span class="comment">// If the muxTry() fails then drop immediately into case 3.</span></span><br><span class="line">        <span class="comment">// If we&#x27;re using thread-local free lists then try</span></span><br><span class="line">        <span class="comment">// to reprovision the caller&#x27;s free list.</span></span><br><span class="line">        <span class="keyword">if</span> (gFreeList != NULL) &#123;</span><br><span class="line">            <span class="comment">// Reprovision the thread&#x27;s omFreeList.</span></span><br><span class="line">            <span class="comment">// Use bulk transfers to reduce the allocation rate and heat</span></span><br><span class="line">            <span class="comment">// on various locks.</span></span><br><span class="line">            Thread::muxAcquire (&amp;ListLock, <span class="string">&quot;omAlloc&quot;</span>) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Self-&gt;omFreeProvision; --i &gt;= <span class="number">0</span> &amp;&amp; gFreeList != NULL; ) &#123;</span><br><span class="line">                MonitorFreeCount --;</span><br><span class="line">                ObjectMonitor * take = gFreeList ;</span><br><span class="line">                gFreeList = take-&gt;FreeNext ;</span><br><span class="line">                guarantee (take-&gt;object() == NULL, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">                guarantee (!take-&gt;is_busy(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">                take-&gt;Recycle() ;</span><br><span class="line">                omRelease (Self, take, <span class="literal">false</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            Thread::muxRelease (&amp;ListLock) ;</span><br><span class="line">            Self-&gt;omFreeProvision += <span class="number">1</span> + (Self-&gt;omFreeProvision/<span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">if</span> (Self-&gt;omFreeProvision &gt; MAXPRIVATE ) Self-&gt;omFreeProvision = MAXPRIVATE ;</span><br><span class="line">            TEVENT (omFirst - reprovision) ;</span><br><span class="line"></span><br><span class="line">            const <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> MonitorBound ;</span><br><span class="line">            <span class="keyword">if</span> (mx &gt; <span class="number">0</span> &amp;&amp; (MonitorPopulation-MonitorFreeCount) &gt; mx) &#123;</span><br><span class="line">              <span class="comment">// We can&#x27;t safely induce a STW safepoint from omAlloc() as our thread</span></span><br><span class="line">              <span class="comment">// state may not be appropriate for such activities and callers may hold</span></span><br><span class="line">              <span class="comment">// naked oops, so instead we defer the action.</span></span><br><span class="line">              InduceScavenge (Self, <span class="string">&quot;omAlloc&quot;</span>) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3: allocate a block of new ObjectMonitors</span></span><br><span class="line">        <span class="comment">// Both the local and global free lists are empty -- resort to malloc().</span></span><br><span class="line">        <span class="comment">// In the current implementation objectMonitors are TSM - immortal.</span></span><br><span class="line">        <span class="keyword">assert</span> (_BLOCKSIZE &gt; <span class="number">1</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        ObjectMonitor * temp = <span class="keyword">new</span> <span class="title class_">ObjectMonitor</span>[_BLOCKSIZE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> (almost) no way to recover if allocation failed.</span></span><br><span class="line">        <span class="comment">// We might be able to induce a STW safepoint and scavenge enough</span></span><br><span class="line">        <span class="comment">// objectMonitors to permit progress.</span></span><br><span class="line">        <span class="keyword">if</span> (temp == NULL) &#123;</span><br><span class="line">            vm_exit_out_of_memory (sizeof (ObjectMonitor[_BLOCKSIZE]), OOM_MALLOC_ERROR,</span><br><span class="line">                                   <span class="string">&quot;Allocate ObjectMonitors&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Format the block.</span></span><br><span class="line">        <span class="comment">// initialize the linked list, each monitor points to its next</span></span><br><span class="line">        <span class="comment">// forming the single linked free list, the very first monitor</span></span><br><span class="line">        <span class="comment">// will points to next block, which forms the block list.</span></span><br><span class="line">        <span class="comment">// The trick of using the 1st element in the block as gBlockList</span></span><br><span class="line">        <span class="comment">// linkage should be reconsidered.  A better implementation would</span></span><br><span class="line">        <span class="comment">// look like: class Block &#123; Block * next; int N; ObjectMonitor Body [N] ; &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; _BLOCKSIZE ; i++) &#123;</span><br><span class="line">           temp[i].FreeNext = &amp;temp[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// terminate the last monitor as the end of list</span></span><br><span class="line">        temp[_BLOCKSIZE - <span class="number">1</span>].FreeNext = NULL ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Element [0] is reserved for global list linkage</span></span><br><span class="line">        temp[<span class="number">0</span>].set_object(CHAINMARKER);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Consider carving out this thread&#x27;s current request from the</span></span><br><span class="line">        <span class="comment">// block in hand.  This avoids some lock traffic and redundant</span></span><br><span class="line">        <span class="comment">// list activity.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Acquire the ListLock to manipulate BlockList and FreeList.</span></span><br><span class="line">        <span class="comment">// An Oyama-Taura-Yonezawa scheme might be more efficient.</span></span><br><span class="line">        Thread::muxAcquire (&amp;ListLock, <span class="string">&quot;omAlloc [2]&quot;</span>) ;</span><br><span class="line">        MonitorPopulation += _BLOCKSIZE-<span class="number">1</span>;</span><br><span class="line">        MonitorFreeCount += _BLOCKSIZE-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the new block to the list of extant blocks (gBlockList).</span></span><br><span class="line">        <span class="comment">// The very first objectMonitor in a block is reserved and dedicated.</span></span><br><span class="line">        <span class="comment">// It serves as blocklist &quot;next&quot; linkage.</span></span><br><span class="line">        temp[<span class="number">0</span>].FreeNext = gBlockList;</span><br><span class="line">        gBlockList = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the new string of objectMonitors to the global free list</span></span><br><span class="line">        temp[_BLOCKSIZE - <span class="number">1</span>].FreeNext = gFreeList ;</span><br><span class="line">        gFreeList = temp + <span class="number">1</span>;</span><br><span class="line">        Thread::muxRelease (&amp;ListLock) ;</span><br><span class="line">        TEVENT (Allocate block of monitors) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="重量级锁竞争"   >
          <a href="#重量级锁竞争" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁竞争" class="headerlink" title="重量级锁竞争"></a>重量级锁竞争</h3>
      
        <h4 id="ObjectMonitor-enter"   >
          <a href="#ObjectMonitor-enter" class="heading-link"><i class="fas fa-link"></i></a><a href="#ObjectMonitor-enter" class="headerlink" title="ObjectMonitor::enter"></a>ObjectMonitor::enter</h4>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// The following code is ordered to check the most common cases first</span></span><br><span class="line">  <span class="comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span></span><br><span class="line">  Thread * <span class="type">const</span> Self = THREAD ;</span><br><span class="line">  <span class="type">void</span> * cur ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//记录当前线程，CUR记录CAS结果 </span></span><br><span class="line">  <span class="comment">//cas成功会返回null</span></span><br><span class="line">  cur = Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//CAS成功 即加锁成功</span></span><br><span class="line">      </span><br><span class="line">     <span class="comment">// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span></span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (_owner      == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="comment">// CONSIDER: set or assert OwnerIsThread == 1</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">      <span class="comment">//判断是否是当前线程，如果是就是重量级锁重入</span></span><br><span class="line">     <span class="comment">// TODO-<span class="doctag">FIXME:</span> check for integer overflow!  BUGID 6557169.</span></span><br><span class="line">     _recursions ++ ;</span><br><span class="line">      <span class="comment">//重量级锁重入次数++</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;<span class="built_in">is_lock_owned</span> ((address)cur)) &#123;</span><br><span class="line">    	<span class="comment">//判断持锁线程是不是地址值，就是当前拥有轻量级锁的重入</span></span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将重量级锁重入次数设置为1</span></span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span></span><br><span class="line">    <span class="comment">// a full-fledged &quot;Thread *&quot;.</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//将监视器的信息更新，锁变成重量级锁</span></span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ve encountered genuine contention.</span></span><br><span class="line">  <span class="built_in">assert</span> (Self-&gt;_Stalled == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try one round of spinning *before* enqueueing Self</span></span><br><span class="line">  <span class="comment">// and before going through the awkward and expensive state</span></span><br><span class="line">  <span class="comment">// transitions.  The following spin is strictly optional ...</span></span><br><span class="line">  <span class="comment">// Note that if we acquire the monitor from an initial spin</span></span><br><span class="line">  <span class="comment">// we forgo posting JVMTI events and firing DTRACE probes.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断环境变量是否能自旋，然后自适应自旋</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (_recursions == <span class="number">0</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span> (_owner != Self          , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_succ  != Self          , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (Self-&gt;<span class="built_in">is_Java_thread</span>()  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  JavaThread * jt = (JavaThread *) Self ;</span><br><span class="line">  <span class="built_in">assert</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (jt-&gt;<span class="built_in">thread_state</span>() != _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (<span class="keyword">this</span>-&gt;<span class="built_in">object</span>() != <span class="literal">NULL</span>  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent deflation at STW-time.  See deflate_idle_monitors() and is_busy().</span></span><br><span class="line">  <span class="comment">// Ensure the object-monitor relationship remains stable while there&#x27;s contention.</span></span><br><span class="line">  Atomic::<span class="built_in">inc_ptr</span>(&amp;_count);</span><br><span class="line"></span><br><span class="line">  EventJavaMonitorEnter event;</span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">// Change java thread status to indicate blocked on monitor enter.</span></span><br><span class="line">    <span class="function">JavaThreadBlockedOnMonitorEnterState <span class="title">jtbmes</span><span class="params">(jt, <span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__enter, <span class="keyword">this</span>, <span class="built_in">object</span>(), jt);</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_contended_enter</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_monitor_contended_enter</span>(jt, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The current thread does not yet own the monitor and does not</span></span><br><span class="line">      <span class="comment">// yet appear on any queues that would get it made the successor.</span></span><br><span class="line">      <span class="comment">// This means that the JVMTI_EVENT_MONITOR_CONTENDED_ENTER event</span></span><br><span class="line">      <span class="comment">// handler cannot accidentally consume an unpark() meant for the</span></span><br><span class="line">      <span class="comment">// ParkEvent associated with this ObjectMonitor.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">OSThreadContendState <span class="title">osts</span><span class="params">(Self-&gt;osthread())</span></span>;</span><br><span class="line">    <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line"></span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO-<span class="doctag">FIXME:</span> change the following for(;;) loop to straight-line code.</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="comment">//死循环(自旋) 进入EnterI,如果出现意外导致拿锁失败则退出 </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">      <span class="comment">// cleared by handle_special_suspend_equivalent_condition()</span></span><br><span class="line">      <span class="comment">// or java_suspend_self()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入EnterI方法</span></span><br><span class="line">      <span class="built_in">EnterI</span> (THREAD) ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ExitSuspendEquivalent</span>(jt)) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We have acquired the contended monitor, but while we were</span></span><br><span class="line">      <span class="comment">// waiting another thread suspended us. We don&#x27;t want to enter</span></span><br><span class="line">      <span class="comment">// the monitor while suspended because that would surprise the</span></span><br><span class="line">      <span class="comment">// thread that suspended us.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">          _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出现意外导致拿锁失败了则结束</span></span><br><span class="line">      <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line"></span><br><span class="line">      jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We cleared the pending monitor info since we&#x27;ve just gotten past</span></span><br><span class="line">    <span class="comment">// the enter-check-for-suspend dance and we now own the monitor free</span></span><br><span class="line">    <span class="comment">// and clear, i.e., it is no longer pending. The ThreadBlockInVM</span></span><br><span class="line">    <span class="comment">// destructor can go to a safepoint at the end of this block. If we</span></span><br><span class="line">    <span class="comment">// do a thread dump during that safepoint, then this thread will show</span></span><br><span class="line">    <span class="comment">// as having &quot;-locked&quot; the monitor, but the OS and java.lang.Thread</span></span><br><span class="line">    <span class="comment">// states will still report that the thread is blocked trying to</span></span><br><span class="line">    <span class="comment">// acquire it.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Atomic::<span class="built_in">dec_ptr</span>(&amp;_count);</span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must either set _recursions = 0 or ASSERT _recursions == 0.</span></span><br><span class="line">  <span class="built_in">assert</span> (_recursions == <span class="number">0</span>     , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_owner == Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (_succ  != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The thread -- now the owner -- is back in vm mode.</span></span><br><span class="line">  <span class="comment">// Report the glorious news via TI,DTrace and jvmstat.</span></span><br><span class="line">  <span class="comment">// The probe effect is non-trivial.  All the reportage occurs</span></span><br><span class="line">  <span class="comment">// while we hold the monitor, increasing the length of the critical</span></span><br><span class="line">  <span class="comment">// section.  Amdahl&#x27;s parallel speedup law comes vividly into play.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Another option might be to aggregate the events (thread local or</span></span><br><span class="line">  <span class="comment">// per-monitor aggregation) and defer reporting until a more opportune</span></span><br><span class="line">  <span class="comment">// time -- such as next time some thread encounters contention but has</span></span><br><span class="line">  <span class="comment">// yet to acquire the lock.  While spinning that thread could</span></span><br><span class="line">  <span class="comment">// spinning we could increment JVMStat counters, etc.</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__entered, <span class="keyword">this</span>, <span class="built_in">object</span>(), jt);</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_contended_entered</span>()) &#123;</span><br><span class="line">    JvmtiExport::<span class="built_in">post_monitor_contended_entered</span>(jt, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The current thread already owns the monitor and is not going to</span></span><br><span class="line">    <span class="comment">// call park() for the remainder of the monitor enter protocol. So</span></span><br><span class="line">    <span class="comment">// it doesn&#x27;t matter if the JVMTI_EVENT_MONITOR_CONTENDED_ENTERED</span></span><br><span class="line">    <span class="comment">// event handler consumed an unpark() issued by the thread that</span></span><br><span class="line">    <span class="comment">// just exited the monitor.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">    event.<span class="built_in">set_klass</span>(((oop)<span class="keyword">this</span>-&gt;<span class="built_in">object</span>())-&gt;<span class="built_in">klass</span>());</span><br><span class="line">    event.<span class="built_in">set_previousOwner</span>((TYPE_JAVALANGTHREAD)_previous_owner_tid);</span><br><span class="line">    event.<span class="built_in">set_address</span>((TYPE_ADDRESS)(<span class="type">uintptr_t</span>)(<span class="keyword">this</span>-&gt;<span class="built_in">object_addr</span>()));</span><br><span class="line">    event.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ObjectMonitor::_sync_ContendedLockAttempts != <span class="literal">NULL</span>) &#123;</span><br><span class="line">     ObjectMonitor::_sync_ContendedLockAttempts-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="ObjectMonitor-entryI"   >
          <a href="#ObjectMonitor-entryI" class="heading-link"><i class="fas fa-link"></i></a><a href="#ObjectMonitor-entryI" class="headerlink" title="ObjectMonitor::entryI"></a>ObjectMonitor::entryI</h4>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    <span class="built_in">assert</span> (Self-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (((JavaThread *) Self)-&gt;<span class="built_in">thread_state</span>() == _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the lock - TATAS</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//TryLock方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (_succ != Self              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner == Self             , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_Responsible != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We try one round of spinning *before* enqueueing Self.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// If the _owner is ready but OFFPROC we could use a YieldTo()</span></span><br><span class="line">    <span class="comment">// operation to donate the remainder of this thread&#x27;s quantum</span></span><br><span class="line">    <span class="comment">// to the owner.  This has subtle but beneficial affinity</span></span><br><span class="line">    <span class="comment">// effects.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试自旋拿锁</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">assert</span> (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span> (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Spin failed -- Enqueue and park the thread ...</span></span><br><span class="line">    <span class="built_in">assert</span> (_succ  != Self            , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (_owner != Self            , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (_Responsible != Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue &quot;Self&quot; on ObjectMonitor&#x27;s _cxq.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Node acts as a proxy for Self.</span></span><br><span class="line">    <span class="comment">// As an aside, if were to ever rewrite the synchronization code mostly</span></span><br><span class="line">    <span class="comment">// in Java, WaitNodes, ObjectMonitors, and Events would become 1st-class</span></span><br><span class="line">    <span class="comment">// Java objects.  This would avoid awkward lifecycle and liveness issues,</span></span><br><span class="line">    <span class="comment">// as well as eliminate a subset of ABA issues.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> eliminate ObjectWaiter and enqueue either Threads or Events.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自适应自旋拿不到锁 所以要入阻塞队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push &quot;Self&quot; onto the front of the _cxq.</span></span><br><span class="line">    <span class="comment">// Once on cxq/EntryList, Self stays on-queue until it acquires the lock.</span></span><br><span class="line">    <span class="comment">// Note that spinning tends to reduce the rate at which threads</span></span><br><span class="line">    <span class="comment">// enqueue and dequeue on EntryList|cxq.</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取cxq阻塞队列  node.next和nxt都指向这个阻塞队列</span></span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="comment">//CAS操作，如果成功说明这个ObjectWaiter进入了Monitor的阻塞队列中队列中</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interference - the CAS failed because _cxq changed.  Just retry.</span></span><br><span class="line">        <span class="comment">// As an optional optimization we retry the lock.</span></span><br><span class="line">        <span class="comment">//尝试去获取锁，如果成功则返回1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">assert</span> (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">assert</span> (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">assert</span> (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for cxq|EntryList edge transition to non-null.  This indicates</span></span><br><span class="line">    <span class="comment">// the onset of contention.  While contention persists exiting threads</span></span><br><span class="line">    <span class="comment">// will use a ST:MEMBAR:LD 1-1 exit protocol.  When contention abates exit</span></span><br><span class="line">    <span class="comment">// operations revert to the faster 1-0 mode.  This enter operation may interleave</span></span><br><span class="line">    <span class="comment">// (race) a concurrent 1-0 exit operation, resulting in stranding, so we</span></span><br><span class="line">    <span class="comment">// arrange for one of the contending thread to use a timed park() operations</span></span><br><span class="line">    <span class="comment">// to detect and recover from the race.  (Stranding is form of progress failure</span></span><br><span class="line">    <span class="comment">// where the monitor is unlocked but all the contending threads remain parked).</span></span><br><span class="line">    <span class="comment">// That is, at least one of the contended threads will periodically poll _owner.</span></span><br><span class="line">    <span class="comment">// One of the contending threads will become the designated &quot;Responsible&quot; thread.</span></span><br><span class="line">    <span class="comment">// The Responsible thread uses a timed park instead of a normal indefinite park</span></span><br><span class="line">    <span class="comment">// operation -- it periodically wakes and checks for and recovers from potential</span></span><br><span class="line">    <span class="comment">// strandings admitted by 1-0 exit operations.   We need at most one Responsible</span></span><br><span class="line">    <span class="comment">// thread per-monitor at any given moment.  Only threads on cxq|EntryList may</span></span><br><span class="line">    <span class="comment">// be responsible for a monitor.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Currently, one of the contended threads takes on the added role of &quot;Responsible&quot;.</span></span><br><span class="line">    <span class="comment">// A viable alternative would be to use a dedicated &quot;stranding checker&quot; thread</span></span><br><span class="line">    <span class="comment">// that periodically iterated over all the threads (or active monitors) and unparked</span></span><br><span class="line">    <span class="comment">// successors where there was risk of stranding.  This would help eliminate the</span></span><br><span class="line">    <span class="comment">// timer scalability issues we see on some platforms as we&#x27;d only have one thread</span></span><br><span class="line">    <span class="comment">// -- the checker -- parked on a timer.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行边界检查</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Try to assume the role of responsible thread for the monitor.</span></span><br><span class="line">        <span class="comment">// CONSIDER:  ST vs CAS vs &#123; if (Responsible==null) Responsible=Self &#125;</span></span><br><span class="line">        Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lock have been released while this thread was occupied queueing</span></span><br><span class="line">    <span class="comment">// itself onto _cxq.  To close the race and avoid &quot;stranding&quot; and</span></span><br><span class="line">    <span class="comment">// progress-liveness failure we must resample-retry _owner before parking.</span></span><br><span class="line">    <span class="comment">// Note the Dekker/Lamport duality: ST cxq; MEMBAR; LD Owner.</span></span><br><span class="line">    <span class="comment">// In this case the ST-MEMBAR is accomplished with CAS().</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Defer all thread state transitions until park-time.</span></span><br><span class="line">    <span class="comment">// Since state transitions are heavy and inefficient we&#x27;d like</span></span><br><span class="line">    <span class="comment">// to defer the state transitions until absolutely necessary,</span></span><br><span class="line">    <span class="comment">// and in doing so avoid some transitions ...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">TEVENT</span> (Inflated enter - Contention) ;</span><br><span class="line">    <span class="type">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运行到这里说明已经进了阻塞队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试去获取锁，获取锁成功就跳出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="built_in">assert</span> (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//阻塞线程</span></span><br><span class="line">        <span class="comment">// park self</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取成功就跳出</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The lock is still contested.</span></span><br><span class="line">        <span class="comment">// Keep a tally of the # of futile wakeups.</span></span><br><span class="line">        <span class="comment">// Note that the counter is not protected by a lock or updated by atomics.</span></span><br><span class="line">        <span class="comment">// That is by design - we trade &quot;lossy&quot; counters which are exposed to</span></span><br><span class="line">        <span class="comment">// races during updates for a lower probe effect.</span></span><br><span class="line">        <span class="built_in">TEVENT</span> (Inflated enter - Futile wakeup) ;</span><br><span class="line">        <span class="keyword">if</span> (ObjectMonitor::_sync_FutileWakeups != <span class="literal">NULL</span>) &#123;</span><br><span class="line">           ObjectMonitor::_sync_FutileWakeups-&gt;<span class="built_in">inc</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ nWakeups ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assuming this is not a spurious wakeup we&#x27;ll normally find _succ == Self.</span></span><br><span class="line">        <span class="comment">// We can defer clearing _succ until after the spin completes</span></span><br><span class="line">        <span class="comment">// TrySpin() must tolerate being called with _succ == Self.</span></span><br><span class="line">        <span class="comment">// Try yet another round of adaptive spinning.</span></span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can find that we were unpark()ed and redesignated _succ while</span></span><br><span class="line">        <span class="comment">// we were spinning.  That&#x27;s harmless.  If we iterate and call park(),</span></span><br><span class="line">        <span class="comment">// park() will consume the event and return immediately and we&#x27;ll</span></span><br><span class="line">        <span class="comment">// just spin again.  This pattern can repeat, leaving _succ to simply</span></span><br><span class="line">        <span class="comment">// spin on a CPU.  Enable Knob_ResetEvent to clear pending unparks().</span></span><br><span class="line">        <span class="comment">// Alternately, we can sample fired() here, and if set, forgo spinning</span></span><br><span class="line">        <span class="comment">// in the next iteration.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Knob_ResetEvent &amp; <span class="number">1</span>) &amp;&amp; Self-&gt;_ParkEvent-&gt;<span class="built_in">fired</span>()) &#123;</span><br><span class="line">           Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">           OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invariant: after clearing _succ a thread *must* retry _owner before parking.</span></span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Egress :</span></span><br><span class="line">    <span class="comment">// Self has acquired the lock -- Unlink Self from the cxq or EntryList.</span></span><br><span class="line">    <span class="comment">// Normally we&#x27;ll find Self on the EntryList .</span></span><br><span class="line">    <span class="comment">// From the perspective of the lock owner (this thread), the</span></span><br><span class="line">    <span class="comment">// EntryList is stable and cxq is prepend-only.</span></span><br><span class="line">    <span class="comment">// The head of cxq is volatile but the interior is stable.</span></span><br><span class="line">    <span class="comment">// In addition, Self.TState is stable.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span> (_owner == Self      , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="built_in">assert</span> (<span class="built_in">object</span>() != <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="comment">// I&#x27;d like to write:</span></span><br><span class="line">    <span class="comment">//   guarantee (((oop)(object()))-&gt;mark() == markOopDesc::encode(this), &quot;invariant&quot;) ;</span></span><br><span class="line">    <span class="comment">// but as we&#x27;re at a safepoint that&#x27;s not safe.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlinkAfterAcquire</span> (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span> (_succ != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="keyword">if</span> (_Responsible == Self) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>(); <span class="comment">// Dekker pivot-point</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// We may leave threads on cxq|EntryList without a designated</span></span><br><span class="line">        <span class="comment">// &quot;Responsible&quot; thread.  This is benign.  When this thread subsequently</span></span><br><span class="line">        <span class="comment">// exits the monitor it can &quot;see&quot; such preexisting &quot;old&quot; threads --</span></span><br><span class="line">        <span class="comment">// threads that arrived on the cxq|EntryList before the fence, above --</span></span><br><span class="line">        <span class="comment">// by LDing cxq|EntryList.  Newly arrived threads -- that is, threads</span></span><br><span class="line">        <span class="comment">// that arrive on cxq after the ST:MEMBAR, above -- will set Responsible</span></span><br><span class="line">        <span class="comment">// non-null and elect a new &quot;Responsible&quot; timer thread.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This thread executes:</span></span><br><span class="line">        <span class="comment">//    ST Responsible=null; MEMBAR    (in enter epilog - here)</span></span><br><span class="line">        <span class="comment">//    LD cxq|EntryList               (in subsequent exit)</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// Entering threads in the slow/contended path execute:</span></span><br><span class="line">        <span class="comment">//    ST cxq=nonnull; MEMBAR; LD Responsible (in enter prolog)</span></span><br><span class="line">        <span class="comment">//    The (ST cxq; MEMBAR) is accomplished with CAS().</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The MEMBAR, above, prevents the LD of cxq|EntryList in the subsequent</span></span><br><span class="line">        <span class="comment">// exit operation from floating above the ST Responsible=null.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;ve acquired ownership with CAS().</span></span><br><span class="line">    <span class="comment">// CAS is serializing -- it has MEMBAR/FENCE-equivalent semantics.</span></span><br><span class="line">    <span class="comment">// But since the CAS() this thread may have also stored into _succ,</span></span><br><span class="line">    <span class="comment">// EntryList, cxq or Responsible.  These meta-data updates must be</span></span><br><span class="line">    <span class="comment">// visible __before this thread subsequently drops the lock.</span></span><br><span class="line">    <span class="comment">// Consider what could occur if we didn&#x27;t enforce this constraint --</span></span><br><span class="line">    <span class="comment">// STs to monitor meta-data and user-data could reorder with (become</span></span><br><span class="line">    <span class="comment">// visible after) the ST in exit that drops ownership of the lock.</span></span><br><span class="line">    <span class="comment">// Some other thread could then acquire the lock, but observe inconsistent</span></span><br><span class="line">    <span class="comment">// or old monitor meta-data and heap data.  That violates the JMM.</span></span><br><span class="line">    <span class="comment">// To that end, the 1-0 exit() operation must have at least STST|LDST</span></span><br><span class="line">    <span class="comment">// &quot;release&quot; barrier semantics.  Specifically, there must be at least a</span></span><br><span class="line">    <span class="comment">// STST|LDST barrier in exit() before the ST of null into _owner that drops</span></span><br><span class="line">    <span class="comment">// the lock.   The barrier ensures that changes to monitor meta-data and data</span></span><br><span class="line">    <span class="comment">// protected by the lock will be visible before we release the lock, and</span></span><br><span class="line">    <span class="comment">// therefore before some other thread (CPU) has a chance to acquire the lock.</span></span><br><span class="line">    <span class="comment">// See also: http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Critically, any prior STs to _succ or EntryList must be visible before</span></span><br><span class="line">    <span class="comment">// the ST of null into _owner in the *subsequent* (following) corresponding</span></span><br><span class="line">    <span class="comment">// monitorexit.  Recall too, that in 1-0 mode monitorexit does not necessarily</span></span><br><span class="line">    <span class="comment">// execute a serializing instruction.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SyncFlags &amp; <span class="number">8</span>) &#123;</span><br><span class="line">       OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="TryLock"   >
          <a href="#TryLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#TryLock" class="headerlink" title="TryLock"></a>TryLock</h4>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自旋</span></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">   <span class="comment">//获取锁的持有者</span></span><br><span class="line">      <span class="type">void</span> * own = _owner ;</span><br><span class="line">       <span class="comment">//如果是有锁则返回0</span></span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="comment">//如果加锁成功了就返回1</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">         <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The lock had been free momentarily, but we lost the race to the lock.</span></span><br><span class="line">      <span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line">      <span class="comment">// We can either return -1 or retry.</span></span><br><span class="line">      <span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//锁没有主人但是竞争的时候失败了就返回-1</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="自适应自旋"   >
          <a href="#自适应自旋" class="heading-link"><i class="fas fa-link"></i></a><a href="#自适应自旋" class="headerlink" title="自适应自旋"></a>自适应自旋</h4>
      <p>自适应自旋是指:如果上一次自旋获取到了那就会将自选次数添加，认为你能获取锁，如果上一次自旋之后还没有获取到，那就认为你获取不到锁，自旋次数就会减少，这个是一个很复杂的一个过程。具体代码如下</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ObjectMonitor::TrySpin_VaryDuration</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dumb, brutal spin.  Good for comparative measurements against adaptive spinning.</span></span><br><span class="line">    <span class="type">int</span> ctr = Knob_FixedSpin ;</span><br><span class="line">    <span class="keyword">if</span> (ctr != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (--ctr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">            <span class="built_in">SpinPause</span> () ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ctr = Knob_PreSpin + <span class="number">1</span>; --ctr &gt;= <span class="number">0</span> ; ) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Increase _SpinDuration ...</span></span><br><span class="line">        <span class="comment">// Note that we don&#x27;t clamp SpinDuration precisely at SpinLimit.</span></span><br><span class="line">        <span class="comment">// Raising _SpurDuration to the poverty line is key.</span></span><br><span class="line">        <span class="type">int</span> x = _SpinDuration ;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; Knob_SpinLimit) &#123;</span><br><span class="line">           <span class="keyword">if</span> (x &lt; Knob_Poverty) x = Knob_Poverty ;</span><br><span class="line">           _SpinDuration = x + Knob_BonusB ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">SpinPause</span> () ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Admission control - verify preconditions for spinning</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We always spin a little bit, just to prevent _SpinDuration == 0 from</span></span><br><span class="line">    <span class="comment">// becoming an absorbing state.  Put another way, we spin briefly to</span></span><br><span class="line">    <span class="comment">// sample, just in case the system load, parallelism, contention, or lock</span></span><br><span class="line">    <span class="comment">// modality changed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Consider the following alternative:</span></span><br><span class="line">    <span class="comment">// Periodically set _SpinDuration = _SpinLimit and try a long/full</span></span><br><span class="line">    <span class="comment">// spin attempt.  &quot;Periodically&quot; might mean after a tally of</span></span><br><span class="line">    <span class="comment">// the # of failed spin attempts (or iterations) reaches some threshold.</span></span><br><span class="line">    <span class="comment">// This takes us into the realm of 1-out-of-N spinning, where we</span></span><br><span class="line">    <span class="comment">// hold the duration constant but vary the frequency.</span></span><br><span class="line"></span><br><span class="line">    ctr = _SpinDuration  ;</span><br><span class="line">    <span class="keyword">if</span> (ctr &lt; Knob_SpinBase) ctr = Knob_SpinBase ;</span><br><span class="line">    <span class="keyword">if</span> (ctr &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Knob_SuccRestrict &amp;&amp; _succ != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Knob_OState &amp;&amp; <span class="built_in">NotRunnable</span> (Self, (Thread *) _owner)) &#123;</span><br><span class="line">       <span class="built_in">TEVENT</span> (Spin abort - notrunnable [TOP]);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> MaxSpin = Knob_MaxSpinners ;</span><br><span class="line">    <span class="keyword">if</span> (MaxSpin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (_Spinner &gt; MaxSpin) &#123;</span><br><span class="line">          <span class="built_in">TEVENT</span> (Spin abort -- too many spinners) ;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Slighty racy, but benign ...</span></span><br><span class="line">       <span class="built_in">Adjust</span> (&amp;_Spinner, <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We&#x27;re good to spin ... spin ingress.</span></span><br><span class="line">    <span class="comment">// CONSIDER: use Prefetch::write() to avoid RTS-&gt;RTO upgrades</span></span><br><span class="line">    <span class="comment">// when preparing to LD...CAS _owner, etc and the CAS is likely</span></span><br><span class="line">    <span class="comment">// to succeed.</span></span><br><span class="line">    <span class="type">int</span> hits    = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">int</span> msk     = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">int</span> caspty  = Knob_CASPenalty ;</span><br><span class="line">    <span class="type">int</span> oxpty   = Knob_OXPenalty ;</span><br><span class="line">    <span class="type">int</span> sss     = Knob_SpinSetSucc ;</span><br><span class="line">    <span class="keyword">if</span> (sss &amp;&amp; _succ == <span class="literal">NULL</span> ) _succ = Self ;</span><br><span class="line">    Thread * prv = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// There are three ways to exit the following loop:</span></span><br><span class="line">    <span class="comment">// 1.  A successful spin where this thread has acquired the lock.</span></span><br><span class="line">    <span class="comment">// 2.  Spin failure with prejudice</span></span><br><span class="line">    <span class="comment">// 3.  Spin failure without prejudice</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--ctr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Periodic polling -- Check for pending GC</span></span><br><span class="line">      <span class="comment">// Threads may spin while they&#x27;re unsafe.</span></span><br><span class="line">      <span class="comment">// We don&#x27;t want spinning threads to delay the JVM from reaching</span></span><br><span class="line">      <span class="comment">// a stop-the-world safepoint or to steal cycles from GC.</span></span><br><span class="line">      <span class="comment">// If we detect a pending safepoint we abort in order that</span></span><br><span class="line">      <span class="comment">// (a) this thread, if unsafe, doesn&#x27;t delay the safepoint, and (b)</span></span><br><span class="line">      <span class="comment">// this thread, if safe, doesn&#x27;t steal cycles from GC.</span></span><br><span class="line">      <span class="comment">// This is in keeping with the &quot;no loitering in runtime&quot; rule.</span></span><br><span class="line">      <span class="comment">// We periodically check to see if there&#x27;s a safepoint pending.</span></span><br><span class="line">      <span class="keyword">if</span> ((ctr &amp; <span class="number">0xFF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (SafepointSynchronize::<span class="built_in">do_call_back</span>()) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Spin: safepoint) ;</span><br><span class="line">            <span class="keyword">goto</span> Abort ;           <span class="comment">// abrupt spin egress</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (Knob_UsePause &amp; <span class="number">1</span>) <span class="built_in">SpinPause</span> () ;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">int</span> (*scb)(<span class="type">intptr_t</span>,<span class="type">int</span>) = SpinCallbackFunction ;</span><br><span class="line">         <span class="keyword">if</span> (hits &gt; <span class="number">50</span> &amp;&amp; scb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">int</span> abend = (*scb)(SpinCallbackArgument, <span class="number">0</span>) ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Knob_UsePause &amp; <span class="number">2</span>) <span class="built_in">SpinPause</span>() ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Exponential back-off ...  Stay off the bus to reduce coherency traffic.</span></span><br><span class="line">      <span class="comment">// This is useful on classic SMP systems, but is of less utility on</span></span><br><span class="line">      <span class="comment">// N1-style CMT platforms.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Trade-off: lock acquisition latency vs coherency bandwidth.</span></span><br><span class="line">      <span class="comment">// Lock hold times are typically short.  A histogram</span></span><br><span class="line">      <span class="comment">// of successful spin attempts shows that we usually acquire</span></span><br><span class="line">      <span class="comment">// the lock early in the spin.  That suggests we want to</span></span><br><span class="line">      <span class="comment">// sample _owner frequently in the early phase of the spin,</span></span><br><span class="line">      <span class="comment">// but then back-off and sample less frequently as the spin</span></span><br><span class="line">      <span class="comment">// progresses.  The back-off makes a good citizen on SMP big</span></span><br><span class="line">      <span class="comment">// SMP systems.  Oversampling _owner can consume excessive</span></span><br><span class="line">      <span class="comment">// coherency bandwidth.  Relatedly, if we _oversample _owner we</span></span><br><span class="line">      <span class="comment">// can inadvertently interfere with the the ST m-&gt;owner=null.</span></span><br><span class="line">      <span class="comment">// executed by the lock owner.</span></span><br><span class="line">      <span class="keyword">if</span> (ctr &amp; msk) <span class="keyword">continue</span> ;</span><br><span class="line">      ++hits ;</span><br><span class="line">      <span class="keyword">if</span> ((hits &amp; <span class="number">0xF</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// The 0xF, above, corresponds to the exponent.</span></span><br><span class="line">        <span class="comment">// Consider: (msk+1)|msk</span></span><br><span class="line">        msk = ((msk &lt;&lt; <span class="number">2</span>)|<span class="number">3</span>) &amp; BackOffMask ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Probe _owner with TATAS</span></span><br><span class="line">      <span class="comment">// If this thread observes the monitor transition or flicker</span></span><br><span class="line">      <span class="comment">// from locked to unlocked to locked, then the odds that this</span></span><br><span class="line">      <span class="comment">// thread will acquire the lock in this spin attempt go down</span></span><br><span class="line">      <span class="comment">// considerably.  The same argument applies if the CAS fails</span></span><br><span class="line">      <span class="comment">// or if we observe _owner change from one non-null value to</span></span><br><span class="line">      <span class="comment">// another non-null value.   In such cases we might abort</span></span><br><span class="line">      <span class="comment">// the spin without prejudice or apply a &quot;penalty&quot; to the</span></span><br><span class="line">      <span class="comment">// spin count-down variable &quot;ctr&quot;, reducing it by 100, say.</span></span><br><span class="line"></span><br><span class="line">      Thread * ox = (Thread *) _owner ;</span><br><span class="line">      <span class="keyword">if</span> (ox == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         ox = (Thread *) Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">         <span class="keyword">if</span> (ox == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// The CAS succeeded -- this thread acquired ownership</span></span><br><span class="line">            <span class="comment">// Take care of some bookkeeping to exit spin state.</span></span><br><span class="line">            <span class="keyword">if</span> (sss &amp;&amp; _succ == Self) &#123;</span><br><span class="line">               _succ = <span class="literal">NULL</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (MaxSpin &gt; <span class="number">0</span>) <span class="built_in">Adjust</span> (&amp;_Spinner, <span class="number">-1</span>) ;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Increase _SpinDuration :</span></span><br><span class="line">            <span class="comment">// The spin was successful (profitable) so we tend toward</span></span><br><span class="line">            <span class="comment">// longer spin attempts in the future.</span></span><br><span class="line">            <span class="comment">// CONSIDER: factor &quot;ctr&quot; into the _SpinDuration adjustment.</span></span><br><span class="line">            <span class="comment">// If we acquired the lock early in the spin cycle it</span></span><br><span class="line">            <span class="comment">// makes sense to increase _SpinDuration proportionally.</span></span><br><span class="line">            <span class="comment">// Note that we don&#x27;t clamp SpinDuration precisely at SpinLimit.</span></span><br><span class="line">            <span class="type">int</span> x = _SpinDuration ;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; Knob_SpinLimit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x &lt; Knob_Poverty) x = Knob_Poverty ;</span><br><span class="line">                _SpinDuration = x + Knob_Bonus ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// The CAS failed ... we can take any of the following actions:</span></span><br><span class="line">         <span class="comment">// * penalize: ctr -= Knob_CASPenalty</span></span><br><span class="line">         <span class="comment">// * exit spin with prejudice -- goto Abort;</span></span><br><span class="line">         <span class="comment">// * exit spin without prejudice.</span></span><br><span class="line">         <span class="comment">// * Since CAS is high-latency, retry again immediately.</span></span><br><span class="line">         prv = ox ;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Spin: cas failed) ;</span><br><span class="line">         <span class="keyword">if</span> (caspty == <span class="number">-2</span>) <span class="keyword">break</span> ;</span><br><span class="line">         <span class="keyword">if</span> (caspty == <span class="number">-1</span>) <span class="keyword">goto</span> Abort ;</span><br><span class="line">         ctr -= caspty ;</span><br><span class="line">         <span class="keyword">continue</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Did lock ownership change hands ?</span></span><br><span class="line">      <span class="keyword">if</span> (ox != prv &amp;&amp; prv != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">          <span class="built_in">TEVENT</span> (spin: Owner changed)</span><br><span class="line">          <span class="keyword">if</span> (oxpty == <span class="number">-2</span>) <span class="keyword">break</span> ;</span><br><span class="line">          <span class="keyword">if</span> (oxpty == <span class="number">-1</span>) <span class="keyword">goto</span> Abort ;</span><br><span class="line">          ctr -= oxpty ;</span><br><span class="line">      &#125;</span><br><span class="line">      prv = ox ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Abort the spin if the owner is not executing.</span></span><br><span class="line">      <span class="comment">// The owner must be executing in order to drop the lock.</span></span><br><span class="line">      <span class="comment">// Spinning while the owner is OFFPROC is idiocy.</span></span><br><span class="line">      <span class="comment">// Consider: ctr -= RunnablePenalty ;</span></span><br><span class="line">      <span class="keyword">if</span> (Knob_OState &amp;&amp; <span class="built_in">NotRunnable</span> (Self, ox)) &#123;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Spin abort - notrunnable);</span><br><span class="line">         <span class="keyword">goto</span> Abort ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (sss &amp;&amp; _succ == <span class="literal">NULL</span> ) _succ = Self ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Spin failed with prejudice -- reduce _SpinDuration.</span></span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> Use an AIMD-like policy to adjust _SpinDuration.</span></span><br><span class="line">   <span class="comment">// AIMD is globally stable.</span></span><br><span class="line">   <span class="built_in">TEVENT</span> (Spin failure) ;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">int</span> x = _SpinDuration ;</span><br><span class="line">     <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Consider an AIMD scheme like: x -= (x &gt;&gt; 3) + 100</span></span><br><span class="line">        <span class="comment">// This is globally sample and tends to damp the response.</span></span><br><span class="line">        x -= Knob_Penalty ;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = <span class="number">0</span> ;</span><br><span class="line">        _SpinDuration = x ;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> Abort:</span><br><span class="line">   <span class="keyword">if</span> (MaxSpin &gt;= <span class="number">0</span>) <span class="built_in">Adjust</span> (&amp;_Spinner, <span class="number">-1</span>) ;</span><br><span class="line">   <span class="keyword">if</span> (sss &amp;&amp; _succ == Self) &#123;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="comment">// Invariant: after setting succ=null a contending thread</span></span><br><span class="line">      <span class="comment">// must recheck-retry _owner before parking.  This usually happens</span></span><br><span class="line">      <span class="comment">// in the normal usage of TrySpin(), but it&#x27;s safest</span></span><br><span class="line">      <span class="comment">// to make TrySpin() as foolproof as possible.</span></span><br><span class="line">      OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="阻塞队列图解"   >
          <a href="#阻塞队列图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#阻塞队列图解" class="headerlink" title="阻塞队列图解"></a>阻塞队列图解</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803184039161.png"  alt="阻塞队列图解">
      </p>

        <h3 id="重量级锁竞争流程图"   >
          <a href="#重量级锁竞争流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁竞争流程图" class="headerlink" title="重量级锁竞争流程图"></a>重量级锁竞争流程图</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803182841184.png"  alt="重量级锁竞争流程图">
      </p>

        <h2 id="锁释放"   >
          <a href="#锁释放" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁释放" class="headerlink" title="锁释放"></a>锁释放</h2>
      
        <h3 id="轻量级锁释放-monitorexit"   >
          <a href="#轻量级锁释放-monitorexit" class="heading-link"><i class="fas fa-link"></i></a><a href="#轻量级锁释放-monitorexit" class="headerlink" title="轻量级锁释放(monitorexit)"></a>轻量级锁释放(monitorexit)</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorexit): &#123;</span><br><span class="line">    	<span class="comment">//从栈中获取对象</span></span><br><span class="line">        oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">    	<span class="comment">//对lockee判空</span></span><br><span class="line">        <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">        <span class="comment">// derefing&#x27;s lockee ought to provoke implicit null check</span></span><br><span class="line">        <span class="comment">// find our monitor slot</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//指向栈顶的监视器</span></span><br><span class="line">        BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">    	<span class="comment">//指向栈底的监视器</span></span><br><span class="line">        BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">    	<span class="comment">//循环，当栈底和栈顶不指向同一个监视器时</span></span><br><span class="line">        <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">            <span class="comment">//如果找到监视器监视的lockee是指向当前锁</span></span><br><span class="line">          <span class="keyword">if</span> ((most_recent)-&gt;<span class="built_in">obj</span>() == lockee) &#123;</span><br><span class="line">            BasicLock* lock = most_recent-&gt;<span class="built_in">lock</span>();</span><br><span class="line">            markOop header = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">              <span class="comment">//将监视器指向的obj设为空</span></span><br><span class="line">            most_recent-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">                <span class="comment">//如果这个锁不是偏向锁</span></span><br><span class="line">              <span class="type">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">                <span class="comment">//获取环境变量是否禁用偏向锁和轻量级锁，默认是false</span></span><br><span class="line">              <span class="comment">// If it isn&#x27;t recursive we either must swap old header or call the runtime</span></span><br><span class="line">                <span class="comment">//判断头是否为空，因为头为空说明是一个重入锁，就不进这个判断，目的是找到第一个锁头</span></span><br><span class="line">              <span class="keyword">if</span> (header != <span class="literal">NULL</span> || call_vm) &#123;</span><br><span class="line">                  <span class="comment">//如果监视器的头不为空，那么CAS操作将锁的lock更新为无锁状态</span></span><br><span class="line">                <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), lock) != lock) &#123;</span><br><span class="line">                    <span class="comment">//如果失败则进入竞争锁的释放</span></span><br><span class="line">                  <span class="comment">// restore object for the slow case</span></span><br><span class="line">                  most_recent-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">                  <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorexit</span>(THREAD, most_recent), handle_exception);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">              <span class="comment">//运行到这里说明锁是偏向锁，偏向锁就不做任何处理，只更新PC计数器</span></span><br><span class="line">            <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          most_recent++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Need to throw illegal monitor state exception</span></span><br><span class="line">        <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">throw_illegal_monitor_state_exception</span>(THREAD), handle_exception);</span><br><span class="line">        <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="①InterpreterRuntime-monitorexit"   >
          <a href="#①InterpreterRuntime-monitorexit" class="heading-link"><i class="fas fa-link"></i></a><a href="#①InterpreterRuntime-monitorexit" class="headerlink" title="①InterpreterRuntime::monitorexit"></a>①InterpreterRuntime::monitorexit</h4>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="type">void</span>, InterpreterRuntime::<span class="built_in">monitorexit</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">//封装了线程和Object</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (elem == <span class="literal">NULL</span> || <span class="built_in">h_obj</span>()-&gt;<span class="built_in">is_unlocked</span>()) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入Slow_exit</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">slow_exit</span>(<span class="built_in">h_obj</span>(), elem-&gt;<span class="built_in">lock</span>(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line">  <span class="comment">// exit. If it is not cleared, the exception handling code will try to unlock the monitor again.</span></span><br><span class="line">  elem-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;<span class="built_in">last_frame</span>().<span class="built_in">interpreter_frame_verify_monitor</span>(elem);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></div></figure>


        <h4 id="②slow-exit"   >
          <a href="#②slow-exit" class="heading-link"><i class="fas fa-link"></i></a><a href="#②slow-exit" class="headerlink" title="②slow_exit"></a>②slow_exit</h4>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::slow_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进入fast_exit</span></span><br><span class="line">  <span class="built_in">fast_exit</span> (object, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="③fast-exit"   >
          <a href="#③fast-exit" class="heading-link"><i class="fas fa-link"></i></a><a href="#③fast-exit" class="headerlink" title="③fast_exit"></a>③fast_exit</h4>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::fast_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!object-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line">  <span class="comment">// if displaced header is null, the previous enter is recursive enter, no-op</span></span><br><span class="line">    <span class="comment">//获得锁头信息</span></span><br><span class="line">  markOop dhw = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">  markOop mark ;</span><br><span class="line">    <span class="comment">//如果lockee的头是null说明是一个重入</span></span><br><span class="line">  <span class="keyword">if</span> (dhw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// Recursive stack-lock.</span></span><br><span class="line">     <span class="comment">// Diagnostics -- Could be: stack-locked, inflating, inflated.</span></span><br><span class="line">     mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line">     <span class="built_in">assert</span> (!mark-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; mark != markOopDesc::<span class="built_in">INFLATING</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>()), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_monitor</span>()) &#123;</span><br><span class="line">        ObjectMonitor * m = mark-&gt;<span class="built_in">monitor</span>() ;</span><br><span class="line">        <span class="built_in">assert</span>(((oop)(m-&gt;<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == mark, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="built_in">assert</span>(m-&gt;<span class="built_in">is_entered</span>(THREAD), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取BasicObjectLock头信息</span></span><br><span class="line">  mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the object is stack-locked by the current thread, try to</span></span><br><span class="line">  <span class="comment">// swing the displaced header from the box back to the mark.</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">      <span class="comment">//如果这两个地址相同，说明是一个轻量级锁</span></span><br><span class="line">     <span class="built_in">assert</span> (dhw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      <span class="comment">//CAS操作将栈中的BasicObjectLock的头信息改成dhw</span></span><br><span class="line">     <span class="keyword">if</span> ((markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (dhw, object-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">         <span class="comment">//如果CAS成功说明轻量级锁释放</span></span><br><span class="line">        <span class="built_in">TEVENT</span> (fast_exit: release stacklock) ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有进入上面轻量级锁的释放说明在mark中的数据改变了，说明是重量级锁的释放</span></span><br><span class="line">    <span class="comment">//调用下面方法膨胀锁获取监视器对象，通过监视器的方法来释放锁</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, object)-&gt;<span class="built_in">exit</span> (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="重量级锁释放-ObjectMonitor-exit"   >
          <a href="#重量级锁释放-ObjectMonitor-exit" class="heading-link"><i class="fas fa-link"></i></a><a href="#重量级锁释放-ObjectMonitor-exit" class="headerlink" title="重量级锁释放(ObjectMonitor::exit)"></a>重量级锁释放(ObjectMonitor::exit)</h3>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="type">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">    <span class="comment">//判断当前线程是否是持锁线程，目的是将当前线程指向持锁线程</span></span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">       <span class="comment">//如果当前线程不是持锁线程.那么从栈中找到持锁线程地址交给Thread</span></span><br><span class="line">     <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) _owner)) &#123;</span><br><span class="line">       <span class="comment">// Transmute _owner from a BasicLock pointer to a Thread address.</span></span><br><span class="line">       <span class="comment">// We don&#x27;t need to hold _mutex for this transition.</span></span><br><span class="line">       <span class="comment">// Non-null to Non-null is safe as long as all readers can</span></span><br><span class="line">       <span class="comment">// tolerate either flavor.</span></span><br><span class="line">       <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">       _owner = THREAD ;</span><br><span class="line">       _recursions = <span class="number">0</span> ;</span><br><span class="line">       OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">NOTE:</span> we need to handle unbalanced monitor enter/exit</span></span><br><span class="line">       <span class="comment">// in native code by throwing an exception.</span></span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> Throw an IllegalMonitorStateException ?</span></span><br><span class="line">       <span class="built_in">TEVENT</span> (Exit - Throw IMSX) ;</span><br><span class="line">       <span class="built_in">assert</span>(<span class="literal">false</span>, <span class="string">&quot;Non-balanced monitor enter/exit!&quot;</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalMonitorStateException</span>());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运行到这里已经找到了持锁线程</span></span><br><span class="line">	<span class="comment">//判断重入次数，如果不为0说明是重量级锁重入的释放</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//重入次数-1然后结束方法</span></span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">     <span class="built_in">TEVENT</span> (Inflated exit - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invariant: after setting Responsible=null an thread must execute</span></span><br><span class="line">   <span class="comment">// a MEMBAR or other serializing instruction before fetching EntryList|cxq.</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INCLUDE_TRACE</span></span><br><span class="line">   <span class="comment">// get the owner&#x27;s thread id for the MonitorEnter event</span></span><br><span class="line">   <span class="comment">// if it is enabled and the thread isn&#x27;t suspended</span></span><br><span class="line">   <span class="keyword">if</span> (not_suspended &amp;&amp; Tracing::<span class="built_in">is_event_enabled</span>(TraceJavaMonitorEnterEvent)) &#123;</span><br><span class="line">     _previous_owner_tid = SharedRuntime::<span class="built_in">get_java_tid</span>(Self);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="built_in">assert</span> (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">// release semantics: prior loads and stores from within the critical section</span></span><br><span class="line">         <span class="comment">// must not float (reorder) past the following store that drops the lock.</span></span><br><span class="line">         <span class="comment">// On SPARC that requires MEMBAR #loadstore|#storestore.</span></span><br><span class="line">         <span class="comment">// But of course in TSO #loadstore|#storestore is not required.</span></span><br><span class="line">         <span class="comment">// I&#x27;d like to write one of the following:</span></span><br><span class="line">         <span class="comment">// A.  OrderAccess::release() ; _owner = NULL</span></span><br><span class="line">         <span class="comment">// B.  OrderAccess::loadstore(); OrderAccess::storestore(); _owner = NULL;</span></span><br><span class="line">         <span class="comment">// Unfortunately OrderAccess::release() and OrderAccess::loadstore() both</span></span><br><span class="line">         <span class="comment">// store into a _dummy variable.  That store is not needed, but can result</span></span><br><span class="line">         <span class="comment">// in massive wasteful coherency traffic on classic SMP systems.</span></span><br><span class="line">         <span class="comment">// Instead, I use release_store(), which is implemented as just a simple</span></span><br><span class="line">         <span class="comment">// ST on x64, x86 and SPARC.</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//设置ObjectMonitor的Owner为NUll</span></span><br><span class="line">         OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">         OrderAccess::<span class="built_in">storeload</span>() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line">         </span><br><span class="line">          <span class="comment">//判断cxq阻塞队列和唤醒线程是否为空，如果为空就说明释放结束</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Normally the exiting thread is responsible for ensuring succession,</span></span><br><span class="line">         <span class="comment">// but if other successors are ready or other entering threads are spinning</span></span><br><span class="line">         <span class="comment">// then this thread can simply store NULL into _owner and exit without</span></span><br><span class="line">         <span class="comment">// waking a successor.  The existence of spinners or ready successors</span></span><br><span class="line">         <span class="comment">// guarantees proper succession (liveness).  Responsibility passes to the</span></span><br><span class="line">         <span class="comment">// ready or running successors.  The exiting thread delegates the duty.</span></span><br><span class="line">         <span class="comment">// More precisely, if a successor already exists this thread is absolved</span></span><br><span class="line">         <span class="comment">// of the responsibility of waking (unparking) one.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// The _succ variable is critical to reducing futile wakeup frequency.</span></span><br><span class="line">         <span class="comment">// _succ identifies the &quot;heir presumptive&quot; thread that has been made</span></span><br><span class="line">         <span class="comment">// ready (unparked) but that has not yet run.  We need only one such</span></span><br><span class="line">         <span class="comment">// successor thread to guarantee progress.</span></span><br><span class="line">         <span class="comment">// See http://www.usenix.org/events/jvm01/full_papers/dice/dice.pdf</span></span><br><span class="line">         <span class="comment">// section 3.3 &quot;Futile Wakeup Throttling&quot; for details.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">         <span class="comment">// Note that spinners in Enter() also set _succ non-null.</span></span><br><span class="line">         <span class="comment">// In the current implementation spinners opportunistically set</span></span><br><span class="line">         <span class="comment">// _succ so that exiting threads might avoid waking a successor.</span></span><br><span class="line">         <span class="comment">// Another less appealing alternative would be for the exiting thread</span></span><br><span class="line">         <span class="comment">// to drop the lock and then spin briefly to see if a spinner managed</span></span><br><span class="line">         <span class="comment">// to acquire the lock.  If so, the exiting thread could exit</span></span><br><span class="line">         <span class="comment">// immediately without waking a successor, otherwise the exiting</span></span><br><span class="line">         <span class="comment">// thread would need to dequeue and wake a successor.</span></span><br><span class="line">         <span class="comment">// (Note that we&#x27;d need to make the post-drop spin short, but no</span></span><br><span class="line">         <span class="comment">// shorter than the worst-case round-trip cache-line migration time.</span></span><br><span class="line">         <span class="comment">// The dropped lock needs to become visible to the spinner, and then</span></span><br><span class="line">         <span class="comment">// the acquisition of the lock by the spinner must become visible to</span></span><br><span class="line">         <span class="comment">// the exiting thread).</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// It appears that an heir-presumptive (successor) must be made ready.</span></span><br><span class="line">         <span class="comment">// Only the current lock owner can manipulate the EntryList or</span></span><br><span class="line">         <span class="comment">// drain _cxq, so we need to reacquire the lock.  If we fail</span></span><br><span class="line">         <span class="comment">// to reacquire the lock the responsibility for ensuring succession</span></span><br><span class="line">         <span class="comment">// falls to the new owner.</span></span><br><span class="line">         <span class="comment">//</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="comment">//运行到这里说明线程的阻塞队列或者唤醒队列有线程等待</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="comment">//CAS操作重新获取一把锁，将监视器指向持锁线程，说明唤醒线程操作只能由持锁线程进行</span></span><br><span class="line">         <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="comment">//获取锁失败则返回</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">TEVENT</span> (Exit - Reacquired) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//判断cxq阻塞队列和唤醒线程是否为空，如果为空就说明释放结束</span></span><br><span class="line">         <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             </span><br><span class="line">             <span class="comment">//设置ObjectMonitor的Owner为NUll</span></span><br><span class="line">            OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">            OrderAccess::<span class="built_in">storeload</span>() ;</span><br><span class="line">            <span class="comment">// Ratify the previously observed values.</span></span><br><span class="line">             </span><br><span class="line">             <span class="comment">//如果cxq为空 则结束</span></span><br><span class="line">            <span class="keyword">if</span> (_cxq == <span class="literal">NULL</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// inopportune interleaving -- the exiting thread (this thread)</span></span><br><span class="line">            <span class="comment">// in the fast-exit path raced an entering thread in the slow-enter</span></span><br><span class="line">            <span class="comment">// path.</span></span><br><span class="line">            <span class="comment">// We have two choices:</span></span><br><span class="line">            <span class="comment">// A.  Try to reacquire the lock.</span></span><br><span class="line">            <span class="comment">//     If the CAS() fails return immediately, otherwise</span></span><br><span class="line">            <span class="comment">//     we either restart/rerun the exit operation, or simply</span></span><br><span class="line">            <span class="comment">//     fall-through into the code below which wakes a successor.</span></span><br><span class="line">            <span class="comment">// B.  If the elements forming the EntryList|cxq are TSM</span></span><br><span class="line">            <span class="comment">//     we could simply unpark() the lead thread and return</span></span><br><span class="line">            <span class="comment">//     without having set _succ.</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">             <span class="comment">//运行到这里说明cxq不为空，将持锁线程重新交给监视器的ONWER</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//cas失败则加锁失败返回</span></span><br><span class="line">               <span class="built_in">TEVENT</span> (Inflated exit - reacquired succeeded) ;</span><br><span class="line">               <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - reacquired failed) ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//接下来是唤醒等待队列线程的操作 通过Qmode来判断唤醒操作</span></span><br><span class="line">      <span class="built_in">guarantee</span> (_owner == THREAD, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="type">int</span> QMode = Knob_QMode ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// QMode == 2 : cxq has precedence over EntryList.</span></span><br><span class="line">          <span class="comment">// Try to directly wake a successor from the cxq.</span></span><br><span class="line">          <span class="comment">// If successful, the successor will need to unlink itself from cxq.</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line">          <span class="comment">// This policy ensure that recently-run threads live at the head of EntryList.</span></span><br><span class="line">          <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">          <span class="comment">// First, detach _cxq.</span></span><br><span class="line">          <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Append the RATs to the EntryList</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> organize EntryList as a CDLL so we can locate the tail in constant-time.</span></span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line">          <span class="comment">// This policy ensure that recently-run threads live at the head of EntryList.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">          <span class="comment">// First, detach _cxq.</span></span><br><span class="line">          <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Prepend the RATs to the EntryList</span></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          _EntryList = w ;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// I&#x27;d like to write: guarantee (w-&gt;_thread != Self).</span></span><br><span class="line">          <span class="comment">// But in practice an exiting thread may find itself on the EntryList.</span></span><br><span class="line">          <span class="comment">// Lets say thread T1 calls O.wait().  Wait() enqueues T1 on O&#x27;s waitset and</span></span><br><span class="line">          <span class="comment">// then calls exit().  Exit release the lock by setting O._owner to NULL.</span></span><br><span class="line">          <span class="comment">// Lets say T1 then stalls.  T2 acquires O and calls O.notify().  The</span></span><br><span class="line">          <span class="comment">// notify() operation moves T1 from O&#x27;s waitset to O&#x27;s EntryList. T2 then</span></span><br><span class="line">          <span class="comment">// release the lock &quot;O&quot;.  T2 resumes immediately after the ST of null into</span></span><br><span class="line">          <span class="comment">// _owner, above.  T2 notices that the EntryList is populated, so it</span></span><br><span class="line">          <span class="comment">// reacquires the lock and then finds itself on the EntryList.</span></span><br><span class="line">          <span class="comment">// Given all that, we have to tolerate the circumstance where &quot;w&quot; is</span></span><br><span class="line">          <span class="comment">// associated with Self.</span></span><br><span class="line">          <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we find that both _cxq and EntryList are null then just</span></span><br><span class="line">      <span class="comment">// re-run the exit protocol from the top.</span></span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Drain _cxq into EntryList - bulk transfer.</span></span><br><span class="line">      <span class="comment">// First, detach _cxq.</span></span><br><span class="line">      <span class="comment">// The following loop is tantamount to: w = swap (&amp;cxq, NULL)</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Inflated exit - drain cxq into EntryList) ;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      <span class="built_in">assert</span> (_EntryList  == <span class="literal">NULL</span>    , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Convert the LIFO SLL anchored by _cxq into a DLL.</span></span><br><span class="line">      <span class="comment">// The list reorganization step operates in O(LENGTH(w)) time.</span></span><br><span class="line">      <span class="comment">// It&#x27;s critical that this step operate quickly as</span></span><br><span class="line">      <span class="comment">// &quot;Self&quot; still holds the outer-lock, restricting parallelism</span></span><br><span class="line">      <span class="comment">// and effectively lengthening the critical section.</span></span><br><span class="line">      <span class="comment">// Invariant: s chases t chases u.</span></span><br><span class="line">      <span class="comment">// TODO-<span class="doctag">FIXME:</span> consider changing EntryList from a DLL to a CDLL so</span></span><br><span class="line">      <span class="comment">// we have faster access to the tail.</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : drain cxq to EntryList, reversing order</span></span><br><span class="line">         <span class="comment">// We also reverse the order of the list.</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         <span class="built_in">assert</span> (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL</span></span><br><span class="line">      <span class="comment">// The MEMBAR is satisfied by the release_store() operation in ExitEpilog().</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// See if we can abdicate to a spinner instead of waking a thread.</span></span><br><span class="line">      <span class="comment">// A primary goal of the implementation is to reduce the</span></span><br><span class="line">      <span class="comment">// context-switch rate.</span></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="built_in">guarantee</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="锁释放流程图"   >
          <a href="#锁释放流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁释放流程图" class="headerlink" title="锁释放流程图"></a>锁释放流程图</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230803194242527.png"  alt="锁释放流程图">
      </p>

        <h2 id="锁的降级"   >
          <a href="#锁的降级" class="heading-link"><i class="fas fa-link"></i></a><a href="#锁的降级" class="headerlink" title="锁的降级"></a>锁的降级</h2>
      <p>我们在前面的偏向锁加锁和撤销偏向锁、轻量级锁膨胀、重量级锁膨胀、以及最后的锁的释放过程好像只是把锁头信息给改正，但是好像没有看到锁降级的过程，而锁降级确实是提供了一个方法</p>
<p><strong>即锁在虚拟机的全局安全点会检查是否有闲置的监控器</strong>，<strong>如果有会进行一个锁降级</strong></p>
<p>锁降级方法：在JVM的STW状态进行一个锁的降级</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ObjectSynchronizer::deflate_monitor</span><span class="params">(ObjectMonitor* mid, oop obj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         ObjectMonitor** FreeHeadp, ObjectMonitor** FreeTailp)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> deflated;</span><br><span class="line">  <span class="comment">// Normal case ... The monitor is associated with obj.</span></span><br><span class="line">  <span class="built_in">guarantee</span> (obj-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(mid), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  <span class="built_in">guarantee</span> (mid == obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">monitor</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">  <span class="built_in">guarantee</span> (mid-&gt;<span class="built_in">header</span>()-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mid-&gt;<span class="built_in">is_busy</span>()) &#123;</span><br><span class="line">     <span class="keyword">if</span> (ClearResponsibleAtSTW) mid-&gt;_Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">     deflated = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// Deflate the monitor if it is no longer being used</span></span><br><span class="line">     <span class="comment">// It&#x27;s idle - scavenge and return to the global free list</span></span><br><span class="line">     <span class="comment">// plain old deflation ...</span></span><br><span class="line">     <span class="built_in">TEVENT</span> (deflate_idle_monitors - scavenge1) ;</span><br><span class="line">     <span class="keyword">if</span> (TraceMonitorInflation) &#123;</span><br><span class="line">       <span class="keyword">if</span> (obj-&gt;<span class="built_in">is_instance</span>()) &#123;</span><br><span class="line">         ResourceMark rm;</span><br><span class="line">           tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Deflating object &quot;</span> INTPTR_FORMAT <span class="string">&quot; , mark &quot;</span> INTPTR_FORMAT <span class="string">&quot; , type %s&quot;</span>,</span><br><span class="line">                (<span class="type">void</span> *) obj, (<span class="type">intptr_t</span>) obj-&gt;<span class="built_in">mark</span>(), obj-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">external_name</span>());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Restore the header back to obj</span></span><br><span class="line">     obj-&gt;<span class="built_in">release_set_mark</span>(mid-&gt;<span class="built_in">header</span>());</span><br><span class="line">     mid-&gt;<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">     <span class="built_in">assert</span> (mid-&gt;<span class="built_in">object</span>() == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Move the object to the working free list defined by FreeHead,FreeTail.</span></span><br><span class="line">     <span class="keyword">if</span> (*FreeHeadp == <span class="literal">NULL</span>) *FreeHeadp = mid;</span><br><span class="line">     <span class="keyword">if</span> (*FreeTailp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       ObjectMonitor * prevtail = *FreeTailp;</span><br><span class="line">       <span class="built_in">assert</span>(prevtail-&gt;FreeNext == <span class="literal">NULL</span>, <span class="string">&quot;cleaned up deflated?&quot;</span>); <span class="comment">// TODO KK</span></span><br><span class="line">       prevtail-&gt;FreeNext = mid;</span><br><span class="line">      &#125;</span><br><span class="line">     *FreeTailp = mid;</span><br><span class="line">     deflated = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deflated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">37</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>KkkerAn</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>