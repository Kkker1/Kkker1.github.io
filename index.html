<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Kkker1&#39;s Blog">
<meta property="og:url" content="https://username.github.io/index.html">
<meta property="og:site_name" content="Kkker1&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kkker1">
<meta name="twitter:card" content="summary"><title>Kkker1's Blog</title><link ref="canonical" href="https://username.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2024/10/29/HarmonyOS%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%5B%E5%88%9D%E7%BA%A7%5D/">HarmonyOS学习手册</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-10-29</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">4.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">32分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>前言</strong></p>
<p>本篇知识将完全记载HarmonyOS视频教程知识内容，只用于后续复习、夯实基础或者八股(笑</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/" >HarmonyOS官网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<hr>

        <h1 id="简介"   >
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
      <p>为了应对应用开发目前所遇到的机遇、挑战和趋势，HarmonyOS孕育而生。</p>
<p>而当今移动应用开发所遇到的主要挑战</p>
<ul>
<li>针对不同设备上的不同操作系统，重复开发，维护多套版本</li>
<li>多种技术栈，对人员技能要求高</li>
<li>多种开发框架，不同的编程范式</li>
<li>命令式编程，关注细节，变更频繁，维护成本高</li>
</ul>
<p><em>HarmonyOS是新一代的智能终端操作系统，为不同设备的智能化、互联与协同提供了统一的语言，为用户带来简捷，流畅，连续，安全可靠的全场景交互体验</em></p>

        <h2 id="HarmonyOS的核心技术理念"   >
          <a href="#HarmonyOS的核心技术理念" class="heading-link"><i class="fas fa-link"></i></a><a href="#HarmonyOS的核心技术理念" class="headerlink" title="HarmonyOS的核心技术理念"></a>HarmonyOS的核心技术理念</h2>
      
        <h3 id="一次开发，多端部署"   >
          <a href="#一次开发，多端部署" class="heading-link"><i class="fas fa-link"></i></a><a href="#一次开发，多端部署" class="headerlink" title="一次开发，多端部署"></a>一次开发，多端部署</h3>
      <p>多端开发环境</p>
<ul>
<li>多端双向预览</li>
<li>低代码可视化开发</li>
</ul>
<p>多端开发能力</p>
<ul>
<li>多端UI适配</li>
<li>事件交互归一</li>
<li>设备能力抽象</li>
</ul>
<p>多端分发机制</p>
<ul>
<li>多设备按需分发</li>
<li>多入口按需分发</li>
</ul>

        <h3 id="可分克合，自由流转"   >
          <a href="#可分克合，自由流转" class="heading-link"><i class="fas fa-link"></i></a><a href="#可分克合，自由流转" class="headerlink" title="可分克合，自由流转"></a>可分克合，自由流转</h3>
      <p>可分可合</p>
<ul>
<li>独立开发元服务，按需组合为应用</li>
<li>应用和元服务独立商家</li>
</ul>
<p>自由流转</p>
<ul>
<li>跨端迁移</li>
<li>多端协同</li>
</ul>

        <h3 id="统一生态，原生智能"   >
          <a href="#统一生态，原生智能" class="heading-link"><i class="fas fa-link"></i></a><a href="#统一生态，原生智能" class="headerlink" title="统一生态，原生智能"></a>统一生态，原生智能</h3>
      <p>统一生态</p>
<ul>
<li>多应用生态共存，支持多端融合</li>
<li>统一接入标准，实现快速接入</li>
</ul>
<p>原生智能</p>
<ul>
<li>服务能力开放</li>
<li>应用能力开放</li>
<li>芯片能力开放</li>
</ul>

        <h1 id="DevEco-Studio搭建"   >
          <a href="#DevEco-Studio搭建" class="heading-link"><i class="fas fa-link"></i></a><a href="#DevEco-Studio搭建" class="headerlink" title="DevEco Studio搭建"></a>DevEco Studio搭建</h1>
      
        <h2 id="下载安装包"   >
          <a href="#下载安装包" class="heading-link"><i class="fas fa-link"></i></a><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2>
      <p>先下载安装包，DevEco Studio集成了SDK、构建插件、ohpm等工具，所以可以直接使用</p>
<blockquote>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://developer.huawei.com/consumer/cn/deveco-studio/#download" >官方下载地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="傻瓜式安装"   >
          <a href="#傻瓜式安装" class="heading-link"><i class="fas fa-link"></i></a><a href="#傻瓜式安装" class="headerlink" title="傻瓜式安装"></a>傻瓜式安装</h2>
      <p>下载解压，打开可执行文件(exe文件)，修改文件安装路径，傻瓜式下一步点击即可。</p>

        <h2 id="配置环境，启动第一个项目"   >
          <a href="#配置环境，启动第一个项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#配置环境，启动第一个项目" class="headerlink" title="配置环境，启动第一个项目"></a>配置环境，启动第一个项目</h2>
      <p><del>总所周知，第一个项目都是Hello World</del></p>
<p>快速入门，启动一个Hello World项目</p>

        <h3 id="新建项目"   >
          <a href="#新建项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h3>
      <p>新建一个Empty Ability项目，然后配置项目文件，命名为Hello World工程</p>

        <h3 id="初始化环境"   >
          <a href="#初始化环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h3>
      <p>初始化项目，如果报错可以通过检查开发环境来调整，通过<em>Diagnose Development Environment</em>也即诊断开发环境。</p>
<blockquote>
<p>Diagnose 具体打开路径： Help -&gt; Diagnostic Tools -&gt; Diagnose Development Environment </p>
</blockquote>
<p>如果出现如下报错</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Installing pnpm@8.13.1...</span><br><span class="line">npm ERR! code EExist</span><br><span class="line">...</span><br></pre></td></tr></table></div></figure>

<p><strong>解决方案</strong></p>
<p>1、将c盘下的.npmrc文件的register由淘宝镜像改成华为云镜像 <code>https://repo.huaweicloud.com/repository/npm</code></p>
<p>具体路径为：<code>C:\Users\Administrator\.npmrc</code></p>
<p>2、清除Node.js缓存</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean </span><br></pre></td></tr></table></div></figure>



<p>3、清除HarmonyOS缓存，并且重启应用</p>
<blockquote>
<p>File -&gt; Invalidate Caches..  -&gt; invalidate and Restart </p>
</blockquote>
<p>4、也许是Node.js文件权限不足，打开Node.js文件夹，将权限改成完全控制</p>

        <h3 id="启动项目"   >
          <a href="#启动项目" class="heading-link"><i class="fas fa-link"></i></a><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3>
      <p>从项目文件中找到Index.ets 然后选择设备启动（无绑定设备可以用Previewer启动项目），启动第一个Hello World工程，并且可以通过按钮交互</p>

        <h2 id="快捷键使用"   >
          <a href="#快捷键使用" class="heading-link"><i class="fas fa-link"></i></a><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>快捷键</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+Alt+B</td>
<td>跨语言跳转(如使用Native的C&#x2F;C++函数)</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td>Ctrl+F12</td>
<td>打开代码结构树</td>
</tr>
<tr>
<td>Alt+F7</td>
<td>查看变量引用位置</td>
</tr>
<tr>
<td>“&#x2F;**”+回车键</td>
<td>文档注释</td>
</tr>
<tr>
<td>“&#x2F;&#x2F;!”+回车键</td>
<td>C++文件快速生成注释</td>
</tr>
<tr>
<td>两次Shift键</td>
<td>代码查找界面</td>
</tr>
<tr>
<td>Ctrl+Alt+O</td>
<td>清除未引用的Import语句，对Import语句进行合并或排序</td>
</tr>
<tr>
<td>Ctrl+H</td>
<td>查看父子类的层次结构</td>
</tr>
<tr>
<td>Ctrl+O</td>
<td>重写方法</td>
</tr>
<tr>
<td>Alt+Insert</td>
<td>重构构造函数、GET&#x2F;SET方法、生成声明信息到Index文件</td>
</tr>
</tbody></table></div>

        <h2 id="模拟器"   >
          <a href="#模拟器" class="heading-link"><i class="fas fa-link"></i></a><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h2>
      <p>当没有真机运行时，我们可以自定义模拟器(虚拟机)来模拟真机。</p>
<p>在菜单栏的<code>Tools -&gt;Device Manager</code> 通过<code>Edit</code>设置模拟器的存储路径，然后点击<code>New Emulator</code>新建一个模拟器，新建模拟器时需要下载<strong>模拟器镜像</strong>，然后点击<code>Next</code>设置内存和存储空间，再点击<code>Finish</code>完成模拟器创建</p>
<ul>
<li><p>模拟器运行</p>
<p>模拟器通过点击<code>Actions</code>中的运行(RUN)按钮，随即等待开机即可运行</p>
</li>
<li><p>清除用户数据</p>
<p>模拟器通过点击<code>Actions</code>中的<code>Wipe User Data</code>清除用户数据，类似于回复出厂设置</p>
</li>
<li><p>关闭模拟器</p>
<p>模拟器可以通过显示的×或者<code>Actions</code>中的暂停(STOP)按钮关闭运行</p>
</li>
<li><p>操控屏幕（<strong>缩放</strong>）</p>
<p>可以通过<strong>按住Ctrl+鼠标左键</strong>缩放模拟器屏幕，按住Ctrl键之后，鼠标点击则会改成缩放状态</p>
</li>
<li><p>安装应用和上传文件</p>
<p>文件上传可以直接使用拖拽的方式，这样即可安装应用、上传文件</p>
</li>
</ul>

        <h1 id="ArkTS语言基础"   >
          <a href="#ArkTS语言基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArkTS语言基础" class="headerlink" title="ArkTS语言基础"></a>ArkTS语言基础</h1>
      
        <h2 id="变量和常量"   >
          <a href="#变量和常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2>
      <p><strong>声明</strong></p>
<p>声明结构如下</p>
<p><code>关键字</code>  +  <code>变量名/常量名</code>  +  <code>:</code>  +  <code>类型注释</code>  +  <code>=</code>  +  <code>值</code></p>
<p>例如</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//关键字 变量名/常量名 : 注释类型 =  值</span><br><span class="line">let        var   :  String = &#x27;Hello,world&#x27;;</span><br><span class="line"></span><br><span class="line">//这样就声明了一个变量var，其数据类型为String，并且初始值为Hello，World</span><br></pre></td></tr></table></div></figure>

<ul>
<li>变量声明：以关键字let开头的声明引入变量，变量在程序执行过程中可以具有不一样的值</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let var : number = 1;</span><br><span class="line">var = 2;</span><br></pre></td></tr></table></div></figure>



<ul>
<li>常量声明：以关键字const开头的声明引入常量，常量值不能被改变</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const VAR : number=2;</span><br><span class="line"></span><br><span class="line">VAR = 1; //编译时会报错</span><br></pre></td></tr></table></div></figure>



<p>又因为<code>ArkTS</code>在编译时必须确定所有数据类型，所以也有自动类型判断。</p>
<p>如果数据在声明时就已经确定了值，那么不需要显式声明变量类型，ArkTS允许自动推断类型。假如现在要声明一个Number类型A</p>
<ul>
<li><p>显式声明数据类型</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let A : number = 10  </span><br><span class="line">//该声明语法正确</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>非显式声明数据类型</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let A = 10;</span><br><span class="line">//该声明语法正确</span><br></pre></td></tr></table></div></figure></li>
</ul>
<hr>
<p><em><del>夹带私货环节</del></em></p>
<p>在我最熟悉的<code>java</code>中声明变量和常量的方式则如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java中声明变量   数据类型  变量名  =  值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//java中声明常量  final static 数据类型 变量名(大写) = 值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">STR_ABC</span> <span class="operator">=</span> <span class="string">&quot;ABC&quot;</span></span><br></pre></td></tr></table></div></figure>



<hr>

        <h2 id="数据类型"   >
          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2>
      <p>这里目前只介绍有哪些数据类型以及声明方法，具体数据类型具有的属性或者方法需要再由其他文章介绍</p>

        <h3 id="Number"   >
          <a href="#Number" class="heading-link"><i class="fas fa-link"></i></a><a href="#Number" class="headerlink" title="Number"></a>Number</h3>
      <p>任何整数、浮点数都能由number表示。</p>
<ul>
<li><p>整数部分</p>
<ul>
<li><p>十进制</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a1 = 10;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>十六进制</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a2 = 0Xaf;  //十六进制换算成十进制为175</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>八进制</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a3 = 0o7777; //八进制换算成十进制为4095</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>二进制</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a4 = 0b10010; //二进制换成十进制为18</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li><p>小数点</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let f1 = .234;  //0.234</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>十进制小数</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let f2 = 1.234; //1.234</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>指数</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let f3 = 1e2; //100</span><br><span class="line">let f4 = 1e-2; //0.01</span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
</ul>

        <h3 id="Boolean"   >
          <a href="#Boolean" class="heading-link"><i class="fas fa-link"></i></a><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3>
      <p>布尔类型，只有<code>true</code>和<code>flase</code>两个值。通常赋值为<code>flase</code>，程序运行阶段赋值为<code>true</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//初始化赋值为flase</span><br><span class="line">let isTrue : boolean = flase;</span><br><span class="line">//...</span><br><span class="line"></span><br><span class="line">isTrue = true;</span><br></pre></td></tr></table></div></figure>




        <h3 id="String"   >
          <a href="#String" class="heading-link"><i class="fas fa-link"></i></a><a href="#String" class="headerlink" title="String"></a>String</h3>
      <p>字符串类型，同样可以在字符串中利用转义字符<code>\</code>来表示字符</p>
<ul>
<li><p>单引号之间的字符可以表示字符串</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str1 = &#x27;Hello,World&#x27;;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>双引号之间的字符可以表示字符串</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str2 = &quot;Hello,World&quot;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>可以用反引号(&#96;)之间的字符可以表示字符串</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let temp = &#x27;XiaoMing&#x27;;</span><br><span class="line"></span><br><span class="line">let str3 = `Hello,World , My name is $&#123;temp&#125;` // Hello,World , My name is XiaoMing</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="Void"   >
          <a href="#Void" class="heading-link"><i class="fas fa-link"></i></a><a href="#Void" class="headerlink" title="Void"></a>Void</h3>
      <p>空返回类型，常用于指定某函数的返回为空</p>

        <h3 id="Object"   >
          <a href="#Object" class="heading-link"><i class="fas fa-link"></i></a><a href="#Object" class="headerlink" title="Object"></a>Object</h3>
      <p>对象类型，是所有类型的基类型，所有类型的值可以直接被赋给<code>Object</code>类型变量，<strong>都会被自动装箱</strong></p>

        <h3 id="Array"   >
          <a href="#Array" class="heading-link"><i class="fas fa-link"></i></a><a href="#Array" class="headerlink" title="Array"></a>Array</h3>
      <p>数组类型，由赋值的数据类型组成的存储对象。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [&#x27;zhangsan&#x27;,&#x27;lisi&#x27;,&#x27;wangwu&#x27;];</span><br><span class="line"></span><br><span class="line">let arr2 = [1,2,3,4,5];</span><br></pre></td></tr></table></div></figure>




        <h3 id="Enum"   >
          <a href="#Enum" class="heading-link"><i class="fas fa-link"></i></a><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h3>
      <p>枚举类型，预先定义好值的值类型。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum NUMBER &#123;ONE = 0X01,TWO = 0X02, THREE= 0X03&#125;;</span><br><span class="line">enum COLOR &#123;BLUE,WHITE,RED&#125;</span><br><span class="line"></span><br><span class="line">//枚举数据使用</span><br><span class="line">let num1 =NUMBER.ONE;</span><br><span class="line">let c = COLOR.BLUE;</span><br></pre></td></tr></table></div></figure>




        <h3 id="Union"   >
          <a href="#Union" class="heading-link"><i class="fas fa-link"></i></a><a href="#Union" class="headerlink" title="Union"></a>Union</h3>
      <p>联合类型，由多个类型组成的引用类型。联合类型包括了变量可能所有的类型</p>
<blockquote>
<p>有点像是<code>java</code>中的父类和子类的概念，父类包括了子类的所有类型</p>
</blockquote>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">  name:String = &#x27;dog&#x27;;</span><br><span class="line">  age:Number = 3;</span><br><span class="line"></span><br><span class="line">  sleep()&#123;</span><br><span class="line">    console.log(this.name+&#x27;正在睡觉&#x27;); //dog正在睡觉</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  wang()&#123;</span><br><span class="line">    console.log(this.name+&#x27;正在狗叫&#x27;); //dog正在狗叫</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">class Cat &#123;</span><br><span class="line">  name: String = &#x27;cat&#x27;;</span><br><span class="line">  age:Number = 5;</span><br><span class="line"></span><br><span class="line">  sleep()&#123;</span><br><span class="line">    console.log(this.name+&#x27;正在睡觉&#x27;); //cat正在睡觉</span><br><span class="line">  &#125;;</span><br><span class="line">  miao()&#123;</span><br><span class="line">    console.log(this.name+&#x27;正在喵喵叫&#x27;) //cat正在喵喵叫</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cow&#123;</span><br><span class="line">  name:String = &#x27;cow&#x27;;</span><br><span class="line">  age : number =2;</span><br><span class="line"></span><br><span class="line">  sleep()&#123;</span><br><span class="line">    console.log(this.name+&#x27;正在睡觉&#x27;); //cow正在睡觉</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  meow()&#123;</span><br><span class="line">    console.log(this.name+&#x27;勇敢牛牛不怕困难&#x27;); //cow勇敢牛牛不怕困难</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Animal = Cat | Cow | Dog  ; //Animal包括Cat/Cow/Dog类型</span><br><span class="line">let animal :Animal =new Cat(); //新建一个Cat对象，用Animal类型来装</span><br><span class="line">animal.sleep();//cat正在睡觉</span><br><span class="line">animal.miao(); //cat正在喵喵叫</span><br><span class="line"></span><br><span class="line">animal = new Cow();//新建一个Cow对象，赋值给animal</span><br><span class="line"></span><br><span class="line">animal.sleep(); //cow正在睡觉</span><br><span class="line"></span><br><span class="line">function foo(animal: Animal)&#123;</span><br><span class="line">  if(animal instanceof Cat)&#123;</span><br><span class="line">    //如果是Cat类型的对象，则会进来启动miao方法</span><br><span class="line">    animal.miao(); </span><br><span class="line">  &#125;</span><br><span class="line">  animal.sleep();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//传入Animal对象的值</span><br><span class="line">foo(animal)</span><br></pre></td></tr></table></div></figure>




        <h3 id="Aliases"   >
          <a href="#Aliases" class="heading-link"><i class="fas fa-link"></i></a><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h3>
      <p>匿名类型，为数组、函数、对象字面量、联合类型提供名称，或为已有类型提供替代名称</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Animal = Cat | Dog | Cow;</span><br></pre></td></tr></table></div></figure>




        <h2 id="运算符"   >
          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>
      <p>运算符和其他语言的部分都是大差不差的，可以简单过一下即可。</p>

        <h3 id="赋值运算符"   >
          <a href="#赋值运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3>
      <p>赋值运算符：<code>=</code></p>
<p>复合赋值运算符:<code>+=</code>、<code>-=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&gt;&gt;&gt;=</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code>。</p>

        <h3 id="比较运算符"   >
          <a href="#比较运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;&#x3D;</td>
<td>如果两个操作数严格相等（对于不同类型的操作数认为是不相等的），则返回true。</td>
</tr>
<tr>
<td>!&#x3D;&#x3D;</td>
<td>如果两个操作数严格不相等（对于不同类型的操作数认为是不相等的），则返回true。</td>
</tr>
<tr>
<td>&#x3D;&#x3D;</td>
<td>如果两个操作数相等，则返回true。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>如果两个操作数不相等，则返回true。</td>
</tr>
<tr>
<td>&gt;</td>
<td>如果左操作数大于右操作数，则返回true</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>如果左操作数大于或等于右操作数，则返回true。</td>
</tr>
<tr>
<td>&lt;</td>
<td>如果左操作数小于右操作数，则返回true。</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>如果左操作数小于或等于右操作数，则返回true。</td>
</tr>
</tbody></table></div>

        <h3 id="算术运算符"   >
          <a href="#算术运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>除法</td>
</tr>
<tr>
<td>%</td>
<td>除法后余数（求余数）</td>
</tr>
<tr>
<td>–</td>
<td>减减(-1)</td>
</tr>
<tr>
<td>++</td>
<td>加加(+1)</td>
</tr>
</tbody></table></div>

        <h3 id="位运算符"   >
          <a href="#位运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a &amp; b</td>
<td><strong>按位与</strong>，a和b的二进制对应位都为1时，将这个位设为1，反之设为0</td>
</tr>
<tr>
<td>a | b</td>
<td><strong>按位或</strong>，a和b的二进制对应位有一个为1时，将这个位设为1，反之设为0</td>
</tr>
<tr>
<td>a ^ b</td>
<td><strong>按位异或</strong>，a和b的二进制对应位如果不同，将这个位设为1，反之设为0</td>
</tr>
<tr>
<td>~ b</td>
<td><strong>按位非</strong>，反转操作数的位（按64位计算，如10010 则反转之后为FFFF FFFF FFFF FFED)</td>
</tr>
<tr>
<td>a &lt;&lt; b</td>
<td><strong>左移</strong>，将a的二进制按位左移b位（如10010 &lt;&lt; 2 则左移之后为 0100 1000）</td>
</tr>
<tr>
<td>a &gt;&gt; b</td>
<td><strong>算数右移</strong>，将a的二进制按位右移b位，保持原正负属性（即正数高位补0，负数高位补1）</td>
</tr>
<tr>
<td>a &gt;&gt;&gt; b</td>
<td><strong>逻辑右移</strong>，将a的二进制按位右移b位，高位补0</td>
</tr>
</tbody></table></div>

        <h3 id="逻辑运算符"   >
          <a href="#逻辑运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a &amp;&amp; b</td>
<td>逻辑与</td>
</tr>
<tr>
<td>a || b</td>
<td>逻辑或</td>
</tr>
<tr>
<td>！a</td>
<td>逻辑非</td>
</tr>
</tbody></table></div>

        <h2 id="语句"   >
          <a href="#语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#语句" class="headerlink" title="语句"></a>语句</h2>
      <p>语句这部分也和基础语言类型一致，可以简单过一遍(跳过)</p>

        <h3 id="if"   >
          <a href="#if" class="heading-link"><i class="fas fa-link"></i></a><a href="#if" class="headerlink" title="if"></a>if</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (判断条件A) &#123;</span><br><span class="line">	//条件A为真 则进入该语句中</span><br><span class="line">	</span><br><span class="line">&#125;else if (判断条件B) &#123;</span><br><span class="line">	//条件A为假并且B为真 则进入该语句中</span><br><span class="line">	</span><br><span class="line">&#125;else if&#123;</span><br><span class="line">	//条件A为假并且B为假 则进入该语句中</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="switch"   >
          <a href="#switch" class="heading-link"><i class="fas fa-link"></i></a><a href="#switch" class="headerlink" title="switch"></a>switch</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式)&#123;</span><br><span class="line">	case A :</span><br><span class="line">	//语句一	</span><br><span class="line">	//可以选择使用break跳出当前循环</span><br><span class="line">	break; </span><br><span class="line">	//如果没有break跳出循环，则会执行下面所有语句</span><br><span class="line">	case B:</span><br><span class="line">	case C:</span><br><span class="line">	//如果表达式符合B或者C，则会执行下面语句</span><br><span class="line">	</span><br><span class="line">	//...</span><br><span class="line">	</span><br><span class="line">	//选择break跳出switch语句</span><br><span class="line">	break;</span><br><span class="line">	</span><br><span class="line">	default:</span><br><span class="line">	//默认执行语句，当条件都不符合的时候执行默认语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="三元表达式"   >
          <a href="#三元表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3>
      <p><strong>公式为</strong><code>判断条件 ? 结果1 : 结果2</code></p>
<p>简单举个例子</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let flag = number &gt;= 10 ? true : false</span><br><span class="line">//如果number &gt;= 10 则赋值语句执行 ? 后面的结果，反之执行 :后面的结果</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="For"   >
          <a href="#For" class="heading-link"><i class="fas fa-link"></i></a><a href="#For" class="headerlink" title="For"></a>For</h3>
      <p><strong>公式为</strong><code>For(初始化数据 ; 条件 ;单层循环后执行的语句)&#123;&#125;</code></p>
<p>也举一个最简单例子，做十次循环</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt;= 10; i++) &#123;</span><br><span class="line">  //语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="For-of"   >
          <a href="#For-of" class="heading-link"><i class="fas fa-link"></i></a><a href="#For-of" class="headerlink" title="For-of"></a>For-of</h3>
      <p>增强<code>For</code>语句，<strong>公式为</strong> <code>For( arr of arrs)&#123;&#125;</code></p>
<p>假设一个数组Arrs&#x3D; [1,2,3,4,5]，那么将每一个元素Arr取出来也即Arr[0],…,Arr[4]。也即是遍历</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let Arrs = [ 1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">for( Arr of Arrs)&#123;</span><br><span class="line">	//...语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="While"   >
          <a href="#While" class="heading-link"><i class="fas fa-link"></i></a><a href="#While" class="headerlink" title="While"></a>While</h3>
      <p><strong>公式为</strong><code>While(条件)&#123;&#125;</code></p>
<p>只要条件为真则会一直循环下去，直到条件为假</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let w_1 = 10;</span><br><span class="line">while ( w_1 -- &gt;=0)&#123; //倒数10-0</span><br><span class="line">  console.log((w_1+1).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="Do-While"   >
          <a href="#Do-While" class="heading-link"><i class="fas fa-link"></i></a><a href="#Do-While" class="headerlink" title="Do-While"></a>Do-While</h3>
      <p><strong>公式为</strong><code>Do &#123; 语句 &#125; while (条件)</code></p>
<p>Do-While也即必定会先执行一次语句的While语句</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let i_2 = 0;</span><br><span class="line">do &#123;</span><br><span class="line">  i_2 += 1;</span><br><span class="line">  console.log(i_2.toString());</span><br><span class="line">&#125; while (i_2 &lt; 10)</span><br></pre></td></tr></table></div></figure>


        <h3 id="Break"   >
          <a href="#Break" class="heading-link"><i class="fas fa-link"></i></a><a href="#Break" class="headerlink" title="Break"></a>Break</h3>
      <p>Break语句用于跳出循环，一般用于循环或者Switch语句中</p>
<p>我们拿之前For循环的语句举例，当我们倒数到5的时候就跳出循环</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt;= 10; i++) &#123;</span><br><span class="line">  //语句</span><br><span class="line">  if( i == 5 ) break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="continue"   >
          <a href="#continue" class="heading-link"><i class="fas fa-link"></i></a><a href="#continue" class="headerlink" title="continue"></a>continue</h3>
      <p>continue语句用于结束本次循环，继续下次循环</p>
<p>我们也拿之前For循环的语句举例，当我们倒数为3的时候就跳到下一次循环中(2)</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &lt;= 10; i++) &#123;</span><br><span class="line">   if( i == 2 ) continue;</span><br><span class="line">   //语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="Throw"   >
          <a href="#Throw" class="heading-link"><i class="fas fa-link"></i></a><a href="#Throw" class="headerlink" title="Throw"></a>Throw</h3>
      <p>Throw语句用于跑出异常</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new Error(&#x27;this error&#x27;)</span><br></pre></td></tr></table></div></figure>




        <h3 id="Try"   >
          <a href="#Try" class="heading-link"><i class="fas fa-link"></i></a><a href="#Try" class="headerlink" title="Try"></a>Try</h3>
      <p>Try语句用于捕捉和处理异常或者错误</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  // 可能发生异常的语句块</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">  // 异常处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>Finally，用于Try-Catch语句中一定要执行的语句</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   // ...</span><br><span class="line">   // 可能发生异常的语句</span><br><span class="line">   // ...</span><br><span class="line"> &#125; catch (e) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   // 异常处理</span><br><span class="line">   // ...</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line">   if (error != null) &#123;</span><br><span class="line">     console.log(`Error caught: input=&#x27;$&#123;s&#125;&#x27;, message=&#x27;$&#123;error.message&#125;&#x27;`);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="函数"   >
          <a href="#函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数" class="headerlink" title="函数"></a>函数</h2>
      
        <h3 id="函数声明"   >
          <a href="#函数声明" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function 函数名 (变量名 : 变量类型) : 返回类型 &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>举例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//定义一个函数foo，传入number类型的参数n，函数返回string类型结果</span><br><span class="line">function foo ( n : number ) : string &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>传参规则：</p>
<ul>
<li>每个参数必须标记类型</li>
<li>如果参数是可选参数，则调用函数时可以省略传递该参数</li>
<li>可以为可变参数(rest参数)，那么可变参数(rest参数)一定是最后一个参数</li>
</ul>

        <h3 id="可选参数"   >
          <a href="#可选参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3>
      <p>可选参数意思是指定过程中参数是可选的，可以不传递则默认为<code>undefined</code></p>
<p><strong>可选参数的格式为</strong>：<code>name ?: type</code></p>
<ul>
<li><code>name</code> 变量名</li>
<li><code>?:</code> 表示参数为可选参数</li>
<li><code>type</code> 参数数据类型</li>
</ul>
<p>举例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义一个函数foo，传入number类型的参数n，一个可选参数str，函数返回string类型结果</span><br><span class="line">function foo ( n : number , str ?: string ) : string &#123;&#125;</span><br><span class="line"></span><br><span class="line">//使用方式</span><br><span class="line">foo(1);</span><br><span class="line">foo(1,&#x27;Hello&#x27;)</span><br></pre></td></tr></table></div></figure>




        <h3 id="Rest参数"   >
          <a href="#Rest参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rest参数" class="headerlink" title="Rest参数"></a>Rest参数</h3>
      <p>可变参数(rest参数)，表示这个参数有零个或者多个数量</p>
<p>rest参数的格式为：<code>... name : types</code></p>
<ul>
<li><code>...</code> 表示该参数为可变参数</li>
<li><code>name</code> 参数名</li>
<li><code>:</code> 后接参数类型</li>
<li><code>types</code> 接变量数据类型的数组</li>
</ul>
<p>举例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义一个函数foo,传入一个可选参数str,可变参数numbers,函数返回number类型结果</span><br><span class="line">function foo (str ?: string  , ...numbers : number[]) : number &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用方式</span><br><span class="line">foo(undefined,1);</span><br><span class="line">foo(undefined,1,2,3);</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="返回类型"   >
          <a href="#返回类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3>
      <ul>
<li>显式返回类型</li>
<li>不标注返回类型</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//显式标注返回类型</span><br><span class="line">funtion foo (n : number) : string &#123; return &#x27;result&#x27;;&#125;</span><br><span class="line"></span><br><span class="line">//不标注返回类型，可以通过函数声明中判断</span><br><span class="line">function foo2 (n: number)  &#123;return &#x27;result&#x27;;&#125; //通过return判断返回string类型</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>不需要返回类型，使用void或者省略标注</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//显式标注返回类型为void</span><br><span class="line">function foo3(n:number) : void &#123;&#125;</span><br><span class="line"></span><br><span class="line">//省略标注void返回类型</span><br><span class="line">function foo4(n:number)&#123;&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="作用域"   >
          <a href="#作用域" class="heading-link"><i class="fas fa-link"></i></a><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3>
      <p>函数的作用域也和基础语言一致，都有局部属性</p>
<p>函数内被定义的变量和实例仅可以在函数内部访问，而不能从外部访问。并且当函数的局部变量和外部有重名，则会函数内的局部定义将会覆盖外部定义直到结束函数。</p>

        <h3 id="函数调用"   >
          <a href="#函数调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3>
      <p>函数调用如果有传入参数，则实参会被赋给形参。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义函数</span><br><span class="line">function foo ( n1: number ,n2 : number ) &#123;&#125;</span><br><span class="line"></span><br><span class="line">//调用函数</span><br><span class="line">foo(1,2); //将1传给n1, 2传给n2</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="函数类型"   >
          <a href="#函数类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3>
      <p>函数类型通常用于定义回调：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type trigFunc = (x: number) =&gt; number //这是一个函数类型 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function do_action(f: trigFunc) &#123;</span><br><span class="line">f(3.141592653589); // 调用函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do_action(Math.sin); // 将函数作为参数传入</span><br></pre></td></tr></table></div></figure>


        <h3 id="Lambda函数"   >
          <a href="#Lambda函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h3>
      <p><code>lambda</code>函数，可以通过匿名函数的方式声明函数</p>
<p>举例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sum = (x : number , y : number) : number =&gt; &#123;</span><br><span class="line">	let result = 0;</span><br><span class="line">	//...</span><br><span class="line">	</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>省略返回数据类型</p>
<p>如果返回类型可以从函数体内推断出，那么可以省略返回类型</p>
</li>
<li><p>省略大括号</p>
<p>如果函数体只有一条，那么可以省略大括号</p>
</li>
<li><p>省略<code>return</code></p>
<p>如果函数体只有一条，那么可以省略<code>return</code></p>
</li>
</ul>
<p>完整形式</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let sum = (x : number ,y : number) : number =&gt;&#123;</span><br><span class="line">	return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>具体解析</p>
<ul>
<li><code>(x : number , y: number)</code> 表示函数有两个<code>number</code> 类型参数<code>x</code>和&#96;y&#96;&#96;</li>
<li>&#96;&#96;:&#96;  后接返回数据类型</li>
<li><code>number</code> 表示返回<code>number</code> 类型数据</li>
<li><code>=&gt;</code> 表示此为<code>lambda</code> 形式函数，后接函数体</li>
<li><code>&#123;</code> 大括号(左)，表示这是函数体的开始</li>
<li><code>return x + y;</code> 函数体内容，返回<code>x + y</code>的结果数据</li>
<li><code>&#125;</code> 大括号(右)，表示这是函数体的结束</li>
</ul>
</li>
<li><p>省略返回数据类型</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sum = (x : number, y : number) =&gt; &#123;return x + y;&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>省略大括号、省略<code>return</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let sum = (x : number , y : number) =&gt; x+y</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="闭包"   >
          <a href="#闭包" class="heading-link"><i class="fas fa-link"></i></a><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3>
      <p>闭包是由函数及声明该函数的环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。</p>
<p>在下例中，f函数返回了一个闭包，它捕获了count变量，每次调用z，count的值会被保留并递增。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(): () =&gt; number &#123;</span><br><span class="line">  let count = 0;</span><br><span class="line">  let g = (): number =&gt; &#123; count++; return count; &#125;;</span><br><span class="line">  return g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let z = f();</span><br><span class="line">z(); // 返回：1</span><br><span class="line">z(); // 返回：2</span><br></pre></td></tr></table></div></figure>


        <h3 id="函数重载"   >
          <a href="#函数重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3>
      <p>一个函数名可以通过不同的函数头实现函数的重载，具体操作如下</p>
<p>一个函数写入多个同名但是参数不同的函数头，<strong>函数实现必须紧随其后</strong></p>
<p>具体实例</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fun2 ( n : number ) :string ; //第一个函数定义</span><br><span class="line">function fun2 ( n ?: string) :string ; //第二个函数定义</span><br><span class="line">function fun2 ( n: number | string | undefined) : string &#123; /* 函数实现 */</span><br><span class="line">  return &#x27;&#x27;;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//使用第一个函数定义</span><br><span class="line">fun2(1);</span><br><span class="line">//使用第二个函数定义</span><br><span class="line">fun2(undefined);</span><br></pre></td></tr></table></div></figure>

<ul>
<li>在函数重载时，函数头后不允许带入大括号，表示这不是一个完整的函数</li>
<li>在函数实现时，函数必须紧跟所有函数头之后，然后需要带上大括号，表示这是一个函数的实现</li>
</ul>

        <h2 id="类"   >
          <a href="#类" class="heading-link"><i class="fas fa-link"></i></a><a href="#类" class="headerlink" title="类"></a>类</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2024/10/15/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BAWLAN%E9%97%AE%E9%A2%98/">网络排查-无法正常显示WLAN问题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-10-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">891</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">4分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="情况背景"   >
          <a href="#情况背景" class="heading-link"><i class="fas fa-link"></i></a><a href="#情况背景" class="headerlink" title="情况背景"></a>情况背景</h1>
      <p>到生产环境中，由于工作需要所以突发性的需要用电脑连接网线，但是出现了问题：<strong>网络连接正常，无法连接网络</strong>。</p>

        <h2 id="网络属性"   >
          <a href="#网络属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络属性" class="headerlink" title="网络属性"></a>网络属性</h2>
      <p>网络属性一切正常，但是仍然出现异常网络问题</p>
<blockquote>
<p> DNS服务器以及分发到的IP地址成功获取&#96;</p>
</blockquote>
<p><strong>异常一</strong> ：无法Ping通已有局域网的设备IP</p>
<p><strong>异常二</strong>：无法Ping通公共网络IP地址，如<code>www.baidu.com</code>、<code>www.bilibili.com</code></p>
<p>但是仍然能Ping通DNS服务器也即交换机IP</p>

        <h2 id="排查过程"   >
          <a href="#排查过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2>
      <p>1、将网线端口重新拔插，验证是否与交换机网线端口相连，结果：端口与交换机正常相连</p>
<p>2、将LAN口的网线直接与交换机相连，结果：网线正常</p>
<p>3、将LAN口的网线直接与其他设备相连，结果：显示PING不通，但是设备依然能够联网</p>
<p>4、重新插入到本机，结果：<strong>依然不能联网</strong></p>
<p><strong>排查结果</strong>：网线、端口以及交换机正常，本机网络配置有问题</p>
<p>然后采用WLAN，尝试用无线连接互联网，结果是：<strong>已连接，但无法访问网络。安全</strong></p>
<p>此时才正式确定是我本机网络配置，也即网卡驱动异常导致</p>

        <h1 id="解决过程"   >
          <a href="#解决过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1>
      
        <h2 id="重启"   >
          <a href="#重启" class="heading-link"><i class="fas fa-link"></i></a><a href="#重启" class="headerlink" title="重启"></a>重启</h2>
      <p>古话说得好，重启能解决一切问题。然而，此次重启之后再连接无线网络，仍然无法访问网络</p>

        <h2 id="重新挂起-关闭-VPN"   >
          <a href="#重新挂起-关闭-VPN" class="heading-link"><i class="fas fa-link"></i></a><a href="#重新挂起-关闭-VPN" class="headerlink" title="重新挂起&#x2F;关闭 VPN"></a>重新挂起&#x2F;关闭 VPN</h2>
      <p>VPN没关可能会导致DNS解析错误，因此导致访问网络失败。但是本次并未解决完成</p>

        <h2 id="确定局域网网络配置是否是自动配置或者使用代理服务器"   >
          <a href="#确定局域网网络配置是否是自动配置或者使用代理服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#确定局域网网络配置是否是自动配置或者使用代理服务器" class="headerlink" title="确定局域网网络配置是否是自动配置或者使用代理服务器"></a>确定局域网网络配置是否是自动配置或者使用代理服务器</h2>
      <p>本次都是自动获取，所以本项没有进行</p>

        <h2 id="初始化网络环境"   >
          <a href="#初始化网络环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化网络环境" class="headerlink" title="初始化网络环境"></a>初始化网络环境</h2>
      <p>使用命令行代码，尝试初始化网络环境，然后设置成功后重启</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br><span class="line">//用管理员身份的打开命令提示符(CMD),初始化网络环境</span><br></pre></td></tr></table></div></figure>


        <h2 id="重置网络"   >
          <a href="#重置网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#重置网络" class="headerlink" title="重置网络"></a>重置网络</h2>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20241016005666666.JPG"  alt="重启网络">
      </p>
<p>重置网络待重启之后，<strong>发现WLAN标志消失，无法连接WIFI</strong></p>

        <h2 id="删除网卡驱动，重新获取网卡"   >
          <a href="#删除网卡驱动，重新获取网卡" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除网卡驱动，重新获取网卡" class="headerlink" title="删除网卡驱动，重新获取网卡"></a>删除网卡驱动，重新获取网卡</h2>
      <ul>
<li><p>打开设备管理器，选择网络适配器</p>
</li>
<li><p>选择卸载设备，<strong>取消勾选</strong>删除驱动 </p>
</li>
<li><p>重新点击扫描硬件改动</p>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20241016005736933.png"  alt="卸载网卡，重新扫描">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20241016005945348.png"  alt="扫描硬件改动">
      </p>

        <h2 id="更新网络驱动"   >
          <a href="#更新网络驱动" class="heading-link"><i class="fas fa-link"></i></a><a href="#更新网络驱动" class="headerlink" title="更新网络驱动"></a>更新网络驱动</h2>
      <ul>
<li>打开设备管理器，选择网络适配器</li>
<li>选择网卡驱动，更新驱动程序</li>
<li>选择浏览我的电脑以查找驱动程序</li>
<li>选择让我从计算机上可用驱动程序列表中获取</li>
<li>选择更新最新的驱动，随机等待更新完成</li>
</ul>

        <h2 id="尝试打开-关闭飞行模式"   >
          <a href="#尝试打开-关闭飞行模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#尝试打开-关闭飞行模式" class="headerlink" title="尝试打开&#x2F;关闭飞行模式"></a>尝试打开&#x2F;关闭飞行模式</h2>
      
        <h2 id="选择删除注册表内容"   >
          <a href="#选择删除注册表内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择删除注册表内容" class="headerlink" title="选择删除注册表内容"></a>选择删除注册表内容</h2>
      <p>因为可能由于虚拟机改变了网卡设置，所以尝试删除注册表内容</p>
<blockquote>
<p> 此处学习了UP主：鸟人飞飞  所发出的视频，具体视频链接：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HW4y1q7Kx/?spm_id_from=333.999.0.0&vd_source=481a97bdbe9fdb27ab06f7f88300d77b" >网卡错误代码56的解决方法及原因分析（无声）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<ul>
<li><p>如已经删除VM虚拟机，则执行以下指令删除注册表内容</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg delete HKCR\CLSID\&#123;3d09c1ca-2bcc-40b7-b9bb-3f3ec143a87b&#125; /f</span><br><span class="line">//以管理员身份运行CMD后，执行</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>如未删除VM虚拟机，则执行以下指令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 C:\WINDOWS\System32\vmnetbridge.dll</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>最终重启解决问题</p>
</li>
</ul>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>以上是我解决实际遇到的网卡驱动导致的联网问题，希望有遇到该类问题时能再回顾来看本篇记载，一步步排查问题并尽快解决</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2024/03/10/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%5B%E7%BC%93%E5%AD%98%5D/">系统架构设计-[缓存]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-03-10</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">352</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">2分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="MyBatis"   >
          <a href="#MyBatis" class="heading-link"><i class="fas fa-link"></i></a><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1>
      
        <h2 id="一级缓存"   >
          <a href="#一级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2>
      <p>在<code>MyBatis</code>中的一级缓存是指在同一个<code>sqlSession</code>中执行同样的语句，会优先去命中一级缓存。避免多次同样的查询直接击中数据库</p>

        <h3 id="如何使用一级缓存"   >
          <a href="#如何使用一级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用一级缓存" class="headerlink" title="如何使用一级缓存"></a>如何使用一级缓存</h3>
      <p>当我们使用<code>MyBatis</code>时可以设置参数<code>local-cache-scope</code></p>
<ul>
<li>session：同一个session会添加一级缓存</li>
<li>statement：<strong>默认级别</strong>，添加的缓存仅对当前执行的<code>statement</code>有效</li>
</ul>
<p><code>application.yml</code>中配置session级别</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    local-cache-scope: session </span><br></pre></td></tr></table></div></figure>

<p><code>application.yml</code>中配置statement级别</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    local-cache-scope: statement</span><br></pre></td></tr></table></div></figure>




        <h3 id="缓存的属性"   >
          <a href="#缓存的属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存的属性" class="headerlink" title="缓存的属性"></a>缓存的属性</h3>
      
        <h4 id="生命周期"   >
          <a href="#生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4>
      <p>生命周期和<code>sqlSession</code>一致，当会话开启产生一级缓存，当会话结束关闭一级缓存</p>

        <h4 id="存储形式"   >
          <a href="#存储形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h4>
      <p>一级缓存通过<code>HashMap</code>的设置，实际上通过<code>HashMap</code>实现缓存</p>

        <h4 id="刷新周期"   >
          <a href="#刷新周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#刷新周期" class="headerlink" title="刷新周期"></a>刷新周期</h4>
      <p>一级缓存的刷新<strong>只能</strong>对数据有所更改的时候刷新（增删改）。所以如果使用一级缓存，在会话没有关闭之前没有进行增删改手动刷新一级缓存，那么就可能会产生脏数据</p>

        <h2 id="二级缓存"   >
          <a href="#二级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2>
      <p>二级缓存是全局的，相较于一级缓存只能在同一个SqlSession中，二级缓存的作用范围更加广泛</p>

        <h3 id="如何使用二级缓存"   >
          <a href="#如何使用二级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用二级缓存" class="headerlink" title="如何使用二级缓存"></a>如何使用二级缓存</h3>
      <p>二级缓存的使用可以通过<code>xml</code>文件中添加<code>&lt;cache/&gt;</code>，如此一来就能启动二级缓存</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">2023年度总结</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-12-31</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">287</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>我这飘忽不定的2023年</strong></p>
<hr>
<p> 今年不知从何处来，也不知往何处去。从年初的闭关却陷入体育生沉淀之途，年中杭州之行的失败尝试，再到年底的秋招无果之旅，仿佛说明我这一年的失败是必然而成的。</p>
<p><strong>未完成的任务</strong></p>
<hr>
<p>我还有好几篇文章还没写完。</p>
<p>【深入剖析并发编程】我还有并发容器等还没能补全</p>
<p>【死之前要学完的算法】我还有算法题还没能做完，但从十二月份的失败之后就开始停摆了，在2024年前我得重启任务</p>
<p>【面试题】部分我还有特别多篇没有写完</p>
<p>【Java基础】我还没重新看起</p>
<p>【项目】还没能全部写完</p>
<p><strong>对未来的展望</strong></p>
<hr>
<p>首当其冲的就是先把今年未能完成的任务补完，然后是继续启动算法任务。</p>
<p>其次就是在哪里失败就在哪里爬起来，继续沉淀</p>
<p>第三就是好好生活，好好吃饭</p>
<p>明年会变的更好，一步步往前走，是往前就好</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/11/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B7-%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%5D/">深入剖析并发编程-JUC篇[7-线程、线程池]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-11-06</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">101分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>本篇是进程、线程、多线程详解</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
<li>第四篇是Atomic原子包源码详解</li>
<li>第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC并发工具包</li>
<li>第六篇是并发容器</li>
<li>第七篇是进程、线程、线程池</li>
</ul>
<hr>

        <h1 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h1>
      
        <h2 id="基础概念"   >
          <a href="#基础概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2>
      
        <h3 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程" class="headerlink" title="进程"></a>进程</h3>
      <p>进程是也就是平时所说的程序，是系统运行程序的基本单位。进程是用于加载指令、管理内存、管理IO的，是系统中运行的程序的独立实例。</p>
<p>进程也是<strong>系统分配资源的基本单位</strong>，也即系统分配资源以进程为单位分配资源。</p>

        <h3 id="线程-1"   >
          <a href="#线程-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3>
      <p>线程又叫<strong>轻量级进程</strong>，是进程内的执行单位，一个进程可以包含多个线程。</p>
<p>线程也是<strong>操作系统调度(CPU调度)的执行的最小单位</strong></p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>两者关系：线程是进程内的执行单元，一个进程可以包含多个线程</li>
<li>资源隔离：<ul>
<li>进程：进程是高度资源隔离的，一个进程崩溃通常不会影响其他进程</li>
<li>线程：线程有共享的内存单元，一个线程崩溃可能会影响整个进程</li>
</ul>
</li>
<li>通信<ul>
<li>进程：进程之间相互独立，具有较高的隔离性所以进程之间通信是在面对多进程场景下的需要<ul>
<li><strong>管道</strong><ul>
<li>管道应用在具有亲缘关系的父子进程之间的通信（单向通信，由父进程写子进程接收）</li>
<li>命名管道：可以应用在无亲缘关系的进程通信（双向通信）</li>
</ul>
</li>
<li><strong>消息队列</strong>：允许进程之间异步通信</li>
<li><strong>共享内存</strong>：多个进程指向同一块内存区域，这也是最快速和高效的通信方式</li>
<li><strong>信号(singal)</strong> ：用于进程之间的异步通新，一个进程通知另一个进程某些事情发生，如进程中断、终止或者其他</li>
<li><strong>信号量(Semaphore)</strong> ：信号量是用于控制多个进程之间访问同一个资源的方式</li>
<li><strong>套接字(socket)<strong>：通常用于网络通信，也可以用于进程之间的通信。</strong>这一方式更常用于进程中通信</strong></li>
</ul>
</li>
<li>线程：线程之间有共享的内存单元而进行线程之间通信有以下几种方法:<ul>
<li><strong>共享内存</strong>：多个线程之间有共享相同的内存区域，所以这是最快速和高效的通信方式</li>
<li><strong>消息队列</strong>：通过消息队列发送消息以及接收消息，实现异步通信</li>
<li><strong>互斥锁</strong>：用互斥锁来保护共享资源</li>
<li><strong>信号量</strong>：可以用信号量来控制资源访问和释放的同步机制，类似生产者-消费者环境</li>
<li><strong>套接字(socket)<strong>：如果线程在不同计算机或者不同进程中，可以使用socket通信。</strong>这一方式更多用于进程中通信</strong></li>
</ul>
</li>
</ul>
</li>
<li>并发性<ul>
<li>进程：进程隔离性较高、相互独立，所以并发性较低</li>
<li>线程：线程共享进程内的内存空间，并发性较高</li>
</ul>
</li>
<li>开销<ul>
<li>进程：创建和销毁以及进程之间切换具有较高的系统开销</li>
<li>线程：创建和销毁以及线程之间切换较小的系统开销，也即叫<strong>轻量级进程</strong></li>
</ul>
</li>
</ul>

        <h3 id="协程"   >
          <a href="#协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程" class="headerlink" title="协程"></a><strong>协程</strong></h3>
      <p>协程又叫<strong>轻量级线程</strong>，由程序管理的轻量级线程，对于内核态是不可见的。正如线程和进程的关系，一个线程可以由多个协程</p>

        <h2 id="生命周期"   >
          <a href="#生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2>
      <p>操作系统中的线程生命周期一共有五种状态：<strong>新建状态、就绪状态（可运行状态）、运行状态、阻塞状态、结束状态</strong></p>
<p>如图所示</p>
<blockquote>
<p> 操作系统中线程生命周期</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106203624571.png"  alt="操作系统中线程生命周期">
      </p>
<p>而java中有Thread类也即线程类，这里的生命周期和我们操作系统中定义的生命周期五种状态有一部分区别</p>
<p>我们从<code>Thread.java</code>中直接找到这部分源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        NEW,	<span class="comment">//创建状态</span></span><br><span class="line">        </span><br><span class="line">        RUNNABLE,<span class="comment">//可运行状态（对应操作系统中的就绪态和运行态）</span></span><br><span class="line">        </span><br><span class="line">        BLOCKED,<span class="comment">//阻塞状态</span></span><br><span class="line"></span><br><span class="line">        WAITING,<span class="comment">//等待状态</span></span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,<span class="comment">//等待超时状态</span></span><br><span class="line"></span><br><span class="line">        TERMINATED;<span class="comment">//终止状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略部分源码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Thread类中的线程运行状态枚举：</p>
<ul>
<li><u>NEW</u>：线程新建状态</li>
<li><u>RUNNABLE</u>：线程可运行状态（对应就绪态和运行态），也即就绪态和运行态在java中是合并在一起的</li>
<li><u>BLOCKED</u>：线程阻塞状态，等待锁的释放（竞争Synchronized锁失败，进入阻塞状态或者wait被唤醒之后获取Synchronized锁失败），·<em>这个状态针对Synchronized锁</em></li>
<li><u>WAITING</u>：线程等待状态，处于等待状态的线程等待另一个线程执行特定操作。可以由以下方法进入此状态<ul>
<li><strong>Object.wait()</strong> ：等待其他线程调用Object.notify()或者Object.notifyAll()唤醒</li>
<li><strong>Thread.join()</strong> ：等待指定线程结束</li>
<li><strong>LockSupport.park()</strong> ：等待线程调用LockSupport.unpark()</li>
</ul>
</li>
<li><u>TIMED_WAITING</u>：线程超时等待状态，处于指定等待时间的线程状态。可以由以下方法进入此状态<ul>
<li><strong>Thread.sleep(long)</strong> ：超出指定时间之后会结束此状态</li>
<li><strong>Object.wait(long)</strong> ：超出指定时间或者Object.motify()或者Object.notifyAll()唤醒</li>
<li><strong>LockSupport.parkNanos(long)</strong> ：超出等待时间或者LockSupport.unpark(Thread)唤醒</li>
<li><strong>LockSupport.parkUntil(long)</strong> ：超出等待时间或者LockSupport.unpark(Thread)唤醒</li>
<li><strong>Thread.join(long)</strong> ：等待指定线程结束（规定时间内）或者超出指定时间之后会结束此状态</li>
</ul>
</li>
<li><u>TERMINATED</u> ：线程终止状态</li>
</ul>
<p>也即Java中线程生命周期如下图所示</p>
<blockquote>
<p>Java中线程生命周期</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106214636721.png"  alt="Java中线程生命周期">
      </p>
<p><strong>小结</strong></p>
<p>因此，在Java中线程的生命周期中一共有6种状态：<strong>新建状态、可运行状态、阻塞状态、等待状态、超时等待状态、结束状态</strong></p>
<p>和操作系统中线程生命周期相比，可运行状态包含了就绪态和运行态，阻塞状态更为细致地分成了阻塞状态、等待状态、超时等待状态</p>

        <h2 id="创建线程"   >
          <a href="#创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2>
      <blockquote>
<p> 在之前我写了一篇文章来谈到创建线程的方式——浅谈java中创建线程，在这里我们还是要用到创建线程的知识</p>
</blockquote>
<p>我们创建线程有以下几种方式</p>
<ol>
<li>创建Thread或者创建继承Thread类的子类</li>
<li>Runnable接口的实现类</li>
<li>Callable接口的实现类，需要利用FutureTask类</li>
<li>lambda表达式中匿名内部类创建线程</li>
<li>线程池创建线程</li>
</ol>

        <h3 id="第一种、直接创建新线程"   >
          <a href="#第一种、直接创建新线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一种、直接创建新线程" class="headerlink" title="第一种、直接创建新线程"></a>第一种、直接创建新线程</h3>
      <p>创建Thread或者创建继承Thread类的子类</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我重写了run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();<span class="comment">//调用start()方法创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第二种、Runnable接口的实现类"   >
          <a href="#第二种、Runnable接口的实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二种、Runnable接口的实现类" class="headerlink" title="第二种、Runnable接口的实现类"></a>第二种、Runnable接口的实现类</h3>
      <p>利用Runnable的实现类传入到<code>new Thread()</code>方法中的参数实现创建线程</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我重写了Runnable中的run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implRunnableDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());<span class="comment">//创建Thread类传入自己实现的Runnable实现类对象</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第三种、Callable接口的实现类"   >
          <a href="#第三种、Callable接口的实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三种、Callable接口的实现类" class="headerlink" title="第三种、Callable接口的实现类"></a>第三种、Callable接口的实现类</h3>
      <p>我们知道在创建线程的时候因为前两种的Run()方法返回值都是void，也即无返回值。而我们在部分场景中需要某个线程的执行结果，我们就可以用Callable实现类，利用FutureTask来<strong>获取到线程的执行结果</strong></p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implCallableDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(myCallable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将任务传入到Thread的构造函数中</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = task.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="第四种、lambda表达式创建线程"   >
          <a href="#第四种、lambda表达式创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四种、lambda表达式创建线程" class="headerlink" title="第四种、lambda表达式创建线程"></a>第四种、lambda表达式创建线程</h3>
      <p>lambda表达式实际上就是匿名内部类，实现了Runnable接口</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambdaThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第五种、线程池创建线程"   >
          <a href="#第五种、线程池创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五种、线程池创建线程" class="headerlink" title="第五种、线程池创建线程"></a>第五种、线程池创建线程</h3>
      <p>样例：我们可以调用<code>Executors</code>工具类调用默认的线程工厂创建线程，而线程池相关代码我们到线程池那再继续开展</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ThreadPoolCreateDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Executors.defaultThreadFactory().newThread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我重写了Run方法&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <p>这五种方法本质上都是一个方式创建线程，都是实现了Runnable接口之后调用new Thread()方法创建线程对象，然后调用Thread.start()方法创建线程</p>

        <h4 id="Thread类"   >
          <a href="#Thread类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;...&#125; <span class="comment">//实现Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="Runnable接口实现类"   >
          <a href="#Runnable接口实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Runnable接口实现类" class="headerlink" title="Runnable接口实现类"></a>Runnable接口实现类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;...&#125; <span class="comment">//实现了Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="Callable接口实现类"   >
          <a href="#Callable接口实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Callable接口实现类" class="headerlink" title="Callable接口实现类"></a>Callable接口实现类</h4>
      <p>因为Callable接口实现类需要用到FutureTask类，而在FutureTask类中实现了RunnableFuture接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;...&#125;<span class="comment">//实现了RunnableFuture接口</span></span><br></pre></td></tr></table></div></figure>

<p>而在RunnableFuture接口中又实现了Runnable接口和Future接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;...&#125;<span class="comment">//实现了Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="lambda表达式"   >
          <a href="#lambda表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4>
      <p>lambda表达式的匿名内部类实际上就是匿名Runnable接口的实现类，所以本质上也是实现了Runnable接口</p>

        <h4 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4>
      <p>线程池的线程工厂需要我们传入一个Runnable实现类对象，也即我们需要实现Runnable接口</p>
<p><strong>而这样实际上都是实现Runnable接口然后调用new Thread()方法创建线程对象</strong>，那我们常说的启动线程的Start()方法和直接调用run()方法具有区别，直接调用Run()方法是不会创建新的线程，这又是怎么一回事呢？这需要我们接下来理解线程的常见方法</p>

        <h3 id="常用方法"   >
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3>
      
        <h4 id="sleep"   >
          <a href="#sleep" class="heading-link"><i class="fas fa-link"></i></a><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></div></figure>

<p>我们知道native方法是需要看c++代码的，所以我们从方法注册表中找到cpp中对应的方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_Sleep&#125;, <span class="comment">//这就是我们要找到的sleep方法对应关系</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="type">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="type">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="type">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="type">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setNativeName&quot;</span>,    <span class="string">&quot;(&quot;</span> STR <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p>JVM.cpp中JVM_Sleep方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_Sleep</span>(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_Sleep&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果休眠时间为负数，则抛出异常，时间不能是负数</span></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>(), <span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果休眠被中断过，则抛出异常，休眠被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread::<span class="built_in">is_interrupted</span> (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>(), <span class="string">&quot;sleep interrupted&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//记录现场</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__begin, millis);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_SLEEP_BEGIN</span>(</span><br><span class="line">                             millis);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  EventThreadSleep event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      <span class="comment">//调用yield()方法，让出CPU</span></span><br><span class="line">      os::<span class="built_in">yield</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">      thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(SLEEPING);</span><br><span class="line">      os::<span class="built_in">sleep</span>(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadState old_state = thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(SLEEPING);</span><br><span class="line">    <span class="keyword">if</span> (os::<span class="built_in">sleep</span>(thread, millis, <span class="literal">true</span>) == OS_INTRPT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">          <span class="comment">//休眠</span></span><br><span class="line">          event.<span class="built_in">set_time</span>(millis);</span><br><span class="line">          event.<span class="built_in">commit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">        <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__end,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="built_in">HOTSPOT_THREAD_SLEEP_END</span>(</span><br><span class="line">                                 <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>(), <span class="string">&quot;sleep interrupted&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">    event.<span class="built_in">set_time</span>(millis);</span><br><span class="line">    event.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_SLEEP_END</span>(</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事：</p>
<ul>
<li>调用<code>yield()</code>方法让出CPU</li>
<li>休眠，时长为：<code>millis</code></li>
</ul>

        <h4 id="start"   >
          <a href="#start" class="heading-link"><i class="fas fa-link"></i></a><a href="#start" class="headerlink" title="start"></a>start</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="comment">//校验线程是否已经初始化完成(准备好进入就绪态)，如果没有初始化完成则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>在这里最关键的是<code>start0()</code>方法，也即这个方法应该和创建线程关联</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>而这又是native方法，我们只能找到cpp源码中的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,<span class="comment">//这就是我们要找到的start0方法对应关系</span></span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>JVM.cpp</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命名一个本地线程变量 所以创建的线程和JavaThread有关系</span></span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::<span class="built_in">thread</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::<span class="built_in">stackSize</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread));</span><br><span class="line">      <span class="type">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="type">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//创建了一个JavaThread对象和native_thread绑定也即创建本地线程和C++线程结构绑定</span></span><br><span class="line">      <span class="comment">//而其中这个参数&amp;thread_entry也是一个方法</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">//JVM线程创建成功之后和JAVA线程绑定</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalThreadStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(native_thread != <span class="literal">NULL</span>, <span class="string">&quot;Starting null thread?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果创建了空线程，那么说明无法</span></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> native_thread;</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_resource_exhausted</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_resource_exhausted</span>(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_OutOfMemoryError</span>(),</span><br><span class="line">              <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定成功之后调用start方法启动线程</span></span><br><span class="line">  Thread::<span class="built_in">start</span>(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li><p>创建<code>JavaThread</code>对象，调用<code>	thread_entry</code>也即线程入口</p>
</li>
<li><p>线程创建之后<code>JavaThread</code>对象和真正创建的线程绑定</p>
</li>
<li><p>调用<code>start</code>方法启动线程</p>
</li>
</ul>
<p>JavaThread对象</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaThread</span>: <span class="keyword">public</span> Thread &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  JavaThread*    _next;                          <span class="comment">// The next thread in the Threads list</span></span><br><span class="line">  oop            _threadObj;                     <span class="comment">// The Java level thread object</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="built_in">JavaThread</span>(ThreadFunction entry_point, <span class="type">size_t</span> stack_size = <span class="number">0</span>); <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>线程入口</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> &#123;</span><br><span class="line">  HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">  Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">  JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),</span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>操作系统内核创建线程，调用pthread_create方法创建操作系统真正的线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统内核创建线程，调用pthread_create方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type, <span class="type">size_t</span> stack_size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>, <span class="string">&quot;caller responsible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate the OSThread object</span></span><br><span class="line">  OSThread* osthread = <span class="keyword">new</span> <span class="built_in">OSThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_thread_type</span>(thr_type);</span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_state</span>(ALLOCATED);</span><br><span class="line"></span><br><span class="line">  thread-&gt;<span class="built_in">set_osthread</span>(osthread);</span><br><span class="line">    </span><br><span class="line">  <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">  <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">  <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stack size</span></span><br><span class="line">  <span class="keyword">if</span> (os::Linux::<span class="built_in">supports_variable_stack_size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack_size == <span class="number">0</span>) &#123;</span><br><span class="line">      stack_size = os::Linux::<span class="built_in">default_stack_size</span>(thr_type);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (thr_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> os::java_thread:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span> (JavaThread::<span class="built_in">stack_size_at_create</span>() &gt; <span class="number">0</span>, <span class="string">&quot;this should be set&quot;</span>);</span><br><span class="line">        stack_size = JavaThread::<span class="built_in">stack_size_at_create</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> os::compiler_thread:</span><br><span class="line">        <span class="keyword">if</span> (CompilerThreadStackSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          stack_size = (<span class="type">size_t</span>)(CompilerThreadStackSize * K);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      <span class="keyword">case</span> os::vm_thread:</span><br><span class="line">      <span class="keyword">case</span> os::pgc_thread:</span><br><span class="line">      <span class="keyword">case</span> os::cgc_thread:</span><br><span class="line">      <span class="keyword">case</span> os::watcher_thread:</span><br><span class="line">        <span class="keyword">if</span> (VMThreadStackSize &gt; <span class="number">0</span>) stack_size = (<span class="type">size_t</span>)(VMThreadStackSize * K);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack_size = <span class="built_in">MAX2</span>(stack_size, os::Linux::min_stack_allowed);</span><br><span class="line">    <span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_attr_setguardsize</span>(&amp;attr, os::Linux::<span class="built_in">default_guard_size</span>(thr_type));</span><br><span class="line"></span><br><span class="line">  ThreadState state;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">bool</span> lock = os::Linux::<span class="built_in">is_LinuxThreads</span>() &amp;&amp; !os::Linux::<span class="built_in">is_floating_stack</span>();</span><br><span class="line">    <span class="comment">//创建线程先上锁，如果上锁了则到达线程安全点开始创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">      os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">lock_without_safepoint_check</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//调用pthread_create()方法创建线程</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, (<span class="type">void</span>* (*)(<span class="type">void</span>*)) java_start, thread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      thread-&gt;<span class="built_in">set_osthread</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">if</span> (lock) os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    osthread-&gt;<span class="built_in">set_pthread_id</span>(tid);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      Monitor* sync_with_child = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line">      <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//等待子线程初始化完成或者中止</span></span><br><span class="line">      <span class="keyword">while</span> ((state = osthread-&gt;<span class="built_in">get_state</span>()) == ALLOCATED) &#123;</span><br><span class="line">        sync_with_child-&gt;<span class="built_in">wait</span>(Mutex::_no_safepoint_check_flag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">      os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state == ZOMBIE) &#123;</span><br><span class="line">      thread-&gt;<span class="built_in">set_osthread</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//线程处于初始化完成状态</span></span><br><span class="line">  <span class="built_in">assert</span>(state == INITIALIZED, <span class="string">&quot;race condition&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>调用<code>pthread_create</code>函数，让操作系统创建线程</li>
<li>线程创建完成之后调用<code>java_start</code>方法初始化线程</li>
<li>等待子线程创建完成或者中止</li>
</ul>
<p>我们知道线程创建之后要初始化，而线程初始化则关键在java_start方法中</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">java_start</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pid = os::<span class="built_in">current_process_id</span>();</span><br><span class="line">  <span class="built_in">alloca</span>(((pid ^ counter++) &amp; <span class="number">7</span>) * <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">  ThreadLocalStorage::<span class="built_in">set_thread</span>(thread);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  Monitor* sync = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_thread_safety_check(thread)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">    osthread-&gt;<span class="built_in">set_state</span>(ZOMBIE);</span><br><span class="line">    sync-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_thread_id</span>(os::Linux::<span class="built_in">gettid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">    <span class="type">int</span> lgrp_id = os::<span class="built_in">numa_get_group_id</span>();</span><br><span class="line">    <span class="keyword">if</span> (lgrp_id != <span class="number">-1</span>) &#123;</span><br><span class="line">      thread-&gt;<span class="built_in">set_lgrp_id</span>(lgrp_id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  os::Linux::<span class="built_in">hotspot_sigmask</span>(thread);</span><br><span class="line"></span><br><span class="line">  os::Linux::<span class="built_in">init_thread_fpu_state</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程为初始化完成</span></span><br><span class="line">    osthread-&gt;<span class="built_in">set_state</span>(INITIALIZED);</span><br><span class="line">    <span class="comment">//唤醒所有线程</span></span><br><span class="line">    sync-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋判断线程是否是初始化完成</span></span><br><span class="line">    <span class="keyword">while</span> (osthread-&gt;<span class="built_in">get_state</span>() == INITIALIZED) &#123;</span><br><span class="line">      sync-&gt;<span class="built_in">wait</span>(Mutex::_no_safepoint_check_flag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程被notify/notifyAll唤醒执行run方法</span></span><br><span class="line">  thread-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>初始化线程</li>
<li>当初始化线程完成之后设置线程生命状态：<strong>INITIALIZED</strong></li>
<li><code>notify_all()</code>唤醒线程</li>
<li><code>wait()</code>挂起线程，使其初始化完成</li>
<li>线程被唤醒之后调用<code>thread_run()</code>方法</li>
</ul>
<p>绑定线程成功之后调用start方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">trace</span>(<span class="string">&quot;start&quot;</span>, thread);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!DisableStartThread) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;<span class="built_in">is_Java_thread</span>()) &#123;</span><br><span class="line">      java_lang_Thread::<span class="built_in">set_thread_status</span>(((JavaThread*)thread)-&gt;<span class="built_in">threadObj</span>(),</span><br><span class="line">                                          java_lang_Thread::RUNNABLE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用具体操作系统对应的启动线程方法</span></span><br><span class="line">    os::<span class="built_in">start_thread</span>(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>调用操作系统启动线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// guard suspend/resume</span></span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="comment">//将线程设置成Runnable状态</span></span><br><span class="line">  osthread-&gt;<span class="built_in">set_state</span>(RUNNABLE);</span><br><span class="line">  <span class="comment">//调用方法去唤醒线程</span></span><br><span class="line">  <span class="built_in">pd_start_thread</span>(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::pd_start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  OSThread * osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="built_in">assert</span>(osthread-&gt;<span class="built_in">get_state</span>() != INITIALIZED, <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line">  Monitor* sync_with_child = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  <span class="comment">//唤醒线程，使其能够去执行run方法</span></span><br><span class="line">  sync_with_child-&gt;<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="run"   >
          <a href="#run" class="heading-link"><i class="fas fa-link"></i></a><a href="#run" class="headerlink" title="run"></a>run</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Thread类中实现了Runnable接口，所以重写了run方法</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果有具体的任务，那么就调用具体任务的run方法(我们重写的run方法)</span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Runnable接口实现类,具体线程需要做的内容</span></span><br><span class="line">	<span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></div></figure>



<p>而在操作系统之后创建了线程那么如何执行run方法的呢？</p>
<p>我们找到thread.cpp中的run方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化一些数据</span></span><br><span class="line">  <span class="built_in">this</span>-&gt;initialize_tlab();</span><br><span class="line">  <span class="built_in">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class="line">  <span class="built_in">this</span>-&gt;record_stack_base_and_size();</span><br><span class="line">  <span class="built_in">this</span>-&gt;initialize_thread_local_storage();</span><br><span class="line">  <span class="built_in">this</span>-&gt;create_stack_guard_pages();</span><br><span class="line">  <span class="built_in">this</span>-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  ThreadStateTransition::transition_and_fence(<span class="built_in">this</span>, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="built_in">this</span>, <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">assert</span>(!Thread::current()-&gt;owns_locks(), <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  DTRACE_THREAD_PROBE(start, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  EventThreadStart event;</span><br><span class="line">  <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">     event.set_javalangthread(java_lang_Thread::thread_id(<span class="built_in">this</span>-&gt;threadObj()));</span><br><span class="line">     event.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  thread_main_inner();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个run方法主要做的事：</p>
<ul>
<li>初始化一些数据</li>
<li>调用<code>thread_main_inner()</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="built_in">this</span>, <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">this</span>-&gt;threadObj() != NULL, <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正常情况下会回到线程入口，除非有异常挂起</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">      !java_lang_Thread::is_stillborn(<span class="built_in">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      ResourceMark <span class="title function_">rm</span><span class="params">(<span class="built_in">this</span>)</span>;</span><br><span class="line">      <span class="comment">//设置线程name</span></span><br><span class="line">      <span class="built_in">this</span>-&gt;set_native_thread_name(<span class="built_in">this</span>-&gt;get_thread_name());</span><br><span class="line">    &#125;</span><br><span class="line">    HandleMark <span class="title function_">hm</span><span class="params">(<span class="built_in">this</span>)</span>;</span><br><span class="line">    <span class="comment">//回到线程入口</span></span><br><span class="line">    <span class="built_in">this</span>-&gt;entry_point()(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(stop, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>-&gt;exit(<span class="literal">false</span>);</span><br><span class="line">  delete <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事：</p>
<ul>
<li>如果正常情况下会回到线程入口</li>
</ul>
<p><strong>线程入口</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> &#123;</span><br><span class="line">  HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">  Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">  JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),<span class="comment">//回调我们自己重写的run方法</span></span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法在这里做的事：</p>
<ul>
<li>回调 <code>vmSymbols::run_method_name()</code>：回到我们自己重写的run方法</li>
</ul>

        <h4 id="yield"   >
          <a href="#yield" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield" class="headerlink" title="yield"></a>yield</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>这个方法又是native方法，所以我们找到<code>Thread.c</code>中的方法注册表，找到对应的方法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,<span class="comment">//这就是我们要找到的yield方法对应关系</span></span><br><span class="line">	<span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中代码</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_Yield</span>(JNIEnv *env, jclass threadClass))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_Yield&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (os::<span class="built_in">dont_yield</span>()) <span class="keyword">return</span>; <span class="comment">//如果操作系统不允许让出CPU，那么直接返回(不让频繁yield浪费性能)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE0</span>(hotspot, thread__yield);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_YIELD</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断操作系统对应的yield要不要让线程休眠</span></span><br><span class="line">  <span class="keyword">if</span> (ConvertYieldToSleep) &#123;</span><br><span class="line">    os::<span class="built_in">sleep</span>(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//调用相应操作系统yield方法</span></span><br><span class="line">    os::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>判断是否能让出CPU，如果频繁<code>yield</code>则会浪费性能</li>
<li>调用操作系统中的yield方法，具体看操作系统的方法实现</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sched_yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="join"   >
          <a href="#join" class="heading-link"><i class="fas fa-link"></i></a><a href="#join" class="headerlink" title="join"></a>join</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);<span class="comment">//调用有参重载函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用有参重载函数</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果没有等待时间</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//运行到这里是有等待时间</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="comment">//如果现在已经超出了超出等待时间，那么就结束方法</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，调用wait方法阻塞，时长为delay</span></span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>调用<code>isAlive</code>方法，判断当前线程是否结束</p>
</li>
<li><p>没有等待时间，那么就调用<code>wait(0)</code>，等待线程唤醒直至当前线程死亡</p>
</li>
<li><p>如果有等待时间，那么就调用<code>wait(delay)</code>，等待超时或者当前线程死亡</p>
</li>
</ul>
<p><code>isAlive</code>方法是native方法，所以找到jvm.cpp中相关方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_IsThreadAlive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">oop</span> <span class="variable">thread_oop</span> <span class="operator">=</span> JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="keyword">return</span> java_lang_Thread::is_alive(thread_oop);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>返回线程是否结束</li>
</ul>

        <h5 id="join方法使用案例"   >
          <a href="#join方法使用案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#join方法使用案例" class="headerlink" title="join方法使用案例"></a>join方法使用案例</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestJoinMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>); <span class="comment">//模拟线程执行逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);<span class="comment">//模拟线程执行逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让主线程等待t1和t2完成逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>正因为有<code>t1.join</code>以及<code>t2.join</code>所以主线程会等待t1和t2线程完成之后再执行后序任务</p>
<p> 也即最后执行结果是如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">2</span>已经完成</span><br><span class="line">Thread-<span class="number">3</span>已经完成</span><br><span class="line">主线程已经结束</span><br></pre></td></tr></table></div></figure>




        <h4 id="stop"   >
          <a href="#stop" class="heading-link"><i class="fas fa-link"></i></a><a href="#stop" class="headerlink" title="stop"></a>stop</h4>
      <p>这个方法已经被废弃，但是为了提到如何优雅结束线程，我们要从这个最见名知意的stop方法开始看如何结束线程</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">           checkAccess();</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">               security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">           resume(); <span class="comment">// Wake up thread if it was suspended; no-op otherwise</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用stop0方法真正结束线程</span></span><br><span class="line">       stop0(<span class="keyword">new</span> <span class="title class_">ThreadDeath</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>stop0</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></div></figure>

<p>不出意料地，这个方法果然又是native方法，所以我们还是继续找到源码去看具体做了什么事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中代码</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StopThread</span>(JNIEnv* env, jobject jthread, jobject throwable))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StopThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">  oop java_throwable = JNIHandles::<span class="built_in">resolve</span>(throwable);</span><br><span class="line">  <span class="keyword">if</span> (java_throwable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//空指针异常</span></span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_NullPointerException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oop java_thread = JNIHandles::<span class="built_in">resolve_non_null</span>(jthread);</span><br><span class="line">  JavaThread* receiver = java_lang_Thread::<span class="built_in">thread</span>(java_thread);</span><br><span class="line">  Events::<span class="built_in">log_exception</span>(JavaThread::<span class="built_in">current</span>(),</span><br><span class="line">                        <span class="string">&quot;JVM_StopThread thread JavaThread &quot;</span> INTPTR_FORMAT <span class="string">&quot; as oop &quot;</span> INTPTR_FORMAT <span class="string">&quot; [exception &quot;</span> INTPTR_FORMAT <span class="string">&quot;]&quot;</span>,</span><br><span class="line">                        <span class="built_in">p2i</span>(receiver), <span class="built_in">p2i</span>((address)java_thread), <span class="built_in">p2i</span>(throwable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果线程还在活动，那么可能产生了异常</span></span><br><span class="line">  <span class="keyword">if</span> (receiver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      </span><br><span class="line">  	<span class="comment">//是否是self产生</span></span><br><span class="line">    <span class="keyword">if</span> (java_thread == thread-&gt;<span class="built_in">threadObj</span>()) &#123;</span><br><span class="line">      <span class="built_in">THROW_OOP</span>(java_throwable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//暂停所有线程，传递异常</span></span><br><span class="line">      Thread::<span class="built_in">send_async_exception</span>(java_thread, JNIHandles::<span class="built_in">resolve</span>(throwable));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//反之 1.线程在停止前未启动 2.线程已经停止  </span></span><br><span class="line">   </span><br><span class="line">    java_lang_Thread::<span class="built_in">set_stillborn</span>(java_thread);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法做的事：</p>
<ul>
<li>强制线程进入<strong>线程安全点</strong>，这可能会导致有部分代码会没能执行完毕，假如一个业务逻辑并未执行完成就被强制结束线程，那么可能会对整个业务造成影响</li>
<li>如果发起结束线程是自身线程那么就不需要安全点</li>
</ul>
<p>利用stop方法来停机是不优雅的，所以我们要优雅结束线程需要用到线程中断</p>

        <h4 id="interrupt"   >
          <a href="#interrupt" class="heading-link"><i class="fas fa-link"></i></a><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//如果不是自身中断，那么检查是否有权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//设置中断标志位</span></span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>interrupt0()</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>



<p>因此我们找到方法注册表，看看究竟是个什么事</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p><code>jvm.cpp</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_Interrupt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren&#x27;t freed before we operate</span></span><br><span class="line">  <span class="type">oop</span> <span class="variable">java_thread</span> <span class="operator">=</span> JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  MutexLockerEx <span class="title function_">ml</span><span class="params">(thread-&gt;threadObj()</span> == java_thread ? NULL : Threads_lock);</span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    <span class="comment">//设置中断标志位</span></span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>Thread::interrupt(thr)</code></li>
</ul>
<p><code>thread.cpp</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(<span class="string">&quot;interrupt&quot;</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用操作系统具体的<code>interrupt</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(Thread::<span class="built_in">current</span>() == thread || Threads_lock-&gt;<span class="built_in">owned_by_self</span>(),</span><br><span class="line">    <span class="string">&quot;possibility of dangling Thread pointer&quot;</span>);</span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;<span class="built_in">interrupted</span>()) &#123;</span><br><span class="line">    osthread-&gt;<span class="built_in">set_interrupted</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//加屏障，让unpark()之前对其他线程可见    </span></span><br><span class="line">    OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">    ParkEvent * <span class="type">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;<span class="built_in">is_Java_thread</span>())</span><br><span class="line">    ((JavaThread*)thread)-&gt;<span class="built_in">parker</span>()-&gt;<span class="built_in">unpark</span>();</span><br><span class="line">    </span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="小结-1"   >
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4>
      <ul>
<li>start</li>
</ul>
<ol>
<li>操作系统调用<code>pthread_create</code>指令创建了一个线程，并且和JavaThread相关联</li>
<li>Java中的Thread对象和操作系统中创建线程相关联，做到了真正的创建线程</li>
<li>让初始化完成之后会被唤醒之后执行run方法</li>
</ol>
<ul>
<li><p>run</p>
<p>正常情况下会回调我们自己写的run方法</p>
</li>
<li><p>join</p>
<p>让某线程等待调用了join方法的线程结束，使用于异步线程执行完结果之后的场景</p>
</li>
<li><p>yield</p>
<p>让当前线程让出cpu，根据对应操作系统的线程调度，让优先级高的可能获取到时间片，但是不会释放对象锁</p>
</li>
<li><p>stop</p>
<p>强制结束线程，并且stop会释放对象锁所以可能会造成数据的不安全</p>
</li>
<li><p>interrupt</p>
<p>线程中断，当线程执行完相应逻辑并感应到线程中断可以自己选择该如何响应中断，相较于stop方法的强制执行更加温柔更加优雅</p>
</li>
<li><p>sleep </p>
<p>让线程从<code>Runnable</code>的执行状态到<code>TIMED_WAITNG</code>状态，会让线程睡眠，但是不会释放对象锁</p>
</li>
</ul>

        <h2 id="线程的通知机制"   >
          <a href="#线程的通知机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程的通知机制" class="headerlink" title="线程的通知机制"></a>线程的通知机制</h2>
      <p>这里的通知机制有：1.Volatile关键字 。 2. <strong>通知唤醒机制(wait&#x2F;notify)</strong> 。 3.条件队列通知机制(await&#x2F;signal) </p>
<p>因为Volatile关键字以及条件队列的通知唤醒机制我们在之前的场景说过了,所以我们这里着重将第二点wait&#x2F;notify</p>

        <h3 id="wait"   >
          <a href="#wait" class="heading-link"><i class="fas fa-link"></i></a><a href="#wait" class="headerlink" title="wait"></a>wait</h3>
      <p><code>thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>找到有参方法，发现又是一个native方法，所以我们又要找到注册表</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hashCode&quot;</span>,    <span class="string">&quot;()I&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;wait&quot;</span>,        <span class="string">&quot;(J)V&quot;</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notify&quot;</span>,      <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notifyAll&quot;</span>,   <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;clone&quot;</span>,       <span class="string">&quot;()Ljava/lang/Object;&quot;</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorWait</span>(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorWait&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  <span class="function">JavaThreadInObjectWaitState <span class="title">jtiows</span><span class="params">(thread, ms != <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_wait</span>()) &#123;</span><br><span class="line">    JvmtiExport::<span class="built_in">post_monitor_wait</span>((JavaThread *)THREAD, (oop)<span class="built_in">obj</span>(), ms);</span><br><span class="line">      <span class="comment">//该线程已经获取了监视器，但是还没有添加到等待队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用同步器中的wait方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">wait</span>(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>ObjectSynchronizer::wait</code></li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::wait</span><span class="params">(Handle obj, jlong millis, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">//如果持有偏向锁</span></span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果阻塞时间小于0</span></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">TEVENT</span> (wait - <span class="keyword">throw</span> IAX) ;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>(), <span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectMonitor* monitor = ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>());</span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_WAIT_PROBE</span>(monitor, <span class="built_in">obj</span>(), THREAD, millis);</span><br><span class="line">  <span class="comment">//调用monitor的wait方法</span></span><br><span class="line">  monitor-&gt;<span class="built_in">wait</span>(millis, <span class="literal">true</span>, THREAD);</span><br><span class="line">  <span class="built_in">dtrace_waited_probe</span>(monitor, obj, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>如果是偏向锁的情况下会消除偏向状态</li>
<li>调用monitor的wait方法</li>
</ul>

        <h3 id="notify"   >
          <a href="#notify" class="heading-link"><i class="fas fa-link"></i></a><a href="#notify" class="headerlink" title="notify"></a>notify</h3>
      <p><code>thread.java</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>因此找到cpp中的代码</p>
<p><code>jvm.cpp</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorNotify</span>(JNIEnv* env, jobject handle))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorNotify&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  <span class="comment">//调用同步器的notify方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">notify</span>(obj, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的<code>notify</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::notify</span><span class="params">(Handle obj, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">notify</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的冲突情况下唤醒线程Thread</li>
</ul>

        <h3 id="notifyAll"   >
          <a href="#notifyAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3>
      <p><code>thread.java</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>因此找到cpp中的代码</p>
<p><code>jvm.cpp</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorNotifyAll</span>(JNIEnv* env, jobject handle))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorNotifyAll&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">notifyall</span>(obj, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的<code>notifyall</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::notifyall</span><span class="params">(Handle obj, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">notifyAll</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的冲突情况下唤醒全部线程</li>
</ul>

        <h3 id="小结-2"   >
          <a href="#小结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3>
      
        <h4 id="sleep、wait、yield方法比较"   >
          <a href="#sleep、wait、yield方法比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#sleep、wait、yield方法比较" class="headerlink" title="sleep、wait、yield方法比较"></a>sleep、wait、yield方法比较</h4>
      <ul>
<li><p><strong>sleep</strong>、<strong>yield</strong>不会释放锁，而<strong>wait</strong>会释放锁</p>
</li>
<li><p><strong>sleep</strong>方法到了时间之后会自己苏醒（也可以感知线程中断而结束休眠），<strong>wait</strong>方法进入等待队列之后必须要调用同一个对象的<code>notify</code>&#x2F;<code>notifyAll</code>唤醒</p>
</li>
<li><p><strong>sleep</strong>方法作用于线程休眠<strong>暂停执行</strong>，而<strong>wait</strong>方法常用于线程之间通信</p>
</li>
<li><p><strong>sleep</strong>方法是Thread类的静态本地方法，因为一个线程休眠只是使线程自己休眠，不会涉及到锁的释放</p>
<p><strong>wait</strong>方法是Object类的本地方法，每个对象阻塞需要释放对象锁，因此应该操作对象（object）而不是线程</p>
<p><strong>yield</strong>方法是Thread类的静态本地方法</p>
</li>
</ul>

        <h1 id="线程池-1"   >
          <a href="#线程池-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h1>
      <p>线程池的引入是为了避免在并发情况下，如果线程执行逻辑很短则需要频繁创建、结束线程，而我们知道线程是一个很重要的资源，所以我们可以利用线程池来复用线程，来避免频繁创建、销毁的操作。</p>
<p>我们可以从Executors（线程池框架）着手对线程池的学习，而我们要知道阿里Java开发手册中禁止使用Excutors来创建线程池，我们会慢慢知道这是为什么？</p>
<p>我们可以从Executors创建三种线程池CachedThreadPool、FixedThreadPool、SingleThreadPool。从这三个线程池开始入手</p>

        <h2 id="CachedThreadPool"   >
          <a href="#CachedThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newCachedThreadPool方法</li>
</ul>
<p><strong>newCachedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="SignleThreadPool"   >
          <a href="#SignleThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#SignleThreadPool" class="headerlink" title="SignleThreadPool"></a>SignleThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SingleThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singlePool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            singlePool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newSingleThreadPool方法</li>
</ul>
<p><strong>newSingleThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (	<span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="FixedThreadPool"   >
          <a href="#FixedThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FixedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newFixedThreadPool方法</li>
</ul>
<p><strong>newFixedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="ThreadPoolExecutor"   >
          <a href="#ThreadPoolExecutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2>
      <p>因此我们都能发现都是返回的ThreadPoolExecutors对象，只是传入的参数不一样，所以我们要认识线程池就得认识ThreadPoolExecutor</p>
<p>我们可以用一个自定义线程池的Demo简单看看这个类到底怎么用</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MyThreadPoolDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">5</span>,	<span class="comment">//核心线程数</span></span><br><span class="line">                <span class="number">10</span>,	<span class="comment">//最大线程数</span></span><br><span class="line">                <span class="number">60L</span>,<span class="comment">//空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">5</span>)<span class="comment">//阻塞队列</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数（范围0~Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大线程数(范围1~Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非核心线程空闲时的超时时间(范围0~Long.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的拒绝策略(抛出异常并且拒绝执行任务)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//移位29位，高3位表示线程池状态，低29位表示线程数量(000 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池最大线程数量1左移29位再-1(000 11111111111111111111111111111)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池运行状态（高三位）</span></span><br><span class="line"><span class="comment">//正在运行(111 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭中(000 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止中(001 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整理中(010 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已终止(011 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁，用于保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池已有线程集合，因为是HashSet结构所以对数据做修改的时候需要加锁处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池中曾经拥有线程的最大数量 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计线程池完成任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心线程是否按照keepAliveTime存活，默认为false(也即核心线程空闲也保持活跃)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>线程池的五种状态</p>
<ul>
<li>RUNNING(-1):运行中，可以正常接收任务，能处理workQueue中的任务</li>
<li>SHUTDOWN(0):关闭中，不能接收新的任务，但是能处理workQueue中的任务</li>
<li>STOP(1):停止中，不能接收新的任务，也不再处理workQueue中的任务，会中断还在执行任务的线程</li>
<li>TIDYING(2):整理中，所有任务已经完成，并且线程数量为0，等待调用terminated()方法进入终止状态</li>
<li>TERMINATED(3)：线程池已经终止</li>
</ul>

        <h3 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,						//核心线程数</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,				//最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,				//超时存活时间</span></span><br><span class="line"><span class="params">                              TimeUnit unit,					//时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务排队队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,		//线程工厂</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler	//拒绝策略</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">    	<span class="comment">//校验参数的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//为成员变量赋值</span></span><br><span class="line">        <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>另外三个重载的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="内部类"   >
          <a href="#内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3>
      
        <h4 id="Worker"   >
          <a href="#Worker" class="heading-link"><i class="fas fa-link"></i></a><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计线程完全任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造方法    </span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">//更新线程状态成-1(阻塞)，目的是在运行worker之前禁止线程中断</span></span><br><span class="line">        </span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);<span class="comment">//调用线程工厂创建线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试解锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        	<span class="comment">//设置锁持有线程为空</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        	</span><br><span class="line">        	<span class="comment">//将线程状态置为0(运行中)</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="CallerRunsPolicy"   >
          <a href="#CallerRunsPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4>
      
        <h4 id="AbortPolicy"   >
          <a href="#AbortPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4>
      
        <h4 id="DiscardPolicy"   >
          <a href="#DiscardPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4>
      
        <h4 id="DiscardOldestPolicy"   >
          <a href="#DiscardOldestPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4>
      <p>这四个内部类是具体的拒绝策略，我们在这里先不看，会单独出一个来讲拒绝策略</p>
<p>因此我们可以获得<code>ThreadPoolExecutor</code>的结构图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231113181935844.png"  alt="ThreadPoolExecutor">
      </p>

        <h3 id="execute"   >
          <a href="#execute" class="heading-link"><i class="fas fa-link"></i></a><a href="#execute" class="headerlink" title="execute"></a>execute</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//对线程任务做非空判断</span></span><br><span class="line">    	<span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//获取到线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/*下面一共三种情况</span></span><br><span class="line"><span class="comment">    		1.已有核心线程数没有到最大核心线程数（还有核心线程可以创建）</span></span><br><span class="line"><span class="comment">    		2.线程池还在运行，并且任务能成功排队</span></span><br><span class="line"><span class="comment">    		3.任务不能排队，那么尝试新建一个线程来执行任务</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况1：已有工作线程小于最大核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//添加工作线程，将任务作为初始任务交给新线程，成功后结束方法</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况2：如果线程池还在运行，并且任务成功添加到等待队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//复查，如果线程池要停止运行或者已经停止运行并且成功从池中移除任务</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">//拒绝任务</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//新起一个空初始任务线程</span></span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况3：如果我们不能对任务进行排队，那么尝试新建一个线程执行任务，如果失败了我们就拒绝执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            <span class="comment">//拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>execute方法做的事</p>
<ul>
<li><p>如果已有线程数小于最大核心线程数（任务能提交到核心线程中）</p>
<p>将任务交给新的核心线程执行<code>addWorker(command,true)</code></p>
</li>
<li><p>如果线程池还在运行并且任务能够成功添加到等待队列中</p>
<ol>
<li>复查，线程池停止运行（不能接受任务）并且任务从队列中去除：拒绝任务</li>
<li>线程池还在运行，那么新起一个新的空线程</li>
</ol>
</li>
<li><p>如果我们不能对任务进行排队，那么尝试新建一个线程执行任务，失败了就拒绝执行任务</p>
</li>
</ul>
<p>以下是简化版流程图,假设核心线程数为10，最大线程数为20，队列容量为10，即将有50个任务待执行</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231114000324848.png"  alt="简化版流程图">
      </p>

        <h3 id="addWorker"   >
          <a href="#addWorker" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">//循环入口retry，判断线程池是否能够添加线程    </span></span><br><span class="line">    retry: 			</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           	<span class="comment">//获取线程池控制状态c和运行状态rs</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			这里判断添加线程失败需要满足两个条件：</span></span><br><span class="line"><span class="comment">				1.线程池状态需要大于等于SHUTDOWN (0) ，也即线程池正在关闭或者已经关闭</span></span><br><span class="line"><span class="comment">				2.第二个判断为false，有以下三种情况：</span></span><br><span class="line"><span class="comment">					2.1: rs!=SHUTDOWN (0)也即rs&gt;0，线程池已经关闭</span></span><br><span class="line"><span class="comment">					2.2: rs==SHUTDOWN &amp;&amp; firstTask != null 也即线程池正在关闭，还有未执行的初始任务也不允许创建新线程</span></span><br><span class="line"><span class="comment">					2.3: rs==SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty() 也即线程池正在关闭，排队队列为空</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">			也即当满足添加线程的条件：</span></span><br><span class="line"><span class="comment">				1.线程池状态小于SHUTDOWN，表示线程池还在运行中能够添加线程</span></span><br><span class="line"><span class="comment">				2.线程池处于关闭状态 &amp;&amp; firstTask==null &amp;&amp;!workQueue.isEmpty()</span></span><br><span class="line"><span class="comment">                	表示线程池正在关闭，排队队列中还有任务未执行</span></span><br><span class="line"><span class="comment">                	</span></span><br><span class="line"><span class="comment">               	也即当线程池关闭状态不接受新任务，但是能处理完已有任务</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">//运行到这里说明线程池能够添加线程</span></span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取现在已有线程数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果已有线程数超出了线程池最大限制(2的29次方-1)或者创建对应线程失败</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="comment">//已有线程数大于核心线程数创建核心线程失败（core为true表示创建核心线程）</span></span><br><span class="line">                    <span class="comment">//已有线程数大于总线程数创建非核心线程失败（core为false表示创建非核心线程）</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS添加线程数成功，跳出外层retry循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//运行到这里CAS失败，重新拉取线程池状态</span></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果线程池状态已经改变则重新判断线程池是否能够添加线程，回到外层循环retry</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//线程池状态没有改变，CAS失败，重新尝试CAS添加线程数，回到内层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//跳出retry循环，下面开始真正创建线程</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//线程启动成功标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//添加线程成功标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//线程标记</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建worker</span></span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">            <span class="comment">//获取线程t</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取锁，因为workers是HashSet结构，所以加锁保证线程安全</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//复查线程池状态</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//如果线程池处于RUNNING（可以创建线程）</span></span><br><span class="line">                    <span class="comment">//或者线程池处于正在关闭并且没有初始任务，那么可以创建线程来处理WorkQueue中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//线程池可以添加新的线程</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//如果线程t已经启动，那么抛出异常（还没有start启动线程但是线程t已经启动说明有问题）</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//当w添加到workers集合中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="comment">//如果工作线程数大于池有过最大线程数，那么更新池有过最大线程数</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        <span class="comment">//将线程添加成功标记置为true</span></span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//解锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果线程成功添加</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">//start启动，并将启动标记置为true</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//添加线程失败，调用addWorkerFailed方法</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//返回线程是否启动成功</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>addWorker逻辑上做了两件事：</p>
<ol>
<li>判断线程池是否能够创建线程<ul>
<li>线程池处于 <strong>RUNNING</strong> (运行中)的时候可以接收新的任务也可以处理等待队列(WorkQueue)中的任务</li>
<li>线程池处于 <strong>SHUTDOWN</strong>  (关闭中)的时候不可以接收新的任务，但是可以处理等待队列<code>WorkQueue</code>中的任务</li>
<li>CAS操作，增加线程数</li>
</ul>
</li>
<li>创建线程，并将worker添加到线程池中<ul>
<li>加锁（因为workers是HashSet集合所以为了线程安全而加锁）</li>
<li>复查线程池状态，确保是可以创建线程状态</li>
<li>检查worker状态，并将正常worker添加到线程池中<code>workers</code>集合</li>
<li>解锁</li>
<li>添加线程成功，调用<code>t.start()</code>启动线程</li>
</ul>
</li>
</ol>
<p>如果创建线程失败，最终会调用addWorkerFailed方法，所以我们看一下如果线程添加失败之后会做什么事</p>

        <h3 id="addWorkerFailed"   >
          <a href="#addWorkerFailed" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取到worker的锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//加锁，因为workers是Hashset结构，所以保证线程安全</span></span><br><span class="line">    	mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">                workers.remove(w); <span class="comment">//将workers中去除失败的w</span></span><br><span class="line">            decrementWorkerCount();<span class="comment">//CAS将线程数--，因为addWorker的时候判断线程池可以创建线程的时候CAS线程数++</span></span><br><span class="line">            tryTerminate();<span class="comment">//可能线程池状态变化或者有问题，于是尝试结束线程池</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>如果创建线程失败：</p>
<ul>
<li>加锁，减去线程池中workers的失败worker</li>
<li>CAS将线程数–</li>
<li>尝试关闭线程池 <del>(因为线程失败是线程池状态出现问题)</del></li>
</ul>

        <h4 id="decrementWorkerCount"   >
          <a href="#decrementWorkerCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#decrementWorkerCount" class="headerlink" title="decrementWorkerCount"></a>decrementWorkerCount</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//自旋直到CAS成功，也即直到线程池的线程数成功-1</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line"> 		<span class="comment">//CAS，将线程数-1</span></span><br><span class="line">    	<span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>CAS将线程数–</p>

        <h4 id="tryTerminate"   >
          <a href="#tryTerminate" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">    	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池控制状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断线程池是否可以结束</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||					<span class="comment">//如果线程池正在运行，则不允许结束</span></span><br><span class="line">                runStateAtLeast(c, TIDYING) ||	<span class="comment">//如果线程池处于整理或者已经结束</span></span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))	<span class="comment">//如果线程池在停止中，但是还有任务没完成</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//有资格结束线程池</span></span><br><span class="line">            <span class="comment">//如果还有存活线程，则先让线程自身中断</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//运行到这里说明线程池可以结束</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//把线程池加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//尝试CAS将线程池更新成TIDYING（整理中）状态</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//终止线程池</span></span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//将线程池更新成(TERMINATED)终止状态</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法做的事就两件</p>
<ul>
<li>判断线程池的状态是否能结束</li>
<li>如果线程池能结束，那么上锁结束线程池</li>
</ul>

        <h3 id="runWorker"   >
          <a href="#runWorker" class="heading-link"><i class="fas fa-link"></i></a><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3>
      <p>线程经过<code>t.start()</code>启动之后会调用<code>run()</code>方法，而<code>Worker</code>中的<code>run()</code>方法会调用<code>runWorker()</code>方法，所以我们当创建线程成功之后启动线程之后要来到这个runWorker方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    	<span class="comment">//task记录worker的初始任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//将worker的第一个线程置空</span></span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//将线程解锁，允许中断（因为会调用tryRelease()方法更新线程状态为0)</span></span><br><span class="line">        w.unlock();</span><br><span class="line">    	<span class="comment">//判断线程是否异常退出，默认为true，如果成功执行则会置为false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*while循环有两个情况可以进入：</span></span><br><span class="line"><span class="comment">            	1.task!=null,这个说明线程携带初始任务，那么优先执行初始任务</span></span><br><span class="line"><span class="comment">            	2.task==null &amp;&amp; (task=getTask())!=null,说明线程一开始没有初始任务，但是从排队队列中获取到了任务</span></span><br><span class="line"><span class="comment">            	</span></span><br><span class="line"><span class="comment">            	也即线程优先做初始任务，然后再从WorkQueue中获取任务</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">				</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	这个IF语句有两种情况，并且当前线程不是中断状态：</span></span><br><span class="line"><span class="comment">                		1.线程池状态大于等于STOP,说明线程池中线程要被中断</span></span><br><span class="line"><span class="comment">                		2.线程池状态小于STOP，则线程不应该出现中断，</span></span><br><span class="line"><span class="comment">                		但是此时Thread.interrupted()为true说明出现了线程中断并且清空了线程中断标志位</span></span><br><span class="line"><span class="comment">                		那么有可能是线程池调用了shutdownNow方法</span></span><br><span class="line"><span class="comment">                		所以重新判断线程池状态，如果线程池状态为STOP则需要执行线程中断</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">//中断线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行前执行的钩子函数，可以子类重写该方法来达到目的</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//运行任务，调用任务的run方法</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//任务执行之后执行的钩子函数，可以子类重写该方法达到目的</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行完成，置空任务，线程任务完成数++，解锁</span></span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程正常处理任务，所以将异常退出标志置为false</span></span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*一定会运行到这里，而运行到这里有两种可能：</span></span><br><span class="line"><span class="comment">            	1.作业队列没有任务了，调用processWorkerExit()方法</span></span><br><span class="line"><span class="comment">            	2.某个线程出现执行过程中产生异常，此时completedAbruptly=true</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>worker的调用run方法会来到这个方法，而这个方法所做的事</p>
<ul>
<li>如果线程有初始任务那么就执行初始任务，完成之后相应计数++</li>
<li>如果线程没有初始任务，那么去尝试获取任务队列(workQueue)中的任务</li>
<li>如果队列中没有任务或者线程执行某任务出错，那么就会进入finally语句中的<code>processWorkerExit()</code>方法中</li>
</ul>

        <h3 id="processWorkerExit"   >
          <a href="#processWorkerExit" class="heading-link"><i class="fas fa-link"></i></a><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	到这个方法有两种可能：</span></span><br><span class="line"><span class="comment">		1.队列中没有任务，线程正常结束，参数completedAbruptly为false</span></span><br><span class="line"><span class="comment">		2.线程执行任务中出现异常，线程异常结束，参数completedAbruptly为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//如果线程出现异常结束，cas将线程池线程数-1</span></span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//加锁，因为要操作workers集合，保证安全</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//统计线程完成数</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将worker移出workers集合中</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//因为线程结束，所以尝试关闭线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//获取线程池控制状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//如果线程池运行状态&lt;STOP，也即RUNNING、SHUTDOWN之一，还能够执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果线程是正常退出也即队列中没有任务了(正常退出completedAbruptly为false)</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">//获取线程池最小的核心线程数min，如果核心线程有存活时间则是0，反之为corePoolSize</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果最少线程数为0但是队列中还有任务，则保持最少有一个线程存活来执行队列中任务</span></span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果线程池已有线程数量足够支持，那么就不添加线程</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果线程执行异常结束，增加一个空任务线程</span></span><br><span class="line">            <span class="comment">//如果线程是正常结束，但是线程池需要最少一个线程来维持队列任务，所以增加一个空任务线程</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>当线程结束的情况下有两种可能：队列没有任务、线程执行任务异常结束</p>
<ul>
<li>队列没有任务，线程正常结束，线程数–</li>
<li>线程异常结束，会添加一个空线程来执行任务</li>
</ul>

        <h3 id="钩子函数"   >
          <a href="#钩子函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3>
      
        <h4 id="beforeExecute"   >
          <a href="#beforeExecute" class="heading-link"><i class="fas fa-link"></i></a><a href="#beforeExecute" class="headerlink" title="beforeExecute"></a>beforeExecute</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//空方法，由子类实现，在执行前执行</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="afterExecute"   >
          <a href="#afterExecute" class="heading-link"><i class="fas fa-link"></i></a><a href="#afterExecute" class="headerlink" title="afterExecute"></a>afterExecute</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//空方法，由子类实现，在执行后执行</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="拒绝策略"   >
          <a href="#拒绝策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3>
      
        <h4 id="CallerRunPolicy"   >
          <a href="#CallerRunPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#CallerRunPolicy" class="headerlink" title="CallerRunPolicy"></a>CallerRunPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                <span class="comment">//如果线程池未停止，那么由调用execute方法的线程执行任务</span></span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>如果线程池没有关闭，由线程池调用execute方法的线程来执行这个任务</p>

        <h4 id="AbortPolicy-1"   >
          <a href="#AbortPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbortPolicy-1" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="comment">///构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//抛出RejectedExecutionException异常</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>抛出<code>RejectedExecution</code>异常拒绝执行任务</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//而这也是默认的拒绝策略（抛出异常并拒绝执行任务）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h4 id="DiscardPolicy-1"   >
          <a href="#DiscardPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardPolicy-1" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//什么都不做，直接抛弃任务</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>什么都不做，直接抛弃任务</p>

        <h4 id="DiscardOldestPolicy-1"   >
          <a href="#DiscardOldestPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardOldestPolicy-1" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    	<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//抛弃第一个任务（最久的），然后将当前任务重新入队</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>抛弃第一个任务，然后将当前任务重新入队</p>
<div class="table-container"><table>
<thead>
<tr>
<th>拒绝策略</th>
<th>具体做法</th>
</tr>
</thead>
<tbody><tr>
<td>CallerRunPolicy</td>
<td>如果线程池没有关闭，由线程池调用execute方法的线程来执行这个任务</td>
</tr>
<tr>
<td>AbortPolicy</td>
<td>抛出<code>RejectedExecution</code>异常拒绝执行任务</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>什么都不做，直接抛弃任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>抛弃第一个任务，然后将当前任务重新入队</td>
</tr>
</tbody></table></div>

        <h2 id="常见问题"   >
          <a href="#常见问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2>
      
        <h3 id="sumbit和execute方法的区别"   >
          <a href="#sumbit和execute方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#sumbit和execute方法的区别" class="headerlink" title="sumbit和execute方法的区别?"></a>sumbit和execute方法的区别?</h3>
      <p>1.sumbit有返回值，而execute没有返回值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;...部分代码&#125;</span><br></pre></td></tr></table></div></figure>



<p>2.sumbit可以接收Runnable和Callable的参数，而execute只能接收Runnable的参数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;...部分代码&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="为什么禁止使用Executors创建线程池"   >
          <a href="#为什么禁止使用Executors创建线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么禁止使用Executors创建线程池" class="headerlink" title="为什么禁止使用Executors创建线程池"></a>为什么禁止使用Executors创建线程池</h3>
      <p><strong>CachedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, 										 <span class="comment">//核心线程数</span></span><br><span class="line">            Integer.MAX_VALUE, 						 <span class="comment">//总线程数</span></span><br><span class="line">            <span class="number">60L</span>,									 <span class="comment">//超时时间</span></span><br><span class="line">            TimeUnit.SECONDS,						 <span class="comment">//时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());		 <span class="comment">//排队队列</span></span><br><span class="line">    		<span class="comment">//默认线程工厂以及拒绝策略</span></span><br><span class="line">    &#125;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>因此我们可以知道CachedThreadPool的模型如下</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117193515963.png"  alt="CachedThreadPool">
      </p>
<p><strong>SingleThreadExecutor</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,						<span class="comment">//核心线程数</span></span><br><span class="line">                                <span class="number">1</span>,						<span class="comment">//总线程数</span></span><br><span class="line">                                <span class="number">0L</span>, 					<span class="comment">//存活时间</span></span><br><span class="line">                                TimeUnit.MILLISECONDS,  <span class="comment">//时间单位</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<span class="comment">//任务阻塞队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此我们可以得到SingleThreadExecutor（单线程的线程池）的模型</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194238410.png"  alt="SingleThreadExecutor">
      </p>
<p><strong>FixedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads,				<span class="comment">//核心线程数 </span></span><br><span class="line">                                  nThreads,				<span class="comment">//总线程数</span></span><br><span class="line">                                  <span class="number">0L</span>,					<span class="comment">//空闲时间 </span></span><br><span class="line">                                  TimeUnit.MILLISECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<span class="comment">//任务阻塞队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此FixedThreadPool的模型我们也能得出</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194303107.png"  alt="FixedThreadPool">
      </p>
<p>因此我们可以由这三个模型图推导出结果</p>
<ul>
<li><p>CachedThreadPool因为非核心线程是最大值，所以会一直创建非核心线程，可能会产生OOM问题</p>
<p>表现形式如下：先CPU达到100％，产生OOM问题</p>
</li>
<li><p>SingleThreadPool和FixedThreadPool因为阻塞作业队列workQueue是无限大的，也即当没有线程足够完成任务时会无止境的放到单向链表中，导致OOM问题</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/10/13/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/">死之前要做完的算法手册-[9.动态规划]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-10-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">29.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">224分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="动态规划"   >
          <a href="#动态规划" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1>
      <p>动态规划的问题，通常是有多个重叠子问题构成，类似于背包问题，于是可以用动态规划来解决。</p>
<blockquote>
<p>动态规划中每一个状态一定是由上一个状态推导出来的</p>
</blockquote>
<p><strong>动态规划</strong>与<strong>贪心算法</strong>的区别：</p>
<ul>
<li>动态规划的每一个状态都是由上一个确定的状态推导出</li>
<li>贪心算法的每一个状态都是局部最优解，来从局部最优解中选出全局最优解</li>
</ul>
<p>通过卡哥的视频学习，我们首先要学习一个做动态规划的一个思路，也即公式：动态规划五部曲</p>
<p><strong>动态规划五部曲</strong></p>
<ul>
<li>确认dp数组以及下标的含义</li>
<li>确定递推公式：</li>
<li>dp数组如何初始化</li>
<li>确认遍历顺序</li>
<li>打印dp数组值，确保推导正确</li>
</ul>

        <h2 id="基本问题"   >
          <a href="#基本问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2>
      
        <h3 id="509-斐波那契数"   >
          <a href="#509-斐波那契数" class="heading-link"><i class="fas fa-link"></i></a><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3>
      <p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<blockquote>
<p>F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
</blockquote>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/" >Leetcode.509(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;13</p>

        <h5 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：我们求这个题可以用动态规划也能用递归函数，但是这里我们主要用的是动态规划来做这道题目，因为这道题目给出了递推公式，也提供了初始化数值，所以这道题很容易就能ac</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确认dp数组以及下标的含义：dp数组用于记录每一个斐波那契数值，下标i就是对应的n</p>
</li>
<li><p>确定递推公式：<br>$$<br>F(n)&#x3D;Fn(n-1)+Fn(n-2)<br>$$</p>
</li>
<li><p>dp数组如何初始化:<code>F(0)=0,F(1)=1</code></p>
</li>
<li><p>确认遍历顺序:从前向后</p>
</li>
<li><p>打印dp数组值，确保推导正确：当出现错误的时候Debug，通过递推公式以及遍历顺序确定dp数组的数值</p>
</li>
</ul>
</li>
<li><p>检验n的有效性，当n小于2的时候数值已经确定，直接返回n：<code>return n</code></p>
</li>
<li><p>维护一个dp数组，由递推公式从前向后给dp数组赋值</p>
</li>
<li><p>返回n对应下标dp[n]：<code>return dp[n]</code></p>
</li>
</ul>
<p><strong>未压缩状态代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//当n为0和1的时候数值都已经确定，直接返回</span></span><br><span class="line">    	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//维护一个dp数组，后一个数字是前两个数字的和，初始化数组</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回对应的数据</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>因此我们可以知道，这个结果后一个数字由前两个数字确定，所以其实不用维护一个dp数组，我们只要知道前两个数的大小就能推出最后一个数是多少，也即：<strong>我们只需知道前两个数字数值就能推出下一个数字数值</strong></p>
<p><strong>压缩状态后代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp0=<span class="number">0</span>; <span class="comment">//第一个数字</span></span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">1</span>; <span class="comment">//第二个数字</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>; <span class="comment">//要求的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=dp0+dp1; <span class="comment">//当前数值是前两个数字之和</span></span><br><span class="line">            dp0=dp1; <span class="comment">//将第一个数字数值更新成第二个数字数值</span></span><br><span class="line">            dp1=sum; <span class="comment">//将第二个数字数值更新成当前数字值，更新数据用于求下一个数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="70-爬楼梯"   >
          <a href="#70-爬楼梯" class="heading-link"><i class="fas fa-link"></i></a><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3>
      <p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/" >Leetcode.70题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;14</p>

        <h5 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp0=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=dp0+dp1;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4>
      <p>思想：这道题和斐波那契数本质上是一样的，只是在分析这道题的题意的时候要推导出<strong>递推公式</strong></p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp[i]是走到第i个台阶有几种方法，下标i对应第n个台阶</p>
</li>
<li><p>确定递推公式</p>
<p>第i阶台阶的走法由第i-1阶台阶以及第i-2阶台阶方法之和：</p>
<ul>
<li>达到第i阶台阶：第i-1阶台阶只走一步，第i-2阶台阶只走两步</li>
<li>也即第i阶台阶&#x3D;第i-1阶台阶方法×（1）+第i-2阶台阶方法× （1），例如i&#x3D;3，那么到达第三阶台阶只有第二阶台阶方法再走一步以及第一阶台阶走两步</li>
</ul>
<p>也即递推公式：</p>
<p>$$<br>F(n)&#x3D;F(n-1)+F(n-2)<br>$$</p>
</li>
<li><p>dp数组如何初始化：第一阶台阶只有一种方法dp1&#x3D;1，第二阶台阶只有两种方法dp2&#x3D;2</p>
</li>
<li><p>遍历顺序：从前向后，因为后一阶台阶都由前面两阶台阶方法确定</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>检验台阶n的有效性：n&lt;&#x3D;2的时候直接返回n：<code>if(n&lt;=2) return n;</code></p>
</li>
<li><p>初始化dp数组：因为第0阶台阶毫无意义，所以我们只要初始化第一阶和第二阶台阶数值：<code>dp1=1;dp2=2;</code></p>
</li>
<li><p>从第三阶台阶开始遍历，维护dp数组</p>
</li>
<li><p>返回第n阶台阶dp[n]</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">1</span>; <span class="comment">//第一阶一种方法</span></span><br><span class="line">        <span class="type">int</span> dp2=<span class="number">2</span>; <span class="comment">//第二阶两种方法</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//从第三阶开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=dp1+dp2;</span><br><span class="line">            dp1=dp2;</span><br><span class="line">            dp2=sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="746-使用最小花费爬楼梯"   >
          <a href="#746-使用最小花费爬楼梯" class="heading-link"><i class="fas fa-link"></i></a><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3>
      <p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/" >Leetcode.746题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;14</p>

        <h5 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cost.length;i&gt;=<span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[i-<span class="number">1</span>]&lt;cost[i-<span class="number">2</span>])&#123;</span><br><span class="line">                sum+=cost[i-<span class="number">1</span>];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=cost[i-<span class="number">2</span>];</span><br><span class="line">                i=i-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:</p>
<p>cost&#x3D;[0,2,2,1]</p>
<p>输出：3</p>
<p>预期输出：2</p>

        <h5 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//维护Cost[i]表示跳到当前位置i所需的最小花费之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;cost.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[i-<span class="number">1</span>]&lt;cost[i-<span class="number">2</span>])&#123;</span><br><span class="line">                cost[i]=cost[i]+cost[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cost[i]=cost[i]+cost[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//因为顶楼可以由倒数第一阶台阶跳一格和倒数第二阶跳两格，所以从两者花费较少的一个达到</span></span><br><span class="line">        <span class="keyword">if</span>(cost[cost.length-<span class="number">2</span>]&lt;cost[cost.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> cost[cost.length-<span class="number">2</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cost[cost.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题由前面爬楼梯题目结合了体力值，本质上还是爬楼梯那道题目，但是这里的区别还有在于楼顶在于多少，例如cost&#x3D;{10,15,20}，cost.length&#x3D;&#x3D;3,那么楼顶在下标为3的位置，也即[10,15,20,楼顶]</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp[i]是对应下标i的<strong>最小体力耗费</strong>，i对应台阶位置</p>
</li>
<li><p>确定递推公式</p>
<p>第i个台阶的最小花费在dp[i-1]+cost[i-1]和dp[i-2]+cost[i-2]之间的最小值<br>$$<br>F(n)&#x3D;Math.min(F(n-1)+cost[n-1],F(n-2)+cost[n-2])<br>$$</p>
</li>
<li><p>初始化dp数组：dp[0]&#x3D;0，dp[1]&#x3D;0，因为可以选择从0或者1台阶开始跳，所以选择的时候花费为0，也即站在0台阶或者1台阶的时候不需要体力消耗</p>
</li>
<li><p>遍历顺序：从前向后，后面的台阶一定是前两个台阶走上来的，所以后一个状态一定能从前两个台阶状态确定</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>初始化dp数组，dp&#x3D;0，dp1&#x3D;0，dpi&#x3D;0</p>
</li>
<li><p>遍历cost数组，到达第i个台阶体力消耗是前两个台阶的最小体力消耗加上对应的跳跃消耗：</p>
<p><code>dpi=Math.min(dp0+cost[i-2],dp1+cost[i-1])</code></p>
<p>更新dp0和dp1，<code>dp0=dp1;dp1=dpi;</code></p>
</li>
</ul>
<p>因为顶楼在数组外面，所以达到顶楼之后不需要花费，直接返回dpI</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> dp0=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dpi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cost.length;i++)&#123;</span><br><span class="line">            dpi=Math.min(dp0+cost[i-<span class="number">2</span>],dp1+cost[i-<span class="number">1</span>]);</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=dpi;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="62-不同路径"   >
          <a href="#62-不同路径" class="heading-link"><i class="fas fa-link"></i></a><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3>
      <p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/submissions/474226548/" >Leetcode.62(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;15</p>

        <h5 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果是第一行则初始化</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是第一列则初始化</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//反之是需要推导的位置</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//F(M,N)=F(M-1,N)+F(M,N-1);</span></span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题和爬楼梯思路也是一样，但是这个维度从一维变成了二维，当位置(I,J)只能由(i-1,j)往右走以及(i,j-1)往下走，因此很容易可以推出推导公式，那么接下来就是遍历方式以及初始化dp数组的问题了，因为当前位置要靠前两个状态，所以是从左往右以及从上往下遍历。接下来明确dp数组就能简单做出解</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp是从(0,0)走到(i，j)位置走法有几种，下标i，j对应的位置</p>
</li>
<li><p>确定递推公式：当位置处于(i,j)的时候只能由上面(i,j-1)往下走以及由左边(i-1,j)往右走，也即f(M,N)&#x3D;f(M-1,N)×1+f(M,N-1)×1<br>$$<br>F(M,N)&#x3D;F(M-1,N)+F(M,N-1)<br>$$</p>
</li>
<li></li>
<li><p>初始化dp数组：</p>
<ul>
<li>dp数组的第一行只能从起始位置(0,0)往右走，也即走法只有一种（向右），所以第一行初始化为1</li>
<li>dp数组的第一列只能从起始位置(0,0)往下走，也即走法只有一种（向下），所以第一列初始化为1</li>
</ul>
</li>
<li><p>确定遍历顺序：因为位置(i，j)需要(i-1，j)以及(i，j-1)状态，所以遍历是同一列<strong>从左往右</strong>、同一行<strong>从上往下</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>定义dp数组，初始化dp数组：<code>for(int i=0;i&lt;m;i++) dp[i][0]=1; for(int j=0;j&lt;n;j++) dp[0][j]=1;</code></p>
</li>
<li><p>遍历，并给dp数组赋值</p>
</li>
<li><p>返回终点值：<code>return dp[m-1,n-1];</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    	<span class="comment">//初始化dp数组，将第一行以及第一列都初始化为1(最上面以及最左边只有一种走法)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//从左往右从上往下遍历dp数组，给dp数组赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">//要推导的位置</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="63-不同路径II"   >
          <a href="#63-不同路径II" class="heading-link"><i class="fas fa-link"></i></a><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h3>
      <p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/" >Leetcode.63(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;16</p>

        <h5 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:执行错误</p>
<p>obstacleGrid&#x3D;[0,0]</p>

        <h5 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++) dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++) dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE：解答错误</p>
<p>obstacleGrid&#x3D;[1,0]</p>
<p>输出1</p>
<p>预期输出0</p>

        <h5 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//如果碰到障碍物后面都走不了</span></span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[j][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//如果碰到障碍物后面都走不了</span></span><br><span class="line">            <span class="keyword">else</span> dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="comment">//如果碰到障碍物，那么这条路的方法只能是0</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题和不同路径那道题是大同小异的，但是这道题有障碍，所以在推导公式以及dp数组初始化这方面会不一样</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标含义：dp数组表示从位置(0,0)到位置(i,j)对应有几种路径，下标i，j对应的是具体位置</p>
</li>
<li><p>确定递推公式</p>
<ul>
<li><p>有障碍：当前（i，j）不能走到，也即dp（i，j）等于0<br>$$<br>F(M,N)&#x3D;0<br>$$</p>
</li>
<li><p>无障碍：当前（i，j）路径只能由上方（i，j-1）向下走以及左方（i，j-1）向右走<br>$$<br>F(M,N)&#x3D;F(M-1,N)+F(M,N-1)<br>$$</p>
</li>
</ul>
</li>
<li></li>
<li><p>初始化dp数组</p>
<ul>
<li>初始化第一行，当提供的obs数组没有障碍的时候初始化为1，当提供的obs有障碍，那么有障碍右边都不能到达，初始化为0</li>
<li>初始化第一列，当提供的obs数组没有障碍的时候初始化为1，当提供的obs有障碍，那么有障碍下面都不能到达，初始化为0</li>
</ul>
</li>
<li><p>遍历顺序：从左往右、从上往下</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length; <span class="comment">//获取宽</span></span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;	  <span class="comment">//获取长</span></span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义dp数组</span></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//初始化第一行，当碰到障碍之后都不能向右初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width &amp;&amp; obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//初始化第一列，碰到障碍之后都不能向下初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length &amp;&amp; obstacleGrid[j][<span class="number">0</span>]==<span class="number">0</span>; j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="comment">//当碰到障碍，则置为0，反之由上和左决定到这个位置的走法有几种</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016091835667.png"  alt="不同路径II">
      </p>

        <h3 id="343-整数拆分"   >
          <a href="#343-整数拆分" class="heading-link"><i class="fas fa-link"></i></a><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3>
      <p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/" >Leetcode.343题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;17</p>

        <h5 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> d1=(<span class="type">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="type">int</span> d2=d1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d1+d2==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> d1 * d2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> result=n-d1-d2;</span><br><span class="line">            <span class="keyword">return</span> d1 * d2 *result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE：n&#x3D;3</p>
<p>输出1</p>
<p>预期输出2</p>
<p>没做出来</p>

        <h4 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：求一个数的拆分求积的最大值，那么就有可能有拆分组合的划分，假如拆分成两组，则当i为1的时候另一组为(n-1)，也即积为1×(n-1)，当i为2的时候另一组为(n-2)，也即积为2×(n-2)，…，也能拆分成三组甚至更多，那么我们可以用一个dp数组来代表这些拆分结果积中最大的一个</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp数组用于表示数的最大拆分积，而下标i对应数字n</p>
</li>
<li><p>确定递推公式</p>
<ul>
<li><p>当数字n拆分的时候，那么最大积应该是（i）×（n-i）以及（i）×dp（n-i）以及当前dp（i）中的最大值</p>
<p>因为当n拆分成的时候，i是确定的数，而另一组是不确定的数，它是dp（n-i），它代表着（n-i）这个数被拆分的最大积</p>
</li>
<li><p>最终最大积应该是这三种之一，以及递推公式为<br>$$<br>dp(i)&#x3D;Math.max(dp(i),Math.max(i×dp(n-i),i×(n-i)))<br>$$</p>
</li>
</ul>
</li>
<li><p>dp数组初始化：dp数组的长度是n+1,因为范围是[0,n]，且因为dp[0]和dp[1]毫无意义，所以初始化只需要初始化dp[2]&#x3D;1</p>
</li>
<li><p>遍历顺序，从3往后到n，因为初始化的时候2已经初始化完了，则要n的时候n之前的数的最大积应该被确定</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//因为2已经被初始化完了，所以从3开始初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//因为可以分为两组，那么我们可以从1位置分割，1为1组而(i-1)为另一组，...,直到划分到i/2位置						</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"> 			<span class="comment">//i的最大积应该是（当前值，j×(i-j)，j×dp(i-j))中最大的一个           </span></span><br><span class="line">            dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="图解-1"   >
          <a href="#图解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4>
      <p>例如当n&#x3D;3的时候，那么只有一种分组方式也即1和2，那么就dp[3]一定在初始化值，1×2以及1×dp[2]之间，dp数组表示的是数字i时该数字的最大分组乘积</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231017230429124.png"  alt="n等于3时">
      </p>
<p>例如当n等于4的时候，那么可以先分成两组，也即1+3和2+2的分组</p>
<p>如下是分成1+3的状态，那么此状态的dp[4]一定在dp[4]，1×3以及1×dp[3]之间</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231017232119871.png"  alt="n等于4分成1+3的状态">
      </p>
<p>而我们也能分成2+2的分组，就如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231017232724110.png"  alt="n等于4分成2+2的状态">
      </p>
<p>不仅如此，我们也能分成三组，也即1+1+2的分组，但是这个分组在1+3的分组中已经考虑过了，正如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231017234201798.png"  alt="当n等于4的时候1+1+2分组">
      </p>
<p>因此我们可以知道的是，当三个分组的时候也是1+3的分组的情况下分完的结果，说明到这里应该对这个分组积有更明确的理解了</p>
<p>所以dp[i]会在**dp[i]，j×(n-j),j×dp[n-j]**产生最大数，我们维持这个dp[i]成为最大，然后最后返回结果dp[n]即可</p>

        <h3 id="96-不同的二叉搜索树"   >
          <a href="#96-不同的二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3>
      <p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/" >Leetcode.96题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;18</p>

        <h5 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h6>
      <p>纯属巧合，我对这道题二叉搜索树没能理解完。但是根据动态规划的思想还是做出来了，我在下意识中以为只能有二叉搜索树的状态</p>

        <h4 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4>
      <p>思想：这道题是一个求二叉搜索树的个数，首先要明确二叉搜索树的含义做这道题才能正确求解，这点十分重要</p>
<blockquote>
<p> 二叉搜索树：左子树的结点都会比根节点小，右子树的结点都会比根节点大。</p>
</blockquote>
<p>那么因此当n为2的时候一定只有两种状态，也即1为根，2为右子树以及2为根，1为左子树</p>
<p>那么好像就能从中找出规律，我们可以从1到n开始做根节点，然后根据左右子树而推断出根节点的状态，例如n为2那么一定可以从0和1推断出来状态，也即符合<strong>动态规划</strong>中的特点，由前面确定的状态推断出后面的状态</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp数组表示存放的各个情况下最大的二叉搜索树个数，下标i对应的数字n也即dp[i]对应i的不同搜索树个数</p>
</li>
<li><p>确定递归函数</p>
<p>当n为3的时候那么就有几种状态，由1做根节点，由2做根节点，由3做根节点</p>
<ul>
<li>当1做根节点的时候，那么左子树有0个结点dp[0]，右子树有2个结点dp[2]</li>
<li>当2做根节点的时候，那么左子树有1个结点dp[1]，右子树有1个结点dp[1]</li>
<li>当3做根节点的时候，那么左子树有2个结点dp[2]，右子树有0个结点dp[0]</li>
<li>因此dp[3]是这三个状态的个数和也即dp[3]&#x3D;dp[0]×dp[2]+dp[1]×dp[1]+dp[2]×dp[0]</li>
</ul>
<p>而推导到全局，那么就能求得以下公式<br>$$<br>dp[n]+&#x3D;dp[i]×dp[n-i]<br>$$</p>
</li>
<li><p>dp数组初始化</p>
<ul>
<li>dp[0]&#x3D;1，因为空树和满二叉树都是一个二叉树，0个结点也是一个状态，只有一种</li>
<li>dp[1]&#x3D;1</li>
</ul>
</li>
<li><p>遍历顺序：从前往后遍历，因为后面状态必须由前面状态确定，也即i从小往大遍历直到n</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>定义dp数组以及初始化</p>
</li>
<li><p>遍历dp数组，i从2开始为dp数组赋值，j从1开始遍历根节点直到i，代表不同的状态</p>
</li>
<li><p>返回结果</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//从2开始赋值，直到赋值到下标n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//根节点从1开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="图解-2"   >
          <a href="#图解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4>
      <p>当n为2的时候，因为二叉搜索树的特性所以我们能轻而易举得到以下图示所示树，也即n为2时只有两种状态：根节点为1以及根节点为2，而这两种状态构成的不同二叉搜索树个数之和就是我们需要的dp[2]</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231018091428333.png"  alt="n等于2">
      </p>
<p>当n为3的时候，我们也能得到三种状态也即当根节点为1，根节点为2，根节点为3，我们先看向根节点1的状态如下图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231018091813420.png"  alt="n为3，根节点为1">
      </p>
<p>然后我们看向根节点为2的时候状态如下图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231018092215083.png"  alt="n为3，根节点为2">
      </p>
<p>最终当根节点为3的时候状态如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231018092517493.png"  alt="n为3，根节点为3">
      </p>
<p>因此由上面三个状态图，我们可以知道dp[3]就由这三种状态二叉搜索树之和确定，也即<strong>dp[3]&#x3D;dp[0]×dp[2]+dp[1]×dp[1]+dp[2]×dp[0]</strong></p>
<p>而当n更大的时候也能从结点个数为0以及结点个数为1两种状态推断出来，不仅如此当结点个数为1的时候也能推出，因为结点个数为1也即左结点为0个右节点为0个的状态</p>

        <h2 id="背包问题"   >
          <a href="#背包问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2>
      
        <h3 id="01背包问题基础"   >
          <a href="#01背包问题基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#01背包问题基础" class="headerlink" title="01背包问题基础"></a>01背包问题基础</h3>
      <p>背包问题的特征：一个物品有重量也有价值，那么在已有的背包容量中可以获取到的物品价值最大。而我们可以用动态规划来解决背包问题。</p>

        <h4 id="1-二维dp数组"   >
          <a href="#1-二维dp数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-二维dp数组" class="headerlink" title="1.二维dp数组"></a>1.二维dp数组</h4>
      <p>dp数组是<code>dp[i][j]</code>二维数组</p>
<p>关键参数：</p>
<ul>
<li>物品重量，weight[]：weight数组用于存放背包中的每件物品的重量</li>
<li>物品价值：value[]：value数组用于存放每件物品的价值</li>
<li>背包重量N：背包最多能装的重量为N</li>
</ul>
<p>我们利用动态规划来解决背包问题，那么我们从动态规划五部曲开始</p>
<ul>
<li><p>确定dp数组含义以及下标对应的含义：我们可以用二维数组<code>dp[i][j]</code>来表示物品i是否放到重量为j的背包中，这个dp数组维持的是背包容量j中的最大价值</p>
</li>
<li><p>明确递推公式：</p>
<p>对于dp数组来说一件物品只有两种状态：1.被放入到背包中 2.不被放入到背包中</p>
<ul>
<li><p>不被放入到背包中，那么当前物品i的状态也即<code>dp[i][j]=dp[i-1][j]</code>，表示当前物品不放入到背包中，那么背包中的最大价值就是<code>0~i-1</code>件物品放入到背包中</p>
</li>
<li><p>放入到背包中，那么当前物品i的状态也即需要占用背包中的容量，那么就需要获取背包除去当前物品重量之后还能存放的最大价值也即：</p>
<ul>
<li>需要删除背包中价值最低的元素腾出位置给当前物品：<code>dp[i][j]=dp[i-1][j-weight[i]]+value[i]</code>,这段代码含义是将 移出重量和当前重量相同的物品，然后将当前物品放到背包中</li>
</ul>
</li>
<li><p>那么(i，j)对应的dp值就为这两种状态的最大值：<code>dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</code><br>$$<br>dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])<br>$$</p>
</li>
</ul>
</li>
<li><p>定义dp数组以及初始化</p>
<ul>
<li><p><code>dp[i][j]</code>的i代表物品的个数，那么i初始化为物品的个数</p>
</li>
<li><p><code>dp[i][j]</code>的j代表背包的重量，那么j初始化为背包的最大容量</p>
</li>
<li><p>初始化dp数组</p>
<p>因为递推公式那么<code>[i][j]</code>的状态可以由<code>[i-1][j]</code>以及<code>[i-1][j-weight[i]]</code>推导出来，也即我们如下图所示</p>
</li>
<li><p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231102174724021.png"  alt="初始化dp数组">
      </p>
</li>
<li><p>也即我们只需要初始化第一列为0（背包容量为0的时候装不下任何物品），以及第一列（当第一个物品能装入的时候初始化为那件物品的价值）</p>
</li>
</ul>
</li>
<li><p>遍历顺序</p>
<ul>
<li>先遍历物品</li>
<li>再遍历背包</li>
</ul>
<p>因为<code>dp[i][j]</code>的状态都由上一个状态推出，那么我们只要保证<code>[i-1][0]</code>到<code>[i-1][j]</code>的状态，我们就能确定<code>dp[i][j]</code></p>
</li>
<li><p>打印dp数组，那么dp数组的最后一个元素就是最大的背包价值,也即<code>dp[M-1][N]</code>是最大的价值</p>
</li>
</ul>

        <h4 id="2-一维dp数组"   >
          <a href="#2-一维dp数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-一维dp数组" class="headerlink" title="2.一维dp数组"></a>2.一维dp数组</h4>
      <p>因为二维dp数组，我们<code>i,j</code>的状态由<code>i-1</code>层的状态确定，但是也就是拷贝一份<code>i-1</code>层数据来进行判断，所以我们可以用滚动数组的想法，压缩这个二维数组成为一维数组dp[j]</p>
<ul>
<li><p>确定dp数组以及对应下标含义：dp数组用于表示重量j下的可以存放最大价值，j对应的背包容量</p>
</li>
<li><p>确定递推公式：因为也就两个状态要么装下要么装下，那么<code>dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i])</code><br>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
</li>
<li><p>初始化dp数组：因为当j&#x3D;0的时候物品都装不下，那么初始化dp[0]&#x3D;0,那么以后的状态都需要跟当前状态对比，所以我们默认以后状态数据都是0，那么初始化dp数组都为0</p>
</li>
<li><p>遍历顺序：</p>
<ul>
<li>第一层for循环遍历物品，从0到M-1</li>
<li>第二层for循环遍历背包，从背包的最大容量开始到需要的重量<code>weight[i]</code>，这样是为了防止一个物品被添加了两次</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>

        <h3 id="01背包"   >
          <a href="#01背包" class="heading-link"><i class="fas fa-link"></i></a><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3>
      <p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 </p>
<p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kamacoder.com/problem.php?id=1046" >卡码网46题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="二维数组题解"   >
          <a href="#二维数组题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解" class="headerlink" title="二维数组题解"></a>二维数组题解</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> M=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=N;j++)&#123; <span class="comment">//遍历背包</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;weight[i])&#123;</span><br><span class="line">                        <span class="comment">//如果物品比背包容量重也即放不下</span></span><br><span class="line">                        dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//反之放得下</span></span><br><span class="line">                        dp[i][j]=value[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(weight[i]&gt;j) <span class="comment">//如果背包本身就装不下</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];                </span><br><span class="line">                <span class="keyword">else</span>			<span class="comment">//如果装得下</span></span><br><span class="line">                dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-weight[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出最后的最大价值</span></span><br><span class="line">        System.out.println(dp[M-<span class="number">1</span>][N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="一维数组题解"   >
          <a href="#一维数组题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解" class="headerlink" title="一维数组题解"></a>一维数组题解</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> M=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=N;j&gt;=weight[i];j--)&#123; <span class="comment">//从背包最大容量开始遍历，防止一个物品被记录两次</span></span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(dp[N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="416-分割等和子集"   >
          <a href="#416-分割等和子集" class="heading-link"><i class="fas fa-link"></i></a><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h4>
      <p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/" >Leetcode.416题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;03</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> bagSize=nums.length+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][bagSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;bagSize;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=Math.max(dp[<span class="number">0</span>][j],nums[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> remain=sum-dp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(remain==dp[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums) sum+=i;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//无论怎么都不能平分</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp+nums[i]&lt;=mid) dp+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dp==mid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="二维数组题解-1"   >
          <a href="#二维数组题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-1" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <ul>
<li><p>确定dp数组及其下标含义：二维dp数组也即<code>dp[i][j]</code>,下标<code>[i]</code>表示的是第i件物品，下标<code>[j]</code>表示背包容量为j。也即<code>dp[i][j]</code>就表示第i件物品是否放到背包容量为j的最大价值</p>
</li>
<li><p>确定递推公式：我们这里将每一件物品的重量都视为价值，那么要平分数组的话，背包容量一定为总价值之和的一半<code>(target=sum/2)</code>,因此我们只需要判断最后一件物品的<code>dp[i][j]==target</code>如果相等那么说明之前的物品中包括当前物品的状态能平分数组。<br>$$<br>dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])<br>$$<br>在递推公式中，当前物品的<code>dp[i][j]</code>由上一层<code>[i-1][j]</code>确定，只有两种状态：要么不放进背包<code>dp[i-1][j]</code>，要么放进背包<code>dp[i-1][j-weight[i]]+value[i]</code></p>
</li>
<li><p>初始化dp数组，dp数组的第一行以及第一列需要初始化数据</p>
<ul>
<li>第一列也即<code>j==0</code>:背包容量为0无法装下任意物品，<code>dp[i][j]=0</code></li>
<li>第一行也即<code>i==0</code>：表示背包中第一个物品，当背包能够装下物品的时候<code>dp[i][j]=dp[0][j-nums[i]]+nums[i]</code></li>
</ul>
</li>
<li><p>遍历顺序：先遍历物品再遍历背包，或者先遍历背包再遍历物品都行，只要<code>[i][j]</code>的状态是由<code>[i-1][...]</code>一层中推断出来的，只要上一层的左上角都被初始化完成，那么就能推断出第<code>(i,j)</code>的数据</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//获取背包容量target</span></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//奇数和一定不会平分</span></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//初始化第一行数据</span></span><br><span class="line">                    <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j]=nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果装得下物品，那么就尝试装下，如果装不下就是上一个背包的状态</span></span><br><span class="line">                    <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//当最后一个物品遍历完之后的最大价值能等于target也即能平分</span></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][target]==target;</span><br></pre></td></tr></table></div></figure>


        <h6 id="一维数组题解-1"   >
          <a href="#一维数组题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-1" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候能装下的最大价值物品，由二维数组的状态压缩而来，而<code>j</code>的数据是由总物品价值的一半，超过这个价值的物品就装不下背包中</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：背包容量为0的时候装不下任何物品</p>
</li>
<li><p>确定遍历顺序：</p>
<ul>
<li>先遍历物品，再遍历物品</li>
<li><strong>物品必须倒序遍历</strong>，因为正序遍历的时候不能保证一个物品不会被添加多次，并且结束条件是背包容量要大于等于物品价值</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums) sum+=i;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果价值之和是奇数，那么一定不能平分</span></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;	<span class="comment">//获取目标容量</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                <span class="comment">//倒序遍历</span></span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果最后能装下，那么dp[target]==target</span></span><br><span class="line">        <span class="keyword">return</span> dp[target]==target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="1049-最后一块石头的重量II"   >
          <a href="#1049-最后一块石头的重量II" class="heading-link"><i class="fas fa-link"></i></a><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h4>
      <p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/" >Leetcode.1049(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;04</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        stones=boomStone(stones);</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] boomStone(<span class="type">int</span>[] stones)&#123;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">        <span class="type">int</span> length=stones.length;</span><br><span class="line">        <span class="keyword">if</span>(stones.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stones.length%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                stones[<span class="number">0</span>]=stones[stones.length-<span class="number">1</span>]-stones[<span class="number">0</span>];</span><br><span class="line">                length=length-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                    stones[l++]=stones[i+<span class="number">1</span>]-stones[i];</span><br><span class="line">                &#125;</span><br><span class="line">                length=length/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            stones=boomStone(Arrays.copyOf(stones,length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:stones) sum+=i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[stones.length][target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=stones[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> remain=sum-<span class="number">2</span>*dp[stones.length-<span class="number">1</span>][target];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain&gt;=<span class="number">0</span> ? remain : -<span class="number">1</span> * remain; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-8"   >
          <a href="#题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-8" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="二维数组题解-2"   >
          <a href="#二维数组题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-2" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <ul>
<li><p>确定dp数组及其下标含义：二维dp数组也即<code>dp[i][j]</code>,下标<code>[i]</code>表示的是第i件物品，下标<code>[j]</code>表示背包容量为j。也即<code>dp[i][j]</code>就表示第i件物品是否放到背包容量为j的最大价值</p>
</li>
<li><p>确定递推公式：我们这里将每一件物品的重量都视为价值，那么要平分数组的话，背包容量一定为总价值之和的一半<code>(target=sum/2)</code>,因此我们只需要判断最后一件物品的<code>dp[i][j]==target</code>如果相等那么说明之前的物品中包括当前物品的状态能平分数组。<br>$$<br>dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])<br>$$<br>在递推公式中，当前物品的<code>dp[i][j]</code>由上一层<code>[i-1][j]</code>确定，只有两种状态：要么不放进背包<code>dp[i-1][j]</code>，要么放进背包<code>dp[i-1][j-weight[i]]+value[i]</code></p>
</li>
<li><p>初始化dp数组，dp数组的第一行以及第一列需要初始化数据</p>
<ul>
<li>第一列也即<code>j==0</code>:背包容量为0无法装下任意物品，<code>dp[i][j]=0</code></li>
<li>第一行也即<code>i==0</code>：表示背包中第一个物品，当背包能够装下物品的时候<code>dp[i][j]=dp[0][j-nums[i]]+nums[i]</code></li>
</ul>
</li>
<li><p>遍历顺序：先遍历物品再遍历背包，或者先遍历背包再遍历物品都行，只要<code>[i][j]</code>的状态是由<code>[i-1][...]</code>一层中推断出来的，只要上一层的左上角都被初始化完成，那么就能推断出第<code>(i,j)</code>的数据</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p>思路：尽量把两块分成重量相同的石碓，那么两块石碓相撞之后剩余的就是最小重量，我们可以用背包来装小于等于总重量一半的石碓，而剩下一堆石碓就是重量大于等于总重量一半的石碓</p>
<p><strong>当剩余部分减去背包石碓就是我们要的答案</strong></p>
<p><code>remain-dp[i][j]</code>就是这两堆石碓相撞的结果</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:stones) sum+=i; <span class="comment">//求出总重量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>; <span class="comment">//求出一半的重量，记录背包容量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[stones.length][target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=stones[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//剩余部分</span></span><br><span class="line">        <span class="type">int</span> remain=sum-dp[stones.length-<span class="number">1</span>][target];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain-dp[stones.length-<span class="number">1</span>][target];<span class="comment">//因为背包容量是向下取整所以remain的部分一定大于等于装入背包的价值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h6 id="一维数组题解-2"   >
          <a href="#一维数组题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-2" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候能装下的最大价值物品，由二维数组的状态压缩而来，而<code>j</code>的数据是由总物品价值的一半，超过这个价值的物品就装不下背包中</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：背包容量为0的时候装不下任何物品</p>
</li>
<li><p>确定遍历顺序：</p>
<ul>
<li>先遍历物品，再遍历物品</li>
<li><strong>物品必须倒序遍历</strong>，因为正序遍历的时候不能保证一个物品不会被添加多次，并且结束条件是背包容量要大于等于物品价值</li>
</ul>
</li>
</ul>
<p>思路：尽量把两块分成重量相同的石碓，那么两块石碓相撞之后剩余的就是最小重量，我们可以用背包来装小于等于总重量一半的石碓，而剩下一堆石碓就是重量大于等于总重量一半的石碓</p>
<p><strong>当剩余部分减去背包石碓就是我们要的答案</strong></p>
<p>那么<code>remain-dp[j]</code>就是这两堆重量相近的石碓最小重量</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:stones) sum+=i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> remain=sum-dp[target];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  remain-dp[target]; <span class="comment">//因为背包容量是向下取整所以remain的部分一定大于等于装入背包的价值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="494-目标和"   >
          <a href="#494-目标和" class="heading-link"><i class="fas fa-link"></i></a><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h4>
      <p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/" >Leetcode.494(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;04</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span>(sum&lt;target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> bagSize=(sum-target)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][bagSize+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=bagSize;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=nums[i]) dp[i][j]=nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][bagSize]==bagSize) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-9"   >
          <a href="#题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-9" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="二维数组题解-3"   >
          <a href="#二维数组题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-3" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <ul>
<li>确定dp数组及其下标含义：二维数组<code>dp[i][j]</code>，我们认为<code>i</code>代表第<code>i-1</code>件物品，也即当<code>i==1</code>的时候说明是第<code>0</code>件物品，<code>j</code>代表当背包容量为<code>j</code>的时候有几种方法，也即<code>dp[i][j]</code>表示第<code>i-1</code>件物品在背包容量为<code>j</code>的时候的方法个数，类似于<strong>爬楼梯</strong>那道题</li>
<li>确定递推公式：当背包容量<code>j</code>小于<code>nums[i]</code>的时候说明背包装不下该物品也即<strong>只有一种状态就是不选中</strong>，那么<code>dp[i][j]=dp[i-1][j]</code>，当背包容量<code>j</code>大于等于<code>nums[i]</code>的时候则背包有两种状态：1.不装入背包中<code>dp[i][j]=dp[i-1][j]</code>，2装入背包中,那么还有<code>j-nums[i]</code>的背包容量的方法个数<code>dp[i][j]=dp[i-1][j-nums[i]]</code>，那么当时的方法就是这两种状态之和：<code>dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</code></li>
</ul>
<p>$$<br>dp[i][j]&#x3D;dp[i-1][j]+dp[i-1][j-nums[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组：</p>
<p>初始化<code>dp[0][0]=1</code>：因为当i为0的时候不代表任何物品，只是空出这一行来为了后面每个物品状态推导，<code>j==0</code>的时候说明背包价值为0，只有<strong>一种方法</strong>，也即<code>dp[i][0]=1</code></p>
</li>
<li><p>遍历顺序：先遍历物品再遍历背包，或者先遍历背包再遍历物品都行，只要<code>[i][j]</code>的状态是由<code>[i-1][...]</code>一层中推断出来的，只要上一层的左上角都被初始化完成，那么就能推断出第<code>(i,j)</code>的数据</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p>思路：因为每个元素要么是加法要么是减法，我们可以默认为加法算出加法和，然后选出部分元素成为减法，也即dp数组用于表示每个物品被选成减法的状态。背包价值<code>j</code>就是这样确定：<strong>背包价值j代表了要求负数之和</strong>，<code>int remain=(sum-target) /2 </code>：算出需要消除的部分的一半就是负数之和</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> remain=(sum-target)/<span class="number">2</span>;<span class="comment">//负数的之和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target || sum-<span class="number">2</span>*remain !=target ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>][remain+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//初始化 当背包容量为0的时候就认为只有一种方法那就是不选中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将i等于1的时候指向物品0 i等于2的时候指向物品1 </span></span><br><span class="line">            <span class="type">int</span> num=nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=remain;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//当选中状态的时候一共有两种方法，一个是不选择该物品 dp[i-1][j] </span></span><br><span class="line">                <span class="comment">//另一种是选中该物品剩下容量物品的方法 dp[i-1][j-num]</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num) dp[i][j]=dp[i-<span class="number">1</span>][j-num]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][remain];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h6 id="一维数组题解-3"   >
          <a href="#一维数组题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-3" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，由二维数组的状态压缩而来，假如<code>j</code>为1就说明当背包为1的时候组合到负数之和为1有几种方法</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-num[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：背包容量为0的时候装不下物品，也即只有<strong>一种方法（不装）</strong></p>
</li>
<li><p>确定遍历顺序：</p>
<ul>
<li>先遍历物品，再遍历物品</li>
<li><strong>物品必须倒序遍历</strong>，因为正序遍历的时候不能保证一个物品不会被添加多次，并且结束条件是背包容量要大于等于物品价值</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) sum+=num;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bagSize=(sum-target) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target || (sum-target)%<span class="number">2</span> !=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果之和小于目标或者 需要的加法和减法之和不相同则返回0</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//当背包容量为0只有一种方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=bagSize;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-nums[i]]; <span class="comment">//因为背包是从大往小算，背包只能有两种状态：1不装2装，也即这两种状态之和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="474-一和零"   >
          <a href="#474-一和零" class="heading-link"><i class="fas fa-link"></i></a><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h4>
      <p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/" >Leetcode.474题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;06</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[strs.length+<span class="number">1</span>][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=strs.length;i++)&#123;</span><br><span class="line">            String str=strs[i-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) one++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="comment">//如果满足可以选下</span></span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=zero &amp;&amp; k&gt;=one) </span><br><span class="line">                    dp[i][j][k]=Math.max(dp[i-<span class="number">1</span>][j][k],dp[i-<span class="number">1</span>][j-zero][k-one]+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j][k]=dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.length][m][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-7"   >
          <a href="#提交成功-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-7" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-10"   >
          <a href="#题解-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-10" class="headerlink" title="题解"></a>题解</h5>
      <p>这题可以看成两个维度的背包问题，我们之前的01背包的问题只有考虑物品重量，而这道题我们可以看成要考虑两个重量：一个是0的个数，另一个是1的个数。也即这个背包要从两个维度考虑，而不仅仅只考虑物品重量这一个维度</p>

        <h6 id="三维数组题解"   >
          <a href="#三维数组题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#三维数组题解" class="headerlink" title="三维数组题解"></a>三维数组题解</h6>
      <ul>
<li><p>确定dp数组含义以及下标含义：三维dp数组的<code>i</code>代表的是第i件物品，<code>j</code>代表背包中0的容量，<code>k</code>代表背包中1的容量，也即<code>dp[i][j][k]</code>表示当物品<code>i</code>在背包容量<code>j</code>和<code>k</code>的情况下所能选出的最多物品数</p>
</li>
<li><p>确定递推公式：</p>
<p>每一件物品当0的容量以及和1的容量足够的情况下就有两种状态：1.不选当前物品。2.选当前物品于是这个物品的<code>dp[i][j][k]</code>就在这两种状态的最大值<br>$$<br>dp[i][j][k]&#x3D;Math.max(dp[i-1][j][k],dp[i-1][j-zero][k-one]+1);<br>$$</p>
</li>
<li><p>初始化dp数组：当背包为0的时候装不下任何物品，所以<code>dp[0][0][0]=0</code></p>
</li>
<li><p>遍历顺序：先物品后背包或者先背包后物品都可以</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[strs.length+<span class="number">1</span>][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=strs.length;i++)&#123;</span><br><span class="line">            String str=strs[i-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> one=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//求这个字符串所含有的1和0个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) one++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="comment">//如果满足可以选下</span></span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=zero &amp;&amp; k&gt;=one) </span><br><span class="line">                    dp[i][j][k]=Math.max(dp[i-<span class="number">1</span>][j][k],dp[i-<span class="number">1</span>][j-zero][k-one]+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j][k]=dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.length][m][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="二维数组题解-4"   >
          <a href="#二维数组题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-4" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <p>因此我们可以压缩三维数组的状态，使其成为二维数组（压缩掉了物品i）</p>
<ul>
<li><p>确定dp数组含义以及下标含义：二维dp数组的<code>j</code>代表背包中0的容量，<code>k</code>代表背包中1的容量，也即<code>dp[j][k]</code>表示物品在背包容量<code>j</code>和<code>k</code>的情况下所能选出的最多物品数</p>
</li>
<li><p>确定递推公式：</p>
<p>每一件物品当0的容量以及和1的容量足够的情况下就有两种状态：1.不选当前物品。2.选当前物品。于是这个物品的<code>dp[j][k]</code>就在这两种状态的最大值<br>$$<br>dp[j][k]&#x3D;Math.max(dp[j][k],dp[j-zero][k-one]+1);<br>$$</p>
</li>
<li><p>初始化dp数组：当背包为0的时候装不下任何物品，所以<code>dp[0][0]=0</code></p>
</li>
<li><p>遍历顺序：先物品后背包，背包必须倒序遍历，防止一件物品被添加多次</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">            String str=strs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) one ++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//倒序遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=zero;j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=one ;k--)&#123;</span><br><span class="line">                    dp[j][k]=Math.max(dp[j][k],dp[j-zero][k-one]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="完全背包理论基础"   >
          <a href="#完全背包理论基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h3>
      <p>完全背包对于01背包的区别就在一个物品可以被装入多次，也即完全背包中可以一直装同一个物品，而我们在01背包的一维数组解法中，为了避免一个物品添加多次我们将遍历背包的顺序是倒序遍历，而这里将遍历顺序变成正序遍历就是题解</p>

        <h4 id="一维dp数组"   >
          <a href="#一维dp数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维dp数组" class="headerlink" title="一维dp数组"></a>一维dp数组</h4>
      <p>如01背包的一维数组题解一样，我们能用一个滚动dp数组来求解这道题</p>
<ul>
<li><p>确定dp数组以及对应下标含义：dp数组用于表示重量j下的可以存放最大价值，j对应的背包容量</p>
</li>
<li><p>确定递推公式：因为也就两个状态要么装下要么装下，那么<code>dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i])</code><br>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
</li>
<li><p>初始化dp数组：因为当j&#x3D;0的时候物品都装不下，那么初始化dp[0]&#x3D;0,那么以后的状态都需要跟当前状态对比，所以我们默认以后状态数据都是0，那么初始化dp数组都为0</p>
</li>
<li><p>遍历顺序：</p>
<ul>
<li>第一层for循环遍历物品，从0到M-1，确保遍历每一个物品</li>
<li>第二层for循环遍历背包，从0到bagSize，因为这样可以将一个物品重复添加，也即取之不尽用之不竭</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> bagSize=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义dp数组</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=weight[i];j&lt;=bagSize;j++)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="518-零钱问题II"   >
          <a href="#518-零钱问题II" class="heading-link"><i class="fas fa-link"></i></a><a href="#518-零钱问题II" class="headerlink" title="518.零钱问题II"></a>518.零钱问题II</h4>
      <p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/" >Leetcode.518题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;08</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> coin=coins[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coin)&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-coin]+coin);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]==amount) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])</span><br><span class="line">                    dp[j]=(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-11"   >
          <a href="#题解-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-11" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-4"   >
          <a href="#一维数组题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-4" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，假如<code>j</code>为1就说明当背包为1的时候使其硬币价值之和为1有几种方法（只装价值为1的一枚硬币）</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-coins[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：背包容量为0的时候装不下物品，也即只有<strong>一种方法（不装）</strong></p>
</li>
<li><p>确定遍历顺序：这道题的装法不分顺序，也即{1,2}和{2,1}是同一种装法，所以求得方法个数是组合而不是排序</p>
<p>先物品后背包（求组合），假如<code>coins=&#123;1,2,5&#125;</code></p>
<ul>
<li>先遍历物品那么遍历顺序一定是先1装入背包之后2、5依次装入背包，因此只有当j为3的时候只会出现<code>&#123;1,2&#125;</code>的情况</li>
</ul>
<p>先背包后物品（求排序）</p>
<ul>
<li><p>先遍历背包那么当遍历到<code>j==3</code>的时候</p>
<p>遍历物品：</p>
<p>先遍历价值为1的硬币，那么有装入一元硬币和不装一元硬币<code>dp[3]=dp[3] + dp[2] </code> ，第二个<code>dp[3]</code>代表不装一元硬币，<code>dp[2]</code>代表装一元硬币之后有几种方法，因此<code>dp[3]=2</code></p>
<p>再遍历价值为2的硬币，那么有装入二元硬币和不装二元硬币<code>dp[3]=dp[3]+dp[1]</code>，第二个<code>dp[3]</code>代表不装二元硬币，<code>dp[1]</code>代表装二元硬币之后有几种方法，因此<code>dp[3]=2+dp[1]=3</code>，也即此时这个排列中有<code>&#123;1,1,1&#125;,&#123;1,2&#125;,&#123;2,1&#125;</code>，<strong>也即不会是一定是一元硬币先装入背包</strong></p>
</li>
</ul>
</li>
<li><p><strong>求组合则遍历顺序先物品后背包，求排列则遍历顺序先背包后物品</strong></p>
</li>
<li><p>这道题的遍历顺序是求组合，因此是先物品后背包</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//当背包容量为0的时候只能有一种方法就是都不装</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//求组合所以先遍历物品后遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123; <span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;<span class="comment">//背包</span></span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="377-组合总和IV"   >
          <a href="#377-组合总和IV" class="heading-link"><i class="fas fa-link"></i></a><a href="#377-组合总和IV" class="headerlink" title="377.组合总和IV"></a>377.组合总和IV</h4>
      <p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/" >Leetcode.377题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;08</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                dp[j]=dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i])</span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="题解-12"   >
          <a href="#题解-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-12" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-5"   >
          <a href="#一维数组题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-5" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，假如<code>j</code>为1就说明当背包为1的时候使其总和价值之和为1有几种方法（只装价值为1数字）</p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个元素的时候，也即<code>j&lt;nums[i]</code><br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个元素的时候，也即<code>j&gt;=nums[i]</code></p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-nums[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：背包容量为0的时候装不下物品，也即只有<strong>一种方法（不装）</strong></p>
</li>
<li><p>确定遍历顺序：这道题是求排序，因为（1,1,2）和（2,1,1）不是同一种方法，也即元素顺序也会造成影响</p>
<p>先背包后物品（求排序）</p>
<ul>
<li><p>先遍历背包那么当遍历到<code>j==3</code>的时候</p>
<p>遍历物品：</p>
<p>先遍历价值为1的元素，那么有装入1和不装1<code>dp[3]=dp[3] + dp[2] </code> ，第二个<code>dp[3]</code>代表不装1这个元素，<code>dp[2]</code>代表装元素1之后有几种方法，因此<code>dp[3]=2</code></p>
<p>再遍历价值为2的元素，那么有装入和不装二元硬币<code>dp[3]=dp[3]+dp[1]</code>，第二个<code>dp[3]</code>代表不装2，<code>dp[1]</code>代表装元素2之后有几种方法，因此<code>dp[3]=2+dp[1]=3</code>，也即此时这个排列中有<code>&#123;1,1,1&#125;,&#123;1,2&#125;,&#123;2,1&#125;</code>，<strong>也即不会是一定是1先装入背包</strong></p>
</li>
</ul>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//背包为0的时候只有一种方法即不装</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                dp[j]=dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i]) <span class="comment">//当足够装下元素的时候，还有一种状态就是装下元素</span></span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="卡码网57-爬楼梯"   >
          <a href="#卡码网57-爬楼梯" class="heading-link"><i class="fas fa-link"></i></a><a href="#卡码网57-爬楼梯" class="headerlink" title="卡码网57.爬楼梯"></a>卡码网57.爬楼梯</h4>
      <p><strong>题目描述</strong></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 </p>
<p>每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ </p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>输入描述</strong></p>
<p>输入共一行，包含两个正整数，分别表示n, m</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示爬到楼顶的方法数。</p>
<p><strong>输入示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></div></figure>

<p><strong>输出示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></div></figure>

<p><strong>提示信息</strong></p>
<p>数据范围：<br>1 &lt;&#x3D; m &lt; n &lt;&#x3D; 32;</p>
<p>当 m &#x3D; 2，n &#x3D; 3 时，n &#x3D; 3 这表示一共有三个台阶，m &#x3D; 2 代表你每次可以爬一个台阶或者两个台阶。</p>
<p>此时你有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶段</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067" >卡码网57.爬楼梯</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;10</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> m=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//一步到位</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//只走一步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i)&#123;</span><br><span class="line">                    dp[j]+=dp[j-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-8"   >
          <a href="#提交成功-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-8" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-13"   >
          <a href="#题解-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-13" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-6"   >
          <a href="#一维数组题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-6" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <p>我们把被可以爬的楼梯m阶看成m个物品，那么一共有m个物品，把总楼阶数n看成背包容量</p>
<ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，假如<code>j</code>为1就说明当总阶数为1的时候，那么有1种方法可以到达一阶</p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个元素的时候，也即<code>j&lt;i</code>要爬的楼层数小于能迈出的步数<br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个元素的时候，也即<code>j&gt;=i</code>要爬的楼层数大于等于能迈出的步数</p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-i]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：当总楼阶数是0的时候说明一步到位，也即只有一种方法</p>
<p><code>dp[1]=1</code>：当总楼阶数是1的时候说明只能走一步，也即只有一个方法（只走一步）</p>
</li>
<li><p>确定遍历顺序：这道题是求排序，因为（1,1,2）和（2,1,1）不是同一种方法，也即元素顺序也会造成影响</p>
<p>先背包后物品（求排序），因为总阶数一样的时候，先走几格后走几格也会造成影响</p>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> m=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//一步到位</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//只走一步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i)&#123;</span><br><span class="line">                    dp[j]+=dp[j-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="322-零钱兑换"   >
          <a href="#322-零钱兑换" class="heading-link"><i class="fas fa-link"></i></a><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4>
      <p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/" >Leetcode.322(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;12</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++) dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=coins.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount? dp[amount]: -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++) dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=coins.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]]);</span><br><span class="line">                    <span class="keyword">if</span>(dp[j]==Integer.MAX_VALUE)</span><br><span class="line">                    dp[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount? dp[amount]: -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-14"   >
          <a href="#题解-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-14" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-7"   >
          <a href="#一维数组题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-7" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <p>我们把背包容量j认为是需要的零钱总数，而dp数组表示获取零钱总数的最少硬币数</p>
<ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有<strong>最少</strong>几个硬币，假如总金额为3那么最少需要两个硬币（一个一元硬币一个二元硬币）也即<code>dp[3]=2</code></p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个硬币价值的时候，则最少硬币数维持不变<br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个元素的时候，也即<code>j&gt;=coins[i]</code>，最少硬币数为<code>dp[j-coins[i]]+1</code>以及<code>dp[j]</code>之间最小的</p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.min(dp[j],dp[j-coins[i]]+1)<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：总金额为0的时候不需要硬币</p>
<p>dp数组其他元素：初始化为<code>Integer.MAX_VALUE-1</code>,一个达不到的数防止对比较最小值的时候产生影响，并且为了防止数据溢出对最终获取不到总金额的影响</p>
</li>
<li><p>确定遍历顺序：这道题是求硬币总数，无论是组合还是排列，那么硬币的总数都不会变，所以可以先背包后物品，也可以先物品后背包</p>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    	<span class="comment">//初始化dp数组，dp[0]=0,其他数为最大值-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp.length;i++) dp[i]=Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果dp[amount]为最大值-1也即无法达到最后的金额，返回-1，反之返回最小硬币个数dp[j]</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]==Integer.MAX_VALUE-<span class="number">1</span>? -<span class="number">1</span>: dp[amount];</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="279-完全平方数"   >
          <a href="#279-完全平方数" class="heading-link"><i class="fas fa-link"></i></a><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4>
      <p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/" >Leetcode.279(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-15"   >
          <a href="#第一次做-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-15" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;13</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//求最大的完全平方数，确定i的平方不会大于n</span></span><br><span class="line">    	<span class="type">int</span> sqrt=(<span class="type">int</span>) Math.sqrt(n);</span><br><span class="line">		</span><br><span class="line">    	<span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i]=Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sqrt;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i * i)&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-9"   >
          <a href="#提交成功-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-9" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-15"   >
          <a href="#题解-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-15" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-8"   >
          <a href="#一维数组题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-8" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <p>这道题和之前零钱兑换的答案几乎一模一样，只是换了一个模样</p>
<ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有<strong>最少</strong>几个完全平方数，假如数字为3那么最少需要两个完全平方数（一个一元一个二）也即<code>dp[3]=2</code></p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个完全平方数的时候，则最少完全平方数维持不变<br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个完全平方数的时候，也即<code>j&gt;=i*i</code>，最少硬币数为<code>dp[j-i*i]+1</code>以及<code>dp[j]</code>之间最小的</p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.min(dp[j],dp[j-i*i]+1)<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：背包为0的时候不需要装完全平方数</p>
<p>dp数组其他元素：初始化为<code>Integer.MAX_VALUE-1</code>,一个达不到的数防止对比较最小值的时候产生影响，并且为了防止数据溢出对最终获取不到总数的影响</p>
</li>
<li><p>确定遍历顺序：这道题是求完全平方数个数，无论是组合还是排列，那么完全平方数的个数都不会变，所以可以先背包后物品，也可以先物品后背包</p>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//求最大的完全平方数，确定i的平方不会大于n</span></span><br><span class="line">    	<span class="type">int</span> sqrt=(<span class="type">int</span>) Math.sqrt(n);</span><br><span class="line">		</span><br><span class="line">    	<span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i]=Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sqrt;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i * i)&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="139-单词拆分"   >
          <a href="#139-单词拆分" class="heading-link"><i class="fas fa-link"></i></a><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h4>
      
        <h5 id="第一次做-16"   >
          <a href="#第一次做-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-16" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;14</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dirt=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            dirt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dp.length;j++)&#123;</span><br><span class="line">            <span class="type">int</span>[] tempDirt=Arrays.copyOf(dirt,dirt.length);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordDict.size();i++)&#123;</span><br><span class="line">                String str=wordDict.get(i);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=str.length())&#123;</span><br><span class="line">                    <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;str.length();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tempDirt[str.charAt(k)-<span class="string">&#x27;a&#x27;</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                            flag=<span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag &amp;&amp; dp[j]&gt;dp[j-str.length()])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;str.length();k++)&#123;</span><br><span class="line">                            tempDirt[str.charAt(k)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        dp[j]=dp[j-str.length()]+str.length();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()]==s.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-12"   >
          <a href="#提交失败-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-12" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-16"   >
          <a href="#题解-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-16" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-9"   >
          <a href="#一维数组题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-9" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li><p>明确dp数组以及下标含义：dp数组用于表示当背包长度为<code>j</code>的时候是否能被字典中的字符串组成，仪表<code>j</code>表示背包长度也即需要组成的字符串<code>s</code>长度</p>
</li>
<li><p>确定递推公式：</p>
<p>当<code>(i,j)</code>这个区间中，如果这个区间的字符串能够在字典中找到，并且<code>dp[j]</code>也为<code>true</code>，就说明<code>dp[j]</code>也为<code>true</code><br>$$<br>i&lt;&#x3D;j,dp[i]&#x3D;&#x3D;true,wordDict.contains(s.substring(i,j))&#x3D;&gt; dp[j]&#x3D;true<br>$$<br>也即<code>dp[i]==true</code>:表示在当前这个字符串之前都能由字典中的字符串组成</p>
<p><code>wordDict.contains(s.substring(i,j))</code>:表示当前字符串在字典中找得到，也即<code>j</code>背包长度下都可以由字典中字符串组成</p>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0]=true</code>：参照字符串为空的情况下为<code>true</code>，以便后序字符串推导</p>
</li>
<li><p>遍历顺序：求<strong>排列</strong>（先背包后物品）：假设字符串<code>s=&quot;leetcode&quot;</code>，字典<code>wordDict=&#123;&quot;leet&quot;,&quot;code&quot;&#125;</code>所以一定是第一个物品<code>&quot;leet&quot;</code>先于第二个物品<code>&quot;code&quot;</code>装入背包，这样才能组成字符串<code>s</code></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String str : wordDict) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> str.length();</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j                            <span class="comment">//背包要装得下这个字符串长度</span></span><br><span class="line">                        &amp;&amp; dp[i - j] == <span class="literal">true</span>          <span class="comment">//在这个间隔前也要是能由wordDict组成</span></span><br><span class="line">                        &amp;&amp; str.equals(s.substring(i - j, i))<span class="comment">//这个间隔能在这个字典中找到</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231114164631944.png"  alt="单词拆分">
      </p>

        <h3 id="多重背包"   >
          <a href="#多重背包" class="heading-link"><i class="fas fa-link"></i></a><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3>
      <p>你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 </p>
<p>给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。</p>
<p><strong>输入描述</strong></p>
<p>输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。 </p>
<p>接下来的三行，每行包含 N 个正整数。具体如下： </p>
<p>第二行包含 N 个整数，表示 N 种矿石的重量。 </p>
<p>第三行包含 N 个整数，表示 N 种矿石的价格。 </p>
<p>第四行包含 N 个整数，表示 N 种矿石的可用数量上限。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066" >卡码网.56题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-17"   >
          <a href="#第一次做-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-17" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;15</p>

        <h5 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> bagSize=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> kind=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] number=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            number[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=bagSize;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(number[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(weight[i]&lt;=j)&#123;</span><br><span class="line">                    <span class="type">int</span> temp=dp[j];</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">                    <span class="keyword">if</span>(temp!=dp[j])</span><br><span class="line">                    number[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-13"   >
          <a href="#提交失败-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-13" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-17"   >
          <a href="#题解-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-17" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题（多重背包）也即一个物品既然不止只有一个，但是又不是能无限选，所以我们可以将这些物品分开成一个个物品，每个物品只能选一个，也即2拆分成1+1,3拆分成1+1+1，所以这就是01背包的一种类型</p>
<ul>
<li><p>关键在于将多个物品拆分成一个个物品，所以我们可以先获取每一个物品的总个数，然后将重量和价值重新对齐每一个物品</p>
</li>
<li><p>确定dp数组以及对应下标含义：dp数组用于表示重量j下的可以存放最大价值，j对应的背包容量</p>
</li>
<li><p>确定递推公式：因为也就两个状态要么装下要么装下，那么<code>dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i])</code><br>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
</li>
<li><p>初始化dp数组：因为当j&#x3D;0的时候物品都装不下，那么初始化dp[0]&#x3D;0,那么以后的状态都需要跟当前状态对比，所以我们默认以后状态数据都是0，那么初始化dp数组都为0</p>
</li>
<li><p>遍历顺序：</p>
<ul>
<li>第一层for循环遍历物品，从0到M-1</li>
<li>第二层for循环遍历背包，从背包的最大容量开始到需要的重量<code>weight[i]</code>，这样是为了防止一个物品被添加了两次</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> bagSize=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> kind=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] firstWeight=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] firstValue=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] number=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            firstWeight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            firstValue[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            number[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取总个数</span></span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:number) size+=i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//展开</span></span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            <span class="comment">//重复的物品将它分开成单独的物品</span></span><br><span class="line">            <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                weight[index]=firstWeight[i];</span><br><span class="line">                value[index]=firstValue[i];</span><br><span class="line">                index++;</span><br><span class="line">                number[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="comment">//倒序遍历防止一个物品被添加两次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=bagSize;j&gt;=weight[i];j--)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="打家劫舍"   >
          <a href="#打家劫舍" class="heading-link"><i class="fas fa-link"></i></a><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2>
      
        <h3 id="198-打家劫舍"   >
          <a href="#198-打家劫舍" class="heading-link"><i class="fas fa-link"></i></a><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3>
      <p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/" >Leetcode.198题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-18"   >
          <a href="#第一次做-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-18" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;16</p>

        <h5 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>] ? nums[<span class="number">0</span>]: nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">2</span>] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                max+=nums[i]+nums[i+<span class="number">2</span>];</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max+=nums[i+<span class="number">1</span>];</span><br><span class="line">                i+=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-14"   >
          <a href="#提交失败-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-14" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>] ? nums[<span class="number">0</span>]: nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&gt;nums[i])&#123;</span><br><span class="line">                max-=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    max+=nums[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                max+=nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-15"   >
          <a href="#提交失败-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-15" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">                dp[i]=<span class="literal">true</span>;</span><br><span class="line">                dp[i+<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i]==<span class="literal">false</span>)</span><br><span class="line">                dp[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i+<span class="number">1</span>]==<span class="literal">true</span>) max+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-16"   >
          <a href="#提交失败-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-16" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-18"   >
          <a href="#题解-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-18" class="headerlink" title="题解"></a>题解</h4>
      <ul>
<li><p>明确dp数组以及下标含义：dp数组表示在下标i的时候能偷到的最大金钱数量，假如i&#x3D;&#x3D;3，那么就表示在三间房子的情况下所能偷到的最大金额，<code>dp[3]</code>不一定会偷第三间屋子，因为可能偷了第二件能保证金额最大就不会偷第三间</p>
</li>
<li><p>明确递推公式</p>
<p>当前屋子的情况只有偷和不偷两种，只有当满足最大金额数量的时候才确定状态，所以也要前两间屋子的状态</p>
<ul>
<li>因为偷了的时候要考虑前两家中第一家屋子偷的金额以及当前屋子偷的金额总价值</li>
<li>如果不偷则要考虑前一家屋子偷的金额最大数量</li>
</ul>
<p>$$<br>dp[i]&#x3D;Math.max(dp[i-1],dp[i-2]+nums[i])<br>$$</p>
<p>解释一下公式：</p>
<ul>
<li><p><code>dp[i-1]</code>表示不偷当前这家，前面一家屋子就能满足最大金额，不一定会偷前一家屋子只是满足前一家的最大金额数量</p>
</li>
<li><p><code>dp[i-2]+nums[i]</code>表示偷当前这家，当前这家的金额为<code>nums[i]</code>，而一定不能偷前面一家，所以之前偷的金额为<code>dp[i-2]</code></p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0]=nums[0]</code>：就一家屋子偷完完事</p>
<p><code>dp[1]=nums[0]&gt;nums[1]? nums[0]:nums[1]</code>：两家偷钱多的一家</p>
</li>
<li><p>遍历顺序</p>
<p>当<code>i=2</code>开始遍历，因为前两家状态确定了，所以从第三家开始递推</p>
</li>
<li><p>打印dp数组</p>
</li>
<li><p>返回<code>dp[nums.length-1]</code>：返回最后一家屋子偷的最大金额为本题题解</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];  <span class="comment">//如果只有一间屋子偷完就结束了</span></span><br><span class="line">    	</span><br><span class="line">    </span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>]? nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);<span class="comment">//dp[i-1]是前一间房子偷的钱最大值（不一定会偷第i-1间)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="213-打家劫舍II"   >
          <a href="#213-打家劫舍II" class="heading-link"><i class="fas fa-link"></i></a><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h3>
      <p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/description/" >Leetcode.213(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-19"   >
          <a href="#第一次做-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-19" class="headerlink" title="第一次做"></a>第一次做</h4>
      
        <h5 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>] &gt;nums[<span class="number">1</span>] ? nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=nums.length-<span class="number">1</span>)</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]-nums[<span class="number">0</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-17"   >
          <a href="#提交失败-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-17" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-19"   >
          <a href="#题解-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-19" class="headerlink" title="题解"></a>题解</h4>
      <p>因为这道题是一个环状数组，所以我们考虑环状数组的时候不知道哪里是头结点，所以我们可以把环状数组撕开，变成线性数组的情况</p>
<p>环状数组的情况有两种：</p>
<ul>
<li>考虑头结点，不考虑尾结点：也即[1,2,3,4,5]只考虑[1,2,3,4]数组的线性问题，头结点不一定就被选中，只要变成这样就变成了打家劫舍I类型的题目</li>
<li>考虑尾结点，不考虑头结点：也即[1,2,3,4,5]只考虑[2,3,4,5]数组的线性问题，尾结点不一定就一定被选中</li>
</ul>
<p>这两种情况下的最大结果就是我们这道题的题解</p>
<p>我们可以把打家劫舍I的答案封装成一段函数，所以我们<strong>传入数组以及起始和结束位置</strong>，就能获得两个线性数组</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>]? nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//考虑头结点，不考虑尾结点</span></span><br><span class="line">    	<span class="type">int</span> head=robRow(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//考虑尾结点，不考虑头结点</span></span><br><span class="line">        <span class="type">int</span> tail=robRow(nums,<span class="number">1</span>,nums.length);</span><br><span class="line">        <span class="keyword">return</span> head &gt; tail? head: tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打家劫舍I中的线性数组代码封装成的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robRow</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线性数组（起始位置，结束位置）</span></span><br><span class="line">        <span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[end-start];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            num[i]=nums[start++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[num.length];</span><br><span class="line">        dp[<span class="number">0</span>]=num[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=Math.max(num[<span class="number">0</span>],num[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[num.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="337-打家劫舍III"   >
          <a href="#337-打家劫舍III" class="heading-link"><i class="fas fa-link"></i></a><a href="#337-打家劫舍III" class="headerlink" title="337.打家劫舍III"></a>337.打家劫舍III</h3>
      <p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/" >Leetcode.337题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-20"   >
          <a href="#第一次做-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-20" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;18</p>

        <h5 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=backtracking(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=backtracking(root.left);</span><br><span class="line">        <span class="type">int</span> right=backtracking(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftVal=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightVal=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)</span><br><span class="line">            leftVal=left-root.left.val;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">            rightVal=right-root.right.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left+right,leftVal-rightVal+root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-18"   >
          <a href="#提交失败-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-18" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-20"   >
          <a href="#题解-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-20" class="headerlink" title="题解"></a>题解</h4>
      <p>我们可以用一个一维的dp数组来表示当前结点偷还是不偷，<code>dp[0]</code>用于表示不偷当前结点可以获取的最大金币，<code>dp[1]</code>用于表示偷当前结点可以获取的最大金币</p>
<p><strong>递归三部曲部分</strong></p>
<ul>
<li><p>递归函数的参数与返回值</p>
<ul>
<li>返回值:一维dp数组，每一层都会有一个dp数组用于表示当前结点状态</li>
<li>参数：root,根节点</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当遍历到空结点返回，返回初始化为0的dp数组</p>
</li>
<li><p>递归函数的单层逻辑</p>
<p>每一层结点的状态由dp数组表示，<code>dp[0]</code>表示不偷当前结点可以获取的最大金额，<code>dp[1]</code>表示偷当前结点可以获取的最大金额</p>
<p>我们需要采用<strong>后序遍历</strong>，处理完两边子节点再处理根节点</p>
</li>
</ul>
<p><strong>动态规划部分</strong></p>
<ul>
<li><ul>
<li>明确dp数组及其下标含义：dp数组表示当前结点偷与不偷可以获取的最大金额</li>
<li><code>dp[0]</code>：表示不偷当前结点可以获取的最大金额</li>
<li><code>dp[1]</code>：表示偷当前结点可以获取的最大金额</li>
</ul>
</li>
<li><ul>
<li><p>明确递推公式</p>
<p>当前结点状态只有两个，一个是偷当前结点，一个是不偷当前结点，分别对应dp[1]和dp[0]</p>
<ul>
<li>偷当前结点：<code>dp[1]=root.val+leftDp[0]+rightDp[0]</code><ul>
<li>root.val：表示当前结点值</li>
<li>leftDp:表示左孩子递归后返回的dp数组，leftDp[0]意味着左孩子不偷的情况下最大金额</li>
<li>rightDp:表示右孩子递归后返回的dp数组，rightDp[0]意味着左孩子不偷的情况下最大金额</li>
</ul>
</li>
<li>不偷当前结点：<code>dp[0]=Math.max(leftDp[0],leftDp[1])+Math.max(rightDp[0],rightDp[1])</code><ul>
<li>leftDp：当不偷当前结点，则获取左子树的偷与不偷分别获取到的金额的最大金额</li>
<li>rightDp:当不偷当前结点，则获取右子树的偷与不偷分别获取到的金额的最大金额</li>
</ul>
</li>
</ul>
</li>
<li><p>当前结点的状态就是<code>dp[0]</code>和<code>dp[1]</code>的最大值</p>
</li>
</ul>
</li>
<li><ul>
<li><p>初始化dp数组</p>
<p>当遇到空节点的时候返回初始化为0的dp数组</p>
</li>
</ul>
</li>
<li><ul>
<li>遍历顺序：后序遍历</li>
</ul>
</li>
<li><ul>
<li>打印dp数组</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=backTracking(root);</span><br><span class="line">       <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] backTracking(TreeNode root)&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="type">int</span>[] leftDp=backTracking(root.left);</span><br><span class="line">       <span class="type">int</span>[] rightDp=backTracking(root.right);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//偷当前结点dp[0]</span></span><br><span class="line">       dp[<span class="number">1</span>]=root.val+leftDp[<span class="number">0</span>]+rightDp[<span class="number">0</span>];</span><br><span class="line">       <span class="comment">//不偷当前结点dp[0]</span></span><br><span class="line">       dp[<span class="number">0</span>]=Math.max(leftDp[<span class="number">0</span>],leftDp[<span class="number">1</span>])+Math.max(rightDp[<span class="number">0</span>],rightDp[<span class="number">1</span>]);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="股票问题"   >
          <a href="#股票问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h2>
      
        <h3 id="121-买卖股票的最佳时机"   >
          <a href="#121-买卖股票的最佳时机" class="heading-link"><i class="fas fa-link"></i></a><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h3>
      <p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" >LeetCode.121题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-21"   >
          <a href="#第一次做-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-21" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;19</p>

        <h5 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lowIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;low)&#123;</span><br><span class="line">                low=prices[i];</span><br><span class="line">                lowIndex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high=low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lowIndex+<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;high)&#123;</span><br><span class="line">                high=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high-low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-19"   >
          <a href="#提交失败-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-19" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:prices&#x3D;[2,4,1] </p>

        <h5 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> cul=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//记录一开始买的价格</span></span><br><span class="line">                low=prices[i];</span><br><span class="line">                high=prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cul=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(cul&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//当前是股价下跌</span></span><br><span class="line">                    <span class="keyword">if</span>(prices[i]&lt;low)&#123;</span><br><span class="line">                        <span class="comment">//如果跌出最低价，记录从买入到这次跌之间最大的卖出价格</span></span><br><span class="line">                        <span class="type">int</span> tempMax=high-low;</span><br><span class="line">                        <span class="keyword">if</span>(tempMax&gt;max ) max=tempMax;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//重新购入最低价股票</span></span><br><span class="line">                        low=prices[i];</span><br><span class="line">                        high=low;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当前是股价不跌</span></span><br><span class="line">                    <span class="keyword">if</span>(prices[i]&gt;high)&#123;</span><br><span class="line">                        high=prices[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//到最后没卖出股票，所以我们卖出去</span></span><br><span class="line">        <span class="keyword">if</span>(high!=low)&#123;</span><br><span class="line">            <span class="keyword">if</span>(high-low&gt;max) max=high-low;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//返回这期间的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-10"   >
          <a href="#提交成功-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-10" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-21"   >
          <a href="#题解-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-21" class="headerlink" title="题解"></a>题解</h4>
      <p>我们可以用一个二维dp数组来表示股票的每一天买卖情况，<code>dp[i][0]</code>表示持有当前股票现金，而<code>dp[i][1]</code>表示当前不持股现金，我们要知道的是这一题中这支股票<strong>只能买卖一次</strong></p>
<ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<ul>
<li>持股的情况下：<ul>
<li>前一天就买入股票：<code>dp[i-1][0]</code>，表示前一天买入股票的最大金额</li>
<li>当天买入股票：<code>-prices[i]</code>，表示今天买入股票，需要支付金额</li>
</ul>
</li>
<li>不持股的情况下：<ul>
<li>前一天就卖出了股票：<code>dp[i-1][1]</code>：表示前一天就卖出了股票</li>
<li>前天持股并且当天把股票卖出：<code>dp[i-1][0]+prices[i]</code>：表示今天卖出股票，所能获取的最大金额</li>
</ul>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],-prices)</code>：表示当天持股所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices)</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=-prices[i]</code>：第一天就买入股票，所以持有股票最大金额是<code>-prices[i]</code></p>
<p><code>dp[0][1]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
<p><del>也即不炒股就不会亏</del></p>
</li>
<li><p>遍历顺序：因为后一天的最大金额需要前一天的最大金额确定，所以<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一天持有股票，支付prices[0]现金</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//第一天不持有股票，持有现金数</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="comment">//持有股票（前一天持股，买入当前股票）之间最大现金</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不持有股票（前一天就卖出去，前一天持股并且当天卖出股票）之间最大现金</span></span><br><span class="line">        dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回最后一天卖出股票的价格(因为最后一天卖出去才能赚钱)</span></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>








        <h3 id="122-买卖股票的最佳时机II"   >
          <a href="#122-买卖股票的最佳时机II" class="heading-link"><i class="fas fa-link"></i></a><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h3>
      <p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" >Leetcode.122题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-22"   >
          <a href="#第一次做-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-22" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>这道题其实在贪心算法部分做过了一遍</p>

        <h4 id="第二次做"   >
          <a href="#第二次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次做" class="headerlink" title="第二次做"></a>第二次做</h4>
      <p>第二次做于23&#x2F;11&#x2F;20</p>

        <h5 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>]!=dp[i][<span class="number">1</span>] &amp;&amp;dp[i][<span class="number">1</span>]&gt;<span class="number">0</span>) max=dp[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-20"   >
          <a href="#提交失败-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-20" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-22"   >
          <a href="#题解-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-22" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题和买卖股票I的时候的思路是一样的，但是那支股票只能买卖一次，而这里股票可以买卖多次，所以我们的买卖股票的状态会有所不同</p>
<ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<ul>
<li>持股的情况下：<ul>
<li>前一天就买入股票：<code>dp[i-1][0]</code>，表示前一天买入股票的最大金额</li>
<li>当天买入股票：<code>dp[i-1][1]-prices[i]</code>，表示今天买入股票，需要支付金额，前一天不持有股票的现金减去买入股票价格</li>
</ul>
</li>
<li>不持股的情况下：<ul>
<li>前一天就卖出了股票：<code>dp[i-1][1]</code>：表示前一天就卖出了股票</li>
<li>前天持股并且当天把股票卖出：<code>dp[i-1][0]+prices[i]</code>：表示今天卖出股票，所能获取的最大金额</li>
</ul>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices)</code>：表示当天持股所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices)</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=-prices[i]</code>：第一天就买入股票，所以持有股票最大金额是<code>-prices[i]</code></p>
<p><code>dp[0][1]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
</li>
<li><p>遍历顺序：因为后一天的最大金额需要前一天的最大金额确定，所以<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           <span class="comment">//持有股票，可能是前一天就持有股票以及前一天不持有股票的金额-购买股票价格</span></span><br><span class="line">           dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">           <span class="comment">//不持有股票</span></span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="123-买卖股票的最佳时机III"   >
          <a href="#123-买卖股票的最佳时机III" class="heading-link"><i class="fas fa-link"></i></a><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h3>
      <p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/" >Leetcode.123题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-23"   >
          <a href="#第一次做-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-23" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;21</p>

        <h5 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i];</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length &amp;&amp; num&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max)&#123;</span><br><span class="line">                max=dp[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>]!=dp[i][<span class="number">0</span>])<span class="comment">//同一只股票</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    result=max;</span><br><span class="line">                    max=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-21"   >
          <a href="#提交失败-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-21" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length &amp;&amp; num&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max)&#123;</span><br><span class="line">                max=dp[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>]!=dp[i][<span class="number">0</span>])<span class="comment">//同一只股票</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    result+=max;</span><br><span class="line">                    max=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">2</span> &amp;&amp; max!=<span class="number">0</span>) result+=max;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-22"   >
          <a href="#提交失败-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-22" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-23"   >
          <a href="#题解-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-23" class="headerlink" title="题解"></a>题解</h4>
      <p>我们可以用二维数组来表示买卖两次股票的状态，我们把所有状态都推导出来，然后返回卖出股票的最大值即可</p>
<ul>
<li><p>明确dp数组及其下标含义：<code>dp[i][.]</code>表示第<code>i</code>天的金额状态，例如<code>dp[1][0]</code>表示第一天的不操作股票的金额数量</p>
<ul>
<li><code>dp[i][j]</code>：下标<code>j</code>的含义有五种状态，分别对应股票的操作五种状态<ul>
<li><code>dp[i][0]</code>：表示第<code>i</code>天不操作股票，也即不卖入也不卖出，那么现金数应该是0</li>
<li><code>dp[i][1]</code>：表示第一次持有(买入)股票</li>
<li><code>dp[i][2]</code>：表示第一次不持有(卖出)股票</li>
<li><code>dp[i][3]</code>：表示第二次持有(买入)股票</li>
<li><code>dp[i][4]</code>：表示第二次不持有(卖出)股票</li>
</ul>
</li>
</ul>
</li>
<li><p>明确递推公式：因为第<code>i</code>天的状态都可以由第<code>i-1</code>天推导并且操作而来</p>
<ul>
<li><p><code>dp[i][0]</code>：不操作，也即现金一定是0</p>
</li>
<li><p><code>dp[i][1]</code>：第一次买入股票，可以是前一天买入当天持有：<code>dp[i-1][1]</code>，也可以是前一天不操作，当天买入:</p>
<p><code>dp[i-1][0]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2]</code>：第一次卖出股票，可以是前一天卖出：<code>dp[i-1][2]</code>，也可以是前一天持有，第二天卖出： </p>
<p><code>dp[i-1][1]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code></p>
</li>
<li><p><code>dp[i][3]</code>：第二次买入股票，可以是前一天第二次买入：<code>dp[i-1][3]</code>，也可以是前一天第二次卖出，当天买入： </p>
<p><code>dp[i-1][2]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][3]=Math.max(dp[i-1][3],dp[i-1][2]-prices[i])</code></p>
</li>
<li><p><code>dp[i][4]</code>：第二次卖出股票，可以是前一天卖出：<code>dp[i-1][4]</code>，也可以是前一天第二次买入，当天卖出:</p>
<p><code>dp[i-1][3]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][4]=Math.max(dp[i-1][4],dp[i-1][3]+prices[i])</code></p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：第一天不操作，现金为0</p>
<p><code>dp[0][1]=-prices[0]</code>：第一天第一次买入股票，现金为<code>-prices[i]</code></p>
<p><code>dp[0][2]=0</code>：第一次卖出，可以认为是第一次买入然后卖出，现金为0</p>
<p><code>dp[0][3]=-prices[0]</code>：第一天第二次买入股票，可以看成是买卖过一次之后再买入现金为<code>-prices[i]</code></p>
<p><code>dp[0][4]=0</code>：第一天第二次卖出，可以是看成第二次买入之后再卖出，现金为0</p>
</li>
<li><p>遍历顺序：因为<code>i</code>天状态由<code>i-1</code>天推导出来，所以遍历顺序是从前往后</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line">    	<span class="comment">//初始化dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//都由前一天状态推导而来</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//一定是第二次卖出价格更高（因为可以同一天买卖两次，第二次结果包含了第一次）</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="188-买卖股票的最佳时机IV"   >
          <a href="#188-买卖股票的最佳时机IV" class="heading-link"><i class="fas fa-link"></i></a><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h3>
      <p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" >Leetcode.188题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-24"   >
          <a href="#第一次做-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-24" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;22</p>

        <h5 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][(<span class="number">2</span>*k) +<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-11"   >
          <a href="#提交成功-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-11" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-24"   >
          <a href="#题解-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-24" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题和上一题<em>买卖股票的最佳时机III</em>是相似的，因为上一题的买卖次数是两次，而这题的买卖次数为K次，这里是区别</p>
<p>我们可以用二维数组来表示买卖k次股票的状态，我们把所有状态都推导出来，然后返回卖出股票的最大值即可</p>
<ul>
<li><p>明确dp数组及其下标含义：<code>dp[i][.]</code>表示第<code>i</code>天的金额状态，例如<code>dp[1][0]</code>表示第一天的不操作股票的金额数量</p>
<ul>
<li><code>dp[i][j]</code>：下标<code>j</code>的含义有<code>2*k+1</code>种状态，分别对应股票的操作<code>2*k+1</code>种状态<ul>
<li><code>dp[i][0]</code>：表示第<code>i</code>天不操作股票，也即不卖入也不卖出，那么现金数应该是0</li>
<li><code>dp[i][1]</code>：表示第一次持有(买入)股票</li>
<li><code>dp[i][2]</code>：表示第一次不持有(卖出)股票</li>
<li><code>...</code></li>
<li><code>dp[i][2k-1]</code>：表示第k次持有(买入)股票</li>
<li><code>dp[i][2k]</code>：表示第k次不持有(卖出)股票</li>
</ul>
</li>
</ul>
</li>
<li><p>明确递推公式：因为第<code>i</code>天的状态都可以由第<code>i-1</code>天推导并且操作而来</p>
<ul>
<li><p><code>dp[i][0]</code>：不操作，也即现金一定是0</p>
</li>
<li><p><code>dp[i][1]</code>：第一次买入股票，可以是前一天买入当天持有：<code>dp[i-1][1]</code>，也可以是前一天不操作，当天买入:</p>
<p><code>dp[i-1][0]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2]</code>：第一次卖出股票，可以是前一天卖出：<code>dp[i-1][2]</code>，也可以是前一天持有，第二天卖出： </p>
<p><code>dp[i-1][1]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code></p>
</li>
<li><p><code>...</code></p>
</li>
<li><p><code>dp[i][2k-1]</code>：第k次买入股票，可以是前一天第k次买入：<code>dp[i-1][2k-1]</code>，也可以是前一天第k-1次卖出，当天买入： </p>
<p><code>dp[i-1][2k-2]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2k]=Math.max(dp[i-1][2k-1],dp[i-1][2k-2]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2k]</code>：第k次卖出股票，可以是前一天卖出：<code>dp[i-1][2k]</code>，也可以是前一天第k次买入，当天卖出:</p>
<p><code>dp[i-1][2k-1]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2k]=Math.max(dp[i-1][2k],dp[i-1][2k-1]+prices[i])</code></p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：第一天不操作，现金为0</p>
<p><code>dp[0][1]=-prices[0]</code>：第一天第一次买入股票，现金为<code>-prices[i]</code></p>
<p><code>dp[0][2]=0</code>：第一次卖出，可以认为是第一次买入然后卖出，现金为0</p>
<p><code>...</code></p>
<p><code>dp[0][2k-1]=-prices[0]</code>：第一天第k次买入股票，可以看成是买卖过k-1次之后再买入现金为<code>-prices[i]</code></p>
<p><code>dp[0][2k]=0</code>：第一天第k次卖出，可以是看成第k次买入之后再卖出，现金为0</p>
</li>
<li><p>遍历顺序：因为<code>i</code>天状态由<code>i-1</code>天推导出来，所以遍历顺序是从前往后</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p>定义dp数组:<code>int[][] dp=new int[prices.length][2*k+1]</code></p>
<ul>
<li>下标i长度：<code>prices.length</code>，下标i对应股市的i+1天，所以一共有股市几天就定义多长dp数组</li>
<li>下标j长度:<code>2k+1</code>：一共要交易k次股票，每一次交易股票对应(买入，卖出)两种状态，所以一共有2k种状态，而不操作股票对应下标0</li>
</ul>
</li>
<li><p>递推公式实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第2天开始遍历股市，因为第一天被初始化完了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    <span class="comment">//从第一次买卖股票，到第k次买卖股票</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">        <span class="comment">//如果j是偶数，说明对应不持有股票(前一天第n次不持有，前一天第n-1次持有)最大值</span></span><br><span class="line">        <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相反j是奇数，说明持有股票</span></span><br><span class="line">            dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：表示不操作股票</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">    <span class="comment">//如果i是偶数说明不持有 股票，应该初始化为0</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//i是偶数，初始化为-第0天股票价格</span></span><br><span class="line">    dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][(<span class="number">2</span>*k) +<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//初始化第0天的股票状态</span></span><br><span class="line">    	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果i是偶数说明不持有股票，应该初始化为0</span></span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i是偶数，初始化为-第0天股票价格</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//j是偶数，不持有股票</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//j是奇数，持有股票</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="309-买卖股票的最佳时机含冷冻期"   >
          <a href="#309-买卖股票的最佳时机含冷冻期" class="heading-link"><i class="fas fa-link"></i></a><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309.买卖股票的最佳时机含冷冻期"></a>309.买卖股票的最佳时机含冷冻期</h3>
      <p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" >Leetcode.309(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-25"   >
          <a href="#第一次做-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-25" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;23</p>

        <h5 id="第一次代码-15"   >
          <a href="#第一次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-15" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mat</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-23"   >
          <a href="#提交失败-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-23" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h6 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//冷冻期(不操作)</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//持有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">0</span>],dp[prices.length-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-12"   >
          <a href="#提交成功-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-12" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-25"   >
          <a href="#题解-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-25" class="headerlink" title="题解"></a>题解</h5>
      <ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天不操作股票含有的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][2]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<p>因为股票一共分成三个状态：1、不操作（冷冻期）2、持有股票 3、不持有股票，所以我们对这三个状态逐个分析</p>
<ul>
<li><p><code>dp[i][0]</code>冷冻期（不操作股票）：因为不操作的状态由可能有两个状态</p>
<ul>
<li>前一天是冷冻期，当天不操作：<code>dp[i-1][0]</code></li>
<li>前一天卖出股票，当天是冷冻期:<code>dp[i-1][2]</code></li>
</ul>
<p>因此是这两个状态之间的最大值:<code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2])</code></p>
</li>
<li><p><code>dp[i][1]</code>持有股票：持有股票也有两个状态推导而来</p>
<ul>
<li>前一天持有股票，当天不卖出：<code>dp[i-1][1]</code></li>
<li>前一天是冷冻期（不操作股票），当天买入:<code>dp[i-1][0]-prices[i]</code></li>
</ul>
<p>因此是这两个状态之间的最大值:<code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2]</code>不持有股票：不持有股票也有两个状态</p>
<ul>
<li>前一天不持有股票，当天也不持有：<code>dp[i-1][2]</code></li>
<li>前一天持有股票，当天卖出:<code>dp[i-1][1]+prices[i]</code></li>
</ul>
<p>因此i这两个状态之间的最大值:<code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code></p>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2])</code>：表示当天不操作股票所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code>：表示当天持股所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：第一天不操作股票，所以持有金额是0</p>
<p><code>dp[0][1]=-prices[i]</code>：第一天买入股票，持股的最大金额是-股价</p>
<p><code>dp[0][2]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
</li>
<li><p>遍历顺序：<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    		<span class="comment">//冷冻期(不操控股票)</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//持有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">0</span>],dp[prices.length-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="714-买卖股票的最佳时机含手续费"   >
          <a href="#714-买卖股票的最佳时机含手续费" class="heading-link"><i class="fas fa-link"></i></a><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h3>
      <p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" >Leetcode.714(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-26"   >
          <a href="#第一次做-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-26" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;24</p>

        <h5 id="第一次代码-16"   >
          <a href="#第一次代码-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-16" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>]-fee;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-13"   >
          <a href="#提交成功-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-13" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-26"   >
          <a href="#题解-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-26" class="headerlink" title="题解"></a>题解</h4>
      <ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<ul>
<li>持股的情况下：<ul>
<li>前一天就买入股票：<code>dp[i-1][0]</code>，表示前一天买入股票的最大金额</li>
<li>当天买入股票：<code>dp[i-1][1]-prices[i]-fee</code>，表示今天买入股票，需要支付金额并且支付手续费</li>
</ul>
</li>
<li>不持股的情况下：<ul>
<li>前一天就卖出了股票：<code>dp[i-1][1]</code>：表示前一天就卖出了股票</li>
<li>前天持股并且当天把股票卖出：<code>dp[i-1][0]+prices[i]</code>：表示今天卖出股票，所能获取的最大金额</li>
</ul>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices)-fee</code>：表示当天持股支付完手续费后所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices)</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=-prices[i]-fee</code>：第一天就买入股票，并且付完手续费，所以持有股票最大金额是<code>-prices[i]</code></p>
<p><code>dp[0][1]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
</li>
<li><p>遍历顺序：<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    	<span class="comment">//第一天持股，付完手续费</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>]-fee;</span><br><span class="line">    	<span class="comment">//第一天不持股</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//第i天持股（前一天持股，前一天不持股今天买入【需要付手续费】）</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]-fee);</span><br><span class="line">            <span class="comment">//第i天不持股</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="子序列问题"   >
          <a href="#子序列问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2>
      
        <h3 id="300-最长递增子序列"   >
          <a href="#300-最长递增子序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h3>
      <p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></div></figure>

<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" >Leetcode.300(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-27"   >
          <a href="#第一次做-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-27" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;25</p>

        <h5 id="第一次代码-17"   >
          <a href="#第一次代码-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-17" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];    </span><br><span class="line">        <span class="type">int</span> max=-<span class="number">10001</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;dp[i-<span class="number">1</span>])&#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;max)&#123;</span><br><span class="line">                    max=num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;max) max=num;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-24"   >
          <a href="#提交失败-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-24" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][<span class="number">2</span>];    </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=nums[i];</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][<span class="number">0</span>]&lt;dp[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>]=Math.max(dp[j][<span class="number">1</span>]+<span class="number">1</span>,dp[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max) max=dp[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="题解-27"   >
          <a href="#题解-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-27" class="headerlink" title="题解"></a>题解</h4>
      <ul>
<li><p>明确dp数组及其下标含义：我们用一个二维的dp数组表示每一个元素为结尾的子序列长度</p>
<ul>
<li><code>dp[i][0]=nums[i]</code>：我们用下标0表示当前元素的数值</li>
<li><code>dp[i][1]</code>：我们用下标1表示以当前元素结尾的递增子序列的最大子序列长度</li>
</ul>
</li>
<li><p>明确递推公式：因为下标<code>i</code>为最长子序列的结尾，所以我们要从<code>i-1</code>的状态开始推断出</p>
<p>我们用<code>j</code>来遍历<code>0~i-1</code>个元素，当<code>nums[j]&lt;nums[i]</code>也即<code>j</code>结尾的子序列到<code>i</code>是递增的也即<br>$$<br>if(dp[j][0]&lt;dp[i][0])&#x3D;&gt;dp[i][1]&#x3D;Math.max(dp[j][1]+1,dp[i][1])<br>$$<br><code>dp[j][0]&lt;·dp[i][0]</code>：表示以<code>j</code>为结尾的最长递增子序列加上<code>i</code>为结尾，一样是递增的</p>
<p><code>dp[j][1]+1</code>：表示将<code>j</code>为结尾的最长子序列+1</p>
<p><code>dp[i][1]</code>：表示当前<code>i</code>为结尾的最长子序列</p>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=nums[0]</code>：存储第1个元素数值，用于后面比对</p>
<p><code>dp[0][1]=1</code>：表示将第一个元素添加进子序列的首位</p>
<p><code>dp[i][1]=1</code>：表示每一个元素都可以是子序列的首位</p>
</li>
<li><p>遍历顺序</p>
<ul>
<li>第一个遍历从前往后：<code>0-i-1</code></li>
<li>第二个遍历从前往后也可以从后往前：用于遍历<code>i</code>之前的每一个元素为结尾的子序列状态</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][<span class="number">2</span>];    </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//存储数据</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=nums[i];</span><br><span class="line">            <span class="comment">//将每一个子序列设为首位</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//如果可以是递增的</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j][<span class="number">0</span>]&lt;dp[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>]=Math.max(dp[j][<span class="number">1</span>]+<span class="number">1</span>,dp[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//再遍历一遍，用于获取最长子序列长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max) max=dp[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>因为之前的每一个数值都存在nums数值中，所以可以用一维数组压缩掉数值</p>
<p><strong>压缩状态代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];    </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i]=Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="674-最长连续递增序列"   >
          <a href="#674-最长连续递增序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#674-最长连续递增序列" class="headerlink" title="674.最长连续递增序列"></a>674.最长连续递增序列</h3>
      
        <h4 id="第一次做-28"   >
          <a href="#第一次做-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-28" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;26</p>

        <h5 id="第一次代码-18"   >
          <a href="#第一次代码-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-18" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[i-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-14"   >
          <a href="#提交成功-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-14" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-28"   >
          <a href="#题解-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-28" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题和300那道最长递增子序列关键在于是否是<strong>连续</strong>的，如果是连续的只需要比较当前i位置之前i-1位置元素</p>
<ul>
<li><p>明确dp数组及其下标含义：<code>dp[i]</code>表示以第<code>i</code>个元素为结尾的最长<strong>连续</strong>递增子序列的长度为<code>dp[i]</code>个</p>
</li>
<li><p>明确递推公式：因为<code>i</code>元素比<code>i-1</code>的元素大，也即当前元素为结尾的时候是连续递增的，所以<code>dp[i]=dp[i-1]+1</code>，反之不是连续的，<code>dp[i]=1</code><br>$$<br>dp[i]&#x3D;dp[i-1]+1<br>$$</p>
</li>
<li></li>
<li><p>初始化dp数组：</p>
<p><code>dp[i]=1</code>：表示如果不是连续递增的，则当前元素是连续递增子序列的第一个元素</p>
</li>
<li><p>遍历顺序：从前往后，因为后面的元素需要前面的元素推导而出</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//是连续的子序列</span></span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="718-最长重复子数组"   >
          <a href="#718-最长重复子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a>718.最长重复子数组</h3>
      <p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/" >Leetcode.718题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-29"   >
          <a href="#第一次做-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-29" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;27</p>

        <h5 id="第一次代码-19"   >
          <a href="#第一次代码-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-19" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line">            len=nums1.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            len=nums2.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j ==<span class="number">0</span> )dp[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]&amp;&amp;nums1[i]==nums2[j]) dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-25"   >
          <a href="#提交失败-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-25" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-29"   >
          <a href="#题解-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-29" class="headerlink" title="题解"></a>题解</h4>
      
        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/29/%E7%9F%A5%E5%85%B6%E7%84%B6,%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E4%B9%8BJAVA%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E7%AF%87%5B1%5D/">知其然,知其所以然之JAVA虚拟机-JVM篇[1]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-29</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">63</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h1>
        <h2 id="字节码篇"   >
          <a href="#字节码篇" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节码篇" class="headerlink" title="字节码篇"></a>字节码篇</h2>
      <p>说说JVM的生命周期？</p>
<p>什么是JAVA虚拟机?</p>
<p>jvm的组成-》尽量手能画出来</p>
<p>为什么要使用JVM虚拟机？</p>
<p>说说Java虚拟机的体系结构？  </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/29/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B6-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%5D/">深入剖析并发编程-JUC篇[6.并发容器]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-29</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">0</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/26/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B8.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%5D/">死之前要做完的算法手册-[8.贪心算法]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-26</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">145分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="贪心算法"   >
          <a href="#贪心算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1>
      
        <h2 id="贪心算法理论基础"   >
          <a href="#贪心算法理论基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法理论基础" class="headerlink" title="贪心算法理论基础"></a>贪心算法理论基础</h2>
      <p>贪心算法就是由<strong>局部最优解推出全局最优解</strong>，并且没有反例。</p>
<p>比如取钞票取十张，那么怎么样才能取到总数最大的呢？</p>
<p>也即每次都取最大面额(100)的钞票，那么一共取十张就是一个总数最大的一个结果</p>
<p>贪心也类似于我们的常识性的解决方案，所以实际上没有一个必然的套路，我们从题目开始做起学习</p>

        <h2 id="455-分发饼干"   >
          <a href="#455-分发饼干" class="heading-link"><i class="fas fa-link"></i></a><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2>
      <p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/" >Leetcode.455(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;27</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g.length&amp;&amp;i&lt;s.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[i])</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:g&#x3D;[10,9,8,7] s&#x3D;[5,6,7,8] 输出0 预期输出2</p>
<p>原因是这饼干小的时候没有发出饼干，然后直接把这个对应的小朋友i给丢弃了，而后面有符合胃口大小的饼干</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;g.length &amp;&amp; j&lt;s.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：将小孩按胃口从小到大排序，饼干大小从大到小排序。然后喂小孩的时候就喂最小能满足胃口的饼干即可</p>
<blockquote>
<p>局部最优解：每个小孩只吃比自己胃口相等或者比胃口大的饼干，并且是从小胃口开始投喂，大胃口就一直饿着</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">     	<span class="comment">//小孩和饼干排序</span></span><br><span class="line">    	Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    		循环</span></span><br><span class="line"><span class="comment">    			参数i控制的是小孩</span></span><br><span class="line"><span class="comment">    			参数j控制的是饼干</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;g.length &amp;&amp; j&lt;s.length;)&#123;</span><br><span class="line">            <span class="comment">//判断饼干大小是否满足小孩胃口</span></span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//满足胃口则投喂成功，指向下一个小孩</span></span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指向下一个饼干</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="376-摆动序列"   >
          <a href="#376-摆动序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#376-摆动序列" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h2>
      <p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/" >Leetcode.376题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;27</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span>  )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入nums[0,0] ,输出2 预期输出1</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums.length!=<span class="number">1</span> &amp;&amp; nums[i+<span class="number">1</span>]-nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span>  )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输出nums&#x3D;[3,3,3,2,5]，输出2，预期输出3</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span>  )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[51,226,208,165,202,286,190,212,219,271,36,245,20,238,238,89,105,66,73,9,254,206,221,237,203,33,249,253,150,102,57,249,203,10,123,178,85,203,35,276,129,116,37,163,99,142,187,249,134,77,217,298,29,127,174,115,122,178,12,80,122,76,16,41,115,84,104,121,127,40,287,129,9,172,112,51,40,135,205,53,259,196,248,5,123,184,209,130,271,42,18,143,24,101,10,273,252,50,173,80,119,129,45,257,299,78,278,78,190,215,284,129,200,232,103,97,167,120,49,298,141,146,154,233,214,196,244,50,110,48,152,82,226,26,254,276,292,286,215,56,128,122,82,241,222,12,272,192,224,136,116,70,39,207,295,49,194,90,210,123,271,18,276,87,177,240,276,33,155,200,51,6,212,36,149,202,48,114,58,91,83,221,175,148,278,300,284,86,191,95,77,215,113,257,153,135,217,76,85,269,126,194,199,195,20,204,194,50,220,228,90,221,256,87,157,246,74,156,9,196,16,259,234,79,31,206,148,12,223,151,96,229,165,9,144,26,255,201,33,89,145,155,1,204,37,107,80,212,88,186,254,9,158,180,24,45,158,100,52,131,71,174,229,236,296,299,184,168,41,45,76,68,122,85,292,238,293,179,143,128,47,87,267,53,187,76,292,0,160,70,172,292,9,64,156,153,26,145,196,222]</p>
<p>输出201 预期输出202</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(i&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[i+<span class="number">1</span>]==nums[i])&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               </span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span> )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; nums[i]!=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>没能自己做出来</p>

        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们只要手机前后坡度不一样的结点，也即波峰或者波谷，然后统计波峰波谷的个数，最后返回个数即可</p>
<blockquote>
<p>局部最优解：每次统计的结点都在波峰或者波谷</p>
</blockquote>
<ul>
<li>情形1：具有单调坡，比如[3,7,2,5,6,8,3]，那么本题解的个数也即5，在单调坡上的元素不能算在内</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927194251615.png"  alt="具有单调坡">
      </p>
<ul>
<li>情形2：只有两个元素，而这又分两种情况<ul>
<li>两个元素不同，如[3,4]，那么摆动序列的长度为2</li>
</ul>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927194627710.png"  alt="两个元素不同">
      </p>
<ul>
<li><ul>
<li>两个元素相同，如[3,3]，那么摆动序列的长度为1</li>
</ul>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927194906277.png"  alt="两个元素相同">
      </p>
<p>也即我们当<strong>碰到坡度为0的元素的时候只要处理最后一个元素即可</strong></p>
<ul>
<li><p>情况3：单调坡有平坡的情况</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927195612985.png"  alt="单调坡有平坡">
      </p>
<p>我们在更新prediff的时候一定要在拐点更新，这样我们后面再统计的时候才不会将5统计进去</p>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>设置长度count&#x3D;1，也即nums最后一个元素默认算一个长度</li>
<li>设置前坡度prediff&#x3D;0，假设第一个元素之前坡度为0</li>
<li>循环遍历(i,nums.length-1)，因为最后一个元素默认算一个长度<ul>
<li>计算当前坡度culdiff&#x3D;nums[i+1]-nums[i]</li>
<li>当峰值的时候统计个数，并且将前坡度更新成当前坡度<ul>
<li>prediff&lt;&#x3D;0 &amp;&amp; culdiff&gt;0 也即前面是下坡或者平坡后面是上坡，也即峰谷</li>
<li>prediff&gt;&#x3D;0 &amp;&amp; culdiff&lt;0 也即前面是上坡或者平坡后面是下坡，也即峰顶</li>
</ul>
</li>
</ul>
</li>
<li>返回count</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>; <span class="comment">//默认最后一个元素也算一个</span></span><br><span class="line">      	<span class="comment">//默认前面坡度为0</span></span><br><span class="line">    	<span class="type">int</span> prediff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//计算当前结点后面坡度</span></span><br><span class="line">            <span class="type">int</span> culdiff=nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//满足峰值的结点</span></span><br><span class="line">            <span class="keyword">if</span>((prediff&lt;=<span class="number">0</span> &amp;&amp; culdiff&gt;<span class="number">0</span>) ||(prediff&gt;=<span class="number">0</span> &amp;&amp; culdiff&lt;<span class="number">0</span>) )&#123;</span><br><span class="line">                count++;</span><br><span class="line">   				<span class="comment">//将当前坡度更新到前面坡度</span></span><br><span class="line">                prediff=culdiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="53-最大子数组和"   >
          <a href="#53-最大子数组和" class="heading-link"><i class="fas fa-link"></i></a><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h2>
      <p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/" >Leetcode.53(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;28</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prediff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> culdiff=nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(prediff&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                    max=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(culdiff&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prediff=culdiff;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                    max=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>题意理解错误，这道题是连续子数组，也即可以是负数算在内</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次代码-1"   >
          <a href="#第四次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-1" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Nmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;Nmax+nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    i=j;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;Nmax)&#123;</span><br><span class="line">                    j=i;</span><br><span class="line">                    Nmax=nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                    max=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums[-2，-1]，输出0，预期输出-1</p>
<p>没做出来</p>

        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题在第一次做的第三次代码中差一点写出来了，只是还差了一些思路上的问题，也许当时不该看2023年杭州亚运会的英雄联盟项目</p>
<p>思路：当我们在获取连续和为负数的情况，我们不妨让连续和置零，让下一个数成为我们连续子数组和的起始位置，也即<strong>当连续和已经小于0了那么无论怎么样它都会拖累我们后面的数，只能让后面的数字变小</strong>，所以我们当连续和为负数的时候不妨直接丢弃，取下一个数的数值成为连续和</p>
<blockquote>
<p>局部最优解：当连续和为正数的时候继续积累，当连续和为负数的时候丢弃</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>定义变量sum：用于统计当前连续和</p>
</li>
<li><p>定义变量max：用于记录连续和的最大值，注意：<strong>这里max初始化为Integer.MIN_VALUE，当最大连续和是负数的时候也会统计</strong></p>
</li>
<li><p>循环遍历数组</p>
<ul>
<li>取得当前连续和sum+&#x3D;num[i]</li>
<li>如果sum&gt;max，也即是当前连续和最大，将max&#x3D;sum</li>
<li>如果sum&lt;0，说明sum会拖累以后的元素，让后面的连续和变小，所以直接丢弃，sum&#x3D;0</li>
</ul>
</li>
<li><p>返回统计值max</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//记录最大的连续和</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max) max=sum;</span><br><span class="line">            <span class="comment">//当连续和为负数</span></span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="122-买卖股票的最佳时机-II"   >
          <a href="#122-买卖股票的最佳时机-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122.买卖股票的最佳时机 II"></a>122.买卖股票的最佳时机 II</h2>
      <p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" >Leetcode.122题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;30，中秋节快乐！</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buy==<span class="number">0</span>)&#123;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                sell=prices[i+<span class="number">1</span>];</span><br><span class="line">                sum+=sell-buy;</span><br><span class="line">                buy=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:prices:[7,1,5,3,6,4],输出-1，预期输出7</p>
<p>我每次卖股票的时候都是卖掉了当天的，而实际上理论应该是下一天减去这一天，所以我当下一天贵的时候应该卖掉下一天的价格。如果下一天低的时候卖掉当天的价钱</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buy==<span class="number">0</span>)&#123;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                sell=prices[i+<span class="number">1</span>];</span><br><span class="line">                sum+=sell-buy;</span><br><span class="line">                buy=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sell=prices[i];</span><br><span class="line">                buy=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以假设每天都买卖股票，当下一天股票的价值超过当天价值，那么我们就卖出股票，然后记录下一天卖出股票的利润</p>
<p>如果下一天的股票没有超过当天的价值，那么我们当天就卖出当天购买的股票，也即利润为0，当利润大于0的时候我们记录利润，于是我们的最大利润就是每一天大于0的利润之和</p>
<blockquote>
<p>局部最优解：我们每一天利润大于0的时候统计利润，那么利润最大就是所有利润大于0的总和</p>
</blockquote>
<p><strong>实现</strong></p>
<p>我们获取每一天的股票价格和下一天的股票价格进行比较</p>
<ul>
<li>price[i+1]&gt;price[i]：说明利润大于0，我们要下一天卖出股票并且记录在总利润和之中</li>
<li>price[i+1]&lt;&#x3D;price[i]：说明利润小于等于0，我们每一天就卖出当天自己的股票即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//每一天买股票</span></span><br><span class="line">            buy=prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                <span class="comment">//卖出价为下一天的股票价格，统计利润</span></span><br><span class="line">                sell=prices[i+<span class="number">1</span>];</span><br><span class="line">                sum+=sell-buy;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//卖出价为当天的股票价格</span></span><br><span class="line">                sell=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//卖出股票</span></span><br><span class="line">            buy=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>简化之后</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//从第二天开始每天都卖前一天股票，当利润大于0的时候就记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>) sum+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="55-跳跃游戏"   >
          <a href="#55-跳跃游戏" class="heading-link"><i class="fas fa-link"></i></a><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h2>
      <p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/" >Leetcode.55题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;30</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> step=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(step==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sum+=step;</span><br><span class="line">            i+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超过时间限制</p>

        <h4 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//记录最大可以跳跃数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;step)&#123;</span><br><span class="line">                step=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果跳跃数为0且值为0那么就说明最大能到达的位置就是这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; step==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           	</span><br><span class="line">            <span class="comment">//向后跳一格，sum++ , step--，i++</span></span><br><span class="line">            sum++;</span><br><span class="line">            step--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以用一个step记录我们能跳的范围，然后我们一步一步跳，如果当前值大于step我们就更新我们的最大跳跃次数，如果我们跳到0的位置并且不能往后跳了就说明最大只能跳到0的位置</p>
<blockquote>
<p>局部最优解：我们每一次获取最大跳跃次数，如果能跳到最后就说明为true</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>定义变量sum:用于记录跳跃了总范围</li>
<li>定义变量step：用于还可以跳几步</li>
<li>循环<ul>
<li>当sum+nums[i]&gt;nums.length-1也即一定能跳到最后位置，返回true</li>
<li>当nums[i]&gt;step:更新最大跳跃次数</li>
<li>当step&#x3D;&#x3D;0&amp;&amp;nums[i]&#x3D;&#x3D;0,也即跳到0的位置也没能力继续往后跳则返回false</li>
<li>sum++,step–,i++:一次跳一格，确保不遗漏</li>
</ul>
</li>
<li>循环结束还没跳到返回false</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//记录最大可以跳跃数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;step)&#123;</span><br><span class="line">                step=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果跳跃数为0且值为0那么就说明最大能到达的位置就是这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; step==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           	</span><br><span class="line">            <span class="comment">//向后跳一格，sum++ , step--，i++</span></span><br><span class="line">            sum++;</span><br><span class="line">            step--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="45-跳跃游戏II"   >
          <a href="#45-跳跃游戏II" class="heading-link"><i class="fas fa-link"></i></a><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h2>
      <p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;01</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+dept&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;dept)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                dept=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            dept--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[7,0,9,6,9,6,1,7,9,0,1,2,9,0,3],输出4，预期输出2</p>

        <h4 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums[i]&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i+=nums[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交失败-12"   >
          <a href="#提交失败-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-12" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> cover=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=i;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;cover;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+nums[cover]&gt;max)&#123;</span><br><span class="line">                    max=j+nums[cover];</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            i=i+index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-13"   >
          <a href="#提交失败-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-13" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次代码-2"   >
          <a href="#第四次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-2" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> cover=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i+cover&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=i;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=cover;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+nums[j]&gt;max)&#123;</span><br><span class="line">                    max=j+nums[j];</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            i=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-14"   >
          <a href="#提交失败-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-14" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超出时间限制</p>
<p>CASE:nums[1,1,1,1] </p>

        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们用两个覆盖范围，cul来代表当前一跳能到达的位置，next代表下一跳能达到的最大位置，在当前跳的范围中记录下一跳最大位置，如果当前跳能跳到数组的末尾，直接break返回result结果即可，如果当前跳跳不到末尾，那么就启动下一跳的最大位置</p>
<p><strong>实现</strong></p>
<ul>
<li>定义变量<ul>
<li>result：用于记录一共跳了几次</li>
<li>cul：用于表示当前跳的最大覆盖范围</li>
<li>next：用于表示下一跳的最大覆盖范围</li>
</ul>
</li>
<li>当nums.length&#x3D;&#x3D;1，也即只有一个元素，那么不用跳就能跳到末尾，return 0;</li>
<li>循环<ul>
<li>统计当前跳中下一跳能达到的最大覆盖位置next&#x3D;Math.max(i+nums[i],next)<ul>
<li>i+nums[i]表示当前i位置下的最大覆盖范围，和next比较，也即更新最大的覆盖范围给next</li>
</ul>
</li>
<li>如果i&#x3D;&#x3D;cul，也即跳到了当前跳的末尾<ul>
<li>如果cul!&#x3D;nums.length-1，也即当前跳跃跳不到数组的末尾，那么就启动下一跳<ul>
<li>cul&#x3D;next，更新cul为下一跳的最大覆盖范围</li>
<li>result++，表示多跳了一次</li>
<li>判断next是否能跳到数组末尾，如果是则break即可</li>
</ul>
</li>
<li>如果cul&#x3D;&#x3D;nums.length,也即当前跳跃能跳到数组的末尾，break</li>
</ul>
</li>
</ul>
</li>
<li>返回result</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    	<span class="comment">//如果数组只有一个元素，那么不用跳</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//result用于统计跳跃次数，cul用于当前覆盖范围，next表示下一跳覆盖范围</span></span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cul=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//统计当前跳中最大的覆盖范围，作为下一跳的覆盖范围</span></span><br><span class="line">            next=Math.max(i+nums[i],next);</span><br><span class="line">            <span class="keyword">if</span>(i==cul)&#123;</span><br><span class="line">                <span class="comment">//没有覆盖数组的最后一个元素，也即当前一跳跳不到末尾</span></span><br><span class="line">                <span class="keyword">if</span>(cul!=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    cul=next;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="comment">//如果下一跳跳到了break;</span></span><br><span class="line">                    <span class="keyword">if</span>(next&gt;=nums.length-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果当前跳跳到了就break;</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="1005-K次取反后最大化的数组和"   >
          <a href="#1005-K次取反后最大化的数组和" class="heading-link"><i class="fas fa-link"></i></a><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2>
      <p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>
</ul>
<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>
<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/" >Leetcode.1005题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;02</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span> &amp;&amp; k!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i]=-<span class="number">1</span> * nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    count--;</span><br><span class="line">                    nums[i]=-<span class="number">1</span> *nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:nums &#x3D;[-8,3,-5,-3,-5,-2],k&#x3D;6，输出20，预期输出22</p>

        <h4 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span> &amp;&amp;k%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            nums[<span class="number">0</span>]=-<span class="number">1</span>*nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span> &amp;&amp; k!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    k=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                        k=<span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        nums[i-<span class="number">1</span>]=-<span class="number">1</span>*nums[i-<span class="number">1</span>];</span><br><span class="line">                        sum+=<span class="number">2</span>*nums[i-<span class="number">1</span>];</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    count--;</span><br><span class="line">                    nums[i]=-<span class="number">1</span> *nums[i];         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-15"   >
          <a href="#提交失败-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-15" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums &#x3D;[8,-7,-3,-9,1,9,-6,-9,3],k&#x3D;8，输出49，预期输出53</p>

        <h4 id="第三次代码-3"   >
          <a href="#第三次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-3" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//如果count&gt;=k,说明不能反转完所有负数</span></span><br><span class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[i]=-<span class="number">1</span>*nums[i];</span><br><span class="line">                    count--;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明能反转完所有负数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[i]=-<span class="number">1</span>*nums[i];</span><br><span class="line">                    count--;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="comment">//如果还有奇数次要反转，那么就反转正数第一个</span></span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                nums[<span class="number">0</span>]=-<span class="number">1</span>*nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相加</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们这里的贪心就是，我们尝试将nums数组的所有负数都反转，并且是从绝对值大的负数开始反转，然后反转之后再排序，判断反转次数有没有用完，如果反转次数还没有用完，那么就反转第一个元素，最后统计元素之和</p>
<p><strong>实现</strong></p>
<ul>
<li><p>第一次排序，使数组从小到大排序，例如[-3,-1,0,1,3],那么绝对值越大就越小，<strong>保证反转从绝对值大的负数开始</strong></p>
</li>
<li><p>统计负数个数count，for循环，一旦nums[i]&lt;0，那么count++</p>
</li>
<li><p>尝试将所有负数反转，有两种可能：</p>
<ul>
<li><p>count&gt;k，那么也即所有负数不能反转完，那么我们保证绝对值大的负数先反转</p>
</li>
<li><p>count&lt;k，那么当所有负数反转完毕之后，还有反转次数k没能用完</p>
<p>也即count&#x3D;&#x3D;0 ||k&#x3D;&#x3D;0，那么就反转结束</p>
<p><strong>count&#x3D;&#x3D;0，说明全部负数反转完,break;</strong></p>
<p><strong>k&#x3D;&#x3D;0，说明反转次数用完,break;</strong></p>
<p><em><em>k&gt;0 &amp;&amp; count&gt;0，说明还有负数可以反转,count–,k–,nums</em>&#x3D;-1</em>*</p>
</li>
</ul>
</li>
<li><p>反转完之后再将数组排序，保证从小到大</p>
</li>
<li><p>判断反转次数是否用完</p>
<ul>
<li><p>k%2&#x3D;&#x3D;1,说明还有奇数次，那么只要反转第一个元素即可</p>
</li>
<li><p>k%2&#x3D;&#x3D;0,说明还有偶数次(也可能是0次)，那么不做处理即可</p>
</li>
</ul>
</li>
<li><p>统计数组和sum，for循环遍历nums</p>
</li>
<li><p>返回sum</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//对数组排序，统计小于0的元素个数</span></span><br><span class="line">    	Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//尝试将所有负数反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                k--;</span><br><span class="line">                nums[i] *=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//对反转之后的数组再排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//说明k大于count，全部反转完还有奇数次未反转</span></span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">1</span>) nums[<span class="number">0</span>]*=-<span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//统计之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="134-加油站"   >
          <a href="#134-加油站" class="heading-link"><i class="fas fa-link"></i></a><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h2>
      <p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/" >Leetcode.134题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;03</p>

        <h4 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=gas.length;</span><br><span class="line">        <span class="type">int</span> length=gas.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-16"   >
          <a href="#提交失败-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-16" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:gas&#x3D;[5,1,2,3,4] cost&#x3D;[4,4,1,5,1] 输出2 预期输出4</p>

        <h4 id="第二次代码-7"   >
          <a href="#第二次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-7" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=gas.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n=gas.length;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-17"   >
          <a href="#提交失败-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-17" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:gas&#x3D;[2],cost&#x3D;[2],输出2,预期输出0</p>

        <h4 id="第三次代码-4"   >
          <a href="#第三次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-4" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=gas.length;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>]&gt;=<span class="number">0</span> ? <span class="number">0</span>: -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n=gas.length;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>暴力法</strong></p>
<p>思想：每遇到一个站就搜索能不能加够油，然后如果能转一圈到达i，那么就返回i</p>
<p>这里主要是说<strong>贪心算法</strong>的做法，所以这个暴力法只是提一嘴</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">//记录总站数</span></span><br><span class="line">    	<span class="type">int</span> length=gas.length;</span><br><span class="line">    	<span class="comment">//如果只有一站判断能不能出发</span></span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>]&gt;=<span class="number">0</span> ? <span class="number">0</span>: -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="comment">//记录总油数，当前指向站index，需要走的总站数n</span></span><br><span class="line">            <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n=gas.length;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="comment">//如果当前站能走到下一站</span></span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//尝试走n站，n为总站数长度</span></span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="comment">//如果走不到下一站</span></span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>贪心算法</strong></p>
<p>思路：我们判断一个站的存量和耗油量做一个宏观上的判断，如果gas&gt;cost那么就是增油，如果gas&lt;cost就是耗油，然后当存油量小于0的时候那么就一定不可能重来一遍</p>
<blockquote>
<p>局部最优解：如果油量走到某个位置i小于0，说明要从这个位置之后(i+1)才可能使其能重新跑一遍</p>
</blockquote>
<p>也即我们宏观的判断这个站点是加油还是少油</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231003194034342.png"  alt="加油站">
      </p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义变量start：用于记录第一个站的位置</p>
</li>
<li><p>定义变量cul：用于记录当前油量</p>
</li>
<li><p>定义变量totalCost：用于记录全程旅程总共的油耗量，如果totalCost&lt;0说明怎么走都不可能从头到尾走一遍</p>
</li>
<li><p>循环统计totalCost，如果totalCost小于0则直接返回-1</p>
</li>
<li><p>循环</p>
<ul>
<li>统计总油量cul+&#x3D;gas[i]-cost[i]</li>
<li>如果cul小于0说明到这一站之后不可能继续往后走了<ul>
<li>所以将cul置为0，并且将起始位置start更新成i之后也即start&#x3D;i+1</li>
</ul>
</li>
</ul>
</li>
<li><p>循环之后返回start</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cul=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalCost=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果总耗油量大于存油量那么就不可能重来一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            totalCost+=gas[i]-cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(totalCost&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            cul+=gas[i]-cost[i];</span><br><span class="line">            <span class="comment">//如果当前油量小于0，说明无法从i位置走回i</span></span><br><span class="line">            <span class="keyword">if</span>(cul&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">                cul=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="135-分发糖果"   >
          <a href="#135-分发糖果" class="heading-link"><i class="fas fa-link"></i></a><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h2>
      <p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/" >Leetcode.135题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;04</p>

        <h4 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ratings[<span class="number">0</span>]&gt;ratings[<span class="number">1</span>])&#123;</span><br><span class="line">                    give++;</span><br><span class="line">                &#125;</span><br><span class="line">                total+=give;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-18"   >
          <a href="#提交失败-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-18" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>输入ratings&#x3D;[1,3,2,2,1] 输出6，预期输出7</p>

        <h4 id="第二次代码-8"   >
          <a href="#第二次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-8" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ratings[<span class="number">0</span>]&gt;ratings[<span class="number">1</span>])&#123;</span><br><span class="line">                    give++;</span><br><span class="line">                &#125;</span><br><span class="line">                total+=give;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==ratings.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    give++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]==ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    give=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]&lt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    give= give==<span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                total+=give;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-19"   >
          <a href="#提交失败-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-19" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[1,2,87,87,87,2,1],输出11，预期输出13</p>

        <h4 id="第三次代码-5"   >
          <a href="#第三次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-5" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123;</span><br><span class="line">                        total+=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]==ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]&lt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(give-<span class="number">1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                give= give-<span class="number">1</span>==<span class="number">0</span>? <span class="number">1</span>: give-<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=count;i++)&#123;</span><br><span class="line">                total+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-20"   >
          <a href="#提交失败-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-20" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:ratings&#x3D;[1,3,4,5,2]，输出13，预期输出11</p>

        <h4 id="第四次代码-3"   >
          <a href="#第四次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-3" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">                <span class="keyword">if</span>(give&gt;max) max=give;</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123;</span><br><span class="line">                        total+=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">1</span>+count&gt;=max &amp;&amp; max!=<span class="number">2</span>) &#123;</span><br><span class="line">                        max=<span class="number">1</span>+count-max+<span class="number">1</span>;</span><br><span class="line">                        total+=<span class="number">1</span>+count-max+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]==ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]&lt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(give-<span class="number">1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=count;i++)&#123;</span><br><span class="line">                total+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>+count&gt;=max &amp;&amp; max!=<span class="number">2</span>) total+=<span class="number">1</span>+count-max+<span class="number">1</span>;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-21"   >
          <a href="#提交失败-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-21" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>没能做出来</p>

        <h3 id="题解-8"   >
          <a href="#题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们每个小孩最少要有一颗糖，我们可以定义一个candys数组来模拟要分发的小孩糖果个数，并将其初始化为1.</p>
<p>然后我们<strong>从左向右判断</strong>，当右孩子比左孩子大的时候那么右孩子糖果个数应该是左孩子糖果个数+1</p>
<p>不仅如此我们还要<strong>从右向左判断</strong>，当左孩子比右孩子大的时候那么左孩子糖果个数应该是右孩子糖果个数+1</p>
<blockquote>
<p>局部最优解:</p>
<p>当我们第一次从左向右获取了右孩子比左孩子大情况下的最小糖果个数分发情况</p>
<p>当我们第二次从右向左获取了左孩子比右孩子大情况下的最小糖果个数分发情况</p>
<p>我们将这两种情况合并，就是我们的最小糖果分发情况</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>初始化数组candys，初始化数值为1，表示每个小孩最小能分发一颗糖果</p>
</li>
<li><p>遍历，从前往后遍历(i&#x3D;1;i&lt;candys.length;i++)</p>
<p>当右孩子比左孩子大，那么右孩子应该比左孩子多一个糖果也即(ratings[i]&gt;ratings[i-1]时，candys[i]&#x3D;candys[i-1]+1)</p>
<p><em>我们这样就获取了右孩子比左孩子大的分发糖果情况</em></p>
</li>
<li><p>遍历，从后往前遍历(i&#x3D;candys.length-2;i&gt;&#x3D;0;i–)</p>
<p>当左孩子比右孩子大的时候，那么左孩子要比右孩子多一个糖果也即(ratings[i]&gt;rating[i+1])时</p>
<p>candys&#x3D;Math.max(<strong>candys[i],candys[i+1]+1</strong>)，我们在第一次循环获取的分发个数和右孩子糖果个数+1之间取最大值。这样保证了这个糖果个数必然考虑了右孩子比左孩子大也考虑了左孩子比右孩子大的情况</p>
</li>
<li><p>遍历candys数组，获取最终个数result</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candys=<span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">//初始化数组，每个小孩至少一颗糖</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;candys.length;i++)&#123;</span><br><span class="line">            candys[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//右孩子比左孩子大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                candys[i]=candys[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//左孩子比右孩子大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ratings.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//取原来candys的数量与右孩子数量+1的最大值</span></span><br><span class="line">                candys[i]=Math.max(candys[i],candys[i+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//统计总数</span></span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:candys)&#123;</span><br><span class="line">            result+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="860-柠檬水找零"   >
          <a href="#860-柠檬水找零" class="heading-link"><i class="fas fa-link"></i></a><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2>
      <p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/" >Leetcode.860题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;05</p>

        <h4 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] billsCount=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span>(bills[<span class="number">0</span>]!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bills.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (bills[i]-<span class="number">5</span>) / <span class="number">5</span> ;</span><br><span class="line">            <span class="keyword">if</span>( result == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//支付5 则直接收下</span></span><br><span class="line">                billsCount[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( result ==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//支付10 则要返回一张5</span></span><br><span class="line">                <span class="keyword">if</span>(billsCount[<span class="number">0</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                billsCount[<span class="number">0</span>]--;</span><br><span class="line">                billsCount[<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( result ==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//支付20则要返回一张10一张5，或者三张5</span></span><br><span class="line">                <span class="keyword">if</span>(billsCount[<span class="number">1</span>]!=<span class="number">0</span> &amp;&amp; billsCount[<span class="number">0</span>] !=<span class="number">0</span>)&#123;</span><br><span class="line">                    billsCount[<span class="number">1</span>]--;</span><br><span class="line">                    billsCount[<span class="number">0</span>]--;</span><br><span class="line">                    billsCount[<span class="number">2</span>]++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(billsCount[<span class="number">0</span>]&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    billsCount[<span class="number">0</span>]-=<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-9"   >
          <a href="#题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题的情形其实一下子就能想明白，我们只要做好找零的规划就可以解出这道题，支付5元则直接收下，支付10元则找一张5元，支付20元则找一张10元一张五元或者三张五元，而在取舍先找10元还是直接付3张五元的时候要先将面额大的10元支付出去</p>
<blockquote>
<p>局部最优解：在客户支付20的时候优先支付10+5的组合，因为5元更为通用</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>变量five：记录五元钞票的张数，用于找零</li>
<li>变量ten：记录十元钞票的张数，用于找零</li>
<li>遍历接待客人<ul>
<li>如果客人支付五元，直接收下</li>
<li>如果客人支付十元，则找一张五块，如果找不出来则return false</li>
<li>如果客人支付二十元，则优先找10+5元，如果不行再找三张5元，如果都找不出来则return false</li>
</ul>
</li>
<li>遍历结束，说明客人都接待成功了，return true</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> five=<span class="number">0</span>; <span class="type">int</span> ten=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bills.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i]==<span class="number">5</span>)&#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five != <span class="number">0</span> &amp;&amp; ten != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//找一张五块一张10块</span></span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="comment">//找三张五块</span></span><br><span class="line">                    five-=<span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//找不出钱</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="406-根据身高重建队列"   >
          <a href="#406-根据身高重建队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2>
      <p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/" >Leetcode.406(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;06</p>

        <h4 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[][] result=<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//排序</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;people.length;j++)&#123;</span><br><span class="line">               <span class="type">int</span> oldNum=people[i][<span class="number">0</span>];</span><br><span class="line">               <span class="type">int</span> newNum=people[j][<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">if</span>(newNum&lt;oldNum)&#123;</span><br><span class="line">                   <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                   people[i]=people[j];</span><br><span class="line">                   people[j]=temp;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNum==oldNum)&#123;</span><br><span class="line">                   <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                   <span class="keyword">if</span>(people[i][<span class="number">1</span>]&gt;people[j][<span class="number">1</span>])&#123;</span><br><span class="line">                       people[i]=people[j];</span><br><span class="line">                       people[j]=temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">           <span class="type">int</span>[] arr=people[i];</span><br><span class="line">           <span class="type">int</span> prev=arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(count!=prev &amp;&amp; j&lt;people.length)&#123;</span><br><span class="line">               <span class="keyword">if</span>(result[j][<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; result[j][<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(result[j][<span class="number">0</span>]&gt;=arr[<span class="number">0</span>])</span><br><span class="line">               count++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;people.length &amp;&amp;(result[j][<span class="number">0</span>]!=<span class="number">0</span> || result[j][<span class="number">1</span>]!=<span class="number">0</span>))&#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(j==people.length)&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           result[j]=arr;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-22"   >
          <a href="#提交失败-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-22" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:people：[[0,0],[6,2],[5,5],[4,3],[5,2],[1,1],[6,0],[6,3],[7,0],[5,1]]</p>
<p>输出[[6,0],[1,1],[5,1],[5,2],[4,3],[7,0],[6,2],[5,5],[6,3],[0,0]]</p>
<p>预期输出[[0,0],[6,0],[1,1],[5,1],[5,2],[4,3],[7,0],[6,2],[5,5],[6,3]]</p>

        <h4 id="第二次代码-9"   >
          <a href="#第二次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-9" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] result=<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> zeroCount=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;people.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldNum=people[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newNum=people[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(newNum&lt;oldNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                    people[i]=people[j];</span><br><span class="line">                    people[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNum==oldNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                    <span class="keyword">if</span>(people[i][<span class="number">1</span>]&gt;people[j][<span class="number">1</span>])&#123;</span><br><span class="line">                        people[i]=people[j];</span><br><span class="line">                        people[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] arr=people[i];</span><br><span class="line">            <span class="comment">//统计身高为0并且序号为0的元素个数</span></span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; arr[<span class="number">1</span>]==<span class="number">0</span>) zeroCount++;</span><br><span class="line">            <span class="type">int</span> prev=arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//统计一共有多少个位置</span></span><br><span class="line">            <span class="keyword">while</span>(count!=prev &amp;&amp; j&lt;people.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(result[j][<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; result[j][<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result[j][<span class="number">0</span>]&gt;=arr[<span class="number">0</span>])</span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当所在位置j不为空</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;people.length &amp;&amp;(result[j][<span class="number">0</span>]!=<span class="number">0</span> || result[j][<span class="number">1</span>]!=<span class="number">0</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==people.length)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            result[j]=arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当身高为0并且排名为0的个数不为1，则将最末尾的元素移到前面</span></span><br><span class="line">        <span class="keyword">if</span>(zeroCount!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[][] copyResult=<span class="keyword">new</span> <span class="title class_">int</span>[result.length][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.length-zeroCount;i++)&#123;</span><br><span class="line">                copyResult[zeroCount+i]=result[i];</span><br><span class="line">            &#125;</span><br><span class="line">            result=copyResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-10"   >
          <a href="#题解-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题也是要考虑两个维度，一个是身高另一个是排在其前面人数，我们不妨确认一个维度身高，身高相同的根据Kj从小到大排序，因为这样就能保证最大身高顺序不会错，然后从小的身高中不断插入到大的队列中</p>
<blockquote>
<p>局部最优解：当身高顺序保证了的时候，矮的插入到高的并不会对原有顺序造成影响</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>先对排队队列排序</p>
<p>排列规则：</p>
<ul>
<li>身高由高到低排序</li>
<li>身高相同的按照kj由小到大排序</li>
</ul>
</li>
<li><p>定义一个集合，用于存放之后正确顺序的身高队形</p>
</li>
<li><p>遍历数组</p>
<ul>
<li>获取index，也即kj代表的是将要插入的位置</li>
<li>插入到集合中</li>
</ul>
</li>
<li><p>将集合变成二维数组返回</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">    	sortQueue(people);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> index=people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//插入到集合中</span></span><br><span class="line">            list.add(index,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.toArray(people);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortQueue</span><span class="params">(<span class="type">int</span>[][]people)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;people.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldNum=people[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newNum=people[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldNum&lt;newNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                    people[i]=people[j];</span><br><span class="line">                    people[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldNum==newNum)&#123;</span><br><span class="line">                    <span class="type">int</span> oldQ=people[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> newQ=people[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(oldQ&gt;newQ)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                        people[i]=people[j];</span><br><span class="line">                        people[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231006215439956.png"  alt="根据身高重建队列">
      </p>

        <h2 id="452-用最少数量的箭引爆气球"   >
          <a href="#452-用最少数量的箭引爆气球" class="heading-link"><i class="fas fa-link"></i></a><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452.用最少数量的箭引爆气球"></a>452.用最少数量的箭引爆气球</h2>
      <p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/" >Leetcode.452题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;07</p>

        <h4 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        sortShots(points);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] point=points[i];</span><br><span class="line">            <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(shotStart&lt;=END||shotEnd&lt;=END) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(shotEnd&gt;END)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                END=shotEnd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldStart=points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newStart=points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(newStart&lt;oldStart)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                    points[i]=points[j];</span><br><span class="line">                    points[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldStart==newStart)&#123;</span><br><span class="line">                    <span class="type">int</span> oldEnd=points[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> newEnd=points[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newEnd&lt;oldEnd)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                        points[i]=points[j];</span><br><span class="line">                        points[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-23"   >
          <a href="#提交失败-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-23" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:Points[[-2147483648,2147483647]]</p>
<p>输出：0</p>
<p>预期输出：1</p>

        <h4 id="第二次代码-10"   >
          <a href="#第二次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-10" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       sortShots(points);</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">           <span class="type">int</span>[] point=points[i];</span><br><span class="line">           <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">           <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(shotStart&lt;= END || shotEnd&lt;=END) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(shotEnd&gt;END)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               END=shotEnd;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">               <span class="type">int</span> oldStart=points[i][<span class="number">0</span>];</span><br><span class="line">               <span class="type">int</span> newStart=points[j][<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">if</span>(newStart&lt;oldStart)&#123;</span><br><span class="line">                   <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                   points[i]=points[j];</span><br><span class="line">                   points[j]=temp;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldStart==newStart)&#123;</span><br><span class="line">                   <span class="type">int</span> oldEnd=points[i][<span class="number">1</span>];</span><br><span class="line">                   <span class="type">int</span> newEnd=points[j][<span class="number">1</span>];</span><br><span class="line">                   <span class="keyword">if</span>(newEnd&lt;oldEnd)&#123;</span><br><span class="line">                       <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                       points[i]=points[j];</span><br><span class="line">                       points[j]=temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-24"   >
          <a href="#提交失败-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-24" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第三次代码-6"   >
          <a href="#第三次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-6" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        sortShots(points);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] point=points[i];</span><br><span class="line">            <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(shotStart&lt;=END &amp;&amp; shotEnd&gt;=END) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(END==Integer.MIN_VALUE)&#123;</span><br><span class="line">                    END=shotEnd;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    END=shotStart;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldGap=points[i][<span class="number">1</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newGap=points[j][<span class="number">1</span>]-points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldGap&gt;newGap)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                    points[i]=points[j];</span><br><span class="line">                    points[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-25"   >
          <a href="#提交失败-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-25" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次提交"   >
          <a href="#第四次提交" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次提交" class="headerlink" title="第四次提交"></a>第四次提交</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        sortShots(points);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; hasShot=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] point=points[i];</span><br><span class="line">            <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(hasShot.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x:hasShot)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(shotStart&lt;=x &amp;&amp; shotEnd&gt;=x )&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">                hasShot.add((shotEnd-shotStart)/<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                hasShot.add((shotEnd-shotStart)/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldNum=points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newNum=points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldNum&gt;newNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                    points[i]=points[j];</span><br><span class="line">                    points[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldNum==newNum)&#123;</span><br><span class="line">                    <span class="type">int</span> oldGap=points[i][<span class="number">1</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> newGap=points[j][<span class="number">1</span>]-points[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span>(oldGap&gt;newGap)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                        points[i]=points[j];</span><br><span class="line">                        points[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-26"   >
          <a href="#提交失败-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-26" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h3 id="题解-11"   >
          <a href="#题解-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们先对气球进行排序，我们就从左边界由小到大排序，进而我们比较的时候只需要将<strong>前一个气球的右边界和当前气球的左边界比较</strong>即可，当不重叠的时候射出一支箭，当重叠的时候则更新最小右边界，保证一支箭能射爆全部重叠气球</p>
<blockquote>
<p>局部最优解：尽量将气球重叠在一起射，这样可以获取最小射箭数</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>排序，对气球数组的左边界从小到大排序</p>
</li>
<li><p>定义变量count用于记录射出的剪数</p>
</li>
<li><p>遍历气球数组</p>
<ul>
<li><p>如果i&#x3D;&#x3D;0，说明是第一个气球，那么必然需要射出一支箭</p>
</li>
<li><p>如果i!&#x3D;0，那么比较当前气球是否和上一个气球重合</p>
<ul>
<li><p>如果当前气球的左边界大于上一个气球的右边界，说明不重合</p>
<p>需要射出一箭</p>
</li>
<li><p>如果当前气球的左边界小于上一个气球的右边界，说明重合</p>
<p>更新当前气球的右边界，使其成为重叠气球中的<strong>最小右边界</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回count</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//用内置函数进行排序</span></span><br><span class="line">        Arrays.sort(points,(a,b)-&gt; Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果左边界大于前一个右边界说明不重叠</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;points[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//更新右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>]=Math.min(points[i-<span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-1"   >
          <a href="#图解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3>
      <p><strong>题意分析</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007045358730.png"  alt="题意分析">
      </p>
<p>我们再举出一个例子如【1,2】，【1,10】，【3,6】，【5,9】，【10,12】</p>
<p>进而来分析需要几支箭</p>
<p><strong>用例排序之后</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007045920353.png"  alt="用例排序之后">
      </p>
<p><strong>求得箭数量过程</strong></p>
<p>因此我们在比较当前气球和上一个气球是否重叠的时候，比较<strong>当前气球的左边界是否大于前一个气球右边界</strong></p>
<p>如果气球左边界大于前一个气球右边界，说明不重叠直接count++</p>
<p>如果气球左边界小于前一个气球右边界，<strong>更新重叠气球最小右边界</strong>，保证一支箭能射爆全部重叠气球</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007050516435.png"  alt="求得箭数量过程">
      </p>

        <h3 id="踩坑点"   >
          <a href="#踩坑点" class="heading-link"><i class="fas fa-link"></i></a><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h3>
      <p>1.在对气球数组的左边界进行排序的时候，如果自己写一个<strong>冒泡排序</strong>，那么就会导致<strong>时间超时！</strong>，所以需要用内置的函数，或者选择其它排序算法排序！</p>
<p>2.如果用内置的函数<code>Arrays.sort()</code>，那么直接用<code>Arrays.sort(points,(a,b)-&gt; a[0]-b[0])</code>在进行Integer边界的数据进行排序，会导致数据溢出而排序出错，所以我们要用内置的排序方式<code>Arrays.sort(points,(a,b)-&gt;Integer.compare(a[0],b[0]))</code></p>

        <h2 id="435-无重叠区间"   >
          <a href="#435-无重叠区间" class="heading-link"><i class="fas fa-link"></i></a><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h2>
      <p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/" >Leetcode.435题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;08</p>

        <h4 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        sortErea(intervals);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortErea</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> val=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newVal=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(val&gt;newVal)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-27"   >
          <a href="#提交失败-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-27" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:intervals &#x3D;[[1,100],[11,22],[1,11],[2,12]]，输出3，预期输出2</p>

        <h4 id="第二次代码-11"   >
          <a href="#第二次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-11" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        sortErea(intervals);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortErea</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> val=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newVal=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(val&gt;newVal)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val==newVal)&#123;</span><br><span class="line">                    <span class="type">int</span> oldEnd=arr[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> newEnd=arr[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(oldEnd&gt;newEnd)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                        arr[i]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-28"   >
          <a href="#提交失败-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-28" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:intervals&#x3D;[[-52,31],[-73,-26],[82,97],[-65,-11],[-62,-49],[95,99],[58,95],[-31,49],[66,98],[-63,2],[30,47],[-40,-26]]，输出8，预期输出7</p>
<p>没做出来</p>

        <h3 id="题解-12"   >
          <a href="#题解-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和上一道用射爆气球的题目相似，都是求取相同重叠区间，所以这道题本质上和那个题一样，求取消除重叠区间个数，也即<strong>求取重叠区间个数</strong></p>
<blockquote>
<p>局部最优解：通过左区间排序，这样尽量让区间都重叠在一起，这样就能判断出重叠区间的个数也即消除重叠区间个数</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>对区间排序，通过左区间排序</p>
</li>
<li><p>统计重叠区间个数count</p>
</li>
<li><p>遍历从1开始，和前一个区间比较。当前区间的左区间小于前一个区间的右区间，说明重叠，个数++，并且更新重叠区间的右区间(使其成为<strong>最小右区间</strong>)</p>
</li>
<li><p>返回count</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">       Arrays.sort(intervals,(a,b)-&gt;&#123; <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//更新重叠区间的最小右区间</span></span><br><span class="line">                intervals[i][<span class="number">1</span>]=Math.min(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="763-划分字母区间"   >
          <a href="#763-划分字母区间" class="heading-link"><i class="fas fa-link"></i></a><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2>
      <p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/" >Leetcode.763(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;09</p>

        <h4 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> usedCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                used[c-<span class="string">&#x27;a&#x27;</span>]=usedCount;</span><br><span class="line">                usedCount++;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                usedCount=used[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used.length;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[j]&gt;usedCount)&#123;</span><br><span class="line">                        used[j]=usedCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> size=list.size()-usedCount+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                usedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> prex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">            result.add(i-prex);</span><br><span class="line">            prex=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-29"   >
          <a href="#提交失败-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-29" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:s&#x3D;”ababcbacadefegdehijhklij”，输出[8,7,8],预期输出[9,7,8]</p>

        <h4 id="第二次代码-12"   >
          <a href="#第二次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-12" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> usedCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                used[c-<span class="string">&#x27;a&#x27;</span>]=usedCount;</span><br><span class="line">                usedCount++;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                usedCount=used[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used.length;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[j]&gt;usedCount)&#123;</span><br><span class="line">                        used[j]=usedCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> size=list.size()-usedCount+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                usedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> prex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prex==<span class="number">0</span>)</span><br><span class="line">            result.add(i-prex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            result.add(i-prex);</span><br><span class="line">            prex=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-30"   >
          <a href="#提交失败-30" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-30" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:s&#x3D;”caedbdedda”</p>
<p>输出[1,10]</p>
<p>预期输出[1,9]</p>

        <h4 id="第三次代码-7"   >
          <a href="#第三次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-7" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//used数组用于表示当前字母属于第几个字符串</span></span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">    	<span class="comment">//list用于表示每个字符串的结束索引</span></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//用于统计字符串个数</span></span><br><span class="line">        <span class="type">int</span> usedCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=arr[i];</span><br><span class="line">            <span class="comment">//如果前面字符串没有包含这个字符，尝试成为新的字符串</span></span><br><span class="line">            <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//更新字符所在字符串个数</span></span><br><span class="line">                used[c-<span class="string">&#x27;a&#x27;</span>]=usedCount;</span><br><span class="line">                <span class="comment">//字符串个数++</span></span><br><span class="line">                usedCount++;</span><br><span class="line">                <span class="comment">//记录结束索引</span></span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//说明这个字符在前面字符串包括了，那么就要将这个字符串的所有出现字母包括在前一个字符串中</span></span><br><span class="line">                usedCount=used[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used.length;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[j]&gt;usedCount)&#123;</span><br><span class="line">                        used[j]=usedCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> size=list.size()-usedCount+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录前一个字符串的结束索引</span></span><br><span class="line">                list.add(i);</span><br><span class="line">                usedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//用于记录结果，从list中获取每一个字符串的结束位置，转换成字符串长度保存在result中</span></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] resultArr=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;resultArr.length;i++)&#123;</span><br><span class="line">            resultArr[i]=list.get(i)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;resultArr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                result.add(resultArr[i]-<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(resultArr[i]-resultArr[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-7"   >
          <a href="#提交成功-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-7" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-13"   >
          <a href="#题解-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以用给一个哈希表来统计每个字母的<strong>最远出现位置</strong>，那么<strong>每个字符串维持每个字符的最远出现位置都小于等于该字符串的结束位置</strong>，这样我们可以划分出多个字符串</p>
<blockquote>
<p>局部最优解：我们取得的每个字符串的结束位置一定要大于等于每个字母的最远出现位置</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>定义一个哈希表used，用于记录每个字母的最远结束位置</p>
</li>
<li><p>遍历第一遍字符数组，记录每一个字母的最远出现位置：<code>used[sArr[i]-&#39;a&#39;]=i</code></p>
</li>
<li><p>定义两个变量left和right，left用于表示字符串的起始位置，right用于表示字符串的结束位置</p>
</li>
<li><p>定义结果集result，用于记录每个字符串的长度</p>
</li>
<li><p>遍历第二遍字符数组</p>
<ul>
<li>维持<strong>字符串的结束位置一定大于等于每个字母的最远出现位置</strong>：<code>right=Math.max(right,used[sArr[i]-&#39;a&#39;])</code>，记录right要在right和当前字母最远出现位置的最大值</li>
<li>如果i&#x3D;&#x3D;right，说明遍历到字符的结束位置，那么就该收获字符串<ul>
<li>获取每个字符串的长度，收获到结果集中：<code>result.add(right-left+1)</code></li>
<li>更新下一个字符串的起始位置：left&#x3D;i+1</li>
</ul>
</li>
</ul>
</li>
<li><p>返回结果集result</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] sArr=s.toCharArray();</span><br><span class="line">        <span class="comment">//记录每个字母出现的最远下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sArr.length;i++)&#123;</span><br><span class="line">            used[sArr[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//定义结果集    </span></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//字符串起始位置left和结束位置right</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sArr.length;i++)&#123;</span><br><span class="line">            <span class="comment">//保证在字符串中每个字母的最远出现位置right</span></span><br><span class="line">            right=Math.max(right,used[sArr[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(right==i)&#123;</span><br><span class="line">                <span class="comment">//如果搜索到最远位置，那么就说明这个字符串的所有字母不会出现再其他位置</span></span><br><span class="line">                <span class="comment">//记录字符串长度，更新下一个字符串的起始位置</span></span><br><span class="line">                result.add(right-left+<span class="number">1</span>);</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="56-合并区间"   >
          <a href="#56-合并区间" class="heading-link"><i class="fas fa-link"></i></a><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2>
      <p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/" >Leetcode.56题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;11</p>

        <h4 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        sortMerge(intervals);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[] &gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>]=Math.min(intervals[i-<span class="number">1</span>][<span class="number">0</span>],intervals[i][<span class="number">0</span>]);</span><br><span class="line">                intervals[i][<span class="number">1</span>]=Math.max(intervals[i-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==intervals.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortMerge</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldStart=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newStart=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldStart&gt;newStart)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-8"   >
          <a href="#提交成功-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-8" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-14"   >
          <a href="#题解-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和452射爆气球以及435无重叠区间都是同一个解法，当遇到重叠区间的时候这里将重叠区间进行<strong>合并</strong></p>
<blockquote>
<p>局部最优解：按照左边界从小打大排序使其重叠区间放在一起，那么当遇到不重叠区间的时候添加到新的结果集即可</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>对原数组进行排序，按照左区间从小打大排序</li>
<li>定义一个结果集合Result，用于接收单个区间(局部最大的重叠区间)</li>
<li>遍历数组，判断区间是否重叠，由<strong>下一个区间判断和前一个区间的状态</strong><ul>
<li>当前区间的左区间小于等于上个区间的右边界：<strong>重叠</strong>，更新重叠区间的左边界和最大右边界</li>
<li>当前区间的左边界大于上个区间的右边界：<strong>不重叠</strong>，将上个重叠区间添加到结果集result中</li>
<li>如果当前区间是最后一个区间，那么添加到结果集中:<code>if(i==intervals.length-1) result.add(intervals[i])</code></li>
</ul>
</li>
<li>将结果集result转为二维数组输出:<code>return result.toArray(new int[result.size()][2]);</code></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        sortMerge(intervals);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[] &gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//当前区间和上一个区间重叠</span></span><br><span class="line">                intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//更新左边界(重叠区间的最左边界)</span></span><br><span class="line">                intervals[i][<span class="number">1</span>]=Math.max(intervals[i-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);<span class="comment">//更新右边界(重叠区间的最右边界)</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当前区间不是上一个区间的重叠部分，将上一个区间添加到结果集中</span></span><br><span class="line">                result.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是最后一个区间那么就添加到结果集中</span></span><br><span class="line">            <span class="keyword">if</span>(i==intervals.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//左区间从小打大排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortMerge</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldStart=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newStart=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldStart&gt;newStart)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="738-单调递增的数字"   >
          <a href="#738-单调递增的数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h2>
      <p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/description/" >Leetcode.738题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-15"   >
          <a href="#第一次做-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-15" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;12</p>

        <h4 id="第一次代码-15"   >
          <a href="#第一次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-15" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> result=n;</span><br><span class="line">       <span class="keyword">while</span>(!isValid(result))&#123;</span><br><span class="line">           result--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> result)</span>&#123;</span><br><span class="line">       <span class="type">int</span> old=result%<span class="number">10</span>;</span><br><span class="line">       result/=<span class="number">10</span>;</span><br><span class="line">       <span class="keyword">while</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">int</span> newValue=result%<span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span>(newValue&gt;old) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           result/=<span class="number">10</span>;</span><br><span class="line">           old=newValue;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-31"   >
          <a href="#提交失败-31" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-31" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>BF法超出时间限制</p>
<p>CASE:输入n&#x3D;853567367</p>

        <h4 id="第二次代码-13"   >
          <a href="#第二次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-13" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        int result=n;</span><br><span class="line">        if(Valid(result))&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int temp=n;</span><br><span class="line">        int old=n%10;</span><br><span class="line">        int count=0;</span><br><span class="line">        while(temp&gt;0)&#123;</span><br><span class="line">            old=temp%10;</span><br><span class="line">            temp/=10;</span><br><span class="line">            count++;</span><br><span class="line">            if(temp==0) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result=0;</span><br><span class="line">        for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            result+=old;</span><br><span class="line">            result*=10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(Valid(result) &amp;&amp;result&lt;=n) return result;</span><br><span class="line"></span><br><span class="line">        result=old-1;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;count;i++)&#123;</span><br><span class="line">            result*=10;</span><br><span class="line">            result+=9;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Valid(int n)&#123;</span><br><span class="line">        int old=n%10;</span><br><span class="line">        n/=10;</span><br><span class="line">        while(n&gt;0)&#123;</span><br><span class="line">            int newValue=n%10;</span><br><span class="line">            if(newValue&gt;old) return false;</span><br><span class="line">            n/=10;</span><br><span class="line">            old=newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交失败-32"   >
          <a href="#提交失败-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-32" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：n&#x3D;120，输出99，预期输出119</p>

        <h4 id="第三次代码-8"   >
          <a href="#第三次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-8" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=n;</span><br><span class="line">        <span class="keyword">if</span>(Valid(result))&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp=n;</span><br><span class="line">        <span class="type">int</span> old=n%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            old=temp%<span class="number">10</span>;</span><br><span class="line">            temp/=<span class="number">10</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result=old;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            result*=<span class="number">10</span>;</span><br><span class="line">            result+=<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Valid(result) || result&gt;n)&#123;</span><br><span class="line">            result--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Valid(result)) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        result=old-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            result*=<span class="number">10</span>;</span><br><span class="line">            result+=<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Valid</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> old=n%<span class="number">10</span>;</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> newValue=n%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;old) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">            old=newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-33"   >
          <a href="#提交失败-33" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-33" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超出时间限制</p>
<p>输入n&#x3D;963856657</p>

        <h4 id="第四次代码-4"   >
          <a href="#第四次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-4" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>+n;</span><br><span class="line">        <span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line">        <span class="type">int</span> diffValue=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> equalsValue=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                diffValue=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                equalsValue=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span>==equalsValue)&#123;</span><br><span class="line">                    arr[diffValue]--;</span><br><span class="line">                    <span class="keyword">while</span>(equalsValue&lt;=arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(equalsValue==<span class="number">0</span>)&#123;</span><br><span class="line">                            equalsValue++;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        arr[equalsValue++]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    arr[i-<span class="number">1</span>]--;</span><br><span class="line">                    arr[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i]&gt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        diffValue=i;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        equalsValue=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                arr[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result=Integer.parseInt(sb.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-34"   >
          <a href="#提交失败-34" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-34" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入n&#x3D;89888</p>
<p>输出88889</p>
<p>预期输出88999</p>
<p>没做出来</p>

        <h3 id="题解-15"   >
          <a href="#题解-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题因为从<strong>后往前</strong>遍历，这样才能更新数据也不会导致前往后遍历多次频繁更新数据，以至于搞混大小关系</p>
<blockquote>
<p>局部最优解：当出现i位置数字小于i-1位置数字时，i-1位置数字减减，i位置数字更新成9</p>
<p>例如  72,i-1为7,i为2，那么要更新成 i-1为6,i为9 也即72&#x3D;&gt;69</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>先将数字转成字符数组方便对每一位操作</p>
</li>
<li><p>定义一个flag，标记需要转换成9的起始下标，初始化为Integer.MAX_VALUE，如果flag没变动说明最初的n就符合单调递增数字要求</p>
<ul>
<li>例如1000，那么flag为1，也即1之后需要转成9也即1000&#x3D;&gt;0999</li>
</ul>
</li>
<li><p>从后往前遍历字符数组</p>
<ul>
<li>当位置i数字小于位置i-1数字时候，将i-1位置数字减减，更新flag标记为i：<code>arr[i-1]--;flag=i;</code></li>
</ul>
</li>
<li><p>当遍历完数组，则开始更新flag下标之后的数字变成9：<code>for(int i=flag;i&lt;arr.length;i++) arr[i]=&#39;9&#39;</code></p>
</li>
<li><p>将字符数组转换回数字返回：<code>Integer.parseInt(String.valueOf(arr))</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String s=<span class="string">&quot;&quot;</span>+n;</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">		<span class="comment">//定义一个标记flag，初始化为一个最大值，表示需要更新成9的下标索引</span></span><br><span class="line">        <span class="type">int</span> flag=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                arr[i-<span class="number">1</span>]--;</span><br><span class="line">                <span class="comment">//将flag记录</span></span><br><span class="line">                flag=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//将需要更新的下标flag之后的数字都更新成9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=flag;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     	<span class="comment">//将char[]数组转成String然后转成Integer返回   </span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="968-监控二叉树"   >
          <a href="#968-监控二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h2>
      <p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/description/" >Leetcode.968题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-16"   >
          <a href="#第一次做-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-16" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;12</p>

        <h4 id="第一次代码-16"   >
          <a href="#第一次代码-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-16" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="type">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        searchTree(root);</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftResult=searchTree(root.left);</span><br><span class="line">        <span class="type">int</span> rightResult=searchTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是子结点是叶子节点，那么本结点加入监控</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">0</span> || rightResult==<span class="number">0</span>)&#123;</span><br><span class="line">            root.val=<span class="number">1</span>;</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-35"   >
          <a href="#提交失败-35" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-35" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次代码-14"   >
          <a href="#第二次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-14" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//需要监控器数量</span></span><br><span class="line">	<span class="type">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=searchTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根节点没被监控，那么就将根节点监控</span></span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>) need++;</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftResult=searchTree(root.left);</span><br><span class="line">        <span class="type">int</span> rightResult=searchTree(root.right);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是叶子结点，那么添加本结点作为监控</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">0</span> || rightResult==<span class="number">0</span>)&#123;</span><br><span class="line">            root.val=<span class="number">2</span>;</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是监控结点，并且当前结点不是监控结点，那么就更新成为被监控的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">2</span> || rightResult==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;<span class="number">2</span>) root.val=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-9"   >
          <a href="#提交成功-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-9" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-16"   >
          <a href="#题解-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们遍历二叉树的时候需要<strong>后序遍历</strong>，从叶子节点开始增加摄像头，尽量要隔两个结点放一个摄像头</p>
<blockquote>
<p>局部最优解：从叶子结点开始，让叶子结点的父节点持有摄像头，然后尽量每隔两个结点放置一个摄像头</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量need：需要的监控器数量</p>
</li>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>参数root：当前处理的根节点</li>
<li>返回值<ul>
<li>-1：说明是空节点，遍历到空节点向上返回即可目的是结束递归</li>
<li>0：说明是没有被监控的结点</li>
<li>1：说明是监控器结点的父节点(被监控)</li>
<li>2：说明是监控器结点</li>
</ul>
</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当root&#x3D;&#x3D;null，也即空结点时候返回-1</p>
</li>
<li><p>单层递归的逻辑</p>
<ul>
<li>向左搜索结果，记录返回值为leftResult</li>
<li>向右搜索结果，记录返回值为rightResult</li>
<li>左右子结点有一个结点是0，那么该节点就应该添加监控器，状态修改为2：<code>if(leftResult==0 || rightResult==0)&#123;root.val=2;need++;&#125;</code></li>
<li>左右子结点有一个结点是监视器，并且当前结点不是监视器那么就更新结点状态为1：<code>if(leftResult==2||rightResult==2)&#123;if(root.val&lt;2) root.val=1;&#125;</code></li>
<li>返回结点的状态值，如果没被监控那么应该返回的值是0</li>
</ul>
</li>
<li><p>递归函数结束，判断根节点返回值是多少，如果根节点为0也即未被监控，那么根节点应该添加一个监控器：</p>
<p><code>if(result==0) need++;</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//需要监控器数量</span></span><br><span class="line">	<span class="type">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=searchTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根节点没被监控，那么就将根节点监控</span></span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>) need++;</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftResult=searchTree(root.left);  <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> rightResult=searchTree(root.right);<span class="comment">//右</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是叶子结点，那么添加本结点作为监控</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">0</span> || rightResult==<span class="number">0</span>)&#123;</span><br><span class="line">            root.val=<span class="number">2</span>;</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是监控结点，并且当前结点不是监控结点，那么就更新成为被监控的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">2</span> || rightResult==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;<span class="number">2</span>) root.val=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>贪心算法也就是类似<strong>常识性</strong>的解题，从思考方向要从<strong>局部最优解</strong>出发，然后在局<strong>部最优解推出全局最优解的时候没有反例</strong>，那么就假设认为<strong>局部最优解往全局推出的全局解就是全局最优解</strong>，下一章节进入<strong>动态规划</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/13/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%E3%80%81ReentrantLock%E3%80%81ReentrantReadWriteLock%5D/">深入剖析并发编程-JUC篇[5-AQS、ReentrantLock、ReentrantReadWriteLock]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">22.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">158分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>AQS、ReentrantLock、ReentrantReadWriteLock、JUC并发工具包</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
<li>第四篇是Atomic原子包源码详解</li>
<li>第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC并发工具包</li>
<li>第六篇是并发容器</li>
<li>第七篇是进程、线程、线程池</li>
</ul>
<hr>
<p><strong>本篇前言</strong></p>
<p>在并发编程中，我们学习到了JUC的并发编程基础，了解了变量在计算机中的存储方式以及内存一致性协议，然后引入了JMM内存模型，并且了解了Volatile关键字怎么将变量可见性，然后为了不加锁我们引入了CAS乐观锁机制，通过Unsafe实现CAS机制，同时有了Atomic原子操作包，而后面乐观锁之后还有Synchronized悲观锁，但是Synchronized悲观锁又是隐式锁，再加锁和释放锁都不需要我们自己手动操作。于是接下来的就是悲观锁中的显式锁Lock，需要我们自己手动加锁和释放锁流程。</p>
<p>但是在提显式锁之前我们先得提一个AQS机制，一个锁再竞争失败之后需要一个容器来接受等待锁的线程，而这个就是AQS</p>

        <h1 id="AQS"   >
          <a href="#AQS" class="heading-link"><i class="fas fa-link"></i></a><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1>
      <p>AQS：AbstractQueuedSynchronizer也即抽象队列同步器，它是Java并发包的核心组件</p>
<p>我们直接从源码开始看起</p>

        <h2 id="成员变量以及内部类"   >
          <a href="#成员变量以及内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步队列的头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步队列的尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">//Unsafe类以及对应偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>又因为AbstractQueuedSynchronizer继承了<strong>AbstractOwnableSynchronizer</strong>所以还有一个成员变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//持锁线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></div></figure>

<p>也即AQS成员变量有<strong>队列头指针、队列尾指针、锁的状态字以及持锁线程</strong></p>
<p>而内部类有<strong>Node</strong>以及<strong>ConditionObject</strong></p>

        <h3 id="Node"   >
          <a href="#Node" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node" class="headerlink" title="Node"></a>Node</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//共享模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="comment">//独占模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是四个信号量 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;	<span class="comment">//表示线程已经结束</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;	<span class="comment">//表示等待被唤醒</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;	<span class="comment">//表示在条件队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;	<span class="comment">//表示共享模式下同步行为会被传播</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前结点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾结点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">Node nextWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空参构造用于创建队列的头或者共享标记</span></span><br><span class="line">Node() &#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于添加Node</span></span><br><span class="line">Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">      <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">      <span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于Condition创建Node</span></span><br><span class="line">Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>也即Node的成员变量有<strong>锁的模式、锁的状态字、锁的信号量、前一结点指针、下一结点指针、线程、nextWaiter</strong></p>
<p>而Node中的方法我们会具体碰到的时候再进行展开</p>

        <h3 id="ConditionObject"   >
          <a href="#ConditionObject" class="heading-link"><i class="fas fa-link"></i></a><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头结点指针 firstWaiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾结点指针	lastWaiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是两个中断标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>因此目前已知情报可公开的数据可能如图所示(<strong>假设</strong>)，我们带着这个假设的模型去进行学习也许可能会更简单一些</p>
<p><em>猜想模型有误，只是提供一个最初印象的模型图，仅供参考</em></p>
<p><strong>同步队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230928181044445.png"  alt="同步队列猜测模型">
      </p>
<p><strong>条件队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230928181742497.png"  alt="条件队列猜测模型">
      </p>
<p>又因为Reentrantlock中的加锁调用了acquire方法，而这个方法在AQS中声明，所以我们要了解加锁过程必然要从acquire方法入手</p>

        <h2 id="同步队列"   >
          <a href="#同步队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2>
      
        <h3 id="acquire"   >
          <a href="#acquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>我们按照总分总的顺序拆分一点点理解代码</p>
<p>1.先调用tryAcquire方法，返回结果为true的时候，直接判断为false也即不会进行逻辑与后面的方法</p>
<p>2.当调用tryAcquire方法，返回结果为false的时候，调用acquireQueued方法</p>
<p>也即：先调用tryAcquire，当tryAcquire不成功则进行acquireQueued方法</p>
<p>进入if语句的情况：</p>
<ul>
<li><strong>tryAcquire失败并且acquireQueued成功</strong></li>
</ul>

        <h3 id="tryAcquire"   >
          <a href="#tryAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试以独占模式获取锁，具体操作由对应子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>当tryAcquire失败，也即获取锁失败，那么说明锁被独占了，<strong>也即进入acquireQueued方法说明获取锁失败有线程竞争</strong></p>

        <h3 id="acquireQueued"   >
          <a href="#acquireQueued" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里传参中还调用了一个addWaiter(Node.EXCLUSIVE), arg)</span></span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断标志位为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前结点的前一个结点p</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句中先判断前一个结点p是否是头结点</span></span><br><span class="line"><span class="comment">                	只有是头结点才会去尝试加锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功获取锁，更新AQS同步器头结点，移动同步队列，将failed置为false</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//return 中断标志位</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句判断为false就来到第二个if语句，而第一个if失败的可能有</span></span><br><span class="line"><span class="comment">                		1.前一个结点p不是头结点，所以没有资格获取锁</span></span><br><span class="line"><span class="comment">                		2.前一个结点是p但是没有获取锁成功</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//失败获取锁之后阻塞，阻塞线程并检查中断位，如果中断位为true则更新中断标志位为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           		因为finally方法一定会执行，而acquireQueued方法什么时候会结束</span></span><br><span class="line"><span class="comment">           			1.当获取锁成功，failed==false</span></span><br><span class="line"><span class="comment">           			2.当try中的方法报错，而当try中的方法报错有什么情况</span></span><br><span class="line"><span class="comment">           				2-1.锁的状态state&gt;Integer.MAX_VALUE,也即可重入次数超过上限</span></span><br><span class="line"><span class="comment">           				2-2.当子类的tryAcquire方法报错</span></span><br><span class="line"><span class="comment">            	也即:情况1则说明正常结束，不会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            		情况2则说明报错结束，会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">//怎么都获取不到锁，移除当前线程结点，唤醒之后的线程</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>因为先调用了addWaiter方法所以我们先看向addWaiter方法，看完之后再来具体看acquireQueued方法做了什么事</p>

        <h3 id="addWaiter"   >
          <a href="#addWaiter" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    	<span class="comment">//new一个Node对象，传入参数有当前线程和锁的模式</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">		<span class="comment">//将尾结点指针赋值给pred</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断尾结点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当尾结点不为空，说明有同步队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将new出来的对象的前驱结点指向pred</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//CAS更新尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//如果更新尾结点成功，将pred指向node结点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//也即更新AQS尾指针，并且更新同步队列</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	运行到这里有两个情况：</span></span><br><span class="line"><span class="comment">    		1.同步队列为空，调用enq方法</span></span><br><span class="line"><span class="comment">    		2.CAS更新尾结点失败，说明线程竞争入同步队列失败</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>那么我们接下来要看向enq方法，看看具体怎么入队</p>

        <h3 id="enq"   >
          <a href="#enq" class="heading-link"><i class="fas fa-link"></i></a><a href="#enq" class="headerlink" title="enq"></a>enq</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//死循环不断尝试入队</span></span><br><span class="line">    	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取尾指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="comment">//当尾指针为空说明队列为空，则需要对同步队列初始化</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//同步队列初始化，初始化成功之后tail！=null</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//说明同步队列存在，将node入队</span></span><br><span class="line">                <span class="comment">//原先尾结点设置为当前结点的前驱结点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//CAS设置尾指针，设置尾指针成功再更新队列</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="comment">//返回t，尾结点的前一个结点(也即原先的尾结点)</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法做了两件事</p>
<ul>
<li>1.当队列为空的时候，初始化队列，并且队列的头结点为新的node结点(空参构造)</li>
<li>2.当队列不为空的时候，将node结点入队，更新AQS同步器也更新同步队列</li>
</ul>
<p>返回了<strong>当前结点的前一个结点</strong></p>

        <h4 id="enq方法流程图"   >
          <a href="#enq方法流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#enq方法流程图" class="headerlink" title="enq方法流程图"></a>enq方法流程图</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230929131807036.png"  alt="enq方法流程图">
      </p>
<p><strong>enq方法当同步队列为空时</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230929132619749.png"  alt="同步队列初始化">
      </p>
<p><strong>enq方法当同步队列不为空时</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930202252236.png"  alt="当同步队列不为空">
      </p>
<p>也即同步队列如果存在，那么<strong>同步队列的第一个结点是空参构造的结点</strong>，可以把它看成当前持锁线程</p>
<p>enq方法将队列初始化或者将新结点添加到队尾，于是我们反过头来看<strong>acquireQueued</strong>方法做了什么事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断标志位为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前结点的前一个结点p</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句中先判断前一个结点p是否是头结点</span></span><br><span class="line"><span class="comment">                	只有是头结点才会去尝试加锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功获取锁，更新AQS同步器头结点，移动同步队列，将failed置为false</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//return 中断标志位</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句判断为false就来到第二个if语句，而第一个if失败的可能有</span></span><br><span class="line"><span class="comment">                		1.前一个结点p不是头结点，所以没有资格获取锁</span></span><br><span class="line"><span class="comment">                		2.前一个结点是p但是没有获取锁成功</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//失败获取锁之后阻塞，阻塞线程并检查中断位，如果中断位为true则更新中断标志位为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           		因为finally方法一定会执行，而acquireQueued方法什么时候会结束</span></span><br><span class="line"><span class="comment">           			1.当获取锁成功，failed==false</span></span><br><span class="line"><span class="comment">           			2.当try中的方法报错，而当try中的方法报错有什么情况</span></span><br><span class="line"><span class="comment">           				2-1.锁的状态state&gt;Integer.MAX_VALUE,也即可重入次数超过上限</span></span><br><span class="line"><span class="comment">           				2-2.当子类的tryAcquire方法报错</span></span><br><span class="line"><span class="comment">            	也即:情况1则说明正常结束，不会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            		情况2则说明报错结束，会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">//怎么都获取不到锁，移除当前线程结点，唤醒之后的线程</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node中的方法，目的是获取当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="comment">//获取当前结点的前一个结点</span></span><br><span class="line">    		<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>当请求结点是头结点的下一个结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930202739393.png"  alt="更新结点前">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930202812518.png"  alt="更新结点后">
      </p>
<p><strong>当请求结点前一个结点不是头结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930203116496.png"  alt="请求结点前一个结点不是头结点">
      </p>

        <h3 id="shouldParkAfterFailedAcquire"   >
          <a href="#shouldParkAfterFailedAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//获取pred中的锁的状态字</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">//当ws==Node.SIGNAL也即ws==-1，意思是当前结点已经阻塞</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当ws&gt;0 也即ws==Node.CANCELLED==1，也即这个结点无效需要退出同步队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将pred移除同步队列</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	将pred指向前一个结点，将node的前一个结点指向pred</span></span><br><span class="line"><span class="comment">            	也即删除同步队列的pred结点</span></span><br><span class="line"><span class="comment">            	直到pred.waitStatus&lt;=0 说明结点有效</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到有效结点，链接双向链表更新pred结点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当ws==0 || ws==-2 || ws==-3</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//说明pred结点是需要更新成SINGAL状态，也即将状态字置为-1表示阻塞</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>shouldParkAfterFailedAcquire方法就是更新waitStatus状态字</p>
<blockquote>
<p>ws&#x3D;pred.waitStatus</p>
<p>static final int CANCELLED &#x3D;  1;	&#x2F;&#x2F;表示线程已经结束</p>
<p>static final int SIGNAL    &#x3D; -1;	&#x2F;&#x2F;表示等待被唤醒</p>
<p>static final int CONDITION &#x3D; -2;	&#x2F;&#x2F;表示在条件队列中 </p>
<p>static final int PROPAGATE &#x3D; -3;	&#x2F;&#x2F;在共享状态表示同步状态会被传播</p>
</blockquote>
<ul>
<li><p>ws &#x3D;&#x3D; -1(ws &#x3D;&#x3D; Node.SIGNAL)</p>
<p>意思是当前已经在阻塞队列中，所以不用操作直接返回true</p>
</li>
<li><p>ws &gt; 0 (ws &#x3D;&#x3D; Node.CANCELLED)</p>
<p>意思是这个结点线程已经结束或者无效，所以需要删除这个结点，直到结点指向一个正常的结点</p>
</li>
<li><p>ws &#x3D;&#x3D; 0 || ws &#x3D;&#x3D; -2 ||ws&#x3D;&#x3D;-3</p>
<p>用CAS更新ws状态成-1</p>
<ul>
<li>ws &#x3D;&#x3D; 0 :表示线程在活跃中</li>
<li>ws &#x3D;&#x3D; -2:表示线程在条件队列中</li>
<li>ws &#x3D;&#x3D; -3:表示线程在共享模式下的同步状态会被传播</li>
</ul>
</li>
</ul>
<p>当更新状态字成功，要调用pardAndCheckInterrupt方法</p>

        <h3 id="parkAndCheckInterrupt"   >
          <a href="#parkAndCheckInterrupt" class="heading-link"><i class="fas fa-link"></i></a><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用LockSupport工具类下的park方法阻塞当前线程，然后返回线程的中断标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="cancelAcquire"   >
          <a href="#cancelAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//如果node为空则结束，肯定不在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//将node的线程置为空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取node的前一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将node的前驱结点指向一个有效的结点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//predNext记录移动后的pred指针的下一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//将node的ws设置成1</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		如果node结点是尾结点，则进入if语句中移除尾结点</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line"></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//node在中间结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	进入下方if语句有两种情况</span></span><br><span class="line"><span class="comment">        	1.pred不是头结点并且pred的线程存在以及ws==SIGNAL</span></span><br><span class="line"><span class="comment">        	2.pred不是头结点并且pred的线程存在以及ws被设置成SIGNAL</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">           ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将next指向下一个结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//next是有效结点，则设置pred的后继结点是next</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	运行到这里有几种可能性</span></span><br><span class="line"><span class="comment">            	1.pred是头结点，也即前驱结点是头结点</span></span><br><span class="line"><span class="comment">            	2.pred的线程不存在</span></span><br><span class="line"><span class="comment">            	3.pred的状态不是SIGNAL</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//唤醒线程</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继结点指向自己</span></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>Node结点在队尾，移除队尾元素</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930180647588.png"  alt="Node结点在队尾">
      </p>
<p><strong>Node结点在队中，移除Node结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930180804316.png"  alt="Node结点在队中">
      </p>

        <h3 id="unparkSuccessor"   >
          <a href="#unparkSuccessor" class="heading-link"><i class="fas fa-link"></i></a><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Node结点的waitStatus</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node有效将ws置为0，意思为活跃中</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	从同步队列的后面往前找，第一个靠近node的结点s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里也即Acquire方法的全部流程，由此我们也可得出一个结论</p>
<p><strong>AQS是一个非公平同步器，当线程需要加锁的时候会直接进行tryAcquire加锁，只有加锁失败才会进入同步队列中</strong></p>
<p>接下来加完锁就要看解锁，所以我们看向release方法</p>

        <h3 id="release"   >
          <a href="#release" class="heading-link"><i class="fas fa-link"></i></a><a href="#release" class="headerlink" title="release"></a>release</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//尝试解锁成功进入下面语句，尝试唤醒其他线程</span></span><br><span class="line">    	<span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//获取头结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	当头结点不为空，也即存在同步队列</span></span><br><span class="line"><span class="comment">            	并且ws.waitStatus不为0，说明有线程在等待唤醒</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//唤醒h之后的第一个需要被唤醒的线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Node结点的waitStatus</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node有效将ws置为0，意思为活跃中</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	从同步队列的后面往前找，第一个靠近node的结点s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="tryRelease"   >
          <a href="#tryRelease" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由子类去重写</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>释放锁流程</strong></p>
<ul>
<li>尝试tryRelease，如果锁的statu为0，说明解锁成功返回true<ul>
<li>获取AQS同步器的头结点<ul>
<li>同步器头结点如果为null，说明没有同步队列也即没有等待线程直接返回true即可</li>
<li>同步器头结点不为空，并且ws!&#x3D;0,说明有线程在等待，唤醒离头结点最近的第一个需要被唤醒的线程</li>
</ul>
</li>
</ul>
</li>
<li>解锁失败返回false</li>
</ul>
<p>而上面我们有返回中断标志位，这是让我们自己去响应中断返回结果，而有没有能帮我们抛出异常而不用我们来反应中断的呢？</p>
<p>当然是有的，那就是acquireInterruptibly方法</p>

        <h3 id="acquireInterruptibly"   >
          <a href="#acquireInterruptibly" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly"></a>acquireInterruptibly</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">   	<span class="comment">//线程中断标志位为true那么就抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//尝试去加锁，加锁失败之后走doAcquireInterruptibly方法加锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="doAcquireInterruptibly"   >
          <a href="#doAcquireInterruptibly" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireInterruptibly" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前线程的前一个线程，只有前一个线程是头结点才允许加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//检查中断标志位为true则抛出异常，而不用我们自己处理</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这一段方法逻辑和acquireQueued方法逻辑是一致的，只是在响应中断方面，acquireQueued方法会返回中断标志位交给我们自己处理，而这个方法是出现中断之后会抛出异常，而不用我们自己处理中断</p>
<p>而上面都在说独占锁的过程，而我们知道共享锁，所以我们接下来看共享锁的获取流程</p>

        <h3 id="acquireShared"   >
          <a href="#acquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//获取共享锁</span></span><br><span class="line">    	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果加锁失败</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="tryAcquireShared"   >
          <a href="#tryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试加锁，由子类去实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="doAcquireShared"   >
          <a href="#doAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个模式为共享模式的结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱结点是头指针结点，那么就尝试进行加锁，如果加锁成功则将头结点更新，并将头结点移除</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//记录一下可以获取共享锁的资源数，也即拿到锁r将大于0</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//如果加锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">//将p的下一个结点置空</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">//判断中断</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否阻塞和处理响应中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	如果failed为false，说明获取到了锁结束方法</span></span><br><span class="line"><span class="comment">        	如果failed为true，说明获取不到锁，将当前线程移除同步队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="setHeadAndPropagate"   >
          <a href="#setHeadAndPropagate" class="heading-link"><i class="fas fa-link"></i></a><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="comment">//记录老的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//设置新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**以下IF语句有五种情况</span></span><br><span class="line"><span class="comment">    	1.当前结点node获取锁成功，也即propagate＞0</span></span><br><span class="line"><span class="comment">    	2.原来的头结点为空，也即同步队列头结点为空</span></span><br><span class="line"><span class="comment">    	3.原来的头结点不为空但是锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    	4.将当前结点更新成头结点为空</span></span><br><span class="line"><span class="comment">    	5.将当前结点更新成头结点之后锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前结点的下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//判断下一个结点如果是共享模式则进入唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="doReleaseShared"   >
          <a href="#doReleaseShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//死循环一直去唤醒</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//当h不为空并且不为尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果头结点没有变化则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里有一个关键点在于每一次循环都会获取头结点<code>Node h = head</code>,并且最后每次还会判断<code>if( h == head ) break;</code></p>
<p>这是因为当头结点不为空，并且不是尾结点的时候都会将其唤醒，如果CAS更新失败则会continue，只有CAS成功进入唤醒状态或者ws从0更新成-3，那么才会进入h&#x3D;&#x3D;head的判断</p>
<p>而每次成功唤醒之后，应该会进行doAcquireShared方法去尝试获取锁，也即当获取锁成功则head还会被重新设置，只有头结点没有改变才会跳出循环</p>
<p>理想状态下：</p>
<p><strong>当第一个获取共享锁的线程成功，则会不断唤醒排在其身后连在一起的共享模式线程</strong></p>

        <h3 id="doAcquireSharedInterruptibly"   >
          <a href="#doAcquireSharedInterruptibly" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败取消线程任务</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法和doAcquireShared方法的唯一区别就在于响应中断的方式不同，这个则是直接抛出中断异常，而那个方法是返回上层我们程序员自己手动处理中断状态</p>
<p>至此，AQS的同步队列中获取锁的方式已经全部说完，我们下一个就是看条件队列</p>

        <h2 id="条件队列"   >
          <a href="#条件队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2>
      <p>条件队列也是阻塞队列，在线程等待某个资源的释放然后唤醒，也即<strong>当条件不成立的时候线程进入条件队列，当条件成立则将线程从条件队列移除并继续执行</strong></p>
<p>而条件队列也主要依靠两个方法，一个是<strong>await方法</strong>(使线程进入条件队列等待资源)，另一个则是<strong>signal方法</strong>(使线程从阻塞唤醒，从条件队列中移除)</p>
<p>我们一开始也将带着条件队列猜测模型学习</p>
<p><em>猜想模型有误，只是提供一个最初印象的模型图，仅供参考</em></p>
<p><strong>条件队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230928181742497.png"  alt="条件队列猜测模型">
      </p>

        <h3 id="await"   >
          <a href="#await" class="heading-link"><i class="fas fa-link"></i></a><a href="#await" class="headerlink" title="await"></a>await</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果线程中断了则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//添加新的结点入条件队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前线程获取的锁全部释放，记录重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="comment">//中断模式为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	进入while循环的条件：不在同步队列中</span></span><br><span class="line"><span class="comment">    	退出while循环的情景：</span></span><br><span class="line"><span class="comment">    		1.因为中断唤醒线程，所以设置中断模式</span></span><br><span class="line"><span class="comment">    		2.因为signal唤醒线程也即资源满足条件，所以结点一定在同步队列中不符合while循环条件</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//如果结点不在同步队列中(在条件队列中)=&gt;阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线程唤醒如果是因为中断过，那么就设置中断模式并且跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新争抢锁成功，并且不是因为中断唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//那么就设置中断模式为REINTERRUPT，需要本线程自己中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果条件队列中的下一个结点不为空，那么清除条件队列的失效结点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果中断模式不为0，也即发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="addConditionWaiter"   >
          <a href="#addConditionWaiter" class="heading-link"><i class="fas fa-link"></i></a><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取条件队列最后一个Waiter</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后一个Waiter存在但是状态不是条件队列状态(-2)，那么并且重新获取LastWaiter</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前线程的结点，状态为条件队列状态(-2)</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后一个Waiter为空，也即条件队列为空，那么当前结点就是条件队列的头结点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将条件队列的头结点修改成node</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//条件队列不为空，将node加入到条件队列的尾部</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">//将尾指针指向最后一个结点</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="unlinkCancelledWaiters方法"   >
          <a href="#unlinkCancelledWaiters方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlinkCancelledWaiters方法" class="headerlink" title="unlinkCancelledWaiters方法"></a>unlinkCancelledWaiters方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//t为第一个Waiter</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="comment">//跟踪指针trail，用于记录操作的结点前一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//当t不为空也即同步队列不为空</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">//当前结点的状态不为条件队列状态，也即要移除出条件队列</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//将t指向下一个结点设置为空</span></span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//如果trail为空也即taril还没被设置值也即头结点就是不合法，则更新头指针</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//trail不为空，则更新trail的下一个结点为当前结点的下一个结点</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果下一个结点为空，也即到了队列的末尾则更新尾指针</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            trail = t; <span class="comment">//当前结点状态是条件队列状态(-2)则保留 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动指针t向后遍历</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="条件队列新增结点和移除结点图解"   >
          <a href="#条件队列新增结点和移除结点图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件队列新增结点和移除结点图解" class="headerlink" title="条件队列新增结点和移除结点图解"></a>条件队列新增结点和移除结点图解</h5>
      <p><strong>新增结点</strong>，判断尾结点是否是条件队列状态，如果不是则进行<strong>删除不合法结点</strong>，如果是则将当前结点添加到条件队列尾部</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007182801004.png"  alt="条件队列新增结点">
      </p>
<p><strong>移除结点</strong>，从<strong>头结点开始</strong>判断是否满足条件队列要求</p>
<ul>
<li>当头结点不合法</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007183346412.png"  alt="删除结点，头结点不合法">
      </p>
<p>删除头结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007183935160.png"  alt="删除头结点">
      </p>
<ul>
<li><p>当中间结点不合法</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007184327495.png"  alt="当中间结点不合法">
      </p>
</li>
</ul>
<p>移除不合法的中间结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007184610289.png"  alt="移除不合法的中间结点">
      </p>
<ul>
<li><p>当尾结点不合法</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007184847981.png"  alt="尾结点不合法">
      </p>
</li>
</ul>
<p>移除尾结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007185104698.png"  alt="移除尾结点">
      </p>

        <h4 id="fullyRelease"   >
          <a href="#fullyRelease" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//失败解锁标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁的重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">//将failed标志位置为false，意思是全部解锁成功</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//没有全部解锁成功，那么就将此节点置为失效结点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="release-1"   >
          <a href="#release-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#release-1" class="headerlink" title="release"></a>release</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试解锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//成功唤醒同步队列中头结点的下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="isOnSyncQueue"   >
          <a href="#isOnSyncQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h4>
      <p>判断当前结点是不是在同步队列中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回true说明在同步队列中，返回false说明不在同步队列中</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果结点等待状态为-2(条件队列)，或者结点的前驱结点为空，说明不在同步队列中</span></span><br><span class="line">  	<span class="comment">//也即同步队列的结点状态不能为-2，并且前驱结点不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后继结点不为空，说明在同步队列中(也即：同步队列除了尾结点后继结点不为空)</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果后继节点为空判断是不是在同步队列的尾结点</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="findNodeFromTail"   >
          <a href="#findNodeFromTail" class="heading-link"><i class="fas fa-link"></i></a><a href="#findNodeFromTail" class="headerlink" title="findNodeFromTail"></a>findNodeFromTail</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾结点开始搜索结点node，遍历结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果尾结点是当前结点node，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果搜索结点为空，说明搜索完同步队列还没找到结点node，说明node不在同步队列中</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//向前搜索</span></span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>checkInterruptWhileWaiting方法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">	<span class="comment">//如果中断过，那么返回值要么是THROW_IE(-1)要么是REINTERRUPT(1)</span></span><br><span class="line">    <span class="comment">//没有中断过则返回0</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也即返回值有 -1(THROW_IE),0,1(REINTERRUPT)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="transferAfterCancelledWait"   >
          <a href="#transferAfterCancelledWait" class="heading-link"><i class="fas fa-link"></i></a><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//CAS设置结点状态标志位从-2到0(也即这是中断唤醒线程再导致添加在同步队列中，所以设置中断模式为THROW_IE)</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//CAS成功，添加结点到同步队列，返回true</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果结点不在同步队列中，那么就让出CPU，直到它在同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="reportInterruptAfterWait"   >
          <a href="#reportInterruptAfterWait" class="heading-link"><i class="fas fa-link"></i></a><a href="#reportInterruptAfterWait" class="headerlink" title="reportInterruptAfterWait"></a>reportInterruptAfterWait</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果中断模式是THROW_IE，也即条件队列线程唤醒是因为线程中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">//如果中断模式是REINTERRUPT说明是SSignal唤醒线程，则线程自己中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="signal"   >
          <a href="#signal" class="heading-link"><i class="fas fa-link"></i></a><a href="#signal" class="headerlink" title="signal"></a>signal</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//判断是否是持锁线程唤醒，如果当前线程不是持锁线程那么则抛错</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//持锁线程可以去唤醒条件队列的结点</span></span><br><span class="line">    </span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取条件队列的第一个Waiter</span></span><br><span class="line">    		<span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="comment">//如果条件线程不为空那么尝试从第一个结点开始Signal唤醒</span></span><br><span class="line">    		<span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="isHeldExclusively"   >
          <a href="#isHeldExclusively" class="heading-link"><i class="fas fa-link"></i></a><a href="#isHeldExclusively" class="headerlink" title="isHeldExclusively"></a>isHeldExclusively</h4>
      <p>方法由子类实现，如果当前线程不是持锁线程则抛错</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="doSignal"   >
          <a href="#doSignal" class="heading-link"><i class="fas fa-link"></i></a><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将条件队列队首开始，尝试将一个结点从条件队列移到同步队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//将第一个结点移出条件队列(无论是否成功移到同步队列)</span></span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//将头结点指针更新成第一个结点的下一个结点，如果下一个结点为空同时也更新条件队列尾指针</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//将第一个结点指针更新为空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;  <span class="comment">//将第一个结点尝试移到同步队列中，当成功则返回true，失败返回false</span></span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一个结点移到同步队列失败，则重新获取第一个结点直到同步队列为空或者成功移动一个结点到同步队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="transferForSignal"   >
          <a href="#transferForSignal" class="heading-link"><i class="fas fa-link"></i></a><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回false:通过Signal转移到同步队列失败</span></span><br><span class="line"><span class="comment">//返回true:通过Signal转移到同步队列成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//如果CAS更新结点状态失败，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//CAS成功，结点状态更新成0</span></span><br><span class="line">    <span class="comment">//将结点入同步队列尾部，enq返回原先的尾结点(此时同步队列的倒数第二个结点)</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果p状态大于0(结点P失效)或者p状态更新成-1失败(0-&gt;-1) 那么唤醒结点线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">//唤醒结点线程，让它去争抢一次锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	因为AQS同步队列中只有前一个结点的是头结点才能争锁成功</span></span><br><span class="line"><span class="comment">        	这里可能是让本线程更新同步队列结点的状态</span></span><br><span class="line"><span class="comment">        	或者移除不合法结点之后此节点前一个结点是头结点，于是能尝试争锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回true，也即通过Signal添加到同步队列成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="signalAll"   >
          <a href="#signalAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="comment">//判断是否是持锁线程进行全部唤醒，不是则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    		<span class="comment">//获取同步队列的头指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    		<span class="comment">//如果同步队列存在则唤醒全部</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>








        <h4 id="doSignalAll"   >
          <a href="#doSignalAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#doSignalAll" class="headerlink" title="doSignalAll"></a>doSignalAll</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    		<span class="comment">//将同步队列的首尾指针指向空</span></span><br><span class="line">            lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//将原先的头结点向后遍历，尝试唤醒全部条件队列线程</span></span><br><span class="line">    		<span class="keyword">do</span> &#123;</span><br><span class="line">          	</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h2>
      <p>AQS是一个<strong>非公平锁</strong>，当需要加锁的时候都是先尝试获取一把锁，如果获取失败才会进入AQS同步队列中。又因为AQS分有独占锁和共享锁，以及同步队列和条件队列，所以这里单独对加锁、解锁以及两个队列再进行一个知识性总结</p>

        <h3 id="独占锁"   >
          <a href="#独占锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3>
      
        <h4 id="加锁"   >
          <a href="#加锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4>
      
        <h5 id="acquire-1"   >
          <a href="#acquire-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire-1" class="headerlink" title="acquire"></a>acquire</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  <span class="comment">//先尝试获取锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//获取锁失败添加到同步队列中</span></span><br><span class="line">        selfInterrupt();   <span class="comment">//获取锁失败后添加到同步队列成功自身中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="acquireQueued-1"   >
          <a href="#acquireQueued-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireQueued-1" class="headerlink" title="acquireQueued"></a>acquireQueued</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步队列尝试获取锁，当出现中断唤醒时，不会抛出异常</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//只有前一个结点是持锁线程(头结点)才能获取锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>; <span class="comment">//更新中断标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//怎么都获取不到锁，同步队列中移除该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="doAcquireInterruptibly-1"   >
          <a href="#doAcquireInterruptibly-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireInterruptibly-1" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步队列尝试获取锁，当出现中断唤醒时，会抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//只有前一个结点是持锁线程(头结点)才能获取锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();<span class="comment">//出现中断，抛出中断异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//怎么都获取不到锁，同步队列中移除该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="await-1"   >
          <a href="#await-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#await-1" class="headerlink" title="await"></a>await</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	进入while循环的条件：不在同步队列中</span></span><br><span class="line"><span class="comment">    	退出while循环的情景：</span></span><br><span class="line"><span class="comment">    		1.因为中断唤醒线程，所以设置中断模式</span></span><br><span class="line"><span class="comment">    		2.因为signal唤醒线程也即资源满足条件，所以结点一定在同步队列中不符合while循环条件</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//如果结点不在同步队列中(在条件队列中)=&gt;阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线程唤醒如果是因为中断过，那么就设置中断模式并且跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新争抢锁成功，并且不是因为中断唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//那么就设置中断模式为REINTERRUPT，需要本线程自己中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>因此AQS独占锁的获取锁流程：</p>
<ul>
<li><p>先判断锁是否获取(非公平锁)-&gt;失败则进入同步队列中-&gt;同步队列中只有前一个结点是头结点的结点才能获取锁</p>
</li>
<li><p>条件队列时，先将结点入条件队列，并且阻塞 -&gt; 唤醒之后结点在同步队列中尝试去同步队列方法获取锁</p>
</li>
</ul>

        <h4 id="解锁"   >
          <a href="#解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4>
      
        <h5 id="release-2"   >
          <a href="#release-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#release-2" class="headerlink" title="release"></a>release</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//释放锁成功，唤醒持锁线程的下一个线程</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>因此AQS独占锁的释放锁流程：</p>
<ul>
<li>如果释放锁成功，当同步队列不为空的时候则会唤醒头结点的下一个线程</li>
</ul>

        <h3 id="共享锁"   >
          <a href="#共享锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3>
      
        <h4 id="加锁-1"   >
          <a href="#加锁-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4>
      
        <h5 id="acquireShared-1"   >
          <a href="#acquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireShared-1" class="headerlink" title="acquireShared"></a>acquireShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    	<span class="comment">//先尝试获取共享锁，获取锁失败则进入同步队列中等待获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="doAcquireShared-1"   >
          <a href="#doAcquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireShared-1" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg); <span class="comment">//获取共享锁的资源数</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r); <span class="comment">//设置头结点并且尝试唤醒下一个共享模式线程</span></span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>; <span class="comment">//设置中断标志位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node); <span class="comment">//怎么都获取不到锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="setHeadAndPropagate-1"   >
          <a href="#setHeadAndPropagate-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#setHeadAndPropagate-1" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="comment">//记录老的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//设置新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**以下IF语句有五种情况</span></span><br><span class="line"><span class="comment">    	1.当前结点node获取锁成功，也即propagate＞0</span></span><br><span class="line"><span class="comment">    	2.原来的头结点为空，也即同步队列头结点为空</span></span><br><span class="line"><span class="comment">    	3.原来的头结点不为空但是锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    	4.将当前结点更新成头结点为空</span></span><br><span class="line"><span class="comment">    	5.将当前结点更新成头结点之后锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前结点的下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//判断下一个结点如果是共享模式则进入唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="doReleaseShared-1"   >
          <a href="#doReleaseShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared-1" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">             <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果头结点没有变化则结束(唤醒之后要去获取锁，获取锁会更新头结点)</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="doAcquireSharedInterruptibly-1"   >
          <a href="#doAcquireSharedInterruptibly-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireSharedInterruptibly-1" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); </span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg); <span class="comment">//当资源大于0的时候</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">//抛出中断异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//取消获取锁任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>因此共享锁加锁流程：</p>
<p>先尝试能不能获取共享锁（非公平锁）-&gt; 加锁失败则进入同步队列中-&gt; 同步队列中获取锁成功那么尝试将下一个共享结点唤醒（共享锁认为当资源合适的时候那么共享线程都能获取锁）</p>

        <h4 id="解锁-1"   >
          <a href="#解锁-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4>
      
        <h5 id="releaseShared"   >
          <a href="#releaseShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">//如果释放锁成功，那么就唤醒下一个线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="doReleaseShared-2"   >
          <a href="#doReleaseShared-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared-2" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">             <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果头结点没有变化则结束(唤醒之后要去获取锁，获取锁会更新头结点)</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此共享锁释放锁流程：</p>
<p>先尝试释放锁，如果释放锁成功那么唤醒同步队列的结点</p>

        <h1 id="ReentrantLock"   >
          <a href="#ReentrantLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1>
      <p>讲完AQS(抽象队列同步器)，那么我们必须要讲到它的落地，也即它的子类，我们常用的可重入锁ReentrantLock</p>

        <h2 id="成员变量以及内部类-1"   >
          <a href="#成员变量以及内部类-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-1" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h2>
      <p><strong>成员变量</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>


        <h3 id="Sync"   >
          <a href="#Sync" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//非公平获取锁，因为AQS同步器本身就是非公平锁</span></span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有持锁线程，那么尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    <span class="comment">//设置持锁线程是当前线程</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">             	<span class="comment">//持锁线程是当前线程，所以是锁的重入，更新锁的重入次数   </span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//解锁</span></span><br><span class="line">    	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="comment">//如果当前线程不是持锁线程则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果释放锁之后锁的重入次数为0也即完全释放锁</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新锁的状态</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//..省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="NonfairSync"   >
          <a href="#NonfairSync" class="heading-link"><i class="fas fa-link"></i></a><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           	<span class="comment">//尝试获取锁，如果获取锁成功则更新锁的持锁线程为当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//加锁失败走AQS的获取锁流程</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//尝试加锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="FairSync"   >
          <a href="#FairSync" class="heading-link"><i class="fas fa-link"></i></a><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//尝试加锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果锁状态为0也即无人持锁，如果同步队列没有线程等待才尝试加锁</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//锁的重入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>hasQueuedPredecessors</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断同步队列中是否有线程等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    	<span class="comment">//如果头结点不等于尾结点并且</span></span><br><span class="line">    	<span class="comment">//	头结点的下一个结点不是当期结点则返回true也即同步队列存在</span></span><br><span class="line">    	<span class="comment">//  头结点的下一个结点不存在说明有其他线程在添加到同步队列中且不是当前线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造，默认构造一个非公平同步器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//有参构造，根据传入参数来构造一个公平同步器或者非公平同步器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="常用方法"   >
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2>
      
        <h3 id="lock"   >
          <a href="#lock" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock" class="headerlink" title="lock"></a>lock</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock(); <span class="comment">//调用同步器的lock方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="非公平同步器"   >
          <a href="#非公平同步器" class="heading-link"><i class="fas fa-link"></i></a><a href="#非公平同步器" class="headerlink" title="非公平同步器"></a>非公平同步器</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         	<span class="comment">//尝试获取锁，如果获取锁成功则更新锁的持锁线程为当前线程</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//加锁失败走AQS的获取锁流程，会进入子类的tryAcquire方法</span></span><br><span class="line">              acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquire(acquires); <span class="comment">//调用同步器的尝试获取锁，如果获取锁失败继续acquire方法添加到同步队列中</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="公平同步器"   >
          <a href="#公平同步器" class="heading-link"><i class="fas fa-link"></i></a><a href="#公平同步器" class="headerlink" title="公平同步器"></a>公平同步器</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//先进AQS的acquire方法，然后再回来进行tryAcquire方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">          acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//尝试加锁</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">          <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//如果锁状态为0也即无人持锁，如果同步队列没有线程等待才尝试加锁</span></span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//锁的重入</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//如果同步队列存在那么就直接加锁失败，然后继续acquire方法进入同步队列中            </span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="tryLock"   >
          <a href="#tryLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>); <span class="comment">//调用同步器的nonfairTryAcquire</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="unlock"   >
          <a href="#unlock" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">//调用同步器的解锁方法，最后是AQS的解锁方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="ReentrantReadWriteLock"   >
          <a href="#ReentrantReadWriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1>
      <p>可重入读写锁，首先我们先要看到它实现的接口ReadWriteLock</p>

        <h2 id="ReadWriteLock"   >
          <a href="#ReadWriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">	<span class="comment">//读锁</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="成员变量以及内部类-2"   >
          <a href="#成员变量以及内部类-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-2" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">//写锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">//同步器</span></span><br><span class="line">   <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">//魔法类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//tid位移偏移量    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TID_OFFSET;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">           Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">           TID_OFFSET = UNSAFE.objectFieldOffset</span><br><span class="line">               (tk.getDeclaredField(<span class="string">&quot;tid&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Sync-1"   >
          <a href="#Sync-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync-1" class="headerlink" title="Sync"></a>Sync</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds; <span class="comment">//ThreadLocalHoldCounter 线程本地变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Thread</span> <span class="variable">firstReader</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//第一个读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> firstReaderHoldCount;  <span class="comment">//第一个读锁持锁次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;	<span class="comment">//最后一个操作读锁的线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//16位是写锁和读锁的分界线，高16位为记录共享锁，低16位用于记录独占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享锁，高16位，高16位用于记录共享锁(读锁)的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的最大重入次数为65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独占锁，低16位，用于计算独占锁（写锁）的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>; <span class="comment">//EXCLUSIVE_MASK 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略部分代码</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="HoldCounter"   >
          <a href="#HoldCounter" class="heading-link"><i class="fas fa-link"></i></a><a href="#HoldCounter" class="headerlink" title="HoldCounter"></a>HoldCounter</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    		<span class="comment">//锁次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="ThreadLocalHoldCounter"   >
          <a href="#ThreadLocalHoldCounter" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalHoldCounter" class="headerlink" title="ThreadLocalHoldCounter"></a>ThreadLocalHoldCounter</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalHoldCounter封装了一下ThreadLocal，为了增加线程tid以及锁的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;</span><br><span class="line">            <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="sharedCount"   >
          <a href="#sharedCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#sharedCount" class="headerlink" title="sharedCount"></a>sharedCount</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取读锁的重入次数 直接将状态字无符号右移16位(高位补0)</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;	</span><br></pre></td></tr></table></div></figure>


        <h5 id="exclusiveCount"   >
          <a href="#exclusiveCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#exclusiveCount" class="headerlink" title="exclusiveCount"></a>exclusiveCount</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写锁的重入次数（低16位），也即写锁的重入次数最大为65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="NonfairSync-1"   >
          <a href="#NonfairSync-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#NonfairSync-1" class="headerlink" title="NonfairSync"></a>NonfairSync</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8159625535654395037L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//非公平锁可以尝试CAS取锁，不需要判断同步队列是否存在</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="FairSync-1"   >
          <a href="#FairSync-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#FairSync-1" class="headerlink" title="FairSync"></a>FairSync</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2274990926593161451L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//公平锁如果同步队列中存在则阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//公平锁如果同步队列中存在则阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="ReadLock"   >
          <a href="#ReadLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5992448646407690164L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//写操作是否需要阻塞，在非公平同步器中，写操作可以不用在乎是否存在同步队列，所以返回false表示不需要阻塞</span></span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//调用AQS中的方法判断是否读操作需要阻塞</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	AQS中的方法，当返回true的时候需要以下几个条件：</span></span><br><span class="line"><span class="comment">		1.同步队列头结点不为空</span></span><br><span class="line"><span class="comment">		2.同步队列头结点的下一个结点存在(也即有等待锁的线程存在)</span></span><br><span class="line"><span class="comment">		3.等待锁的线程是独占模式</span></span><br><span class="line"><span class="comment">		4.同步队列头结点的下一个结点的线程不为空</span></span><br><span class="line"><span class="comment">	也即同步队列中的能够抢锁的第一个线程必须存在并且是独占模式，也即获取读锁要被阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> &#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;	<span class="comment">//同步队列存在头结点不为空</span></span><br><span class="line">            (s = h.next)  != <span class="literal">null</span> &amp;&amp;	<span class="comment">//同步队列的头结点的下一个结点也存在</span></span><br><span class="line">            !s.isShared()         &amp;&amp;	<span class="comment">//同步队列的头结点的下一个结点是独占模式</span></span><br><span class="line">            s.thread != <span class="literal">null</span>;			<span class="comment">//同步队列的头结点的下一个结点的线程不为空</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="WriteLock"   >
          <a href="#WriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4992448646407690164L</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">protected</span> <span class="title function_">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           sync.acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="构造方法-1"   >
          <a href="#构造方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造，默认会构造非公平读写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//有参构造，根据传入参数构造公平读写锁或者非公平读写锁</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">       readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">       writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//给读写锁初始化</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">   <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="title function_">readLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="写锁-写锁"   >
          <a href="#写锁-写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#写锁-写锁" class="headerlink" title="写锁+写锁"></a>写锁+写锁</h3>
      
        <h4 id="lock-1"   >
          <a href="#lock-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-1" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>); <span class="comment">//调用AQS的acquire方法，acquire方法会走tryAcquire方法由子类实现</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquire-1"   >
          <a href="#tryAcquire-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire-1" class="headerlink" title="tryAcquire"></a>tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行写锁+写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁)</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果锁状态不为0，也即有线程拥有锁(这里假设是写锁)</span></span><br><span class="line">                </span><br><span class="line">               	<span class="comment">//因为是写锁，所以w！=0,判断持锁线程是否是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">//如果持锁线程不是当前线程，所以不能加锁(写锁互斥)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//反之是持锁线程的写锁重入，判断重入次数是否大于最大重入次数65535</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//锁重入成功，设置锁的状态值返回true</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//writerShouldBlock()判断写锁是否要阻塞</span></span><br><span class="line">    		<span class="comment">//公平锁要判断同步队列是否存在，非公平锁直接返回false，认为可以去CAS加锁</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果公平锁需要入同步队列或者CAS加锁失败则加锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//反之是第一次加锁成功</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>写锁+写锁</p>
<ul>
<li>未被加锁：根据锁的类型判断是否能抢锁<ul>
<li>公平锁：如果AQS同步队列不存在那么就可以尝试获取锁，如果存在则要进入AQS同步队列</li>
<li>非公平锁：无论AQS同步队列存在不存在那么都可以尝试获取锁</li>
</ul>
</li>
<li>已被加锁：判断锁是否是当前线程加锁（也即锁的重入）<ul>
<li>不是当前线程：那么就是别的线程来抢锁，而写锁是独占锁，返回加锁失败：<code>return false;</code></li>
<li>是当前线程<ul>
<li>判断锁的重入次数是否达到上限：上限为(1&lt;&lt;16)-1，也即65535<ul>
<li>达到上限则抛出异常</li>
<li>没有达到上限则成功加锁，返回加锁成功:<code>return true;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="写锁-读锁"   >
          <a href="#写锁-读锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#写锁-读锁" class="headerlink" title="写锁+读锁"></a>写锁+读锁</h3>
      
        <h4 id="lock-2"   >
          <a href="#lock-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-2" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享锁加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);<span class="comment">//调用AQS的acquireShared方法，会进行tryAcquireShared方法由子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-1"   >
          <a href="#tryAcquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-1" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行写锁+读锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取锁的重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	因为持锁是写锁，所以写锁重入次数!=0，那么就分两种：</span></span><br><span class="line"><span class="comment">    		1.是当前线程持有写锁要加读锁  =&gt;锁的降级</span></span><br><span class="line"><span class="comment">    		2.不是当前线程持写锁			=&gt;加锁失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">//如果不是当前线程持有写锁，那么就返回-1表示加锁失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运行到这里是因为是本线程持有写锁，所以可以进行获取读锁(锁的降级)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);   <span class="comment">//获取共享锁的加锁次数</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">//根据锁的公平/非公平性判断是否需要读操作阻塞</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;		<span class="comment">//如果加锁次数没有达到上限</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;	<span class="comment">//CAS加共享读锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; </span><br><span class="line">        	<span class="comment">//如果共享锁的加锁次数为0，那么就记录第一个加锁线程，并缓存第一个读锁加锁次数为1</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">//如果缓存中第一个读锁线程是当前线程，那么就将缓存读锁加锁次数++</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为这里是写锁+读锁，所以是同一个线程内进行，不会走到这个if语句，以下暂且不看</span></span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回1表示加锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**如果加锁失败,也即上方if判断语句为false，那么就有三种情况：</span></span><br><span class="line"><span class="comment">    	1.同步队列的头结点的下一个结点不是共享模式</span></span><br><span class="line"><span class="comment">    	2.共享锁的加锁次数达到了最大上限(65535)</span></span><br><span class="line"><span class="comment">    	3.CAS加锁失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="fullTryAcquireShared"   >
          <a href="#fullTryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">    <span class="comment">//ThreadLcocal的封装HoldCounter，封装了一个count，用于记录锁的重入次数</span></span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取锁的状态字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个if语句，如果锁是独占锁则进入if条件语句中，我们这个条件下一开始是独占锁所以这里会进入第一个条件语句中</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//走到这里也即写锁(独占锁)重入次数不为0，也即一开始有独占锁存在</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">//如果持锁线程不是本线程则返回-1，如果是本线程则进入下方第二个if语句判断</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//是共享锁，且共享锁需要被阻塞，这里先暂且不谈，因为这里一开始独占锁标记就不为0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个if语句，判断共享锁是否达到上限</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="comment">//达到上限则抛出共享锁达到上限错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三个if语句，则尝试CAS加锁，如果CAS失败则死循环再进行CAS判断</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">/**CAS成功，以下有三种情况:</span></span><br><span class="line"><span class="comment">            	1.本线程是第一次获取共享锁的线程</span></span><br><span class="line"><span class="comment">            	2.本线程是第一个获取共享锁的线程重入</span></span><br><span class="line"><span class="comment">            	3.本线程不是第一个获取共享锁的线程 （在写锁+读锁的情况下不存在，因为读锁一定是当前写锁线程)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//情况1，是第一次获取共享锁，那么就缓存第一个读线程，并且更新共享锁重入次数为1</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">//情况2，是第一个获取共享锁的线程重入，那么就更新共享锁重入次数++</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//情况3，本线程不是第一个获取共享锁的线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//如果缓存rh为空，那么就指向读锁最后一个线程的缓存(也即最后一个获取读锁的线程)</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">//如果缓存rh为空或者rh的线程不是本线程，那么就将rh跟踪当前线程情况</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果最后一个读线程是当前线程并且计数器为0，说明当前线程曾经获取过读锁后面释放完了锁</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//更新一下本地线程变量，将当前线程持锁计数0以及当前线程id的rh重新写入readHolds中</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//缓存rh的锁重入次数++,并且更新最后一个获取读锁线程缓存cacheHoldCounter为当前线程</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//返回1表示加锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>写锁+读锁</p>
<p>判断写锁是否是本线程拥有</p>
<ul>
<li>写锁不是本线程持有，想要加读锁：<strong>不允许</strong>，因为写锁是排它锁，所以其他线程请求读锁会失败</li>
<li>写锁是本线程持有，想要加读锁（<strong>锁的降级</strong>）<ul>
<li>尝试添加读锁成功：<ul>
<li>是第一次添加读锁，更新第一个读锁线程缓存（FirstReader）以及重入次数（FirstReaderHoldCounter）</li>
<li>不是第一次添加读锁，更新第一个读锁线程的重入次数（FirstReaderHolderCounter）</li>
</ul>
</li>
<li>尝试添加读锁失败：<ul>
<li>同步队列的下一个结点不是共享模式，需要阻塞；</li>
<li>共享锁的重入次数达到上限65535：抛出达到共享锁上限错误</li>
<li>CAS失败，进入循环中再次尝试CAS获取读锁</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="读锁-写锁"   >
          <a href="#读锁-写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读锁-写锁" class="headerlink" title="读锁+写锁"></a>读锁+写锁</h3>
      
        <h4 id="lock-3"   >
          <a href="#lock-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-3" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>); <span class="comment">//调用AQS的acquire方法，acquire方法会走tryAcquire方法由子类实现</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquire-2"   >
          <a href="#tryAcquire-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire-2" class="headerlink" title="tryAcquire"></a>tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行读锁+写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁)</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//在进行持读锁想要加写锁的情况下，c！= 0 &amp;&amp; w == 0</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">//也即当持读锁(共享锁)的情况下加写锁(独占锁)会直接返回false，不允许加锁</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>读锁+写锁</p>
<ul>
<li>持有读锁的情况下<code>c != 0</code>，<code>w == 0</code>，走到第一个分支就会加锁失败，也即<strong>持有读锁不允许加写锁</strong>（<strong>不允许锁升级</strong>）</li>
</ul>

        <h3 id="读锁-读锁"   >
          <a href="#读锁-读锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读锁-读锁" class="headerlink" title="读锁+读锁"></a>读锁+读锁</h3>
      
        <h4 id="lock-4"   >
          <a href="#lock-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-4" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReadLock加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;   	</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>AQS中的获取共享锁方法(acquireShared)</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    	<span class="comment">//先尝试获取共享锁，获取锁失败则进入同步队列中等待获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-2"   >
          <a href="#tryAcquireShared-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-2" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">//获取锁的状态</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">      <span class="comment">//获取独占锁的重入次数，因为一开始加的是读锁，所以独占锁次数为0</span></span><br><span class="line">      <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;	<span class="comment">//0==0也即第一个判断中返回false</span></span><br><span class="line">          getExclusiveOwnerThread() != current)</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取共享锁的重入次数</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果读锁操作允许，并且读锁重入次数小于上限，并且CAS成功</span></span><br><span class="line">      <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">//根据同步器的公平/非公平判断是否需要阻塞</span></span><br><span class="line">          r &lt; MAX_COUNT &amp;&amp;		<span class="comment">//读锁重入次数小于上限(65535)</span></span><br><span class="line">          compareAndSetState(c, c + SHARED_UNIT)) &#123;	<span class="comment">//CAS</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//如果共享锁的加锁次数为0，那么就记录第一个加锁线程，并缓存第一个读锁加锁次数为1</span></span><br><span class="line">              firstReader = current;</span><br><span class="line">              firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">              <span class="comment">//如果缓存中第一个读锁线程是当前线程，那么就将缓存读锁加锁次数++</span></span><br><span class="line">              firstReaderHoldCount++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//获取rh，是最后一个读锁操作线程缓存</span></span><br><span class="line">              <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">              <span class="comment">//如果最后一个操作线程缓存不存在，或者最后一个线程不是本线程</span></span><br><span class="line">              <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                  <span class="comment">//那么就更新本线程成为最后一个线程</span></span><br><span class="line">                  cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                  <span class="comment">//本线程就是最后一个操作读锁线程，并且本线程计数器为0，那么更新通用计数器</span></span><br><span class="line">                  readHolds.set(rh);</span><br><span class="line">              <span class="comment">//更新本线程重入次数++</span></span><br><span class="line">              rh.count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回1表示加锁成功</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/**如果加锁失败,也即上方if判断语句为false，那么就有三种情况：</span></span><br><span class="line"><span class="comment">	1.同步队列的头结点的下一个结点不是共享模式</span></span><br><span class="line"><span class="comment">	2.共享锁的加锁次数达到了最大上限(65535)</span></span><br><span class="line"><span class="comment">	3.CAS加锁失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="fullTryAcquireShared-1"   >
          <a href="#fullTryAcquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullTryAcquireShared-1" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">    <span class="comment">//先将通用计数器置空</span></span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//死循环，持续获取读锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//获取锁的状态字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//因为这里是读锁+读锁，所以独占锁的重入次数为0，会进入下方第一个if语句的else判断中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个if语句，判断是否是独占锁，else语句是共享锁或者无锁执行路线</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">			<span class="comment">//是共享锁或者无锁，但是如果读操作需要被阻塞</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果第一个读线程是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">//那么什么都不做</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果第一个读线程不是当前线程</span></span><br><span class="line">                </span><br><span class="line">              	<span class="comment">//如果通用计数器rh为空</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//那么就更新rh成为最后一个操作线程缓存</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    	进入下方分支有两个情况：</span></span><br><span class="line"><span class="comment">                    		1.最后一个读锁线程缓存为空，也即本线程是第一个获取读锁的线程，此时rh==null</span></span><br><span class="line"><span class="comment">                    		2.最后一个读锁线程缓存不为空，也即读锁有线程获取了rh不为空，但不是本线程</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">//将rh跟踪当前线程</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        	对应情况1，因为此时线程是第一个获取读锁的线程失败，所以将本地线程变量移除</span></span><br><span class="line"><span class="comment">                        	对应情况2，因为本线程是第一次获取读锁，但是获取失败，所以本地线程变量移除</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();<span class="comment">//将本地线程变量移除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果是情况1，本线程是第一个获取读锁的线程失败，所以返回-1给上层方法表示需要阻塞获取读锁失败防止死锁</span></span><br><span class="line">                <span class="comment">//如果是情况2，本线程是第一次获取读锁失败，返回-1表示需要阻塞获取读锁失败防止死锁</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**运行到这里有几种可能去竞争锁：</span></span><br><span class="line"><span class="comment">        	1.是共享锁/无锁，获取读锁操作不需要被阻塞</span></span><br><span class="line"><span class="comment">        	2.获取锁操作需要被阻塞，但是因为本线程还持有读锁，可以继续尝试获取读锁,直到获取锁成功返回1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个if语句，判断共享锁次数是否达到上限</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);<span class="comment">//达到上限则抛出Error</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">//如果CAS</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果共享锁次数为0，说明该线程是第一个获取读锁线程</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">//如果本线程是第一个持读锁线程，那么更新第一个读锁重入次数</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//如果rh==null，那么跟踪最后一个获取读锁线程</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">//如果最后一个获取读锁线程不是本线程，那么则将rh跟踪本线程</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                   	</span><br><span class="line">                    <span class="comment">//如果本线程的持锁数量为0，那么更新readHolds</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">//本线程读锁重入次数++</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                <span class="comment">//更新最后一个操作读锁缓存</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>读锁+读锁，当持锁是读锁或者无锁的情况下：</p>
<ul>
<li>简单加锁成功：<strong>获取读锁不被阻塞</strong>、<strong>读锁重入次数不达到上限</strong>、<strong>CAS成功</strong><ul>
<li>是第一次添加读锁，更新第一个读锁线程缓存（FirstReader）以及重入次数（FirstReaderHoldCounter）</li>
<li>当前线程是第一个读锁线程，更新第一个读锁线程的重入次数（FirstReaderHolderCounter）</li>
<li>当前线程不是第一个获取读锁线程，那么就将rh跟踪到当前线程，也即最后一个操作读锁线程是本线程<ul>
<li>假如当前线程的读锁重入次数为零（rh.count&#x3D;&#x3D;0)，那么更新readHolds，重入次数++</li>
<li>假如当前读锁的读锁重入次数不为0，更新重入次数++</li>
</ul>
</li>
</ul>
</li>
<li>简单加锁失败，进入完整加锁流程：<ul>
<li>如果锁是独占锁，那么就加锁失败返回-1</li>
<li>如果锁是无锁或者共享锁<ul>
<li>如果获取读锁操作被阻塞：<ul>
<li>如果该线程是第一个获取读锁或者第一次获取读锁被阻塞，那么返回-1表示获取读锁失败，防止死锁</li>
<li>如果该线程不是第一次获取读锁，那么会不断获取读锁直到成功</li>
</ul>
</li>
<li>如果锁的重入次数达到上限：上限65535，会抛出错误！</li>
<li>不断获取读锁，该情况有：1.获取读锁操作不被阻塞。2.获取读锁操作被阻塞，但是本线程不是第一次获取读锁<ul>
<li>是第一次添加读锁，更新第一个读锁线程缓存（FirstReader）以及重入次数（FirstReaderHoldCounter）</li>
<li>当前线程是第一个读锁线程，更新第一个读锁线程的重入次数（FirstReaderHolderCounter）</li>
<li>当前线程不是第一个获取读锁线程，那么就将rh跟踪到当前线程，也即最后一个操作读锁线程是本线程<ul>
<li>假如当前线程的读锁重入次数为零（rh.count&#x3D;&#x3D;0)，那么更新readHolds，重入次数++</li>
<li>假如当前读锁的读锁重入次数不为0，更新重入次数++</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="特例-写锁-读锁-写锁"   >
          <a href="#特例-写锁-读锁-写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#特例-写锁-读锁-写锁" class="headerlink" title="特例(写锁+读锁+写锁)"></a>特例(写锁+读锁+写锁)</h3>
      <p>我们要知道，在读锁存在的时候获取写锁会失败，也即读锁<strong>不能升级</strong>，但是写锁<strong>可以降级</strong>，那么当降级后的写锁是什么锁？能不能获取写锁呢?答案是<strong>肯定</strong>的，当降级之后的写锁仍然能获取<strong>写锁</strong></p>
<p>在<strong>同一个线程</strong>内获取写锁+读锁+写锁可以成立，这个时候我称之为读写锁</p>
<blockquote>
<p>举例：先获取一次写锁，再获取一次读锁，最后再获取一次写锁</p>
</blockquote>

        <h4 id="第一次写锁tryAcquire"   >
          <a href="#第一次写锁tryAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次写锁tryAcquire" class="headerlink" title="第一次写锁tryAcquire"></a>第一次写锁tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次获取写锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁) c==0,w==0</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//写不被阻塞，并且因为是一个线程在竞争CAS成功</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>执行完CAS操作之后c&#x3D;0000 0000 0000 0000 | 0000 0000 0000 0001 也即c&#x3D;&#x3D;1表示写锁重入次数1，执行完这里表示已经拥有了<strong>写锁</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201615367.png"  alt="第一次加写锁">
      </p>

        <h4 id="第一次读锁tryAcquireShared"   >
          <a href="#第一次读锁tryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次读锁tryAcquireShared" class="headerlink" title="第一次读锁tryAcquireShared"></a>第一次读锁tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次获取读锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">//获取锁的状态字c=1</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; <span class="comment">//独占锁重入次数为1，并且持有读锁线程为本线程，进行锁降级</span></span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);	<span class="comment">//读锁次数为0</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">//CAS成功</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//因为本线程是第一个获取读锁线程，所以更新第一个读锁线程以及第一个读锁重入次数</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取读锁成功表示返回1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>执行完CAS之后，c&#x3D;0000 0000 0000 0001 | 0000 0000 0000 0001 也即c&#x3D;65537，执行完这里表示该线程拥有了<strong>读锁</strong>，也即表示现在拥有了<strong>读写锁</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201709342.png"  alt="第一次加读锁">
      </p>

        <h4 id="第二次写锁tryAcquire"   >
          <a href="#第二次写锁tryAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次写锁tryAcquire" class="headerlink" title="第二次写锁tryAcquire"></a>第二次写锁tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二次获取写锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁) c==65537,w==1</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//独占锁重入次数不为0，又因为是当前线程，所以可以获取写锁</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//独占锁次数没有超过上限</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">//设置状态字加锁成功</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    	</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>执行完CAS之后，c&#x3D;0000 0000 0000 0001| 0000 0000 0000 0010，也即c&#x3D;65538，也即执行完操作之后线程还拥有读写锁</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201804965.png"  alt="第二次加读锁">
      </p>

        <h3 id="写锁解锁"   >
          <a href="#写锁解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#写锁解锁" class="headerlink" title="写锁解锁"></a>写锁解锁</h3>
      
        <h4 id="unlock-1"   >
          <a href="#unlock-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock-1" class="headerlink" title="unlock"></a>unlock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);<span class="comment">//会走AQS的逻辑，然后走到tryRelease由子类实现回到读写锁中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="tryRelease-1"   >
          <a href="#tryRelease-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryRelease-1" class="headerlink" title="tryRelease"></a>tryRelease</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">//判断该线程是否是持锁线程，如果不是持锁线程想要释放锁那么会抛出异常</span></span><br><span class="line">    		<span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取释放锁之后的状态字nextc</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    		<span class="comment">//如果本次释放锁是完全释放锁，那么free为true，反之还有锁的重入free为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)	<span class="comment">//如果是完全释放锁，那么会更新持锁线程为空</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    		<span class="comment">//更新锁的状态字</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<ul>
<li><p>写锁解锁：</p>
<ul>
<li><p>判断本线程是否是持锁线程：不是则抛出异常</p>
</li>
<li><p>判断本次释放锁是否是完全释放锁：是完全释放会设置锁的持有线程为空</p>
</li>
<li><p>更新锁的状态字</p>
</li>
<li><p>返回是否完全释放锁</p>
</li>
</ul>
</li>
</ul>

        <h3 id="读锁解锁"   >
          <a href="#读锁解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读锁解锁" class="headerlink" title="读锁解锁"></a>读锁解锁</h3>
      
        <h4 id="unlock-2"   >
          <a href="#unlock-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock-2" class="headerlink" title="unlock"></a>unlock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="tryReleaseShared"   >
          <a href="#tryReleaseShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">//如果当前线程是第一个读锁线程</span></span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//如果当前线程的共享锁重入次数缓存为1，那么本次释放锁之后就完全释放锁</span></span><br><span class="line">            firstReader = <span class="literal">null</span>;	<span class="comment">//将第一个持锁线程置空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则，说明当前持锁线程没能完全释放锁，重入次数缓存--</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之当前线程不是第一个持锁线程</span></span><br><span class="line">        <span class="comment">//获取最后一个获取读锁线程</span></span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">//如果最后一个获取读锁线程不是当前线程，那么rh指向当前线程</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="comment">//获取当前线程的读锁重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果重入次数等于1，那么就说明本线程释放锁之后就完全释放了锁</span></span><br><span class="line">            readHolds.remove();<span class="comment">//本地线程副本移除当前线程(释放之后不持锁了)</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)<span class="comment">//如果小于等于0也即非加锁线程要解锁，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读锁重入次数--</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取锁的状态字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//如果获取释放锁之后共享锁的重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">//如果CAS成功也即释放锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">			<span class="comment">//返回是否完全释放锁，如果是返回true，如果没有完全释放锁，返回false</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>读锁解锁：</p>
<ul>
<li>判断本线程是否是第一个持锁线程<ul>
<li>是第一个持锁线程，对第一个持锁线程的重入次数判断<ul>
<li>如果本次解锁之后重入次数为0，说明完全释放锁，将第一个持锁线程缓存置空：<code>firstReader=null</code></li>
<li>如果本次解锁之后重入次数不为0，说明没有完全释放锁，直接将第一个持锁线程重入次数–</li>
</ul>
</li>
<li>不是第一个持锁线程<ul>
<li>获取最后一个操作读锁线程，如果最后一个操作读锁线程不是本线程，那么rh指向本线程</li>
<li>获取rh的重入次数<ul>
<li>如果rh的重入次数&#x3D;&#x3D;1，那么本次释放锁之后移出本地线程变量副本</li>
<li>如果rh的重入次数小于等于0，说明是非持锁线程想要释放锁，抛出异常</li>
</ul>
</li>
<li>读锁重入次数–</li>
</ul>
</li>
</ul>
</li>
<li>循环，直到CAS成功，返回是否完全释放锁<ul>
<li>nextc&#x3D;&#x3D;0返回true，说明完全释放了读锁</li>
<li>nextc!&#x3D;0返回false，说明没有完全释放读锁</li>
</ul>
</li>
</ul>

        <h3 id="额外知识-自己总结"   >
          <a href="#额外知识-自己总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#额外知识-自己总结" class="headerlink" title="额外知识(自己总结)"></a>额外知识(自己总结)</h3>
      
        <h4 id="1-为什么需要HoldCount"   >
          <a href="#1-为什么需要HoldCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-为什么需要HoldCount" class="headerlink" title="1.为什么需要HoldCount"></a>1.为什么需要HoldCount</h4>
      <p><strong>原因1</strong>：在线程上下文中我们知道可以用本地线程变量ThreadLocal来存放线程变量副本，而这个锁的重入次数也是一个变量，于是HoldCount记录了线程tid以及锁的重入次数，那么用ThreadLocalHoldCount就封装了ThreadLocal，那么锁的重入次数就能保存在ThreadLocal中</p>
<p><strong>原因2</strong>：在锁的状态字中，因为高16位表示共享锁的重入次数，而低16位表示了独占锁的重入次数</p>
<p>当独占锁在加锁32767次也即0111 1111 1111 1111之后，也即再加一次锁32768次需要进位变成1000 0000 0000 0000 而导致了符号位的溢出，采用记录HoldCount来避免进位的符号位溢出造成的影响</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201506534.png"  alt="共享锁和独占锁重入次数表示">
      </p>

        <h4 id="2-为什么当readholds-count-0还要重新设置readHolds-set-rh-？"   >
          <a href="#2-为什么当readholds-count-0还要重新设置readHolds-set-rh-？" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-为什么当readholds-count-0还要重新设置readHolds-set-rh-？" class="headerlink" title="2.为什么当readholds.count&#x3D;&#x3D;0还要重新设置readHolds.set(rh)？"></a>2.为什么当readholds.count&#x3D;&#x3D;0还要重新设置readHolds.set(rh)？</h4>
      <p>原因：</p>
<p>在<code>fullTryAcquireShared</code>方法中，readholds.count&#x3D;&#x3D;0也即rh.count&#x3D;&#x3D;0,<code>rh.count</code>表示的是读锁的重入次数，那么当rh.count&#x3D;&#x3D;0有两种情况：</p>
<ul>
<li>1.该线程没有获取过读锁，那么初始化rh.count&#x3D;&#x3D;0</li>
<li>2.该线程曾经获取过读锁，并且完全释放了读锁，那么rh.count&#x3D;&#x3D;0</li>
</ul>
<p>而我们已知<code>readHolds</code>是封装了<code>ThreadLocal</code>，并添加了两个属性tid以及count,在count&#x3D;&#x3D;0并且tid&#x3D;&#x3D;current的情况下还要设置<code>readHolds.set(rh)</code>,目的是：<strong>更新ThreadLocal的数据</strong>，保证ThreadLocal一致不会对其他方法造成影响而带来数据的不一致</p>
<p>也即：如果线程曾经获取过读锁并且完全释放了读锁情况不能等同于线程从未获取过读锁</p>
<blockquote>
<p>我们可以把这个方法看成冗余，因为表面上什么都没有更新，但是实际上维护了ThreadLocal的数据安全</p>
</blockquote>

        <h4 id="3-在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？"   >
          <a href="#3-在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？" class="headerlink" title="3.在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？"></a>3.在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？</h4>
      <ul>
<li><p>不能继续获取锁(会被阻塞)</p>
<ul>
<li>本线程是第一个获取读锁的线程，但是获取读锁失败，那么也即<code>rh.count==0</code>,读锁重入次数为0，要执行<code>readHolds.remove();</code>并且要返回-1不能继续竞争读锁，表示获取读锁失败</li>
<li>本线程不是第一个获取读锁的线程，但是是本线程的第一次获取读锁线程并且获取读锁失败，那么也即<code>rh.count==0</code>,读锁重入次数为0，要执行<code>readHolds.remove();</code>并且要返回-1不能继续竞争读锁，表示获取读锁失败</li>
</ul>
<p>首先readHolds.remove()是因为本线程不持有读锁移除ThreadLocal中，保证ThreadLocal的数据安全</p>
<p>其次，因为都是该线程的第一次获取读锁失败并被阻塞，那么为了<strong>防止死锁</strong>，而等待写锁释放而不会自旋重复不断获取读锁</p>
</li>
<li><p>能继续获取锁</p>
<ul>
<li>本线程已经获取过读锁，这次申请读锁是读锁的重入，不会返回-1，因为无论是否阻塞，如果一直都不能获取到读锁，那么它拥有的读锁一直不能释放，又因为读锁不能升级，可能会引起死锁。为了<strong>防止死锁</strong>让线程自旋竞争获取读锁</li>
</ul>
</li>
</ul>

        <h1 id="Java并发工具类"   >
          <a href="#Java并发工具类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java并发工具类" class="headerlink" title="Java并发工具类"></a>Java并发工具类</h1>
      
        <h2 id="Semaphore-信号量"   >
          <a href="#Semaphore-信号量" class="heading-link"><i class="fas fa-link"></i></a><a href="#Semaphore-信号量" class="headerlink" title="Semaphore-信号量"></a>Semaphore-信号量</h2>
      <p>Semaphore用于控制同时访问同一组资源的时候的并发工具，主要目标是控制并发访问的数量</p>

        <h3 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3>
      <p>1.假设一个餐厅有五个餐桌，那么餐桌总量为5个也即Semaphore(信号量)资源为5个，当餐桌总量为0的时候未能就餐的客人只能等待已经就餐的客人吃完，每有一个客人吃完那么就能迎接新的客人就餐</p>
<p>2.假设一个停车场只有五个车位，也即车位总量为5个，Semaphore(信号量)资源为5个，当车位为0的时候未能停车的客人只能等待已经停完车的客人挪车空出车位，每一个车辆离开停车场就放开一个车位</p>
<p>3.限制并发访问，当一个接口或者服务需要被保护，我们可以用Semaphore(信号量)来限制访问次数，Semaphore将超出限制次数的请求阻塞或者延迟</p>

        <h3 id="demo"   >
          <a href="#demo" class="heading-link"><i class="fas fa-link"></i></a><a href="#demo" class="headerlink" title="demo"></a>demo</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化有1个停车位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">initSemaphoreResources</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模拟场景：1.A、B、C三个线程来竞争停车位，因为停车位只有一个，那么只能有一个车获取到车位</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">parking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(initSemaphoreResources);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//线程A来竞争车位，假设它一共来回五次</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//等待两秒，等别的线程启动</span></span><br><span class="line">                    parking.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">1</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//模拟停车</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场&quot;</span>);</span><br><span class="line">                    parking.release();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//线程B来竞争车位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//等待两秒，等别的线程启动</span></span><br><span class="line">                    parking.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">1</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场&quot;</span>);</span><br><span class="line">                    parking.release();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程C来竞争车位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//等待两秒，等别的线程启动</span></span><br><span class="line">                    parking.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">1</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场&quot;</span>);</span><br><span class="line">                    parking.release();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//死循环，让主线程停在这里目的是让上面线程能完整完成任务</span></span><br><span class="line">        <span class="keyword">for</span>(;;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>





<p>测试结果：一个线程一个线程交替获得到车位，每隔一秒会释放车位，每次只能有一个线程获取到资源(因为初始化资源数为1)</p>
<p>例如</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A获取到车位</span><br><span class="line">线程A离开了停车场</span><br><span class="line">线程C获取到车位</span><br><span class="line">线程C离开了停车场</span><br><span class="line">线程B获取到车位</span><br><span class="line">线程B离开了停车场</span><br></pre></td></tr></table></div></figure>


        <h3 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码" class="headerlink" title="源码"></a>源码</h3>
      
        <h4 id="成员变量以及内部类-3"   >
          <a href="#成员变量以及内部类-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-3" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h4>
      
        <h5 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>


        <h5 id="Sync-2"   >
          <a href="#Sync-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync-2" class="headerlink" title="Sync"></a>Sync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化共享资源个数</span></span><br><span class="line">	Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            setState(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取资源</span></span><br><span class="line">        		<span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        		<span class="comment">//获取剩余资源量</span></span><br><span class="line">        		<span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        		<span class="comment">//如果余量为0(抢资源失败)或者CAS成功(抢资源成功)则结束循环</span></span><br><span class="line">        		<span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            		compareAndSetState(available, remaining))</span><br><span class="line">            </span><br><span class="line">            	<span class="comment">//当抢锁成功则返回大于等于0，如果抢锁是啊比则返回负数</span></span><br><span class="line">            	<span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前资源的状态字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//获取释放资源之后的下一个状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果释放资源之后资源还更少，那么就抛出错误</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS成功，则返回true结束死循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h5 id="NonfairSync-2"   >
          <a href="#NonfairSync-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#NonfairSync-2" class="headerlink" title="NonfairSync"></a>NonfairSync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);<span class="comment">//会走同步器中的非公平尝试获取资源方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="FairSync-2"   >
          <a href="#FairSync-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#FairSync-2" class="headerlink" title="FairSync"></a>FairSync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="构造方法-2"   >
          <a href="#构造方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="acquire-2"   >
          <a href="#acquire-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire-2" class="headerlink" title="acquire"></a>acquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);<span class="comment">//走AQS中的方法，然后tryAcquireShared会由子类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-3"   >
          <a href="#tryAcquireShared-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-3" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      
        <h5 id="非公平同步器-1"   >
          <a href="#非公平同步器-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#非公平同步器-1" class="headerlink" title="非公平同步器"></a>非公平同步器</h5>
      
        <h6 id="tryAcquireShared-4"   >
          <a href="#tryAcquireShared-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-4" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="nonfairTryAcquireShared"   >
          <a href="#nonfairTryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#nonfairTryAcquireShared" class="headerlink" title="nonfairTryAcquireShared"></a>nonfairTryAcquireShared</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//死循环不断抢锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取剩余资源量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//如果余量为0(抢资源失败)或者CAS成功(抢资源成功)则结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当抢锁成功则返回大于等于0，如果抢锁是啊比则返回负数</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="公平同步器-1"   >
          <a href="#公平同步器-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#公平同步器-1" class="headerlink" title="公平同步器"></a>公平同步器</h5>
      
        <h6 id="tryAcquireShared-5"   >
          <a href="#tryAcquireShared-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-5" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果同步队列存在，那么不能获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取剩余资源量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//如果余量为0(抢资源失败)或者CAS成功(抢资源成功)则结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当抢锁成功则返回大于等于0，如果抢锁是啊比则返回负数</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="release-3"   >
          <a href="#release-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#release-3" class="headerlink" title="release"></a>release</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);<span class="comment">//调用同步器的释放共享锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="tryReleaseShared-1"   >
          <a href="#tryReleaseShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReleaseShared-1" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前资源的状态字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//获取释放资源之后的下一个状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果释放资源之后资源还更少，那么就抛出错误</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS成功，则返回true结束死循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="CountDownLatch-闭锁"   >
          <a href="#CountDownLatch-闭锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch-闭锁"></a>CountDownLatch-闭锁</h2>
      <p>CountDownLatch可以叫闭锁，也是一个倒计数器。用于等待多个线程完成后继续执行的工具，主要用于多个线程完成执行后执行，如并行结果的手机</p>

        <h3 id="应用场景-1"   >
          <a href="#应用场景-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3>
      <p>1.假设有一个考场，那么有五个考生和一个考官，那么可以用CountDownLatch来模拟这个场景，当所有考生都交卷离开考场之后考官才能离开考场</p>
<p>2.假如你有一个公司，其中有四个员工并且只有你有钥匙，那么你只能等所有人都下班离开公司之后再锁门</p>
<p>3.假如一个测试有四个测试用例，那么只有当所有测试用例都执行完之后，主线程才能生成测试用例报告</p>
<p>4.假如你要办理资金申请，那么需要三个证明你能够有能力还清债务，只有当出示完全三个证明之后，贷款方才能给你提供资金</p>

        <h3 id="demo-1"   >
          <a href="#demo-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#demo-1" class="headerlink" title="demo"></a>demo</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">totalTeacher</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">//监考老师个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">totalStudent</span> <span class="operator">=</span> <span class="number">5</span>;	<span class="comment">//参加考试考生个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟场景：一个考场有五个学生一个老师，老师只有等所有考生都交卷之后才能收卷完成并且离开考场</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CountDownLatchDemoTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalTeacher);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalStudent);</span><br><span class="line">		<span class="comment">//老师线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经进入考场&quot;</span>);</span><br><span class="line">                LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//老师准备考场，并花时间等学生在考场外排队</span></span><br><span class="line">                teacher.countDown();<span class="comment">//表示老师已经进场</span></span><br><span class="line">                student.await();<span class="comment">//等待所有学生进场考试交卷</span></span><br><span class="line">                System.out.println(<span class="string">&quot;所有学生已经交卷,&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;开始收卷&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">		<span class="comment">//五个学生线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            	<span class="keyword">try</span> &#123;</span><br><span class="line">                	teacher.await();<span class="comment">//等待老师进场</span></span><br><span class="line">                	LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000L</span>);<span class="comment">//模拟学生做题，准备交卷</span></span><br><span class="line">                	student.countDown();</span><br><span class="line">                	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经交卷，正在离开考场&quot;</span>);</span><br><span class="line">            	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                	e.printStackTrace();</span><br><span class="line">            	&#125;</span><br><span class="line">        	&#125;,<span class="string">&quot;学生&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死循环不让主线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (;;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>测试结果：一个考场中有一名老师和五名学生，那么只有当五名学生都交卷之后，老师才能收卷离场，如果没有学生交卷那么老师就不能离场</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">老师已经进入考场</span><br><span class="line">学生<span class="number">2</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">3</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">5</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">4</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">1</span>已经交卷，正在离开考场</span><br><span class="line">所有学生已经交卷,老师开始收卷</span><br></pre></td></tr></table></div></figure>


        <h3 id="源码-1"   >
          <a href="#源码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3>
      
        <h4 id="成员变量以及内部类-4"   >
          <a href="#成员变量以及内部类-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-4" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>


        <h5 id="Sync-3"   >
          <a href="#Sync-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync-3" class="headerlink" title="Sync"></a>Sync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//设置资源数</span></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="构造方法-3"   >
          <a href="#构造方法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    	<span class="comment">//如果资源小于0，那么就报错资源不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="countDown"   >
          <a href="#countDown" class="heading-link"><i class="fas fa-link"></i></a><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用Sync中的释放共享资源</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryReleaseShared-2"   >
          <a href="#tryReleaseShared-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReleaseShared-2" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取资源数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果资源数等于0，那么就说明没有资源无法释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取倒计时的下一个状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果CAS成功则返回最后CountDownLatch是否到达0</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="await-2"   >
          <a href="#await-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#await-2" class="headerlink" title="await"></a>await</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);<span class="comment">//会走到AQS的方法，然后走tryAcquireShared从子类实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>AQS中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-6"   >
          <a href="#tryAcquireShared-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-6" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//返回是否倒计时到0，如果倒计时数到0返回1，不是0返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="CyclicBarrier-循环栅栏"   >
          <a href="#CyclicBarrier-循环栅栏" class="heading-link"><i class="fas fa-link"></i></a><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier-循环栅栏"></a>CyclicBarrier-循环栅栏</h2>
      <p>CyclicBarrier通常用于多个线程达到一个同步点之后，再一起执行后续操作。主要目标是等待多个线程在同一个同步点集合后再继续进行</p>

        <h3 id="应用场景-2"   >
          <a href="#应用场景-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3>
      <p>1.假如五个人去爬山，那么有人爬得快有人爬的慢，当爬到半山腰的时候所有人都集合，等待五个人到齐之后再往上爬山</p>
<p>2.假如四个人去购物，那么规定一个集合点，当四个人都到齐的情况之后再一起去逛街</p>
<p>3.假如一场田径比赛，按照离中心跑道越远的跑道在起跑的时候就会分到不同的起跑距离，当所有运动员、以及裁判都在自己对应的起跑线落位之后，裁判才能够吹哨发起比赛</p>
<p>4.假如一场音乐会演出，一个乐队有四个人家住不同地区，那么四个人都必须先到演唱会后台集合之后才能开始表演节目</p>
<p>5.假如进行一场王者荣耀或者英雄联盟，在发起比赛之前必须要五个人都点准备，那么才能进行游戏，如果人数不到五个人则不能进行游戏，需要重新匹配</p>

        <h3 id="demo-2"   >
          <a href="#demo-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#demo-2" class="headerlink" title="demo"></a>demo</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//一共五个人去购物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟一行人达到某个集合点之后才一起去购物</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CyclicBarrierDemoTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(totalNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经到达集合点，等待集合&quot;</span>);</span><br><span class="line">                    barrier.await();<span class="comment">//等待人集合</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;说集合完毕，一起去购物！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;美女&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//死循环，不让主线程结束</span></span><br><span class="line">        <span class="keyword">for</span>(;;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>测试结果：五个人一起去购物，那么只有当五个人都达到集合点之后，那么才会<strong>一起出发</strong>进行同样要做的事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">美女<span class="number">2</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">3</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">4</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">5</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">1</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">1</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">2</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">5</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">4</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">3</span>说集合完毕，一起去购物！</span><br></pre></td></tr></table></div></figure>


        <h3 id="源码-2"   >
          <a href="#源码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3>
      
        <h4 id="成员变量以及内部类-5"   >
          <a href="#成员变量以及内部类-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-5" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义还未达到集合点的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个生成器，用于表示栅栏</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一共参赛的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取trip条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></div></figure>


        <h5 id="Generation"   >
          <a href="#Generation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="构造方法-4"   >
          <a href="#构造方法-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="await-3"   >
          <a href="#await-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#await-3" class="headerlink" title="await"></a>await</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用dowait方法</span></span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="dowait"   >
          <a href="#dowait" class="heading-link"><i class="fas fa-link"></i></a><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取栅栏</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">			</span><br><span class="line">        <span class="comment">//如果栅栏已经被打断，那么抛出栅栏异常打断异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果发生线程中断，那么自己断开栅栏，抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//index表示还需等待的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">//如果还需要等待个数为0，也即马上可以出发</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//如果任务不为空，那么执行任务</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这次任务结束，唤醒条件队列所有结点，创建新的栅栏</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();<span class="comment">//断开栅栏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">//条件队列等待</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="breakBarrier"   >
          <a href="#breakBarrier" class="heading-link"><i class="fas fa-link"></i></a><a href="#breakBarrier" class="headerlink" title="breakBarrier"></a>breakBarrier</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">//唤醒条件队列中的全部线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="nextGeneration"   >
          <a href="#nextGeneration" class="heading-link"><i class="fas fa-link"></i></a><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//唤醒条件队列的全部结点</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="reset"   >
          <a href="#reset" class="heading-link"><i class="fas fa-link"></i></a><a href="#reset" class="headerlink" title="reset"></a>reset</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重新重置栅栏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  	<span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>到此关于AQS的所有内容已经结束</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">48</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">19</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Kkker1</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>