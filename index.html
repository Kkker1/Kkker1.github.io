<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="KkkerAn&#39;s Blog">
<meta property="og:url" content="https://username.github.io/index.html">
<meta property="og:site_name" content="KkkerAn&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KkkerAn">
<meta name="twitter:card" content="summary"><title>KkkerAn's Blog</title><link ref="canonical" href="https://username.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2024/10/15/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BAWLAN%E9%97%AE%E9%A2%98/">网络排查-无法正常显示WLAN问题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-10-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">891</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">4分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="情况背景"   >
          <a href="#情况背景" class="heading-link"><i class="fas fa-link"></i></a><a href="#情况背景" class="headerlink" title="情况背景"></a>情况背景</h1>
      <p>到生产环境中，由于工作需要所以突发性的需要用电脑连接网线，但是出现了问题：<strong>网络连接正常，无法连接网络</strong>。</p>

        <h2 id="网络属性"   >
          <a href="#网络属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络属性" class="headerlink" title="网络属性"></a>网络属性</h2>
      <p>网络属性一切正常，但是仍然出现异常网络问题</p>
<blockquote>
<p> DNS服务器以及分发到的IP地址成功获取&#96;</p>
</blockquote>
<p><strong>异常一</strong> ：无法Ping通已有局域网的设备IP</p>
<p><strong>异常二</strong>：无法Ping通公共网络IP地址，如<code>www.baidu.com</code>、<code>www.bilibili.com</code></p>
<p>但是仍然能Ping通DNS服务器也即交换机IP</p>

        <h2 id="排查过程"   >
          <a href="#排查过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2>
      <p>1、将网线端口重新拔插，验证是否与交换机网线端口相连，结果：端口与交换机正常相连</p>
<p>2、将LAN口的网线直接与交换机相连，结果：网线正常</p>
<p>3、将LAN口的网线直接与其他设备相连，结果：显示PING不通，但是设备依然能够联网</p>
<p>4、重新插入到本机，结果：<strong>依然不能联网</strong></p>
<p><strong>排查结果</strong>：网线、端口以及交换机正常，本机网络配置有问题</p>
<p>然后采用WLAN，尝试用无线连接互联网，结果是：<strong>已连接，但无法访问网络。安全</strong></p>
<p>此时才正式确定是我本机网络配置，也即网卡驱动异常导致</p>

        <h1 id="解决过程"   >
          <a href="#解决过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1>
      
        <h2 id="重启"   >
          <a href="#重启" class="heading-link"><i class="fas fa-link"></i></a><a href="#重启" class="headerlink" title="重启"></a>重启</h2>
      <p>古话说得好，重启能解决一切问题。然而，此次重启之后再连接无线网络，仍然无法访问网络</p>

        <h2 id="重新挂起-关闭-VPN"   >
          <a href="#重新挂起-关闭-VPN" class="heading-link"><i class="fas fa-link"></i></a><a href="#重新挂起-关闭-VPN" class="headerlink" title="重新挂起&#x2F;关闭 VPN"></a>重新挂起&#x2F;关闭 VPN</h2>
      <p>VPN没关可能会导致DNS解析错误，因此导致访问网络失败。但是本次并未解决完成</p>

        <h2 id="确定局域网网络配置是否是自动配置或者使用代理服务器"   >
          <a href="#确定局域网网络配置是否是自动配置或者使用代理服务器" class="heading-link"><i class="fas fa-link"></i></a><a href="#确定局域网网络配置是否是自动配置或者使用代理服务器" class="headerlink" title="确定局域网网络配置是否是自动配置或者使用代理服务器"></a>确定局域网网络配置是否是自动配置或者使用代理服务器</h2>
      <p>本次都是自动获取，所以本项没有进行</p>

        <h2 id="初始化网络环境"   >
          <a href="#初始化网络环境" class="heading-link"><i class="fas fa-link"></i></a><a href="#初始化网络环境" class="headerlink" title="初始化网络环境"></a>初始化网络环境</h2>
      <p>使用命令行代码，尝试初始化网络环境，然后设置成功后重启</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netsh winsock reset</span><br><span class="line">//用管理员身份的打开命令提示符(CMD),初始化网络环境</span><br></pre></td></tr></table></div></figure>


        <h2 id="重置网络"   >
          <a href="#重置网络" class="heading-link"><i class="fas fa-link"></i></a><a href="#重置网络" class="headerlink" title="重置网络"></a>重置网络</h2>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BAWLAN%E9%97%AE%E9%A2%98/%E9%87%8D%E5%90%AF%E7%BD%91%E7%BB%9C.JPG"  alt="重启网络">
      </p>
<p>重置网络待重启之后，<strong>发现WLAN标志消失，无法连接WIFI</strong></p>

        <h2 id="删除网卡驱动，重新获取网卡"   >
          <a href="#删除网卡驱动，重新获取网卡" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除网卡驱动，重新获取网卡" class="headerlink" title="删除网卡驱动，重新获取网卡"></a>删除网卡驱动，重新获取网卡</h2>
      <ul>
<li><p>打开设备管理器，选择网络适配器</p>
</li>
<li><p>选择卸载设备，<strong>取消勾选</strong>删除驱动 </p>
</li>
<li><p>重新点击扫描硬件改动</p>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BAWLAN%E9%97%AE%E9%A2%98/image-20241016005736933.png"  alt="卸载网卡，重新扫描">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E7%BD%91%E7%BB%9C%E6%8E%92%E6%9F%A5-%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BAWLAN%E9%97%AE%E9%A2%98/image-20241016005945348.png"  alt="扫描硬件改动">
      </p>

        <h2 id="更新网络驱动"   >
          <a href="#更新网络驱动" class="heading-link"><i class="fas fa-link"></i></a><a href="#更新网络驱动" class="headerlink" title="更新网络驱动"></a>更新网络驱动</h2>
      <ul>
<li>打开设备管理器，选择网络适配器</li>
<li>选择网卡驱动，更新驱动程序</li>
<li>选择浏览我的电脑以查找驱动程序</li>
<li>选择让我从计算机上可用驱动程序列表中获取</li>
<li>选择更新最新的驱动，随机等待更新完成</li>
</ul>

        <h2 id="尝试打开-关闭飞行模式"   >
          <a href="#尝试打开-关闭飞行模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#尝试打开-关闭飞行模式" class="headerlink" title="尝试打开&#x2F;关闭飞行模式"></a>尝试打开&#x2F;关闭飞行模式</h2>
      
        <h2 id="选择删除注册表内容"   >
          <a href="#选择删除注册表内容" class="heading-link"><i class="fas fa-link"></i></a><a href="#选择删除注册表内容" class="headerlink" title="选择删除注册表内容"></a>选择删除注册表内容</h2>
      <p>因为可能由于虚拟机改变了网卡设置，所以尝试删除注册表内容</p>
<blockquote>
<p> 此处学习了UP主：鸟人飞飞  所发出的视频，具体视频链接：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1HW4y1q7Kx/?spm_id_from=333.999.0.0&vd_source=481a97bdbe9fdb27ab06f7f88300d77b" >网卡错误代码56的解决方法及原因分析（无声）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<ul>
<li><p>如已经删除VM虚拟机，则执行以下指令删除注册表内容</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg delete HKCR\CLSID\&#123;3d09c1ca-2bcc-40b7-b9bb-3f3ec143a87b&#125; /f</span><br><span class="line">//以管理员身份运行CMD后，执行</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>如未删除VM虚拟机，则执行以下指令</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regsvr32 C:\WINDOWS\System32\vmnetbridge.dll</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>最终重启解决问题</p>
</li>
</ul>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>以上是我解决实际遇到的网卡驱动导致的联网问题，希望有遇到该类问题时能再回顾来看本篇记载，一步步排查问题并尽快解决</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2024/03/10/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%5B%E7%BC%93%E5%AD%98%5D/">系统架构设计-[缓存]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-03-10</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">352</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">2分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="MyBatis"   >
          <a href="#MyBatis" class="heading-link"><i class="fas fa-link"></i></a><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1>
      
        <h2 id="一级缓存"   >
          <a href="#一级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2>
      <p>在<code>MyBatis</code>中的一级缓存是指在同一个<code>sqlSession</code>中执行同样的语句，会优先去命中一级缓存。避免多次同样的查询直接击中数据库</p>

        <h3 id="如何使用一级缓存"   >
          <a href="#如何使用一级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用一级缓存" class="headerlink" title="如何使用一级缓存"></a>如何使用一级缓存</h3>
      <p>当我们使用<code>MyBatis</code>时可以设置参数<code>local-cache-scope</code></p>
<ul>
<li>session：同一个session会添加一级缓存</li>
<li>statement：<strong>默认级别</strong>，添加的缓存仅对当前执行的<code>statement</code>有效</li>
</ul>
<p><code>application.yml</code>中配置session级别</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    local-cache-scope: session </span><br></pre></td></tr></table></div></figure>

<p><code>application.yml</code>中配置statement级别</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">  configuration:</span><br><span class="line">    local-cache-scope: statement</span><br></pre></td></tr></table></div></figure>




        <h3 id="缓存的属性"   >
          <a href="#缓存的属性" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存的属性" class="headerlink" title="缓存的属性"></a>缓存的属性</h3>
      
        <h4 id="生命周期"   >
          <a href="#生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4>
      <p>生命周期和<code>sqlSession</code>一致，当会话开启产生一级缓存，当会话结束关闭一级缓存</p>

        <h4 id="存储形式"   >
          <a href="#存储形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储形式" class="headerlink" title="存储形式"></a>存储形式</h4>
      <p>一级缓存通过<code>HashMap</code>的设置，实际上通过<code>HashMap</code>实现缓存</p>

        <h4 id="刷新周期"   >
          <a href="#刷新周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#刷新周期" class="headerlink" title="刷新周期"></a>刷新周期</h4>
      <p>一级缓存的刷新<strong>只能</strong>对数据有所更改的时候刷新（增删改）。所以如果使用一级缓存，在会话没有关闭之前没有进行增删改手动刷新一级缓存，那么就可能会产生脏数据</p>

        <h2 id="二级缓存"   >
          <a href="#二级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2>
      <p>二级缓存是全局的，相较于一级缓存只能在同一个SqlSession中，二级缓存的作用范围更加广泛</p>

        <h3 id="如何使用二级缓存"   >
          <a href="#如何使用二级缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何使用二级缓存" class="headerlink" title="如何使用二级缓存"></a>如何使用二级缓存</h3>
      <p>二级缓存的使用可以通过<code>xml</code>文件中添加<code>&lt;cache/&gt;</code>，如此一来就能启动二级缓存</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/12/31/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">2023年度总结</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-12-31</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">287</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>我这飘忽不定的2023年</strong></p>
<hr>
<p> 今年不知从何处来，也不知往何处去。从年初的闭关却陷入体育生沉淀之途，年中杭州之行的失败尝试，再到年底的秋招无果之旅，仿佛说明我这一年的失败是必然而成的。</p>
<p><strong>未完成的任务</strong></p>
<hr>
<p>我还有好几篇文章还没写完。</p>
<p>【深入剖析并发编程】我还有并发容器等还没能补全</p>
<p>【死之前要学完的算法】我还有算法题还没能做完，但从十二月份的失败之后就开始停摆了，在2024年前我得重启任务</p>
<p>【面试题】部分我还有特别多篇没有写完</p>
<p>【Java基础】我还没重新看起</p>
<p>【项目】还没能全部写完</p>
<p><strong>对未来的展望</strong></p>
<hr>
<p>首当其冲的就是先把今年未能完成的任务补完，然后是继续启动算法任务。</p>
<p>其次就是在哪里失败就在哪里爬起来，继续沉淀</p>
<p>第三就是好好生活，好好吃饭</p>
<p>明年会变的更好，一步步往前走，是往前就好</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/11/06/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B7-%E7%BA%BF%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%5D/">深入剖析并发编程-JUC篇[7-线程、线程池]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-11-06</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">101分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>本篇是进程、线程、多线程详解</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
<li>第四篇是Atomic原子包源码详解</li>
<li>第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC并发工具包</li>
<li>第六篇是并发容器</li>
<li>第七篇是进程、线程、线程池</li>
</ul>
<hr>

        <h1 id="线程"   >
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程" class="headerlink" title="线程"></a>线程</h1>
      
        <h2 id="基础概念"   >
          <a href="#基础概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2>
      
        <h3 id="进程"   >
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程" class="headerlink" title="进程"></a>进程</h3>
      <p>进程是也就是平时所说的程序，是系统运行程序的基本单位。进程是用于加载指令、管理内存、管理IO的，是系统中运行的程序的独立实例。</p>
<p>进程也是<strong>系统分配资源的基本单位</strong>，也即系统分配资源以进程为单位分配资源。</p>

        <h3 id="线程-1"   >
          <a href="#线程-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3>
      <p>线程又叫<strong>轻量级进程</strong>，是进程内的执行单位，一个进程可以包含多个线程。</p>
<p>线程也是<strong>操作系统调度(CPU调度)的执行的最小单位</strong></p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>两者关系：线程是进程内的执行单元，一个进程可以包含多个线程</li>
<li>资源隔离：<ul>
<li>进程：进程是高度资源隔离的，一个进程崩溃通常不会影响其他进程</li>
<li>线程：线程有共享的内存单元，一个线程崩溃可能会影响整个进程</li>
</ul>
</li>
<li>通信<ul>
<li>进程：进程之间相互独立，具有较高的隔离性所以进程之间通信是在面对多进程场景下的需要<ul>
<li><strong>管道</strong><ul>
<li>管道应用在具有亲缘关系的父子进程之间的通信（单向通信，由父进程写子进程接收）</li>
<li>命名管道：可以应用在无亲缘关系的进程通信（双向通信）</li>
</ul>
</li>
<li><strong>消息队列</strong>：允许进程之间异步通信</li>
<li><strong>共享内存</strong>：多个进程指向同一块内存区域，这也是最快速和高效的通信方式</li>
<li><strong>信号(singal)</strong> ：用于进程之间的异步通新，一个进程通知另一个进程某些事情发生，如进程中断、终止或者其他</li>
<li><strong>信号量(Semaphore)</strong> ：信号量是用于控制多个进程之间访问同一个资源的方式</li>
<li><strong>套接字(socket)<strong>：通常用于网络通信，也可以用于进程之间的通信。</strong>这一方式更常用于进程中通信</strong></li>
</ul>
</li>
<li>线程：线程之间有共享的内存单元而进行线程之间通信有以下几种方法:<ul>
<li><strong>共享内存</strong>：多个线程之间有共享相同的内存区域，所以这是最快速和高效的通信方式</li>
<li><strong>消息队列</strong>：通过消息队列发送消息以及接收消息，实现异步通信</li>
<li><strong>互斥锁</strong>：用互斥锁来保护共享资源</li>
<li><strong>信号量</strong>：可以用信号量来控制资源访问和释放的同步机制，类似生产者-消费者环境</li>
<li><strong>套接字(socket)<strong>：如果线程在不同计算机或者不同进程中，可以使用socket通信。</strong>这一方式更多用于进程中通信</strong></li>
</ul>
</li>
</ul>
</li>
<li>并发性<ul>
<li>进程：进程隔离性较高、相互独立，所以并发性较低</li>
<li>线程：线程共享进程内的内存空间，并发性较高</li>
</ul>
</li>
<li>开销<ul>
<li>进程：创建和销毁以及进程之间切换具有较高的系统开销</li>
<li>线程：创建和销毁以及线程之间切换较小的系统开销，也即叫<strong>轻量级进程</strong></li>
</ul>
</li>
</ul>

        <h3 id="协程"   >
          <a href="#协程" class="heading-link"><i class="fas fa-link"></i></a><a href="#协程" class="headerlink" title="协程"></a><strong>协程</strong></h3>
      <p>协程又叫<strong>轻量级线程</strong>，由程序管理的轻量级线程，对于内核态是不可见的。正如线程和进程的关系，一个线程可以由多个协程</p>

        <h2 id="生命周期"   >
          <a href="#生命周期" class="heading-link"><i class="fas fa-link"></i></a><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2>
      <p>操作系统中的线程生命周期一共有五种状态：<strong>新建状态、就绪状态（可运行状态）、运行状态、阻塞状态、结束状态</strong></p>
<p>如图所示</p>
<blockquote>
<p> 操作系统中线程生命周期</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106203624571.png"  alt="操作系统中线程生命周期">
      </p>
<p>而java中有Thread类也即线程类，这里的生命周期和我们操作系统中定义的生命周期五种状态有一部分区别</p>
<p>我们从<code>Thread.java</code>中直接找到这部分源码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        NEW,	<span class="comment">//创建状态</span></span><br><span class="line">        </span><br><span class="line">        RUNNABLE,<span class="comment">//可运行状态（对应操作系统中的就绪态和运行态）</span></span><br><span class="line">        </span><br><span class="line">        BLOCKED,<span class="comment">//阻塞状态</span></span><br><span class="line"></span><br><span class="line">        WAITING,<span class="comment">//等待状态</span></span><br><span class="line"></span><br><span class="line">        TIMED_WAITING,<span class="comment">//等待超时状态</span></span><br><span class="line"></span><br><span class="line">        TERMINATED;<span class="comment">//终止状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略部分源码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Thread类中的线程运行状态枚举：</p>
<ul>
<li><u>NEW</u>：线程新建状态</li>
<li><u>RUNNABLE</u>：线程可运行状态（对应就绪态和运行态），也即就绪态和运行态在java中是合并在一起的</li>
<li><u>BLOCKED</u>：线程阻塞状态，等待锁的释放（竞争Synchronized锁失败，进入阻塞状态或者wait被唤醒之后获取Synchronized锁失败），·<em>这个状态针对Synchronized锁</em></li>
<li><u>WAITING</u>：线程等待状态，处于等待状态的线程等待另一个线程执行特定操作。可以由以下方法进入此状态<ul>
<li><strong>Object.wait()</strong> ：等待其他线程调用Object.notify()或者Object.notifyAll()唤醒</li>
<li><strong>Thread.join()</strong> ：等待指定线程结束</li>
<li><strong>LockSupport.park()</strong> ：等待线程调用LockSupport.unpark()</li>
</ul>
</li>
<li><u>TIMED_WAITING</u>：线程超时等待状态，处于指定等待时间的线程状态。可以由以下方法进入此状态<ul>
<li><strong>Thread.sleep(long)</strong> ：超出指定时间之后会结束此状态</li>
<li><strong>Object.wait(long)</strong> ：超出指定时间或者Object.motify()或者Object.notifyAll()唤醒</li>
<li><strong>LockSupport.parkNanos(long)</strong> ：超出等待时间或者LockSupport.unpark(Thread)唤醒</li>
<li><strong>LockSupport.parkUntil(long)</strong> ：超出等待时间或者LockSupport.unpark(Thread)唤醒</li>
<li><strong>Thread.join(long)</strong> ：等待指定线程结束（规定时间内）或者超出指定时间之后会结束此状态</li>
</ul>
</li>
<li><u>TERMINATED</u> ：线程终止状态</li>
</ul>
<p>也即Java中线程生命周期如下图所示</p>
<blockquote>
<p>Java中线程生命周期</p>
</blockquote>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231106214636721.png"  alt="Java中线程生命周期">
      </p>
<p><strong>小结</strong></p>
<p>因此，在Java中线程的生命周期中一共有6种状态：<strong>新建状态、可运行状态、阻塞状态、等待状态、超时等待状态、结束状态</strong></p>
<p>和操作系统中线程生命周期相比，可运行状态包含了就绪态和运行态，阻塞状态更为细致地分成了阻塞状态、等待状态、超时等待状态</p>

        <h2 id="创建线程"   >
          <a href="#创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2>
      <blockquote>
<p> 在之前我写了一篇文章来谈到创建线程的方式——浅谈java中创建线程，在这里我们还是要用到创建线程的知识</p>
</blockquote>
<p>我们创建线程有以下几种方式</p>
<ol>
<li>创建Thread或者创建继承Thread类的子类</li>
<li>Runnable接口的实现类</li>
<li>Callable接口的实现类，需要利用FutureTask类</li>
<li>lambda表达式中匿名内部类创建线程</li>
<li>线程池创建线程</li>
</ol>

        <h3 id="第一种、直接创建新线程"   >
          <a href="#第一种、直接创建新线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一种、直接创建新线程" class="headerlink" title="第一种、直接创建新线程"></a>第一种、直接创建新线程</h3>
      <p>创建Thread或者创建继承Thread类的子类</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我重写了run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">newThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();<span class="comment">//调用start()方法创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第二种、Runnable接口的实现类"   >
          <a href="#第二种、Runnable接口的实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二种、Runnable接口的实现类" class="headerlink" title="第二种、Runnable接口的实现类"></a>第二种、Runnable接口的实现类</h3>
      <p>利用Runnable的实现类传入到<code>new Thread()</code>方法中的参数实现创建线程</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我重写了Runnable中的run方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implRunnableDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());<span class="comment">//创建Thread类传入自己实现的Runnable实现类对象</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第三种、Callable接口的实现类"   >
          <a href="#第三种、Callable接口的实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三种、Callable接口的实现类" class="headerlink" title="第三种、Callable接口的实现类"></a>第三种、Callable接口的实现类</h3>
      <p>我们知道在创建线程的时候因为前两种的Run()方法返回值都是void，也即无返回值。而我们在部分场景中需要某个线程的执行结果，我们就可以用Callable实现类，利用FutureTask来<strong>获取到线程的执行结果</strong></p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">implCallableDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MyCallable</span> <span class="variable">myCallable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(myCallable);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将任务传入到Thread的构造函数中</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = task.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="第四种、lambda表达式创建线程"   >
          <a href="#第四种、lambda表达式创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四种、lambda表达式创建线程" class="headerlink" title="第四种、lambda表达式创建线程"></a>第四种、lambda表达式创建线程</h3>
      <p>lambda表达式实际上就是匿名内部类，实现了Runnable接口</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambdaThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="第五种、线程池创建线程"   >
          <a href="#第五种、线程池创建线程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五种、线程池创建线程" class="headerlink" title="第五种、线程池创建线程"></a>第五种、线程池创建线程</h3>
      <p>样例：我们可以调用<code>Executors</code>工具类调用默认的线程工厂创建线程，而线程池相关代码我们到线程池那再继续开展</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadDemo</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ThreadPoolCreateDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Executors.defaultThreadFactory().newThread(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我重写了Run方法&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <p>这五种方法本质上都是一个方式创建线程，都是实现了Runnable接口之后调用new Thread()方法创建线程对象，然后调用Thread.start()方法创建线程</p>

        <h4 id="Thread类"   >
          <a href="#Thread类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;...&#125; <span class="comment">//实现Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="Runnable接口实现类"   >
          <a href="#Runnable接口实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Runnable接口实现类" class="headerlink" title="Runnable接口实现类"></a>Runnable接口实现类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span>  <span class="title class_">Runnable</span>&#123;...&#125; <span class="comment">//实现了Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="Callable接口实现类"   >
          <a href="#Callable接口实现类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Callable接口实现类" class="headerlink" title="Callable接口实现类"></a>Callable接口实现类</h4>
      <p>因为Callable接口实现类需要用到FutureTask类，而在FutureTask类中实现了RunnableFuture接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;...&#125;<span class="comment">//实现了RunnableFuture接口</span></span><br></pre></td></tr></table></div></figure>

<p>而在RunnableFuture接口中又实现了Runnable接口和Future接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;...&#125;<span class="comment">//实现了Runnable接口</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="lambda表达式"   >
          <a href="#lambda表达式" class="heading-link"><i class="fas fa-link"></i></a><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4>
      <p>lambda表达式的匿名内部类实际上就是匿名Runnable接口的实现类，所以本质上也是实现了Runnable接口</p>

        <h4 id="线程池"   >
          <a href="#线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4>
      <p>线程池的线程工厂需要我们传入一个Runnable实现类对象，也即我们需要实现Runnable接口</p>
<p><strong>而这样实际上都是实现Runnable接口然后调用new Thread()方法创建线程对象</strong>，那我们常说的启动线程的Start()方法和直接调用run()方法具有区别，直接调用Run()方法是不会创建新的线程，这又是怎么一回事呢？这需要我们接下来理解线程的常见方法</p>

        <h3 id="常用方法"   >
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3>
      
        <h4 id="sleep"   >
          <a href="#sleep" class="heading-link"><i class="fas fa-link"></i></a><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></div></figure>

<p>我们知道native方法是需要看c++代码的，所以我们从方法注册表中找到cpp中对应的方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_StartThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isAlive&quot;</span>,          <span class="string">&quot;()Z&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_IsThreadAlive&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;suspend0&quot;</span>,         <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_SuspendThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;resume0&quot;</span>,          <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_ResumeThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setPriority0&quot;</span>,     <span class="string">&quot;(I)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_SetThreadPriority&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">&quot;sleep&quot;</span>,            <span class="string">&quot;(J)V&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_Sleep&#125;, <span class="comment">//这就是我们要找到的sleep方法对应关系</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">&quot;currentThread&quot;</span>,    <span class="string">&quot;()&quot;</span> THD,     (<span class="type">void</span> *)&amp;JVM_CurrentThread&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;countStackFrames&quot;</span>, <span class="string">&quot;()I&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_CountStackFrames&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;isInterrupted&quot;</span>,    <span class="string">&quot;(Z)Z&quot;</span>,       (<span class="type">void</span> *)&amp;JVM_IsInterrupted&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;holdsLock&quot;</span>,        <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)Z&quot;</span>, (<span class="type">void</span> *)&amp;JVM_HoldsLock&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;getThreads&quot;</span>,        <span class="string">&quot;()[&quot;</span> THD,   (<span class="type">void</span> *)&amp;JVM_GetAllThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;dumpThreads&quot;</span>,      <span class="string">&quot;([&quot;</span> THD <span class="string">&quot;)[[&quot;</span> STE, (<span class="type">void</span> *)&amp;JVM_DumpThreads&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;setNativeName&quot;</span>,    <span class="string">&quot;(&quot;</span> STR <span class="string">&quot;)V&quot;</span>, (<span class="type">void</span> *)&amp;JVM_SetNativeThreadName&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p>JVM.cpp中JVM_Sleep方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_Sleep</span>(JNIEnv* env, jclass threadClass, jlong millis))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_Sleep&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果休眠时间为负数，则抛出异常，时间不能是负数</span></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>(), <span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果休眠被中断过，则抛出异常，休眠被中断</span></span><br><span class="line">  <span class="keyword">if</span> (Thread::<span class="built_in">is_interrupted</span> (THREAD, <span class="literal">true</span>) &amp;&amp; !HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>(), <span class="string">&quot;sleep interrupted&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//记录现场</span></span><br><span class="line">  <span class="function">JavaThreadSleepState <span class="title">jtss</span><span class="params">(thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__begin, millis);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_SLEEP_BEGIN</span>(</span><br><span class="line">                             millis);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  EventThreadSleep event;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ConvertSleepToYield) &#123;</span><br><span class="line">      <span class="comment">//调用yield()方法，让出CPU</span></span><br><span class="line">      os::<span class="built_in">yield</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ThreadState old_state = thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">      thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(SLEEPING);</span><br><span class="line">      os::<span class="built_in">sleep</span>(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">      thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ThreadState old_state = thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(SLEEPING);</span><br><span class="line">    <span class="keyword">if</span> (os::<span class="built_in">sleep</span>(thread, millis, <span class="literal">true</span>) == OS_INTRPT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!HAS_PENDING_EXCEPTION) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">          <span class="comment">//休眠</span></span><br><span class="line">          event.<span class="built_in">set_time</span>(millis);</span><br><span class="line">          event.<span class="built_in">commit</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">        <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__end,<span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="built_in">HOTSPOT_THREAD_SLEEP_END</span>(</span><br><span class="line">                                 <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">        <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_InterruptedException</span>(), <span class="string">&quot;sleep interrupted&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    thread-&gt;<span class="built_in">osthread</span>()-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="built_in">should_commit</span>()) &#123;</span><br><span class="line">    event.<span class="built_in">set_time</span>(millis);</span><br><span class="line">    event.<span class="built_in">commit</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE1</span>(hotspot, thread__sleep__end,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_SLEEP_END</span>(</span><br><span class="line">                           <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事：</p>
<ul>
<li>调用<code>yield()</code>方法让出CPU</li>
<li>休眠，时长为：<code>millis</code></li>
</ul>

        <h4 id="start"   >
          <a href="#start" class="heading-link"><i class="fas fa-link"></i></a><a href="#start" class="headerlink" title="start"></a>start</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) <span class="comment">//校验线程是否已经初始化完成(准备好进入就绪态)，如果没有初始化完成则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">        group.add(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>在这里最关键的是<code>start0()</code>方法，也即这个方法应该和创建线程关联</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>而这又是native方法，我们只能找到cpp源码中的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;start0&quot;</span>,           <span class="string">&quot;()V&quot;</span>,        (<span class="keyword">void</span> *)&amp;JVM_StartThread&#125;,<span class="comment">//这就是我们要找到的start0方法对应关系</span></span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>JVM.cpp</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StartThread</span>(JNIEnv* env, jobject jthread))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StartThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//命名一个本地线程变量 所以创建的线程和JavaThread有关系</span></span><br><span class="line">  JavaThread *native_thread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> throw_illegal_thread_state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLocker <span class="title">mu</span><span class="params">(Threads_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (java_lang_Thread::<span class="built_in">thread</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      throw_illegal_thread_state = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      jlong size =</span><br><span class="line">             java_lang_Thread::<span class="built_in">stackSize</span>(JNIHandles::<span class="built_in">resolve_non_null</span>(jthread));</span><br><span class="line">      <span class="type">size_t</span> sz = size &gt; <span class="number">0</span> ? (<span class="type">size_t</span>) size : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//创建了一个JavaThread对象和native_thread绑定也即创建本地线程和C++线程结构绑定</span></span><br><span class="line">      <span class="comment">//而其中这个参数&amp;thread_entry也是一个方法</span></span><br><span class="line">      native_thread = <span class="keyword">new</span> <span class="built_in">JavaThread</span>(&amp;thread_entry, sz);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">//JVM线程创建成功之后和JAVA线程绑定</span></span><br><span class="line">        native_thread-&gt;<span class="built_in">prepare</span>(jthread);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_illegal_thread_state) &#123;</span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_IllegalThreadStateException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(native_thread != <span class="literal">NULL</span>, <span class="string">&quot;Starting null thread?&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果创建了空线程，那么说明无法</span></span><br><span class="line">  <span class="keyword">if</span> (native_thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> native_thread;</span><br><span class="line">    <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_resource_exhausted</span>()) &#123;</span><br><span class="line">      JvmtiExport::<span class="built_in">post_resource_exhausted</span>(</span><br><span class="line">        JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,</span><br><span class="line">        <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_OutOfMemoryError</span>(),</span><br><span class="line">              <span class="string">&quot;unable to create new native thread&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定成功之后调用start方法启动线程</span></span><br><span class="line">  Thread::<span class="built_in">start</span>(native_thread);</span><br><span class="line"></span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li><p>创建<code>JavaThread</code>对象，调用<code>	thread_entry</code>也即线程入口</p>
</li>
<li><p>线程创建之后<code>JavaThread</code>对象和真正创建的线程绑定</p>
</li>
<li><p>调用<code>start</code>方法启动线程</p>
</li>
</ul>
<p>JavaThread对象</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaThread</span>: <span class="keyword">public</span> Thread &#123;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">VMStructs</span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  JavaThread*    _next;                          <span class="comment">// The next thread in the Threads list</span></span><br><span class="line">  oop            _threadObj;                     <span class="comment">// The Java level thread object</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="built_in">JavaThread</span>(ThreadFunction entry_point, <span class="type">size_t</span> stack_size = <span class="number">0</span>); <span class="comment">//构造函数</span></span><br><span class="line">  <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>线程入口</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> &#123;</span><br><span class="line">  HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">  Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">  JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),</span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>操作系统内核创建线程，调用pthread_create方法创建操作系统真正的线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作系统内核创建线程，调用pthread_create方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">os::create_thread</span><span class="params">(Thread* thread, ThreadType thr_type, <span class="type">size_t</span> stack_size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(thread-&gt;<span class="built_in">osthread</span>() == <span class="literal">NULL</span>, <span class="string">&quot;caller responsible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate the OSThread object</span></span><br><span class="line">  OSThread* osthread = <span class="keyword">new</span> <span class="built_in">OSThread</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (osthread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_thread_type</span>(thr_type);</span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_state</span>(ALLOCATED);</span><br><span class="line"></span><br><span class="line">  thread-&gt;<span class="built_in">set_osthread</span>(osthread);</span><br><span class="line">    </span><br><span class="line">  <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">  <span class="built_in">pthread_attr_init</span>(&amp;attr);</span><br><span class="line">  <span class="built_in">pthread_attr_setdetachstate</span>(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stack size</span></span><br><span class="line">  <span class="keyword">if</span> (os::Linux::<span class="built_in">supports_variable_stack_size</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stack_size == <span class="number">0</span>) &#123;</span><br><span class="line">      stack_size = os::Linux::<span class="built_in">default_stack_size</span>(thr_type);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">switch</span> (thr_type) &#123;</span><br><span class="line">      <span class="keyword">case</span> os::java_thread:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span> (JavaThread::<span class="built_in">stack_size_at_create</span>() &gt; <span class="number">0</span>, <span class="string">&quot;this should be set&quot;</span>);</span><br><span class="line">        stack_size = JavaThread::<span class="built_in">stack_size_at_create</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> os::compiler_thread:</span><br><span class="line">        <span class="keyword">if</span> (CompilerThreadStackSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          stack_size = (<span class="type">size_t</span>)(CompilerThreadStackSize * K);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">      <span class="keyword">case</span> os::vm_thread:</span><br><span class="line">      <span class="keyword">case</span> os::pgc_thread:</span><br><span class="line">      <span class="keyword">case</span> os::cgc_thread:</span><br><span class="line">      <span class="keyword">case</span> os::watcher_thread:</span><br><span class="line">        <span class="keyword">if</span> (VMThreadStackSize &gt; <span class="number">0</span>) stack_size = (<span class="type">size_t</span>)(VMThreadStackSize * K);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack_size = <span class="built_in">MAX2</span>(stack_size, os::Linux::min_stack_allowed);</span><br><span class="line">    <span class="built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pthread_attr_setguardsize</span>(&amp;attr, os::Linux::<span class="built_in">default_guard_size</span>(thr_type));</span><br><span class="line"></span><br><span class="line">  ThreadState state;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">bool</span> lock = os::Linux::<span class="built_in">is_LinuxThreads</span>() &amp;&amp; !os::Linux::<span class="built_in">is_floating_stack</span>();</span><br><span class="line">    <span class="comment">//创建线程先上锁，如果上锁了则到达线程安全点开始创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">      os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">lock_without_safepoint_check</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="comment">//调用pthread_create()方法创建线程</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pthread_create</span>(&amp;tid, &amp;attr, (<span class="type">void</span>* (*)(<span class="type">void</span>*)) java_start, thread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_attr_destroy</span>(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintMiscellaneous &amp;&amp; (Verbose || WizardMode)) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pthread_create()&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      thread-&gt;<span class="built_in">set_osthread</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">if</span> (lock) os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    osthread-&gt;<span class="built_in">set_pthread_id</span>(tid);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      Monitor* sync_with_child = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line">      <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//等待子线程初始化完成或者中止</span></span><br><span class="line">      <span class="keyword">while</span> ((state = osthread-&gt;<span class="built_in">get_state</span>()) == ALLOCATED) &#123;</span><br><span class="line">        sync_with_child-&gt;<span class="built_in">wait</span>(Mutex::_no_safepoint_check_flag);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">      os::Linux::<span class="built_in">createThread_lock</span>()-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (state == ZOMBIE) &#123;</span><br><span class="line">      thread-&gt;<span class="built_in">set_osthread</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="keyword">delete</span> osthread;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//线程处于初始化完成状态</span></span><br><span class="line">  <span class="built_in">assert</span>(state == INITIALIZED, <span class="string">&quot;race condition&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>调用<code>pthread_create</code>函数，让操作系统创建线程</li>
<li>线程创建完成之后调用<code>java_start</code>方法初始化线程</li>
<li>等待子线程创建完成或者中止</li>
</ul>
<p>我们知道线程创建之后要初始化，而线程初始化则关键在java_start方法中</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">java_start</span><span class="params">(Thread *thread)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> pid = os::<span class="built_in">current_process_id</span>();</span><br><span class="line">  <span class="built_in">alloca</span>(((pid ^ counter++) &amp; <span class="number">7</span>) * <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">  ThreadLocalStorage::<span class="built_in">set_thread</span>(thread);</span><br><span class="line"></span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  Monitor* sync = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_thread_safety_check(thread)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">    osthread-&gt;<span class="built_in">set_state</span>(ZOMBIE);</span><br><span class="line">    sync-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  osthread-&gt;<span class="built_in">set_thread_id</span>(os::Linux::<span class="built_in">gettid</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (UseNUMA) &#123;</span><br><span class="line">    <span class="type">int</span> lgrp_id = os::<span class="built_in">numa_get_group_id</span>();</span><br><span class="line">    <span class="keyword">if</span> (lgrp_id != <span class="number">-1</span>) &#123;</span><br><span class="line">      thread-&gt;<span class="built_in">set_lgrp_id</span>(lgrp_id);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  os::Linux::<span class="built_in">hotspot_sigmask</span>(thread);</span><br><span class="line"></span><br><span class="line">  os::Linux::<span class="built_in">init_thread_fpu_state</span>();</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程为初始化完成</span></span><br><span class="line">    osthread-&gt;<span class="built_in">set_state</span>(INITIALIZED);</span><br><span class="line">    <span class="comment">//唤醒所有线程</span></span><br><span class="line">    sync-&gt;<span class="built_in">notify_all</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋判断线程是否是初始化完成</span></span><br><span class="line">    <span class="keyword">while</span> (osthread-&gt;<span class="built_in">get_state</span>() == INITIALIZED) &#123;</span><br><span class="line">      sync-&gt;<span class="built_in">wait</span>(Mutex::_no_safepoint_check_flag);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//线程被notify/notifyAll唤醒执行run方法</span></span><br><span class="line">  thread-&gt;<span class="built_in">run</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>初始化线程</li>
<li>当初始化线程完成之后设置线程生命状态：<strong>INITIALIZED</strong></li>
<li><code>notify_all()</code>唤醒线程</li>
<li><code>wait()</code>挂起线程，使其初始化完成</li>
<li>线程被唤醒之后调用<code>thread_run()</code>方法</li>
</ul>
<p>绑定线程成功之后调用start方法</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Thread::start</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">trace</span>(<span class="string">&quot;start&quot;</span>, thread);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!DisableStartThread) &#123;</span><br><span class="line">    <span class="keyword">if</span> (thread-&gt;<span class="built_in">is_Java_thread</span>()) &#123;</span><br><span class="line">      java_lang_Thread::<span class="built_in">set_thread_status</span>(((JavaThread*)thread)-&gt;<span class="built_in">threadObj</span>(),</span><br><span class="line">                                          java_lang_Thread::RUNNABLE);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//调用具体操作系统对应的启动线程方法</span></span><br><span class="line">    os::<span class="built_in">start_thread</span>(thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>调用操作系统启动线程</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// guard suspend/resume</span></span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(thread-&gt;SR_lock(), Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="comment">//将线程设置成Runnable状态</span></span><br><span class="line">  osthread-&gt;<span class="built_in">set_state</span>(RUNNABLE);</span><br><span class="line">  <span class="comment">//调用方法去唤醒线程</span></span><br><span class="line">  <span class="built_in">pd_start_thread</span>(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::pd_start_thread</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  OSThread * osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="built_in">assert</span>(osthread-&gt;<span class="built_in">get_state</span>() != INITIALIZED, <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line">  Monitor* sync_with_child = osthread-&gt;<span class="built_in">startThread_lock</span>();</span><br><span class="line">  <span class="function">MutexLockerEx <span class="title">ml</span><span class="params">(sync_with_child, Mutex::_no_safepoint_check_flag)</span></span>;</span><br><span class="line">  <span class="comment">//唤醒线程，使其能够去执行run方法</span></span><br><span class="line">  sync_with_child-&gt;<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="run"   >
          <a href="#run" class="heading-link"><i class="fas fa-link"></i></a><a href="#run" class="headerlink" title="run"></a>run</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为Thread类中实现了Runnable接口，所以重写了run方法</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果有具体的任务，那么就调用具体任务的run方法(我们重写的run方法)</span></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Runnable接口实现类,具体线程需要做的内容</span></span><br><span class="line">	<span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></div></figure>



<p>而在操作系统之后创建了线程那么如何执行run方法的呢？</p>
<p>我们找到thread.cpp中的run方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::run() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化一些数据</span></span><br><span class="line">  <span class="built_in">this</span>-&gt;initialize_tlab();</span><br><span class="line">  <span class="built_in">this</span>-&gt;record_base_of_stack_pointer();</span><br><span class="line">  <span class="built_in">this</span>-&gt;record_stack_base_and_size();</span><br><span class="line">  <span class="built_in">this</span>-&gt;initialize_thread_local_storage();</span><br><span class="line">  <span class="built_in">this</span>-&gt;create_stack_guard_pages();</span><br><span class="line">  <span class="built_in">this</span>-&gt;cache_global_variables();</span><br><span class="line"></span><br><span class="line">  ThreadStateTransition::transition_and_fence(<span class="built_in">this</span>, _thread_new, _thread_in_vm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="built_in">this</span>, <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">assert</span>(!Thread::current()-&gt;owns_locks(), <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  DTRACE_THREAD_PROBE(start, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>-&gt;set_active_handles(JNIHandleBlock::allocate_block());</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::should_post_thread_life()) &#123;</span><br><span class="line">    JvmtiExport::post_thread_start(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  EventThreadStart event;</span><br><span class="line">  <span class="keyword">if</span> (event.should_commit()) &#123;</span><br><span class="line">     event.set_javalangthread(java_lang_Thread::thread_id(<span class="built_in">this</span>-&gt;threadObj()));</span><br><span class="line">     event.commit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  thread_main_inner();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个run方法主要做的事：</p>
<ul>
<li>初始化一些数据</li>
<li>调用<code>thread_main_inner()</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> JavaThread::thread_main_inner() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(JavaThread::current() == <span class="built_in">this</span>, <span class="string">&quot;sanity check&quot;</span>);</span><br><span class="line">  <span class="keyword">assert</span>(<span class="built_in">this</span>-&gt;threadObj() != NULL, <span class="string">&quot;just checking&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//正常情况下会回到线程入口，除非有异常挂起</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>-&gt;has_pending_exception() &amp;&amp;</span><br><span class="line">      !java_lang_Thread::is_stillborn(<span class="built_in">this</span>-&gt;threadObj())) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      ResourceMark <span class="title function_">rm</span><span class="params">(<span class="built_in">this</span>)</span>;</span><br><span class="line">      <span class="comment">//设置线程name</span></span><br><span class="line">      <span class="built_in">this</span>-&gt;set_native_thread_name(<span class="built_in">this</span>-&gt;get_thread_name());</span><br><span class="line">    &#125;</span><br><span class="line">    HandleMark <span class="title function_">hm</span><span class="params">(<span class="built_in">this</span>)</span>;</span><br><span class="line">    <span class="comment">//回到线程入口</span></span><br><span class="line">    <span class="built_in">this</span>-&gt;entry_point()(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DTRACE_THREAD_PROBE(stop, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>-&gt;exit(<span class="literal">false</span>);</span><br><span class="line">  delete <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事：</p>
<ul>
<li>如果正常情况下会回到线程入口</li>
</ul>
<p><strong>线程入口</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">thread_entry</span><span class="params">(JavaThread* thread, TRAPS)</span> &#123;</span><br><span class="line">  HandleMark <span class="title function_">hm</span><span class="params">(THREAD)</span>;</span><br><span class="line">  Handle <span class="title function_">obj</span><span class="params">(THREAD, thread-&gt;threadObj()</span>);</span><br><span class="line">  JavaValue <span class="title function_">result</span><span class="params">(T_VOID)</span>;</span><br><span class="line">  JavaCalls::call_virtual(&amp;result,</span><br><span class="line">                          obj,</span><br><span class="line">                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),</span><br><span class="line">                          vmSymbols::run_method_name(),<span class="comment">//回调我们自己重写的run方法</span></span><br><span class="line">                          vmSymbols::void_method_signature(),</span><br><span class="line">                          THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法在这里做的事：</p>
<ul>
<li>回调 <code>vmSymbols::run_method_name()</code>：回到我们自己重写的run方法</li>
</ul>

        <h4 id="yield"   >
          <a href="#yield" class="heading-link"><i class="fas fa-link"></i></a><a href="#yield" class="headerlink" title="yield"></a>yield</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>这个方法又是native方法，所以我们找到<code>Thread.c</code>中的方法注册表，找到对应的方法</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;yield&quot;</span>,            <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Yield&#125;,<span class="comment">//这就是我们要找到的yield方法对应关系</span></span><br><span class="line">	<span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中代码</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_Yield</span>(JNIEnv *env, jclass threadClass))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_Yield&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (os::<span class="built_in">dont_yield</span>()) <span class="keyword">return</span>; <span class="comment">//如果操作系统不允许让出CPU，那么直接返回(不让频繁yield浪费性能)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> USDT2</span></span><br><span class="line">  <span class="built_in">HS_DTRACE_PROBE0</span>(hotspot, thread__yield);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line">  <span class="built_in">HOTSPOT_THREAD_YIELD</span>();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* USDT2 */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断操作系统对应的yield要不要让线程休眠</span></span><br><span class="line">  <span class="keyword">if</span> (ConvertYieldToSleep) &#123;</span><br><span class="line">    os::<span class="built_in">sleep</span>(thread, MinSleepInterval, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//调用相应操作系统yield方法</span></span><br><span class="line">    os::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法主要做的事</p>
<ul>
<li>判断是否能让出CPU，如果频繁<code>yield</code>则会浪费性能</li>
<li>调用操作系统中的yield方法，具体看操作系统的方法实现</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sched_yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="join"   >
          <a href="#join" class="heading-link"><i class="fas fa-link"></i></a><a href="#join" class="headerlink" title="join"></a>join</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        join(<span class="number">0</span>);<span class="comment">//调用有参重载函数</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用有参重载函数</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//如果没有等待时间</span></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//运行到这里是有等待时间</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="comment">//如果现在已经超出了超出等待时间，那么就结束方法</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则，调用wait方法阻塞，时长为delay</span></span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>调用<code>isAlive</code>方法，判断当前线程是否结束</p>
</li>
<li><p>没有等待时间，那么就调用<code>wait(0)</code>，等待线程唤醒直至当前线程死亡</p>
</li>
<li><p>如果有等待时间，那么就调用<code>wait(delay)</code>，等待超时或者当前线程死亡</p>
</li>
</ul>
<p><code>isAlive</code>方法是native方法，所以找到jvm.cpp中相关方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_IsThreadAlive&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">oop</span> <span class="variable">thread_oop</span> <span class="operator">=</span> JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  <span class="keyword">return</span> java_lang_Thread::is_alive(thread_oop);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>返回线程是否结束</li>
</ul>

        <h5 id="join方法使用案例"   >
          <a href="#join方法使用案例" class="heading-link"><i class="fas fa-link"></i></a><a href="#join方法使用案例" class="headerlink" title="join方法使用案例"></a>join方法使用案例</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestJoinMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>); <span class="comment">//模拟线程执行逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);<span class="comment">//模拟线程执行逻辑</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经完成&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让主线程等待t1和t2完成逻辑</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程已经结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>正因为有<code>t1.join</code>以及<code>t2.join</code>所以主线程会等待t1和t2线程完成之后再执行后序任务</p>
<p> 也即最后执行结果是如下</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">2</span>已经完成</span><br><span class="line">Thread-<span class="number">3</span>已经完成</span><br><span class="line">主线程已经结束</span><br></pre></td></tr></table></div></figure>




        <h4 id="stop"   >
          <a href="#stop" class="heading-link"><i class="fas fa-link"></i></a><a href="#stop" class="headerlink" title="stop"></a>stop</h4>
      <p>这个方法已经被废弃，但是为了提到如何优雅结束线程，我们要从这个最见名知意的stop方法开始看如何结束线程</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">       <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">           checkAccess();</span><br><span class="line">           <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread()) &#123;</span><br><span class="line">               security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (threadStatus != <span class="number">0</span>) &#123;</span><br><span class="line">           resume(); <span class="comment">// Wake up thread if it was suspended; no-op otherwise</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//调用stop0方法真正结束线程</span></span><br><span class="line">       stop0(<span class="keyword">new</span> <span class="title class_">ThreadDeath</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>stop0</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">stop0</span><span class="params">(Object o)</span>;</span><br></pre></td></tr></table></div></figure>

<p>不出意料地，这个方法果然又是native方法，所以我们还是继续找到源码去看具体做了什么事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;stop0&quot;</span>,            <span class="string">&quot;(&quot;</span> OBJ <span class="string">&quot;)V&quot;</span>, (<span class="keyword">void</span> *)&amp;JVM_StopThread&#125;,</span><br><span class="line">    <span class="comment">//省略部分代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中代码</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_StopThread</span>(JNIEnv* env, jobject jthread, jobject throwable))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_StopThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">  oop java_throwable = JNIHandles::<span class="built_in">resolve</span>(throwable);</span><br><span class="line">  <span class="keyword">if</span> (java_throwable == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//空指针异常</span></span><br><span class="line">    <span class="built_in">THROW</span>(vmSymbols::<span class="built_in">java_lang_NullPointerException</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  oop java_thread = JNIHandles::<span class="built_in">resolve_non_null</span>(jthread);</span><br><span class="line">  JavaThread* receiver = java_lang_Thread::<span class="built_in">thread</span>(java_thread);</span><br><span class="line">  Events::<span class="built_in">log_exception</span>(JavaThread::<span class="built_in">current</span>(),</span><br><span class="line">                        <span class="string">&quot;JVM_StopThread thread JavaThread &quot;</span> INTPTR_FORMAT <span class="string">&quot; as oop &quot;</span> INTPTR_FORMAT <span class="string">&quot; [exception &quot;</span> INTPTR_FORMAT <span class="string">&quot;]&quot;</span>,</span><br><span class="line">                        <span class="built_in">p2i</span>(receiver), <span class="built_in">p2i</span>((address)java_thread), <span class="built_in">p2i</span>(throwable));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果线程还在活动，那么可能产生了异常</span></span><br><span class="line">  <span class="keyword">if</span> (receiver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      </span><br><span class="line">  	<span class="comment">//是否是self产生</span></span><br><span class="line">    <span class="keyword">if</span> (java_thread == thread-&gt;<span class="built_in">threadObj</span>()) &#123;</span><br><span class="line">      <span class="built_in">THROW_OOP</span>(java_throwable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//暂停所有线程，传递异常</span></span><br><span class="line">      Thread::<span class="built_in">send_async_exception</span>(java_thread, JNIHandles::<span class="built_in">resolve</span>(throwable));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//反之 1.线程在停止前未启动 2.线程已经停止  </span></span><br><span class="line">   </span><br><span class="line">    java_lang_Thread::<span class="built_in">set_stillborn</span>(java_thread);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<p>这个方法做的事：</p>
<ul>
<li>强制线程进入<strong>线程安全点</strong>，这可能会导致有部分代码会没能执行完毕，假如一个业务逻辑并未执行完成就被强制结束线程，那么可能会对整个业务造成影响</li>
<li>如果发起结束线程是自身线程那么就不需要安全点</li>
</ul>
<p>利用stop方法来停机是不优雅的，所以我们要优雅结束线程需要用到线程中断</p>

        <h4 id="interrupt"   >
          <a href="#interrupt" class="heading-link"><i class="fas fa-link"></i></a><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4>
      <p><code>Thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">interrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//如果不是自身中断，那么检查是否有权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            <span class="type">Interruptible</span> <span class="variable">b</span> <span class="operator">=</span> blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//设置中断标志位</span></span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>interrupt0()</code>方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">interrupt0</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>



<p>因此我们找到方法注册表，看看究竟是个什么事</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="type">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;interrupt0&quot;</span>,       <span class="string">&quot;()V&quot;</span>,        (<span class="type">void</span> *)&amp;JVM_Interrupt&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<p><code>jvm.cpp</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JVM_ENTRY(<span class="keyword">void</span>, JVM_Interrupt(JNIEnv* env, jobject jthread))</span><br><span class="line">  JVMWrapper(<span class="string">&quot;JVM_Interrupt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure that the C++ Thread and OSThread structures aren&#x27;t freed before we operate</span></span><br><span class="line">  <span class="type">oop</span> <span class="variable">java_thread</span> <span class="operator">=</span> JNIHandles::resolve_non_null(jthread);</span><br><span class="line">  MutexLockerEx <span class="title function_">ml</span><span class="params">(thread-&gt;threadObj()</span> == java_thread ? NULL : Threads_lock);</span><br><span class="line">  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));</span><br><span class="line">  <span class="keyword">if</span> (thr != NULL) &#123;</span><br><span class="line">    <span class="comment">//设置中断标志位</span></span><br><span class="line">    Thread::interrupt(thr);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>Thread::interrupt(thr)</code></li>
</ul>
<p><code>thread.cpp</code>代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Thread::interrupt(Thread* thread) &#123;</span><br><span class="line">  trace(<span class="string">&quot;interrupt&quot;</span>, thread);</span><br><span class="line">  debug_only(check_for_dangling_thread_pointer(thread);)</span><br><span class="line">  os::interrupt(thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用操作系统具体的<code>interrupt</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">os::interrupt</span><span class="params">(Thread* thread)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(Thread::<span class="built_in">current</span>() == thread || Threads_lock-&gt;<span class="built_in">owned_by_self</span>(),</span><br><span class="line">    <span class="string">&quot;possibility of dangling Thread pointer&quot;</span>);</span><br><span class="line">  OSThread* osthread = thread-&gt;<span class="built_in">osthread</span>();</span><br><span class="line">  <span class="keyword">if</span> (!osthread-&gt;<span class="built_in">interrupted</span>()) &#123;</span><br><span class="line">    osthread-&gt;<span class="built_in">set_interrupted</span>(<span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//加屏障，让unpark()之前对其他线程可见    </span></span><br><span class="line">    OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">    ParkEvent * <span class="type">const</span> slp = thread-&gt;_SleepEvent ;</span><br><span class="line">    <span class="keyword">if</span> (slp != <span class="literal">NULL</span>) slp-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (thread-&gt;<span class="built_in">is_Java_thread</span>())</span><br><span class="line">    ((JavaThread*)thread)-&gt;<span class="built_in">parker</span>()-&gt;<span class="built_in">unpark</span>();</span><br><span class="line">    </span><br><span class="line">  ParkEvent * ev = thread-&gt;_ParkEvent ;</span><br><span class="line">  <span class="keyword">if</span> (ev != <span class="literal">NULL</span>) ev-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="小结-1"   >
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4>
      <ul>
<li>start</li>
</ul>
<ol>
<li>操作系统调用<code>pthread_create</code>指令创建了一个线程，并且和JavaThread相关联</li>
<li>Java中的Thread对象和操作系统中创建线程相关联，做到了真正的创建线程</li>
<li>让初始化完成之后会被唤醒之后执行run方法</li>
</ol>
<ul>
<li><p>run</p>
<p>正常情况下会回调我们自己写的run方法</p>
</li>
<li><p>join</p>
<p>让某线程等待调用了join方法的线程结束，使用于异步线程执行完结果之后的场景</p>
</li>
<li><p>yield</p>
<p>让当前线程让出cpu，根据对应操作系统的线程调度，让优先级高的可能获取到时间片，但是不会释放对象锁</p>
</li>
<li><p>stop</p>
<p>强制结束线程，并且stop会释放对象锁所以可能会造成数据的不安全</p>
</li>
<li><p>interrupt</p>
<p>线程中断，当线程执行完相应逻辑并感应到线程中断可以自己选择该如何响应中断，相较于stop方法的强制执行更加温柔更加优雅</p>
</li>
<li><p>sleep </p>
<p>让线程从<code>Runnable</code>的执行状态到<code>TIMED_WAITNG</code>状态，会让线程睡眠，但是不会释放对象锁</p>
</li>
</ul>

        <h2 id="线程的通知机制"   >
          <a href="#线程的通知机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程的通知机制" class="headerlink" title="线程的通知机制"></a>线程的通知机制</h2>
      <p>这里的通知机制有：1.Volatile关键字 。 2. <strong>通知唤醒机制(wait&#x2F;notify)</strong> 。 3.条件队列通知机制(await&#x2F;signal) </p>
<p>因为Volatile关键字以及条件队列的通知唤醒机制我们在之前的场景说过了,所以我们这里着重将第二点wait&#x2F;notify</p>

        <h3 id="wait"   >
          <a href="#wait" class="heading-link"><i class="fas fa-link"></i></a><a href="#wait" class="headerlink" title="wait"></a>wait</h3>
      <p><code>thread.java</code>中代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>找到有参方法，发现又是一个native方法，所以我们又要找到注册表</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法注册表</span></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod methods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;hashCode&quot;</span>,    <span class="string">&quot;()I&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_IHashCode&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;wait&quot;</span>,        <span class="string">&quot;(J)V&quot;</span>,                   (<span class="keyword">void</span> *)&amp;JVM_MonitorWait&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notify&quot;</span>,      <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotify&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;notifyAll&quot;</span>,   <span class="string">&quot;()V&quot;</span>,                    (<span class="keyword">void</span> *)&amp;JVM_MonitorNotifyAll&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;clone&quot;</span>,       <span class="string">&quot;()Ljava/lang/Object;&quot;</span>,   (<span class="keyword">void</span> *)&amp;JVM_Clone&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p><code>jvm.cpp</code>中</p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorWait</span>(JNIEnv* env, jobject handle, jlong ms))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorWait&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  <span class="function">JavaThreadInObjectWaitState <span class="title">jtiows</span><span class="params">(thread, ms != <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (JvmtiExport::<span class="built_in">should_post_monitor_wait</span>()) &#123;</span><br><span class="line">    JvmtiExport::<span class="built_in">post_monitor_wait</span>((JavaThread *)THREAD, (oop)<span class="built_in">obj</span>(), ms);</span><br><span class="line">      <span class="comment">//该线程已经获取了监视器，但是还没有添加到等待队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//调用同步器中的wait方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">wait</span>(obj, ms, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用<code>ObjectSynchronizer::wait</code></li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::wait</span><span class="params">(Handle obj, jlong millis, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">//如果持有偏向锁</span></span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果阻塞时间小于0</span></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">TEVENT</span> (wait - <span class="keyword">throw</span> IAX) ;</span><br><span class="line">    <span class="built_in">THROW_MSG</span>(vmSymbols::<span class="built_in">java_lang_IllegalArgumentException</span>(), <span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectMonitor* monitor = ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>());</span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_WAIT_PROBE</span>(monitor, <span class="built_in">obj</span>(), THREAD, millis);</span><br><span class="line">  <span class="comment">//调用monitor的wait方法</span></span><br><span class="line">  monitor-&gt;<span class="built_in">wait</span>(millis, <span class="literal">true</span>, THREAD);</span><br><span class="line">  <span class="built_in">dtrace_waited_probe</span>(monitor, obj, THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>如果是偏向锁的情况下会消除偏向状态</li>
<li>调用monitor的wait方法</li>
</ul>

        <h3 id="notify"   >
          <a href="#notify" class="heading-link"><i class="fas fa-link"></i></a><a href="#notify" class="headerlink" title="notify"></a>notify</h3>
      <p><code>thread.java</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>因此找到cpp中的代码</p>
<p><code>jvm.cpp</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorNotify</span>(JNIEnv* env, jobject handle))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorNotify&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  <span class="comment">//调用同步器的notify方法</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">notify</span>(obj, CHECK);</span><br><span class="line">JVM_END</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的<code>notify</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::notify</span><span class="params">(Handle obj, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">notify</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的冲突情况下唤醒线程Thread</li>
</ul>

        <h3 id="notifyAll"   >
          <a href="#notifyAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#notifyAll" class="headerlink" title="notifyAll"></a>notifyAll</h3>
      <p><code>thread.java</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></div></figure>

<p>因此找到cpp中的代码</p>
<p><code>jvm.cpp</code></p>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY</span>(<span class="type">void</span>, <span class="built_in">JVM_MonitorNotifyAll</span>(JNIEnv* env, jobject handle))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_MonitorNotifyAll&quot;</span>);</span><br><span class="line">  <span class="function">Handle <span class="title">obj</span><span class="params">(THREAD, JNIHandles::resolve_non_null(handle))</span></span>;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">notifyall</span>(obj, CHECK);</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的<code>notifyall</code>方法</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::notifyall</span><span class="params">(Handle obj, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, <span class="literal">false</span>, THREAD);</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">notifyAll</span>(THREAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>调用同步器中的冲突情况下唤醒全部线程</li>
</ul>

        <h3 id="小结-2"   >
          <a href="#小结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3>
      
        <h4 id="sleep、wait、yield方法比较"   >
          <a href="#sleep、wait、yield方法比较" class="heading-link"><i class="fas fa-link"></i></a><a href="#sleep、wait、yield方法比较" class="headerlink" title="sleep、wait、yield方法比较"></a>sleep、wait、yield方法比较</h4>
      <ul>
<li><p><strong>sleep</strong>、<strong>yield</strong>不会释放锁，而<strong>wait</strong>会释放锁</p>
</li>
<li><p><strong>sleep</strong>方法到了时间之后会自己苏醒（也可以感知线程中断而结束休眠），<strong>wait</strong>方法进入等待队列之后必须要调用同一个对象的<code>notify</code>&#x2F;<code>notifyAll</code>唤醒</p>
</li>
<li><p><strong>sleep</strong>方法作用于线程休眠<strong>暂停执行</strong>，而<strong>wait</strong>方法常用于线程之间通信</p>
</li>
<li><p><strong>sleep</strong>方法是Thread类的静态本地方法，因为一个线程休眠只是使线程自己休眠，不会涉及到锁的释放</p>
<p><strong>wait</strong>方法是Object类的本地方法，每个对象阻塞需要释放对象锁，因此应该操作对象（object）而不是线程</p>
<p><strong>yield</strong>方法是Thread类的静态本地方法</p>
</li>
</ul>

        <h1 id="线程池-1"   >
          <a href="#线程池-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h1>
      <p>线程池的引入是为了避免在并发情况下，如果线程执行逻辑很短则需要频繁创建、结束线程，而我们知道线程是一个很重要的资源，所以我们可以利用线程池来复用线程，来避免频繁创建、销毁的操作。</p>
<p>我们可以从Executors（线程池框架）着手对线程池的学习，而我们要知道阿里Java开发手册中禁止使用Excutors来创建线程池，我们会慢慢知道这是为什么？</p>
<p>我们可以从Executors创建三种线程池CachedThreadPool、FixedThreadPool、SingleThreadPool。从这三个线程池开始入手</p>

        <h2 id="CachedThreadPool"   >
          <a href="#CachedThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newCachedThreadPool方法</li>
</ul>
<p><strong>newCachedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="SignleThreadPool"   >
          <a href="#SignleThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#SignleThreadPool" class="headerlink" title="SignleThreadPool"></a>SignleThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SingleThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singlePool</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            singlePool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newSingleThreadPool方法</li>
</ul>
<p><strong>newSingleThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (	<span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">            	<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="FixedThreadPool"   >
          <a href="#FixedThreadPool" class="heading-link"><i class="fas fa-link"></i></a><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2>
      <p><strong>demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UseThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">FixedThreadPool</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            fixedThreadPool.execute(<span class="keyword">new</span> <span class="title class_">MyThreadPoolRunnable</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟每个线程完成一百件任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadPoolRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;完成的第&quot;</span>+i+<span class="string">&quot;个任务&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>创建线程池调用newFixedThreadPool方法</li>
</ul>
<p><strong>newFixedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="comment">//返回ThreadPoolExecutor对象</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="ThreadPoolExecutor"   >
          <a href="#ThreadPoolExecutor" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2>
      <p>因此我们都能发现都是返回的ThreadPoolExecutors对象，只是传入的参数不一样，所以我们要认识线程池就得认识ThreadPoolExecutor</p>
<p>我们可以用一个自定义线程池的Demo简单看看这个类到底怎么用</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThreadPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MyThreadPoolDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">myThreadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">5</span>,	<span class="comment">//核心线程数</span></span><br><span class="line">                <span class="number">10</span>,	<span class="comment">//最大线程数</span></span><br><span class="line">                <span class="number">60L</span>,<span class="comment">//空闲时间</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">5</span>)<span class="comment">//阻塞队列</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心线程数（范围0~Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大线程数(范围1~Integer.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非核心线程空闲时的超时时间(范围0~Long.MAX_VALUE)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认的拒绝策略(抛出异常并且拒绝执行任务)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//移位29位，高3位表示线程池状态，低29位表示线程数量(000 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池最大线程数量1左移29位再-1(000 11111111111111111111111111111)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池运行状态（高三位）</span></span><br><span class="line"><span class="comment">//正在运行(111 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭中(000 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止中(001 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整理中(010 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//已终止(011 00000000000000000000000000000)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁，用于保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池已有线程集合，因为是HashSet结构所以对数据做修改的时候需要加锁处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池中曾经拥有线程的最大数量 </span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计线程池完成任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心线程是否按照keepAliveTime存活，默认为false(也即核心线程空闲也保持活跃)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>线程池的五种状态</p>
<ul>
<li>RUNNING(-1):运行中，可以正常接收任务，能处理workQueue中的任务</li>
<li>SHUTDOWN(0):关闭中，不能接收新的任务，但是能处理workQueue中的任务</li>
<li>STOP(1):停止中，不能接收新的任务，也不再处理workQueue中的任务，会中断还在执行任务的线程</li>
<li>TIDYING(2):整理中，所有任务已经完成，并且线程数量为0，等待调用terminated()方法进入终止状态</li>
<li>TERMINATED(3)：线程池已经终止</li>
</ul>

        <h3 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,						//核心线程数</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,				//最大线程数</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,				//超时存活时间</span></span><br><span class="line"><span class="params">                              TimeUnit unit,					//时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,//任务排队队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,		//线程工厂</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler	//拒绝策略</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">    	<span class="comment">//校验参数的有效性</span></span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//为成员变量赋值</span></span><br><span class="line">        <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>另外三个重载的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    	<span class="comment">//调用七个参数的构造方法</span></span><br><span class="line">        <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="内部类"   >
          <a href="#内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3>
      
        <h4 id="Worker"   >
          <a href="#Worker" class="heading-link"><i class="fas fa-link"></i></a><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计线程完全任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            runWorker(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//构造方法    </span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">//更新线程状态成-1(阻塞)，目的是在运行worker之前禁止线程中断</span></span><br><span class="line">        </span><br><span class="line">            <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);<span class="comment">//调用线程工厂创建线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>        &#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>      &#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试解锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">        	<span class="comment">//设置锁持有线程为空</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        	</span><br><span class="line">        	<span class="comment">//将线程状态置为0(运行中)</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="CallerRunsPolicy"   >
          <a href="#CallerRunsPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4>
      
        <h4 id="AbortPolicy"   >
          <a href="#AbortPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4>
      
        <h4 id="DiscardPolicy"   >
          <a href="#DiscardPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4>
      
        <h4 id="DiscardOldestPolicy"   >
          <a href="#DiscardOldestPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4>
      <p>这四个内部类是具体的拒绝策略，我们在这里先不看，会单独出一个来讲拒绝策略</p>
<p>因此我们可以获得<code>ThreadPoolExecutor</code>的结构图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231113181935844.png"  alt="ThreadPoolExecutor">
      </p>

        <h3 id="execute"   >
          <a href="#execute" class="heading-link"><i class="fas fa-link"></i></a><a href="#execute" class="headerlink" title="execute"></a>execute</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//对线程任务做非空判断</span></span><br><span class="line">    	<span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//获取到线程池状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">/*下面一共三种情况</span></span><br><span class="line"><span class="comment">    		1.已有核心线程数没有到最大核心线程数（还有核心线程可以创建）</span></span><br><span class="line"><span class="comment">    		2.线程池还在运行，并且任务能成功排队</span></span><br><span class="line"><span class="comment">    		3.任务不能排队，那么尝试新建一个线程来执行任务</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况1：已有工作线程小于最大核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//添加工作线程，将任务作为初始任务交给新线程，成功后结束方法</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况2：如果线程池还在运行，并且任务成功添加到等待队列中</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//复查，如果线程池要停止运行或者已经停止运行并且成功从池中移除任务</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">//拒绝任务</span></span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//新起一个空初始任务线程</span></span><br><span class="line">                addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//情况3：如果我们不能对任务进行排队，那么尝试新建一个线程执行任务，如果失败了我们就拒绝执行任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">            <span class="comment">//拒绝任务</span></span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>execute方法做的事</p>
<ul>
<li><p>如果已有线程数小于最大核心线程数（任务能提交到核心线程中）</p>
<p>将任务交给新的核心线程执行<code>addWorker(command,true)</code></p>
</li>
<li><p>如果线程池还在运行并且任务能够成功添加到等待队列中</p>
<ol>
<li>复查，线程池停止运行（不能接受任务）并且任务从队列中去除：拒绝任务</li>
<li>线程池还在运行，那么新起一个新的空线程</li>
</ol>
</li>
<li><p>如果我们不能对任务进行排队，那么尝试新建一个线程执行任务，失败了就拒绝执行任务</p>
</li>
</ul>
<p>以下是简化版流程图,假设核心线程数为10，最大线程数为20，队列容量为10，即将有50个任务待执行</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231114000324848.png"  alt="简化版流程图">
      </p>

        <h3 id="addWorker"   >
          <a href="#addWorker" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    <span class="comment">//循环入口retry，判断线程池是否能够添加线程    </span></span><br><span class="line">    retry: 			</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           	<span class="comment">//获取线程池控制状态c和运行状态rs</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			这里判断添加线程失败需要满足两个条件：</span></span><br><span class="line"><span class="comment">				1.线程池状态需要大于等于SHUTDOWN (0) ，也即线程池正在关闭或者已经关闭</span></span><br><span class="line"><span class="comment">				2.第二个判断为false，有以下三种情况：</span></span><br><span class="line"><span class="comment">					2.1: rs!=SHUTDOWN (0)也即rs&gt;0，线程池已经关闭</span></span><br><span class="line"><span class="comment">					2.2: rs==SHUTDOWN &amp;&amp; firstTask != null 也即线程池正在关闭，还有未执行的初始任务也不允许创建新线程</span></span><br><span class="line"><span class="comment">					2.3: rs==SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty() 也即线程池正在关闭，排队队列为空</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">					</span></span><br><span class="line"><span class="comment">			也即当满足添加线程的条件：</span></span><br><span class="line"><span class="comment">				1.线程池状态小于SHUTDOWN，表示线程池还在运行中能够添加线程</span></span><br><span class="line"><span class="comment">				2.线程池处于关闭状态 &amp;&amp; firstTask==null &amp;&amp;!workQueue.isEmpty()</span></span><br><span class="line"><span class="comment">                	表示线程池正在关闭，排队队列中还有任务未执行</span></span><br><span class="line"><span class="comment">                	</span></span><br><span class="line"><span class="comment">               	也即当线程池关闭状态不接受新任务，但是能处理完已有任务</span></span><br><span class="line"><span class="comment">			*/</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			<span class="comment">//运行到这里说明线程池能够添加线程</span></span><br><span class="line">            <span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取现在已有线程数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果已有线程数超出了线程池最大限制(2的29次方-1)或者创建对应线程失败</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="comment">//已有线程数大于核心线程数创建核心线程失败（core为true表示创建核心线程）</span></span><br><span class="line">                    <span class="comment">//已有线程数大于总线程数创建非核心线程失败（core为false表示创建非核心线程）</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS添加线程数成功，跳出外层retry循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//运行到这里CAS失败，重新拉取线程池状态</span></span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果线程池状态已经改变则重新判断线程池是否能够添加线程，回到外层循环retry</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//线程池状态没有改变，CAS失败，重新尝试CAS添加线程数，回到内层循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//跳出retry循环，下面开始真正创建线程</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//线程启动成功标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//添加线程成功标记</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//线程标记</span></span><br><span class="line">        <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建worker</span></span><br><span class="line">            w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">            <span class="comment">//获取线程t</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//获取锁，因为workers是HashSet结构，所以加锁保证线程安全</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//复查线程池状态</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">					</span><br><span class="line">                    <span class="comment">//如果线程池处于RUNNING（可以创建线程）</span></span><br><span class="line">                    <span class="comment">//或者线程池处于正在关闭并且没有初始任务，那么可以创建线程来处理WorkQueue中的任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">//线程池可以添加新的线程</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//如果线程t已经启动，那么抛出异常（还没有start启动线程但是线程t已经启动说明有问题）</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//当w添加到workers集合中</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                        <span class="comment">//如果工作线程数大于池有过最大线程数，那么更新池有过最大线程数</span></span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        <span class="comment">//将线程添加成功标记置为true</span></span><br><span class="line">                        workerAdded = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//解锁</span></span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果线程成功添加</span></span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">//start启动，并将启动标记置为true</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    workerStarted = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//添加线程失败，调用addWorkerFailed方法</span></span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//返回线程是否启动成功</span></span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>addWorker逻辑上做了两件事：</p>
<ol>
<li>判断线程池是否能够创建线程<ul>
<li>线程池处于 <strong>RUNNING</strong> (运行中)的时候可以接收新的任务也可以处理等待队列(WorkQueue)中的任务</li>
<li>线程池处于 <strong>SHUTDOWN</strong>  (关闭中)的时候不可以接收新的任务，但是可以处理等待队列<code>WorkQueue</code>中的任务</li>
<li>CAS操作，增加线程数</li>
</ul>
</li>
<li>创建线程，并将worker添加到线程池中<ul>
<li>加锁（因为workers是HashSet集合所以为了线程安全而加锁）</li>
<li>复查线程池状态，确保是可以创建线程状态</li>
<li>检查worker状态，并将正常worker添加到线程池中<code>workers</code>集合</li>
<li>解锁</li>
<li>添加线程成功，调用<code>t.start()</code>启动线程</li>
</ul>
</li>
</ol>
<p>如果创建线程失败，最终会调用addWorkerFailed方法，所以我们看一下如果线程添加失败之后会做什么事</p>

        <h3 id="addWorkerFailed"   >
          <a href="#addWorkerFailed" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取到worker的锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//加锁，因为workers是Hashset结构，所以保证线程安全</span></span><br><span class="line">    	mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">                workers.remove(w); <span class="comment">//将workers中去除失败的w</span></span><br><span class="line">            decrementWorkerCount();<span class="comment">//CAS将线程数--，因为addWorker的时候判断线程池可以创建线程的时候CAS线程数++</span></span><br><span class="line">            tryTerminate();<span class="comment">//可能线程池状态变化或者有问题，于是尝试结束线程池</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>如果创建线程失败：</p>
<ul>
<li>加锁，减去线程池中workers的失败worker</li>
<li>CAS将线程数–</li>
<li>尝试关闭线程池 <del>(因为线程失败是线程池状态出现问题)</del></li>
</ul>

        <h4 id="decrementWorkerCount"   >
          <a href="#decrementWorkerCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#decrementWorkerCount" class="headerlink" title="decrementWorkerCount"></a>decrementWorkerCount</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">decrementWorkerCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//自旋直到CAS成功，也即直到线程池的线程数成功-1</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compareAndDecrementWorkerCount</span><span class="params">(<span class="type">int</span> expect)</span> &#123;</span><br><span class="line"> 		<span class="comment">//CAS，将线程数-1</span></span><br><span class="line">    	<span class="keyword">return</span> ctl.compareAndSet(expect, expect - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>CAS将线程数–</p>

        <h4 id="tryTerminate"   >
          <a href="#tryTerminate" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">    	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取线程池控制状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断线程池是否可以结束</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||					<span class="comment">//如果线程池正在运行，则不允许结束</span></span><br><span class="line">                runStateAtLeast(c, TIDYING) ||	<span class="comment">//如果线程池处于整理或者已经结束</span></span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))	<span class="comment">//如果线程池在停止中，但是还有任务没完成</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//有资格结束线程池</span></span><br><span class="line">            <span class="comment">//如果还有存活线程，则先让线程自身中断</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//运行到这里说明线程池可以结束</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//把线程池加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//尝试CAS将线程池更新成TIDYING（整理中）状态</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//终止线程池</span></span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//将线程池更新成(TERMINATED)终止状态</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法做的事就两件</p>
<ul>
<li>判断线程池的状态是否能结束</li>
<li>如果线程池能结束，那么上锁结束线程池</li>
</ul>

        <h3 id="runWorker"   >
          <a href="#runWorker" class="heading-link"><i class="fas fa-link"></i></a><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h3>
      <p>线程经过<code>t.start()</code>启动之后会调用<code>run()</code>方法，而<code>Worker</code>中的<code>run()</code>方法会调用<code>runWorker()</code>方法，所以我们当创建线程成功之后启动线程之后要来到这个runWorker方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    	<span class="comment">//获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    	<span class="comment">//task记录worker的初始任务</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//将worker的第一个线程置空</span></span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//将线程解锁，允许中断（因为会调用tryRelease()方法更新线程状态为0)</span></span><br><span class="line">        w.unlock();</span><br><span class="line">    	<span class="comment">//判断线程是否异常退出，默认为true，如果成功执行则会置为false</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*while循环有两个情况可以进入：</span></span><br><span class="line"><span class="comment">            	1.task!=null,这个说明线程携带初始任务，那么优先执行初始任务</span></span><br><span class="line"><span class="comment">            	2.task==null &amp;&amp; (task=getTask())!=null,说明线程一开始没有初始任务，但是从排队队列中获取到了任务</span></span><br><span class="line"><span class="comment">            	</span></span><br><span class="line"><span class="comment">            	也即线程优先做初始任务，然后再从WorkQueue中获取任务</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">				</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	这个IF语句有两种情况，并且当前线程不是中断状态：</span></span><br><span class="line"><span class="comment">                		1.线程池状态大于等于STOP,说明线程池中线程要被中断</span></span><br><span class="line"><span class="comment">                		2.线程池状态小于STOP，则线程不应该出现中断，</span></span><br><span class="line"><span class="comment">                		但是此时Thread.interrupted()为true说明出现了线程中断并且清空了线程中断标志位</span></span><br><span class="line"><span class="comment">                		那么有可能是线程池调用了shutdownNow方法</span></span><br><span class="line"><span class="comment">                		所以重新判断线程池状态，如果线程池状态为STOP则需要执行线程中断</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">//中断线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//任务执行前执行的钩子函数，可以子类重写该方法来达到目的</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//运行任务，调用任务的run方法</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//任务执行之后执行的钩子函数，可以子类重写该方法达到目的</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//执行完成，置空任务，线程任务完成数++，解锁</span></span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程正常处理任务，所以将异常退出标志置为false</span></span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/*一定会运行到这里，而运行到这里有两种可能：</span></span><br><span class="line"><span class="comment">            	1.作业队列没有任务了，调用processWorkerExit()方法</span></span><br><span class="line"><span class="comment">            	2.某个线程出现执行过程中产生异常，此时completedAbruptly=true</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>worker的调用run方法会来到这个方法，而这个方法所做的事</p>
<ul>
<li>如果线程有初始任务那么就执行初始任务，完成之后相应计数++</li>
<li>如果线程没有初始任务，那么去尝试获取任务队列(workQueue)中的任务</li>
<li>如果队列中没有任务或者线程执行某任务出错，那么就会进入finally语句中的<code>processWorkerExit()</code>方法中</li>
</ul>

        <h3 id="processWorkerExit"   >
          <a href="#processWorkerExit" class="heading-link"><i class="fas fa-link"></i></a><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	到这个方法有两种可能：</span></span><br><span class="line"><span class="comment">		1.队列中没有任务，线程正常结束，参数completedAbruptly为false</span></span><br><span class="line"><span class="comment">		2.线程执行任务中出现异常，线程异常结束，参数completedAbruptly为true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//如果线程出现异常结束，cas将线程池线程数-1</span></span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//加锁，因为要操作workers集合，保证安全</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//统计线程完成数</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将worker移出workers集合中</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//因为线程结束，所以尝试关闭线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//获取线程池控制状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//如果线程池运行状态&lt;STOP，也即RUNNING、SHUTDOWN之一，还能够执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果线程是正常退出也即队列中没有任务了(正常退出completedAbruptly为false)</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">//获取线程池最小的核心线程数min，如果核心线程有存活时间则是0，反之为corePoolSize</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果最少线程数为0但是队列中还有任务，则保持最少有一个线程存活来执行队列中任务</span></span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果线程池已有线程数量足够支持，那么就不添加线程</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果线程执行异常结束，增加一个空任务线程</span></span><br><span class="line">            <span class="comment">//如果线程是正常结束，但是线程池需要最少一个线程来维持队列任务，所以增加一个空任务线程</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>当线程结束的情况下有两种可能：队列没有任务、线程执行任务异常结束</p>
<ul>
<li>队列没有任务，线程正常结束，线程数–</li>
<li>线程异常结束，会添加一个空线程来执行任务</li>
</ul>

        <h3 id="钩子函数"   >
          <a href="#钩子函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3>
      
        <h4 id="beforeExecute"   >
          <a href="#beforeExecute" class="heading-link"><i class="fas fa-link"></i></a><a href="#beforeExecute" class="headerlink" title="beforeExecute"></a>beforeExecute</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//空方法，由子类实现，在执行前执行</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="afterExecute"   >
          <a href="#afterExecute" class="heading-link"><i class="fas fa-link"></i></a><a href="#afterExecute" class="headerlink" title="afterExecute"></a>afterExecute</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123; &#125;</span><br><span class="line"><span class="comment">//空方法，由子类实现，在执行后执行</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="拒绝策略"   >
          <a href="#拒绝策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3>
      
        <h4 id="CallerRunPolicy"   >
          <a href="#CallerRunPolicy" class="heading-link"><i class="fas fa-link"></i></a><a href="#CallerRunPolicy" class="headerlink" title="CallerRunPolicy"></a>CallerRunPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">CallerRunsPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                <span class="comment">//如果线程池未停止，那么由调用execute方法的线程执行任务</span></span><br><span class="line">                r.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>如果线程池没有关闭，由线程池调用execute方法的线程来执行这个任务</p>

        <h4 id="AbortPolicy-1"   >
          <a href="#AbortPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#AbortPolicy-1" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">        <span class="comment">///构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AbortPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//抛出RejectedExecutionException异常</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                                 <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                                 e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>抛出<code>RejectedExecution</code>异常拒绝执行任务</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//而这也是默认的拒绝策略（抛出异常并拒绝执行任务）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h4 id="DiscardPolicy-1"   >
          <a href="#DiscardPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardPolicy-1" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">		<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DiscardPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//什么都不做，直接抛弃任务</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>什么都不做，直接抛弃任务</p>

        <h4 id="DiscardOldestPolicy-1"   >
          <a href="#DiscardOldestPolicy-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#DiscardOldestPolicy-1" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    	<span class="comment">//构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DiscardOldestPolicy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//抛弃第一个任务（最久的），然后将当前任务重新入队</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">                e.getQueue().poll();</span><br><span class="line">                e.execute(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>抛弃第一个任务，然后将当前任务重新入队</p>
<div class="table-container"><table>
<thead>
<tr>
<th>拒绝策略</th>
<th>具体做法</th>
</tr>
</thead>
<tbody><tr>
<td>CallerRunPolicy</td>
<td>如果线程池没有关闭，由线程池调用execute方法的线程来执行这个任务</td>
</tr>
<tr>
<td>AbortPolicy</td>
<td>抛出<code>RejectedExecution</code>异常拒绝执行任务</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>什么都不做，直接抛弃任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>抛弃第一个任务，然后将当前任务重新入队</td>
</tr>
</tbody></table></div>

        <h2 id="常见问题"   >
          <a href="#常见问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2>
      
        <h3 id="sumbit和execute方法的区别"   >
          <a href="#sumbit和execute方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#sumbit和execute方法的区别" class="headerlink" title="sumbit和execute方法的区别?"></a>sumbit和execute方法的区别?</h3>
      <p>1.sumbit有返回值，而execute没有返回值</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;...部分代码&#125;</span><br></pre></td></tr></table></div></figure>



<p>2.sumbit可以接收Runnable和Callable的参数，而execute只能接收Runnable的参数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br></pre></td></tr></table></div></figure>

<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;...部分代码&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="为什么禁止使用Executors创建线程池"   >
          <a href="#为什么禁止使用Executors创建线程池" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么禁止使用Executors创建线程池" class="headerlink" title="为什么禁止使用Executors创建线程池"></a>为什么禁止使用Executors创建线程池</h3>
      <p><strong>CachedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, 										 <span class="comment">//核心线程数</span></span><br><span class="line">            Integer.MAX_VALUE, 						 <span class="comment">//总线程数</span></span><br><span class="line">            <span class="number">60L</span>,									 <span class="comment">//超时时间</span></span><br><span class="line">            TimeUnit.SECONDS,						 <span class="comment">//时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());		 <span class="comment">//排队队列</span></span><br><span class="line">    		<span class="comment">//默认线程工厂以及拒绝策略</span></span><br><span class="line">    &#125;	</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure>

<p>因此我们可以知道CachedThreadPool的模型如下</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117193515963.png"  alt="CachedThreadPool">
      </p>
<p><strong>SingleThreadExecutor</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>,						<span class="comment">//核心线程数</span></span><br><span class="line">                                <span class="number">1</span>,						<span class="comment">//总线程数</span></span><br><span class="line">                                <span class="number">0L</span>, 					<span class="comment">//存活时间</span></span><br><span class="line">                                TimeUnit.MILLISECONDS,  <span class="comment">//时间单位</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<span class="comment">//任务阻塞队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此我们可以得到SingleThreadExecutor（单线程的线程池）的模型</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194238410.png"  alt="SingleThreadExecutor">
      </p>
<p><strong>FixedThreadPool</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads,				<span class="comment">//核心线程数 </span></span><br><span class="line">                                  nThreads,				<span class="comment">//总线程数</span></span><br><span class="line">                                  <span class="number">0L</span>,					<span class="comment">//空闲时间 </span></span><br><span class="line">                                  TimeUnit.MILLISECONDS,<span class="comment">//时间单位</span></span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<span class="comment">//任务阻塞队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此FixedThreadPool的模型我们也能得出</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231117194303107.png"  alt="FixedThreadPool">
      </p>
<p>因此我们可以由这三个模型图推导出结果</p>
<ul>
<li><p>CachedThreadPool因为非核心线程是最大值，所以会一直创建非核心线程，可能会产生OOM问题</p>
<p>表现形式如下：先CPU达到100％，产生OOM问题</p>
</li>
<li><p>SingleThreadPool和FixedThreadPool因为阻塞作业队列workQueue是无限大的，也即当没有线程足够完成任务时会无止境的放到单向链表中，导致OOM问题</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/10/13/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/">死之前要做完的算法手册-[9.动态规划]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-10-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">29.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">224分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="动态规划"   >
          <a href="#动态规划" class="heading-link"><i class="fas fa-link"></i></a><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1>
      <p>动态规划的问题，通常是有多个重叠子问题构成，类似于背包问题，于是可以用动态规划来解决。</p>
<blockquote>
<p>动态规划中每一个状态一定是由上一个状态推导出来的</p>
</blockquote>
<p><strong>动态规划</strong>与<strong>贪心算法</strong>的区别：</p>
<ul>
<li>动态规划的每一个状态都是由上一个确定的状态推导出</li>
<li>贪心算法的每一个状态都是局部最优解，来从局部最优解中选出全局最优解</li>
</ul>
<p>通过卡哥的视频学习，我们首先要学习一个做动态规划的一个思路，也即公式：动态规划五部曲</p>
<p><strong>动态规划五部曲</strong></p>
<ul>
<li>确认dp数组以及下标的含义</li>
<li>确定递推公式：</li>
<li>dp数组如何初始化</li>
<li>确认遍历顺序</li>
<li>打印dp数组值，确保推导正确</li>
</ul>

        <h2 id="基本问题"   >
          <a href="#基本问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2>
      
        <h3 id="509-斐波那契数"   >
          <a href="#509-斐波那契数" class="heading-link"><i class="fas fa-link"></i></a><a href="#509-斐波那契数" class="headerlink" title="509.斐波那契数"></a>509.斐波那契数</h3>
      <p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<blockquote>
<p>F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</p>
</blockquote>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/" >Leetcode.509(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;13</p>

        <h5 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：我们求这个题可以用动态规划也能用递归函数，但是这里我们主要用的是动态规划来做这道题目，因为这道题目给出了递推公式，也提供了初始化数值，所以这道题很容易就能ac</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确认dp数组以及下标的含义：dp数组用于记录每一个斐波那契数值，下标i就是对应的n</p>
</li>
<li><p>确定递推公式：<br>$$<br>F(n)&#x3D;Fn(n-1)+Fn(n-2)<br>$$</p>
</li>
<li><p>dp数组如何初始化:<code>F(0)=0,F(1)=1</code></p>
</li>
<li><p>确认遍历顺序:从前向后</p>
</li>
<li><p>打印dp数组值，确保推导正确：当出现错误的时候Debug，通过递推公式以及遍历顺序确定dp数组的数值</p>
</li>
</ul>
</li>
<li><p>检验n的有效性，当n小于2的时候数值已经确定，直接返回n：<code>return n</code></p>
</li>
<li><p>维护一个dp数组，由递推公式从前向后给dp数组赋值</p>
</li>
<li><p>返回n对应下标dp[n]：<code>return dp[n]</code></p>
</li>
</ul>
<p><strong>未压缩状态代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//当n为0和1的时候数值都已经确定，直接返回</span></span><br><span class="line">    	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//维护一个dp数组，后一个数字是前两个数字的和，初始化数组</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回对应的数据</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>因此我们可以知道，这个结果后一个数字由前两个数字确定，所以其实不用维护一个dp数组，我们只要知道前两个数的大小就能推出最后一个数是多少，也即：<strong>我们只需知道前两个数字数值就能推出下一个数字数值</strong></p>
<p><strong>压缩状态后代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp0=<span class="number">0</span>; <span class="comment">//第一个数字</span></span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">1</span>; <span class="comment">//第二个数字</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>; <span class="comment">//要求的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=dp0+dp1; <span class="comment">//当前数值是前两个数字之和</span></span><br><span class="line">            dp0=dp1; <span class="comment">//将第一个数字数值更新成第二个数字数值</span></span><br><span class="line">            dp1=sum; <span class="comment">//将第二个数字数值更新成当前数字值，更新数据用于求下一个数值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="70-爬楼梯"   >
          <a href="#70-爬楼梯" class="heading-link"><i class="fas fa-link"></i></a><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3>
      <p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/description/" >Leetcode.70题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;14</p>

        <h5 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp0=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=dp0+dp1;</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4>
      <p>思想：这道题和斐波那契数本质上是一样的，只是在分析这道题的题意的时候要推导出<strong>递推公式</strong></p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp[i]是走到第i个台阶有几种方法，下标i对应第n个台阶</p>
</li>
<li><p>确定递推公式</p>
<p>第i阶台阶的走法由第i-1阶台阶以及第i-2阶台阶方法之和：</p>
<ul>
<li>达到第i阶台阶：第i-1阶台阶只走一步，第i-2阶台阶只走两步</li>
<li>也即第i阶台阶&#x3D;第i-1阶台阶方法×（1）+第i-2阶台阶方法× （1），例如i&#x3D;3，那么到达第三阶台阶只有第二阶台阶方法再走一步以及第一阶台阶走两步</li>
</ul>
<p>也即递推公式：</p>
<p>$$<br>F(n)&#x3D;F(n-1)+F(n-2)<br>$$</p>
</li>
<li><p>dp数组如何初始化：第一阶台阶只有一种方法dp1&#x3D;1，第二阶台阶只有两种方法dp2&#x3D;2</p>
</li>
<li><p>遍历顺序：从前向后，因为后一阶台阶都由前面两阶台阶方法确定</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>检验台阶n的有效性：n&lt;&#x3D;2的时候直接返回n：<code>if(n&lt;=2) return n;</code></p>
</li>
<li><p>初始化dp数组：因为第0阶台阶毫无意义，所以我们只要初始化第一阶和第二阶台阶数值：<code>dp1=1;dp2=2;</code></p>
</li>
<li><p>从第三阶台阶开始遍历，维护dp数组</p>
</li>
<li><p>返回第n阶台阶dp[n]</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">1</span>; <span class="comment">//第一阶一种方法</span></span><br><span class="line">        <span class="type">int</span> dp2=<span class="number">2</span>; <span class="comment">//第二阶两种方法</span></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//从第三阶开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            sum=dp1+dp2;</span><br><span class="line">            dp1=dp2;</span><br><span class="line">            dp2=sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="746-使用最小花费爬楼梯"   >
          <a href="#746-使用最小花费爬楼梯" class="heading-link"><i class="fas fa-link"></i></a><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3>
      <p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/description/" >Leetcode.746题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;14</p>

        <h5 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cost.length;i&gt;=<span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[i-<span class="number">1</span>]&lt;cost[i-<span class="number">2</span>])&#123;</span><br><span class="line">                sum+=cost[i-<span class="number">1</span>];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=cost[i-<span class="number">2</span>];</span><br><span class="line">                i=i-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:</p>
<p>cost&#x3D;[0,2,2,1]</p>
<p>输出：3</p>
<p>预期输出：2</p>

        <h5 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//维护Cost[i]表示跳到当前位置i所需的最小花费之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;cost.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cost[i-<span class="number">1</span>]&lt;cost[i-<span class="number">2</span>])&#123;</span><br><span class="line">                cost[i]=cost[i]+cost[i-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cost[i]=cost[i]+cost[i-<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//因为顶楼可以由倒数第一阶台阶跳一格和倒数第二阶跳两格，所以从两者花费较少的一个达到</span></span><br><span class="line">        <span class="keyword">if</span>(cost[cost.length-<span class="number">2</span>]&lt;cost[cost.length-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> cost[cost.length-<span class="number">2</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cost[cost.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题由前面爬楼梯题目结合了体力值，本质上还是爬楼梯那道题目，但是这里的区别还有在于楼顶在于多少，例如cost&#x3D;{10,15,20}，cost.length&#x3D;&#x3D;3,那么楼顶在下标为3的位置，也即[10,15,20,楼顶]</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp[i]是对应下标i的<strong>最小体力耗费</strong>，i对应台阶位置</p>
</li>
<li><p>确定递推公式</p>
<p>第i个台阶的最小花费在dp[i-1]+cost[i-1]和dp[i-2]+cost[i-2]之间的最小值<br>$$<br>F(n)&#x3D;Math.min(F(n-1)+cost[n-1],F(n-2)+cost[n-2])<br>$$</p>
</li>
<li><p>初始化dp数组：dp[0]&#x3D;0，dp[1]&#x3D;0，因为可以选择从0或者1台阶开始跳，所以选择的时候花费为0，也即站在0台阶或者1台阶的时候不需要体力消耗</p>
</li>
<li><p>遍历顺序：从前向后，后面的台阶一定是前两个台阶走上来的，所以后一个状态一定能从前两个台阶状态确定</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>初始化dp数组，dp&#x3D;0，dp1&#x3D;0，dpi&#x3D;0</p>
</li>
<li><p>遍历cost数组，到达第i个台阶体力消耗是前两个台阶的最小体力消耗加上对应的跳跃消耗：</p>
<p><code>dpi=Math.min(dp0+cost[i-2],dp1+cost[i-1])</code></p>
<p>更新dp0和dp1，<code>dp0=dp1;dp1=dpi;</code></p>
</li>
</ul>
<p>因为顶楼在数组外面，所以达到顶楼之后不需要花费，直接返回dpI</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> dp0=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dp1=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dpi=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cost.length;i++)&#123;</span><br><span class="line">            dpi=Math.min(dp0+cost[i-<span class="number">2</span>],dp1+cost[i-<span class="number">1</span>]);</span><br><span class="line">            dp0=dp1;</span><br><span class="line">            dp1=dpi;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="62-不同路径"   >
          <a href="#62-不同路径" class="heading-link"><i class="fas fa-link"></i></a><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3>
      <p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/submissions/474226548/" >Leetcode.62(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;15</p>

        <h5 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">//如果是第一行则初始化</span></span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果是第一列则初始化</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//反之是需要推导的位置</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//F(M,N)=F(M-1,N)+F(M,N-1);</span></span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题和爬楼梯思路也是一样，但是这个维度从一维变成了二维，当位置(I,J)只能由(i-1,j)往右走以及(i,j-1)往下走，因此很容易可以推出推导公式，那么接下来就是遍历方式以及初始化dp数组的问题了，因为当前位置要靠前两个状态，所以是从左往右以及从上往下遍历。接下来明确dp数组就能简单做出解</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp是从(0,0)走到(i，j)位置走法有几种，下标i，j对应的位置</p>
</li>
<li><p>确定递推公式：当位置处于(i,j)的时候只能由上面(i,j-1)往下走以及由左边(i-1,j)往右走，也即f(M,N)&#x3D;f(M-1,N)×1+f(M,N-1)×1<br>$$<br>F(M,N)&#x3D;F(M-1,N)+F(M,N-1)<br>$$</p>
</li>
<li></li>
<li><p>初始化dp数组：</p>
<ul>
<li>dp数组的第一行只能从起始位置(0,0)往右走，也即走法只有一种（向右），所以第一行初始化为1</li>
<li>dp数组的第一列只能从起始位置(0,0)往下走，也即走法只有一种（向下），所以第一列初始化为1</li>
</ul>
</li>
<li><p>确定遍历顺序：因为位置(i，j)需要(i-1，j)以及(i，j-1)状态，所以遍历是同一列<strong>从左往右</strong>、同一行<strong>从上往下</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>定义dp数组，初始化dp数组：<code>for(int i=0;i&lt;m;i++) dp[i][0]=1; for(int j=0;j&lt;n;j++) dp[0][j]=1;</code></p>
</li>
<li><p>遍历，并给dp数组赋值</p>
</li>
<li><p>返回终点值：<code>return dp[m-1,n-1];</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    	<span class="comment">//初始化dp数组，将第一行以及第一列都初始化为1(最上面以及最左边只有一种走法)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//从左往右从上往下遍历dp数组，给dp数组赋值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="comment">//要推导的位置</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="63-不同路径II"   >
          <a href="#63-不同路径II" class="heading-link"><i class="fas fa-link"></i></a><a href="#63-不同路径II" class="headerlink" title="63.不同路径II"></a>63.不同路径II</h3>
      <p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/description/" >Leetcode.63(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;16</p>

        <h5 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:执行错误</p>
<p>obstacleGrid&#x3D;[0,0]</p>

        <h5 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++) dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++) dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; j&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE：解答错误</p>
<p>obstacleGrid&#x3D;[1,0]</p>
<p>输出1</p>
<p>预期输出0</p>

        <h5 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//如果碰到障碍物后面都走不了</span></span><br><span class="line">            <span class="keyword">else</span> dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//初始化第一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[j][<span class="number">0</span>]==<span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">//如果碰到障碍物后面都走不了</span></span><br><span class="line">            <span class="keyword">else</span> dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="comment">//如果碰到障碍物，那么这条路的方法只能是0</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：这道题和不同路径那道题是大同小异的，但是这道题有障碍，所以在推导公式以及dp数组初始化这方面会不一样</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标含义：dp数组表示从位置(0,0)到位置(i,j)对应有几种路径，下标i，j对应的是具体位置</p>
</li>
<li><p>确定递推公式</p>
<ul>
<li><p>有障碍：当前（i，j）不能走到，也即dp（i，j）等于0<br>$$<br>F(M,N)&#x3D;0<br>$$</p>
</li>
<li><p>无障碍：当前（i，j）路径只能由上方（i，j-1）向下走以及左方（i，j-1）向右走<br>$$<br>F(M,N)&#x3D;F(M-1,N)+F(M,N-1)<br>$$</p>
</li>
</ul>
</li>
<li></li>
<li><p>初始化dp数组</p>
<ul>
<li>初始化第一行，当提供的obs数组没有障碍的时候初始化为1，当提供的obs有障碍，那么有障碍右边都不能到达，初始化为0</li>
<li>初始化第一列，当提供的obs数组没有障碍的时候初始化为1，当提供的obs有障碍，那么有障碍下面都不能到达，初始化为0</li>
</ul>
</li>
<li><p>遍历顺序：从左往右、从上往下</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> width=obstacleGrid[<span class="number">0</span>].length; <span class="comment">//获取宽</span></span><br><span class="line">        <span class="type">int</span> length=obstacleGrid.length;	  <span class="comment">//获取长</span></span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//定义dp数组</span></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[length][width];</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//初始化第一行，当碰到障碍之后都不能向右初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;width &amp;&amp; obstacleGrid[<span class="number">0</span>][i]==<span class="number">0</span>;i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//初始化第一列，碰到障碍之后都不能向下初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;length &amp;&amp; obstacleGrid[j][<span class="number">0</span>]==<span class="number">0</span>; j++)&#123;</span><br><span class="line">            dp[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;width;j++)&#123;</span><br><span class="line">                <span class="comment">//当碰到障碍，则置为0，反之由上和左决定到这个位置的走法有几种</span></span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>) dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][width-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231016091835667.png"  alt="不同路径II">
      </p>

        <h3 id="343-整数拆分"   >
          <a href="#343-整数拆分" class="heading-link"><i class="fas fa-link"></i></a><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3>
      <p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/description/" >Leetcode.343题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;17</p>

        <h5 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> d1=(<span class="type">int</span>)Math.sqrt(n);</span><br><span class="line">        <span class="type">int</span> d2=d1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(d1+d2==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> d1 * d2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> result=n-d1-d2;</span><br><span class="line">            <span class="keyword">return</span> d1 * d2 *result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE：n&#x3D;3</p>
<p>输出1</p>
<p>预期输出2</p>
<p>没做出来</p>

        <h4 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h4>
      <p>思路：求一个数的拆分求积的最大值，那么就有可能有拆分组合的划分，假如拆分成两组，则当i为1的时候另一组为(n-1)，也即积为1×(n-1)，当i为2的时候另一组为(n-2)，也即积为2×(n-2)，…，也能拆分成三组甚至更多，那么我们可以用一个dp数组来代表这些拆分结果积中最大的一个</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp数组用于表示数的最大拆分积，而下标i对应数字n</p>
</li>
<li><p>确定递推公式</p>
<ul>
<li><p>当数字n拆分的时候，那么最大积应该是（i）×（n-i）以及（i）×dp（n-i）以及当前dp（i）中的最大值</p>
<p>因为当n拆分成的时候，i是确定的数，而另一组是不确定的数，它是dp（n-i），它代表着（n-i）这个数被拆分的最大积</p>
</li>
<li><p>最终最大积应该是这三种之一，以及递推公式为<br>$$<br>dp(i)&#x3D;Math.max(dp(i),Math.max(i×dp(n-i),i×(n-i)))<br>$$</p>
</li>
</ul>
</li>
<li><p>dp数组初始化：dp数组的长度是n+1,因为范围是[0,n]，且因为dp[0]和dp[1]毫无意义，所以初始化只需要初始化dp[2]&#x3D;1</p>
</li>
<li><p>遍历顺序，从3往后到n，因为初始化的时候2已经初始化完了，则要n的时候n之前的数的最大积应该被确定</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//因为2已经被初始化完了，所以从3开始初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//因为可以分为两组，那么我们可以从1位置分割，1为1组而(i-1)为另一组，...,直到划分到i/2位置						</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line"> 			<span class="comment">//i的最大积应该是（当前值，j×(i-j)，j×dp(i-j))中最大的一个           </span></span><br><span class="line">            dp[i]=Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="图解-1"   >
          <a href="#图解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-1" class="headerlink" title="图解"></a>图解</h4>
      <p>例如当n&#x3D;3的时候，那么只有一种分组方式也即1和2，那么就dp[3]一定在初始化值，1×2以及1×dp[2]之间，dp数组表示的是数字i时该数字的最大分组乘积</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231017230429124.png"  alt="n等于3时">
      </p>
<p>例如当n等于4的时候，那么可以先分成两组，也即1+3和2+2的分组</p>
<p>如下是分成1+3的状态，那么此状态的dp[4]一定在dp[4]，1×3以及1×dp[3]之间</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231017232119871.png"  alt="n等于4分成1+3的状态">
      </p>
<p>而我们也能分成2+2的分组，就如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231017232724110.png"  alt="n等于4分成2+2的状态">
      </p>
<p>不仅如此，我们也能分成三组，也即1+1+2的分组，但是这个分组在1+3的分组中已经考虑过了，正如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231017234201798.png"  alt="当n等于4的时候1+1+2分组">
      </p>
<p>因此我们可以知道的是，当三个分组的时候也是1+3的分组的情况下分完的结果，说明到这里应该对这个分组积有更明确的理解了</p>
<p>所以dp[i]会在**dp[i]，j×(n-j),j×dp[n-j]**产生最大数，我们维持这个dp[i]成为最大，然后最后返回结果dp[n]即可</p>

        <h3 id="96-不同的二叉搜索树"   >
          <a href="#96-不同的二叉搜索树" class="heading-link"><i class="fas fa-link"></i></a><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3>
      <p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/description/" >Leetcode.96题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;10&#x2F;18</p>

        <h5 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h6>
      <p>纯属巧合，我对这道题二叉搜索树没能理解完。但是根据动态规划的思想还是做出来了，我在下意识中以为只能有二叉搜索树的状态</p>

        <h4 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h4>
      <p>思想：这道题是一个求二叉搜索树的个数，首先要明确二叉搜索树的含义做这道题才能正确求解，这点十分重要</p>
<blockquote>
<p> 二叉搜索树：左子树的结点都会比根节点小，右子树的结点都会比根节点大。</p>
</blockquote>
<p>那么因此当n为2的时候一定只有两种状态，也即1为根，2为右子树以及2为根，1为左子树</p>
<p>那么好像就能从中找出规律，我们可以从1到n开始做根节点，然后根据左右子树而推断出根节点的状态，例如n为2那么一定可以从0和1推断出来状态，也即符合<strong>动态规划</strong>中的特点，由前面确定的状态推断出后面的状态</p>
<p><strong>实现</strong></p>
<ul>
<li><p>动态规划五部曲</p>
<ul>
<li><p>确定dp数组以及下标的含义：dp数组表示存放的各个情况下最大的二叉搜索树个数，下标i对应的数字n也即dp[i]对应i的不同搜索树个数</p>
</li>
<li><p>确定递归函数</p>
<p>当n为3的时候那么就有几种状态，由1做根节点，由2做根节点，由3做根节点</p>
<ul>
<li>当1做根节点的时候，那么左子树有0个结点dp[0]，右子树有2个结点dp[2]</li>
<li>当2做根节点的时候，那么左子树有1个结点dp[1]，右子树有1个结点dp[1]</li>
<li>当3做根节点的时候，那么左子树有2个结点dp[2]，右子树有0个结点dp[0]</li>
<li>因此dp[3]是这三个状态的个数和也即dp[3]&#x3D;dp[0]×dp[2]+dp[1]×dp[1]+dp[2]×dp[0]</li>
</ul>
<p>而推导到全局，那么就能求得以下公式<br>$$<br>dp[n]+&#x3D;dp[i]×dp[n-i]<br>$$</p>
</li>
<li><p>dp数组初始化</p>
<ul>
<li>dp[0]&#x3D;1，因为空树和满二叉树都是一个二叉树，0个结点也是一个状态，只有一种</li>
<li>dp[1]&#x3D;1</li>
</ul>
</li>
<li><p>遍历顺序：从前往后遍历，因为后面状态必须由前面状态确定，也即i从小往大遍历直到n</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
</li>
<li><p>定义dp数组以及初始化</p>
</li>
<li><p>遍历dp数组，i从2开始为dp数组赋值，j从1开始遍历根节点直到i，代表不同的状态</p>
</li>
<li><p>返回结果</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//从2开始赋值，直到赋值到下标n</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//根节点从1开始</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">                dp[i]+=dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="图解-2"   >
          <a href="#图解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-2" class="headerlink" title="图解"></a>图解</h4>
      <p>当n为2的时候，因为二叉搜索树的特性所以我们能轻而易举得到以下图示所示树，也即n为2时只有两种状态：根节点为1以及根节点为2，而这两种状态构成的不同二叉搜索树个数之和就是我们需要的dp[2]</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231018091428333.png"  alt="n等于2">
      </p>
<p>当n为3的时候，我们也能得到三种状态也即当根节点为1，根节点为2，根节点为3，我们先看向根节点1的状态如下图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231018091813420.png"  alt="n为3，根节点为1">
      </p>
<p>然后我们看向根节点为2的时候状态如下图</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231018092215083.png"  alt="n为3，根节点为2">
      </p>
<p>最终当根节点为3的时候状态如下图所示</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231018092517493.png"  alt="n为3，根节点为3">
      </p>
<p>因此由上面三个状态图，我们可以知道dp[3]就由这三种状态二叉搜索树之和确定，也即<strong>dp[3]&#x3D;dp[0]×dp[2]+dp[1]×dp[1]+dp[2]×dp[0]</strong></p>
<p>而当n更大的时候也能从结点个数为0以及结点个数为1两种状态推断出来，不仅如此当结点个数为1的时候也能推出，因为结点个数为1也即左结点为0个右节点为0个的状态</p>

        <h2 id="背包问题"   >
          <a href="#背包问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2>
      
        <h3 id="01背包问题基础"   >
          <a href="#01背包问题基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#01背包问题基础" class="headerlink" title="01背包问题基础"></a>01背包问题基础</h3>
      <p>背包问题的特征：一个物品有重量也有价值，那么在已有的背包容量中可以获取到的物品价值最大。而我们可以用动态规划来解决背包问题。</p>

        <h4 id="1-二维dp数组"   >
          <a href="#1-二维dp数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-二维dp数组" class="headerlink" title="1.二维dp数组"></a>1.二维dp数组</h4>
      <p>dp数组是<code>dp[i][j]</code>二维数组</p>
<p>关键参数：</p>
<ul>
<li>物品重量，weight[]：weight数组用于存放背包中的每件物品的重量</li>
<li>物品价值：value[]：value数组用于存放每件物品的价值</li>
<li>背包重量N：背包最多能装的重量为N</li>
</ul>
<p>我们利用动态规划来解决背包问题，那么我们从动态规划五部曲开始</p>
<ul>
<li><p>确定dp数组含义以及下标对应的含义：我们可以用二维数组<code>dp[i][j]</code>来表示物品i是否放到重量为j的背包中，这个dp数组维持的是背包容量j中的最大价值</p>
</li>
<li><p>明确递推公式：</p>
<p>对于dp数组来说一件物品只有两种状态：1.被放入到背包中 2.不被放入到背包中</p>
<ul>
<li><p>不被放入到背包中，那么当前物品i的状态也即<code>dp[i][j]=dp[i-1][j]</code>，表示当前物品不放入到背包中，那么背包中的最大价值就是<code>0~i-1</code>件物品放入到背包中</p>
</li>
<li><p>放入到背包中，那么当前物品i的状态也即需要占用背包中的容量，那么就需要获取背包除去当前物品重量之后还能存放的最大价值也即：</p>
<ul>
<li>需要删除背包中价值最低的元素腾出位置给当前物品：<code>dp[i][j]=dp[i-1][j-weight[i]]+value[i]</code>,这段代码含义是将 移出重量和当前重量相同的物品，然后将当前物品放到背包中</li>
</ul>
</li>
<li><p>那么(i，j)对应的dp值就为这两种状态的最大值：<code>dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])</code><br>$$<br>dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])<br>$$</p>
</li>
</ul>
</li>
<li><p>定义dp数组以及初始化</p>
<ul>
<li><p><code>dp[i][j]</code>的i代表物品的个数，那么i初始化为物品的个数</p>
</li>
<li><p><code>dp[i][j]</code>的j代表背包的重量，那么j初始化为背包的最大容量</p>
</li>
<li><p>初始化dp数组</p>
<p>因为递推公式那么<code>[i][j]</code>的状态可以由<code>[i-1][j]</code>以及<code>[i-1][j-weight[i]]</code>推导出来，也即我们如下图所示</p>
</li>
<li><p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231102174724021.png"  alt="初始化dp数组">
      </p>
</li>
<li><p>也即我们只需要初始化第一列为0（背包容量为0的时候装不下任何物品），以及第一列（当第一个物品能装入的时候初始化为那件物品的价值）</p>
</li>
</ul>
</li>
<li><p>遍历顺序</p>
<ul>
<li>先遍历物品</li>
<li>再遍历背包</li>
</ul>
<p>因为<code>dp[i][j]</code>的状态都由上一个状态推出，那么我们只要保证<code>[i-1][0]</code>到<code>[i-1][j]</code>的状态，我们就能确定<code>dp[i][j]</code></p>
</li>
<li><p>打印dp数组，那么dp数组的最后一个元素就是最大的背包价值,也即<code>dp[M-1][N]</code>是最大的价值</p>
</li>
</ul>

        <h4 id="2-一维dp数组"   >
          <a href="#2-一维dp数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-一维dp数组" class="headerlink" title="2.一维dp数组"></a>2.一维dp数组</h4>
      <p>因为二维dp数组，我们<code>i,j</code>的状态由<code>i-1</code>层的状态确定，但是也就是拷贝一份<code>i-1</code>层数据来进行判断，所以我们可以用滚动数组的想法，压缩这个二维数组成为一维数组dp[j]</p>
<ul>
<li><p>确定dp数组以及对应下标含义：dp数组用于表示重量j下的可以存放最大价值，j对应的背包容量</p>
</li>
<li><p>确定递推公式：因为也就两个状态要么装下要么装下，那么<code>dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i])</code><br>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
</li>
<li><p>初始化dp数组：因为当j&#x3D;0的时候物品都装不下，那么初始化dp[0]&#x3D;0,那么以后的状态都需要跟当前状态对比，所以我们默认以后状态数据都是0，那么初始化dp数组都为0</p>
</li>
<li><p>遍历顺序：</p>
<ul>
<li>第一层for循环遍历物品，从0到M-1</li>
<li>第二层for循环遍历背包，从背包的最大容量开始到需要的重量<code>weight[i]</code>，这样是为了防止一个物品被添加了两次</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>

        <h3 id="01背包"   >
          <a href="#01背包" class="heading-link"><i class="fas fa-link"></i></a><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3>
      <p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 </p>
<p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kamacoder.com/problem.php?id=1046" >卡码网46题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="二维数组题解"   >
          <a href="#二维数组题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解" class="headerlink" title="二维数组题解"></a>二维数组题解</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> M=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[M+<span class="number">1</span>][N+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;  <span class="comment">//遍历物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=N;j++)&#123; <span class="comment">//遍历背包</span></span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;weight[i])&#123;</span><br><span class="line">                        <span class="comment">//如果物品比背包容量重也即放不下</span></span><br><span class="line">                        dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//反之放得下</span></span><br><span class="line">                        dp[i][j]=value[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(weight[i]&gt;j) <span class="comment">//如果背包本身就装不下</span></span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];                </span><br><span class="line">                <span class="keyword">else</span>			<span class="comment">//如果装得下</span></span><br><span class="line">                dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-weight[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出最后的最大价值</span></span><br><span class="line">        System.out.println(dp[M-<span class="number">1</span>][N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="一维数组题解"   >
          <a href="#一维数组题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解" class="headerlink" title="一维数组题解"></a>一维数组题解</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc= <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> M=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=N;j&gt;=weight[i];j--)&#123; <span class="comment">//从背包最大容量开始遍历，防止一个物品被记录两次</span></span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(dp[N]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="416-分割等和子集"   >
          <a href="#416-分割等和子集" class="heading-link"><i class="fas fa-link"></i></a><a href="#416-分割等和子集" class="headerlink" title="416.分割等和子集"></a>416.分割等和子集</h4>
      <p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/description/" >Leetcode.416题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;03</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> bagSize=nums.length+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][bagSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;bagSize;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                    dp[i][j]=Math.max(dp[<span class="number">0</span>][j],nums[i]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+nums[i]);</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> remain=sum-dp[i][j];</span><br><span class="line">                <span class="keyword">if</span>(remain==dp[i][j]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums) sum+=i;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//无论怎么都不能平分</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mid=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp+nums[i]&lt;=mid) dp+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dp==mid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="二维数组题解-1"   >
          <a href="#二维数组题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-1" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <ul>
<li><p>确定dp数组及其下标含义：二维dp数组也即<code>dp[i][j]</code>,下标<code>[i]</code>表示的是第i件物品，下标<code>[j]</code>表示背包容量为j。也即<code>dp[i][j]</code>就表示第i件物品是否放到背包容量为j的最大价值</p>
</li>
<li><p>确定递推公式：我们这里将每一件物品的重量都视为价值，那么要平分数组的话，背包容量一定为总价值之和的一半<code>(target=sum/2)</code>,因此我们只需要判断最后一件物品的<code>dp[i][j]==target</code>如果相等那么说明之前的物品中包括当前物品的状态能平分数组。<br>$$<br>dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])<br>$$<br>在递推公式中，当前物品的<code>dp[i][j]</code>由上一层<code>[i-1][j]</code>确定，只有两种状态：要么不放进背包<code>dp[i-1][j]</code>，要么放进背包<code>dp[i-1][j-weight[i]]+value[i]</code></p>
</li>
<li><p>初始化dp数组，dp数组的第一行以及第一列需要初始化数据</p>
<ul>
<li>第一列也即<code>j==0</code>:背包容量为0无法装下任意物品，<code>dp[i][j]=0</code></li>
<li>第一行也即<code>i==0</code>：表示背包中第一个物品，当背包能够装下物品的时候<code>dp[i][j]=dp[0][j-nums[i]]+nums[i]</code></li>
</ul>
</li>
<li><p>遍历顺序：先遍历物品再遍历背包，或者先遍历背包再遍历物品都行，只要<code>[i][j]</code>的状态是由<code>[i-1][...]</code>一层中推断出来的，只要上一层的左上角都被初始化完成，那么就能推断出第<code>(i,j)</code>的数据</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//获取背包容量target</span></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">//奇数和一定不会平分</span></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//初始化第一行数据</span></span><br><span class="line">                    <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j]=nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果装得下物品，那么就尝试装下，如果装不下就是上一个背包的状态</span></span><br><span class="line">                    <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//当最后一个物品遍历完之后的最大价值能等于target也即能平分</span></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>][target]==target;</span><br></pre></td></tr></table></div></figure>


        <h6 id="一维数组题解-1"   >
          <a href="#一维数组题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-1" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候能装下的最大价值物品，由二维数组的状态压缩而来，而<code>j</code>的数据是由总物品价值的一半，超过这个价值的物品就装不下背包中</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：背包容量为0的时候装不下任何物品</p>
</li>
<li><p>确定遍历顺序：</p>
<ul>
<li>先遍历物品，再遍历物品</li>
<li><strong>物品必须倒序遍历</strong>，因为正序遍历的时候不能保证一个物品不会被添加多次，并且结束条件是背包容量要大于等于物品价值</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums) sum+=i;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果价值之和是奇数，那么一定不能平分</span></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;	<span class="comment">//获取目标容量</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                <span class="comment">//倒序遍历</span></span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果最后能装下，那么dp[target]==target</span></span><br><span class="line">        <span class="keyword">return</span> dp[target]==target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="1049-最后一块石头的重量II"   >
          <a href="#1049-最后一块石头的重量II" class="heading-link"><i class="fas fa-link"></i></a><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h4>
      <p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/description/" >Leetcode.1049(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;04</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        stones=boomStone(stones);</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] boomStone(<span class="type">int</span>[] stones)&#123;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">        <span class="type">int</span> length=stones.length;</span><br><span class="line">        <span class="keyword">if</span>(stones.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stones.length%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                stones[<span class="number">0</span>]=stones[stones.length-<span class="number">1</span>]-stones[<span class="number">0</span>];</span><br><span class="line">                length=length-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i+=<span class="number">2</span>)&#123;</span><br><span class="line">                    stones[l++]=stones[i+<span class="number">1</span>]-stones[i];</span><br><span class="line">                &#125;</span><br><span class="line">                length=length/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            stones=boomStone(Arrays.copyOf(stones,length));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stones;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:stones) sum+=i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[stones.length][target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=stones[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> remain=sum-<span class="number">2</span>*dp[stones.length-<span class="number">1</span>][target];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain&gt;=<span class="number">0</span> ? remain : -<span class="number">1</span> * remain; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-8"   >
          <a href="#题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-8" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="二维数组题解-2"   >
          <a href="#二维数组题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-2" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <ul>
<li><p>确定dp数组及其下标含义：二维dp数组也即<code>dp[i][j]</code>,下标<code>[i]</code>表示的是第i件物品，下标<code>[j]</code>表示背包容量为j。也即<code>dp[i][j]</code>就表示第i件物品是否放到背包容量为j的最大价值</p>
</li>
<li><p>确定递推公式：我们这里将每一件物品的重量都视为价值，那么要平分数组的话，背包容量一定为总价值之和的一半<code>(target=sum/2)</code>,因此我们只需要判断最后一件物品的<code>dp[i][j]==target</code>如果相等那么说明之前的物品中包括当前物品的状态能平分数组。<br>$$<br>dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i-1][j-weight[i]]+value[i])<br>$$<br>在递推公式中，当前物品的<code>dp[i][j]</code>由上一层<code>[i-1][j]</code>确定，只有两种状态：要么不放进背包<code>dp[i-1][j]</code>，要么放进背包<code>dp[i-1][j-weight[i]]+value[i]</code></p>
</li>
<li><p>初始化dp数组，dp数组的第一行以及第一列需要初始化数据</p>
<ul>
<li>第一列也即<code>j==0</code>:背包容量为0无法装下任意物品，<code>dp[i][j]=0</code></li>
<li>第一行也即<code>i==0</code>：表示背包中第一个物品，当背包能够装下物品的时候<code>dp[i][j]=dp[0][j-nums[i]]+nums[i]</code></li>
</ul>
</li>
<li><p>遍历顺序：先遍历物品再遍历背包，或者先遍历背包再遍历物品都行，只要<code>[i][j]</code>的状态是由<code>[i-1][...]</code>一层中推断出来的，只要上一层的左上角都被初始化完成，那么就能推断出第<code>(i,j)</code>的数据</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p>思路：尽量把两块分成重量相同的石碓，那么两块石碓相撞之后剩余的就是最小重量，我们可以用背包来装小于等于总重量一半的石碓，而剩下一堆石碓就是重量大于等于总重量一半的石碓</p>
<p><strong>当剩余部分减去背包石碓就是我们要的答案</strong></p>
<p><code>remain-dp[i][j]</code>就是这两堆石碓相撞的结果</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:stones) sum+=i; <span class="comment">//求出总重量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>; <span class="comment">//求出一半的重量，记录背包容量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[stones.length][target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=stones[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=stones[i])</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-stones[i]]+stones[i]);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//剩余部分</span></span><br><span class="line">        <span class="type">int</span> remain=sum-dp[stones.length-<span class="number">1</span>][target];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> remain-dp[stones.length-<span class="number">1</span>][target];<span class="comment">//因为背包容量是向下取整所以remain的部分一定大于等于装入背包的价值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h6 id="一维数组题解-2"   >
          <a href="#一维数组题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-2" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候能装下的最大价值物品，由二维数组的状态压缩而来，而<code>j</code>的数据是由总物品价值的一半，超过这个价值的物品就装不下背包中</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：背包容量为0的时候装不下任何物品</p>
</li>
<li><p>确定遍历顺序：</p>
<ul>
<li>先遍历物品，再遍历物品</li>
<li><strong>物品必须倒序遍历</strong>，因为正序遍历的时候不能保证一个物品不会被添加多次，并且结束条件是背包容量要大于等于物品价值</li>
</ul>
</li>
</ul>
<p>思路：尽量把两块分成重量相同的石碓，那么两块石碓相撞之后剩余的就是最小重量，我们可以用背包来装小于等于总重量一半的石碓，而剩下一堆石碓就是重量大于等于总重量一半的石碓</p>
<p><strong>当剩余部分减去背包石碓就是我们要的答案</strong></p>
<p>那么<code>remain-dp[j]</code>就是这两堆重量相近的石碓最小重量</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:stones) sum+=i;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> target=sum/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> remain=sum-dp[target];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  remain-dp[target]; <span class="comment">//因为背包容量是向下取整所以remain的部分一定大于等于装入背包的价值</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="494-目标和"   >
          <a href="#494-目标和" class="heading-link"><i class="fas fa-link"></i></a><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h4>
      <p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/description/" >Leetcode.494(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;04</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">if</span>(sum&lt;target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> bagSize=(sum-target)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][bagSize+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=bagSize;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=nums[i]) dp[i][j]=nums[i];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&lt;nums[i]) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-nums[i]]+nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][bagSize]==bagSize) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-9"   >
          <a href="#题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-9" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="二维数组题解-3"   >
          <a href="#二维数组题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-3" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <ul>
<li>确定dp数组及其下标含义：二维数组<code>dp[i][j]</code>，我们认为<code>i</code>代表第<code>i-1</code>件物品，也即当<code>i==1</code>的时候说明是第<code>0</code>件物品，<code>j</code>代表当背包容量为<code>j</code>的时候有几种方法，也即<code>dp[i][j]</code>表示第<code>i-1</code>件物品在背包容量为<code>j</code>的时候的方法个数，类似于<strong>爬楼梯</strong>那道题</li>
<li>确定递推公式：当背包容量<code>j</code>小于<code>nums[i]</code>的时候说明背包装不下该物品也即<strong>只有一种状态就是不选中</strong>，那么<code>dp[i][j]=dp[i-1][j]</code>，当背包容量<code>j</code>大于等于<code>nums[i]</code>的时候则背包有两种状态：1.不装入背包中<code>dp[i][j]=dp[i-1][j]</code>，2装入背包中,那么还有<code>j-nums[i]</code>的背包容量的方法个数<code>dp[i][j]=dp[i-1][j-nums[i]]</code>，那么当时的方法就是这两种状态之和：<code>dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i]]</code></li>
</ul>
<p>$$<br>dp[i][j]&#x3D;dp[i-1][j]+dp[i-1][j-nums[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组：</p>
<p>初始化<code>dp[0][0]=1</code>：因为当i为0的时候不代表任何物品，只是空出这一行来为了后面每个物品状态推导，<code>j==0</code>的时候说明背包价值为0，只有<strong>一种方法</strong>，也即<code>dp[i][0]=1</code></p>
</li>
<li><p>遍历顺序：先遍历物品再遍历背包，或者先遍历背包再遍历物品都行，只要<code>[i][j]</code>的状态是由<code>[i-1][...]</code>一层中推断出来的，只要上一层的左上角都被初始化完成，那么就能推断出第<code>(i,j)</code>的数据</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p>思路：因为每个元素要么是加法要么是减法，我们可以默认为加法算出加法和，然后选出部分元素成为减法，也即dp数组用于表示每个物品被选成减法的状态。背包价值<code>j</code>就是这样确定：<strong>背包价值j代表了要求负数之和</strong>，<code>int remain=(sum-target) /2 </code>：算出需要消除的部分的一半就是负数之和</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> remain=(sum-target)/<span class="number">2</span>;<span class="comment">//负数的之和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target || sum-<span class="number">2</span>*remain !=target ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>][remain+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//初始化 当背包容量为0的时候就认为只有一种方法那就是不选中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将i等于1的时候指向物品0 i等于2的时候指向物品1 </span></span><br><span class="line">            <span class="type">int</span> num=nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=remain;j++)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//当选中状态的时候一共有两种方法，一个是不选择该物品 dp[i-1][j] </span></span><br><span class="line">                <span class="comment">//另一种是选中该物品剩下容量物品的方法 dp[i-1][j-num]</span></span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num) dp[i][j]=dp[i-<span class="number">1</span>][j-num]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][remain];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h6 id="一维数组题解-3"   >
          <a href="#一维数组题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-3" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，由二维数组的状态压缩而来，假如<code>j</code>为1就说明当背包为1的时候组合到负数之和为1有几种方法</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-num[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：背包容量为0的时候装不下物品，也即只有<strong>一种方法（不装）</strong></p>
</li>
<li><p>确定遍历顺序：</p>
<ul>
<li>先遍历物品，再遍历物品</li>
<li><strong>物品必须倒序遍历</strong>，因为正序遍历的时候不能保证一个物品不会被添加多次，并且结束条件是背包容量要大于等于物品价值</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) sum+=num;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bagSize=(sum-target) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target || (sum-target)%<span class="number">2</span> !=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果之和小于目标或者 需要的加法和减法之和不相同则返回0</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//当背包容量为0只有一种方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=bagSize;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                dp[j]=dp[j]+dp[j-nums[i]]; <span class="comment">//因为背包是从大往小算，背包只能有两种状态：1不装2装，也即这两种状态之和</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="474-一和零"   >
          <a href="#474-一和零" class="heading-link"><i class="fas fa-link"></i></a><a href="#474-一和零" class="headerlink" title="474.一和零"></a>474.一和零</h4>
      <p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/description/" >Leetcode.474题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;06</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[strs.length+<span class="number">1</span>][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=strs.length;i++)&#123;</span><br><span class="line">            String str=strs[i-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) one++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="comment">//如果满足可以选下</span></span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=zero &amp;&amp; k&gt;=one) </span><br><span class="line">                    dp[i][j][k]=Math.max(dp[i-<span class="number">1</span>][j][k],dp[i-<span class="number">1</span>][j-zero][k-one]+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j][k]=dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.length][m][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-7"   >
          <a href="#提交成功-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-7" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-10"   >
          <a href="#题解-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-10" class="headerlink" title="题解"></a>题解</h5>
      <p>这题可以看成两个维度的背包问题，我们之前的01背包的问题只有考虑物品重量，而这道题我们可以看成要考虑两个重量：一个是0的个数，另一个是1的个数。也即这个背包要从两个维度考虑，而不仅仅只考虑物品重量这一个维度</p>

        <h6 id="三维数组题解"   >
          <a href="#三维数组题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#三维数组题解" class="headerlink" title="三维数组题解"></a>三维数组题解</h6>
      <ul>
<li><p>确定dp数组含义以及下标含义：三维dp数组的<code>i</code>代表的是第i件物品，<code>j</code>代表背包中0的容量，<code>k</code>代表背包中1的容量，也即<code>dp[i][j][k]</code>表示当物品<code>i</code>在背包容量<code>j</code>和<code>k</code>的情况下所能选出的最多物品数</p>
</li>
<li><p>确定递推公式：</p>
<p>每一件物品当0的容量以及和1的容量足够的情况下就有两种状态：1.不选当前物品。2.选当前物品于是这个物品的<code>dp[i][j][k]</code>就在这两种状态的最大值<br>$$<br>dp[i][j][k]&#x3D;Math.max(dp[i-1][j][k],dp[i-1][j-zero][k-one]+1);<br>$$</p>
</li>
<li><p>初始化dp数组：当背包为0的时候装不下任何物品，所以<code>dp[0][0][0]=0</code></p>
</li>
<li><p>遍历顺序：先物品后背包或者先背包后物品都可以</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[strs.length+<span class="number">1</span>][m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=strs.length;i++)&#123;</span><br><span class="line">            String str=strs[i-<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> one=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//求这个字符串所含有的1和0个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) one++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                    <span class="comment">//如果满足可以选下</span></span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=zero &amp;&amp; k&gt;=one) </span><br><span class="line">                    dp[i][j][k]=Math.max(dp[i-<span class="number">1</span>][j][k],dp[i-<span class="number">1</span>][j-zero][k-one]+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j][k]=dp[i-<span class="number">1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[strs.length][m][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="二维数组题解-4"   >
          <a href="#二维数组题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组题解-4" class="headerlink" title="二维数组题解"></a>二维数组题解</h6>
      <p>因此我们可以压缩三维数组的状态，使其成为二维数组（压缩掉了物品i）</p>
<ul>
<li><p>确定dp数组含义以及下标含义：二维dp数组的<code>j</code>代表背包中0的容量，<code>k</code>代表背包中1的容量，也即<code>dp[j][k]</code>表示物品在背包容量<code>j</code>和<code>k</code>的情况下所能选出的最多物品数</p>
</li>
<li><p>确定递推公式：</p>
<p>每一件物品当0的容量以及和1的容量足够的情况下就有两种状态：1.不选当前物品。2.选当前物品。于是这个物品的<code>dp[j][k]</code>就在这两种状态的最大值<br>$$<br>dp[j][k]&#x3D;Math.max(dp[j][k],dp[j-zero][k-one]+1);<br>$$</p>
</li>
<li><p>初始化dp数组：当背包为0的时候装不下任何物品，所以<code>dp[0][0]=0</code></p>
</li>
<li><p>遍历顺序：先物品后背包，背包必须倒序遍历，防止一件物品被添加多次</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">            String str=strs[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c : str.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="string">&#x27;1&#x27;</span>) one ++;</span><br><span class="line">                <span class="keyword">else</span> zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//倒序遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=zero;j--)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=one ;k--)&#123;</span><br><span class="line">                    dp[j][k]=Math.max(dp[j][k],dp[j-zero][k-one]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="完全背包理论基础"   >
          <a href="#完全背包理论基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#完全背包理论基础" class="headerlink" title="完全背包理论基础"></a>完全背包理论基础</h3>
      <p>完全背包对于01背包的区别就在一个物品可以被装入多次，也即完全背包中可以一直装同一个物品，而我们在01背包的一维数组解法中，为了避免一个物品添加多次我们将遍历背包的顺序是倒序遍历，而这里将遍历顺序变成正序遍历就是题解</p>

        <h4 id="一维dp数组"   >
          <a href="#一维dp数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维dp数组" class="headerlink" title="一维dp数组"></a>一维dp数组</h4>
      <p>如01背包的一维数组题解一样，我们能用一个滚动dp数组来求解这道题</p>
<ul>
<li><p>确定dp数组以及对应下标含义：dp数组用于表示重量j下的可以存放最大价值，j对应的背包容量</p>
</li>
<li><p>确定递推公式：因为也就两个状态要么装下要么装下，那么<code>dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i])</code><br>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
</li>
<li><p>初始化dp数组：因为当j&#x3D;0的时候物品都装不下，那么初始化dp[0]&#x3D;0,那么以后的状态都需要跟当前状态对比，所以我们默认以后状态数据都是0，那么初始化dp数组都为0</p>
</li>
<li><p>遍历顺序：</p>
<ul>
<li>第一层for循环遍历物品，从0到M-1，确保遍历每一个物品</li>
<li>第二层for循环遍历背包，从0到bagSize，因为这样可以将一个物品重复添加，也即取之不尽用之不竭</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> N=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> bagSize=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义dp数组</span></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=weight[i];j&lt;=bagSize;j++)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="518-零钱问题II"   >
          <a href="#518-零钱问题II" class="heading-link"><i class="fas fa-link"></i></a><a href="#518-零钱问题II" class="headerlink" title="518.零钱问题II"></a>518.零钱问题II</h4>
      <p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。 </p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change-ii/description/" >Leetcode.518题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;08</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[coins.length+<span class="number">1</span>][amount+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=coins.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> coin=coins[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coin)&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-coin]+coin);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]==amount) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])</span><br><span class="line">                    dp[j]=(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-11"   >
          <a href="#题解-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-11" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-4"   >
          <a href="#一维数组题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-4" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，假如<code>j</code>为1就说明当背包为1的时候使其硬币价值之和为1有几种方法（只装价值为1的一枚硬币）</li>
<li>确定递推公式</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-coins[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：背包容量为0的时候装不下物品，也即只有<strong>一种方法（不装）</strong></p>
</li>
<li><p>确定遍历顺序：这道题的装法不分顺序，也即{1,2}和{2,1}是同一种装法，所以求得方法个数是组合而不是排序</p>
<p>先物品后背包（求组合），假如<code>coins=&#123;1,2,5&#125;</code></p>
<ul>
<li>先遍历物品那么遍历顺序一定是先1装入背包之后2、5依次装入背包，因此只有当j为3的时候只会出现<code>&#123;1,2&#125;</code>的情况</li>
</ul>
<p>先背包后物品（求排序）</p>
<ul>
<li><p>先遍历背包那么当遍历到<code>j==3</code>的时候</p>
<p>遍历物品：</p>
<p>先遍历价值为1的硬币，那么有装入一元硬币和不装一元硬币<code>dp[3]=dp[3] + dp[2] </code> ，第二个<code>dp[3]</code>代表不装一元硬币，<code>dp[2]</code>代表装一元硬币之后有几种方法，因此<code>dp[3]=2</code></p>
<p>再遍历价值为2的硬币，那么有装入二元硬币和不装二元硬币<code>dp[3]=dp[3]+dp[1]</code>，第二个<code>dp[3]</code>代表不装二元硬币，<code>dp[1]</code>代表装二元硬币之后有几种方法，因此<code>dp[3]=2+dp[1]=3</code>，也即此时这个排列中有<code>&#123;1,1,1&#125;,&#123;1,2&#125;,&#123;2,1&#125;</code>，<strong>也即不会是一定是一元硬币先装入背包</strong></p>
</li>
</ul>
</li>
<li><p><strong>求组合则遍历顺序先物品后背包，求排列则遍历顺序先背包后物品</strong></p>
</li>
<li><p>这道题的遍历顺序是求组合，因此是先物品后背包</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//当背包容量为0的时候只能有一种方法就是都不装</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//求组合所以先遍历物品后遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123; <span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;<span class="comment">//背包</span></span><br><span class="line">                dp[j]=dp[j]+dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="377-组合总和IV"   >
          <a href="#377-组合总和IV" class="heading-link"><i class="fas fa-link"></i></a><a href="#377-组合总和IV" class="headerlink" title="377.组合总和IV"></a>377.组合总和IV</h4>
      <p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iv/description/" >Leetcode.377题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;08</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                dp[j]=dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i])</span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="题解-12"   >
          <a href="#题解-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-12" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-5"   >
          <a href="#一维数组题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-5" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，假如<code>j</code>为1就说明当背包为1的时候使其总和价值之和为1有几种方法（只装价值为1数字）</p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个元素的时候，也即<code>j&lt;nums[i]</code><br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个元素的时候，也即<code>j&gt;=nums[i]</code></p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-nums[i]]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：背包容量为0的时候装不下物品，也即只有<strong>一种方法（不装）</strong></p>
</li>
<li><p>确定遍历顺序：这道题是求排序，因为（1,1,2）和（2,1,1）不是同一种方法，也即元素顺序也会造成影响</p>
<p>先背包后物品（求排序）</p>
<ul>
<li><p>先遍历背包那么当遍历到<code>j==3</code>的时候</p>
<p>遍历物品：</p>
<p>先遍历价值为1的元素，那么有装入1和不装1<code>dp[3]=dp[3] + dp[2] </code> ，第二个<code>dp[3]</code>代表不装1这个元素，<code>dp[2]</code>代表装元素1之后有几种方法，因此<code>dp[3]=2</code></p>
<p>再遍历价值为2的元素，那么有装入和不装二元硬币<code>dp[3]=dp[3]+dp[1]</code>，第二个<code>dp[3]</code>代表不装2，<code>dp[1]</code>代表装元素2之后有几种方法，因此<code>dp[3]=2+dp[1]=3</code>，也即此时这个排列中有<code>&#123;1,1,1&#125;,&#123;1,2&#125;,&#123;2,1&#125;</code>，<strong>也即不会是一定是1先装入背包</strong></p>
</li>
</ul>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//背包为0的时候只有一种方法即不装</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                dp[j]=dp[j];</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i]) <span class="comment">//当足够装下元素的时候，还有一种状态就是装下元素</span></span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="卡码网57-爬楼梯"   >
          <a href="#卡码网57-爬楼梯" class="heading-link"><i class="fas fa-link"></i></a><a href="#卡码网57-爬楼梯" class="headerlink" title="卡码网57.爬楼梯"></a>卡码网57.爬楼梯</h4>
      <p><strong>题目描述</strong></p>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 </p>
<p>每次你可以爬至多m (1 &lt;&#x3D; m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ </p>
<p>注意：给定 n 是一个正整数。</p>
<p><strong>输入描述</strong></p>
<p>输入共一行，包含两个正整数，分别表示n, m</p>
<p><strong>输出描述</strong></p>
<p>输出一个整数，表示爬到楼顶的方法数。</p>
<p><strong>输入示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></div></figure>

<p><strong>输出示例</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></div></figure>

<p><strong>提示信息</strong></p>
<p>数据范围：<br>1 &lt;&#x3D; m &lt; n &lt;&#x3D; 32;</p>
<p>当 m &#x3D; 2，n &#x3D; 3 时，n &#x3D; 3 这表示一共有三个台阶，m &#x3D; 2 代表你每次可以爬一个台阶或者两个台阶。</p>
<p>此时你有三种方法可以爬到楼顶。</p>
<ol>
<li>1 阶 + 1 阶 + 1 阶段</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1067" >卡码网57.爬楼梯</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;10</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> m=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//一步到位</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//只走一步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i)&#123;</span><br><span class="line">                    dp[j]+=dp[j-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-8"   >
          <a href="#提交成功-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-8" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-13"   >
          <a href="#题解-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-13" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-6"   >
          <a href="#一维数组题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-6" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <p>我们把被可以爬的楼梯m阶看成m个物品，那么一共有m个物品，把总楼阶数n看成背包容量</p>
<ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有几种方法，假如<code>j</code>为1就说明当总阶数为1的时候，那么有1种方法可以到达一阶</p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个元素的时候，也即<code>j&lt;i</code>要爬的楼层数小于能迈出的步数<br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个元素的时候，也即<code>j&gt;=i</code>要爬的楼层数大于等于能迈出的步数</p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;dp[j]+dp[j-i]<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=1</code>：当总楼阶数是0的时候说明一步到位，也即只有一种方法</p>
<p><code>dp[1]=1</code>：当总楼阶数是1的时候说明只能走一步，也即只有一个方法（只走一步）</p>
</li>
<li><p>确定遍历顺序：这道题是求排序，因为（1,1,2）和（2,1,1）不是同一种方法，也即元素顺序也会造成影响</p>
<p>先背包后物品（求排序），因为总阶数一样的时候，先走几格后走几格也会造成影响</p>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> m=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//一步到位</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//只走一步</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i)&#123;</span><br><span class="line">                    dp[j]+=dp[j-i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="322-零钱兑换"   >
          <a href="#322-零钱兑换" class="heading-link"><i class="fas fa-link"></i></a><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4>
      <p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/description/" >Leetcode.322(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;12</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++) dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=coins.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount? dp[amount]: -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.length;i++) dp[i]=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=coins.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]]);</span><br><span class="line">                    <span class="keyword">if</span>(dp[j]==Integer.MAX_VALUE)</span><br><span class="line">                    dp[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount]==amount? dp[amount]: -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-14"   >
          <a href="#题解-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-14" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-7"   >
          <a href="#一维数组题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-7" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <p>我们把背包容量j认为是需要的零钱总数，而dp数组表示获取零钱总数的最少硬币数</p>
<ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有<strong>最少</strong>几个硬币，假如总金额为3那么最少需要两个硬币（一个一元硬币一个二元硬币）也即<code>dp[3]=2</code></p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个硬币价值的时候，则最少硬币数维持不变<br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个元素的时候，也即<code>j&gt;=coins[i]</code>，最少硬币数为<code>dp[j-coins[i]]+1</code>以及<code>dp[j]</code>之间最小的</p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.min(dp[j],dp[j-coins[i]]+1)<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：总金额为0的时候不需要硬币</p>
<p>dp数组其他元素：初始化为<code>Integer.MAX_VALUE-1</code>,一个达不到的数防止对比较最小值的时候产生影响，并且为了防止数据溢出对最终获取不到总金额的影响</p>
</li>
<li><p>确定遍历顺序：这道题是求硬币总数，无论是组合还是排列，那么硬币的总数都不会变，所以可以先背包后物品，也可以先物品后背包</p>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    	<span class="comment">//初始化dp数组，dp[0]=0,其他数为最大值-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp.length;i++) dp[i]=Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果dp[amount]为最大值-1也即无法达到最后的金额，返回-1，反之返回最小硬币个数dp[j]</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]==Integer.MAX_VALUE-<span class="number">1</span>? -<span class="number">1</span>: dp[amount];</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="279-完全平方数"   >
          <a href="#279-完全平方数" class="heading-link"><i class="fas fa-link"></i></a><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4>
      <p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/description/" >Leetcode.279(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h5 id="第一次做-15"   >
          <a href="#第一次做-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-15" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;13</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//求最大的完全平方数，确定i的平方不会大于n</span></span><br><span class="line">    	<span class="type">int</span> sqrt=(<span class="type">int</span>) Math.sqrt(n);</span><br><span class="line">		</span><br><span class="line">    	<span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i]=Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sqrt;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i * i)&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-9"   >
          <a href="#提交成功-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-9" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-15"   >
          <a href="#题解-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-15" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-8"   >
          <a href="#一维数组题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-8" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <p>这道题和之前零钱兑换的答案几乎一模一样，只是换了一个模样</p>
<ul>
<li><p>确定dp数组以及下标含义：<code>dp[j]</code>表示当背包容量为j的时候有<strong>最少</strong>几个完全平方数，假如数字为3那么最少需要两个完全平方数（一个一元一个二）也即<code>dp[3]=2</code></p>
</li>
<li><p>确定递推公式</p>
<p>当背包装不下这个完全平方数的时候，则最少完全平方数维持不变<br>$$<br>dp[j]&#x3D;dp[j]<br>$$<br>当背包装得下这个完全平方数的时候，也即<code>j&gt;=i*i</code>，最少硬币数为<code>dp[j-i*i]+1</code>以及<code>dp[j]</code>之间最小的</p>
</li>
</ul>
<p>$$<br>dp[j]&#x3D;Math.min(dp[j],dp[j-i*i]+1)<br>$$</p>
<ul>
<li><p>初始化dp数组</p>
<p><code>dp[0]=0</code>：背包为0的时候不需要装完全平方数</p>
<p>dp数组其他元素：初始化为<code>Integer.MAX_VALUE-1</code>,一个达不到的数防止对比较最小值的时候产生影响，并且为了防止数据溢出对最终获取不到总数的影响</p>
</li>
<li><p>确定遍历顺序：这道题是求完全平方数个数，无论是组合还是排列，那么完全平方数的个数都不会变，所以可以先背包后物品，也可以先物品后背包</p>
</li>
<li><p><strong>求排列则遍历顺序先背包后物品，求组合则遍历顺序先物品后背包</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//求最大的完全平方数，确定i的平方不会大于n</span></span><br><span class="line">    	<span class="type">int</span> sqrt=(<span class="type">int</span>) Math.sqrt(n);</span><br><span class="line">		</span><br><span class="line">    	<span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i]=Integer.MAX_VALUE-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sqrt;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=i * i)&#123;</span><br><span class="line">                    dp[j]=Math.min(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="139-单词拆分"   >
          <a href="#139-单词拆分" class="heading-link"><i class="fas fa-link"></i></a><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h4>
      
        <h5 id="第一次做-16"   >
          <a href="#第一次做-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-16" class="headerlink" title="第一次做"></a>第一次做</h5>
      <p>第一次做于23&#x2F;11&#x2F;14</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dirt=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            dirt[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dp.length;j++)&#123;</span><br><span class="line">            <span class="type">int</span>[] tempDirt=Arrays.copyOf(dirt,dirt.length);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;wordDict.size();i++)&#123;</span><br><span class="line">                String str=wordDict.get(i);</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=str.length())&#123;</span><br><span class="line">                    <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;str.length();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tempDirt[str.charAt(k)-<span class="string">&#x27;a&#x27;</span>]&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                            flag=<span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag &amp;&amp; dp[j]&gt;dp[j-str.length()])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;str.length();k++)&#123;</span><br><span class="line">                            tempDirt[str.charAt(k)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        dp[j]=dp[j-str.length()]+str.length();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()]==s.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-12"   >
          <a href="#提交失败-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-12" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="题解-16"   >
          <a href="#题解-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-16" class="headerlink" title="题解"></a>题解</h5>
      
        <h6 id="一维数组题解-9"   >
          <a href="#一维数组题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组题解-9" class="headerlink" title="一维数组题解"></a>一维数组题解</h6>
      <ul>
<li><p>明确dp数组以及下标含义：dp数组用于表示当背包长度为<code>j</code>的时候是否能被字典中的字符串组成，仪表<code>j</code>表示背包长度也即需要组成的字符串<code>s</code>长度</p>
</li>
<li><p>确定递推公式：</p>
<p>当<code>(i,j)</code>这个区间中，如果这个区间的字符串能够在字典中找到，并且<code>dp[j]</code>也为<code>true</code>，就说明<code>dp[j]</code>也为<code>true</code><br>$$<br>i&lt;&#x3D;j,dp[i]&#x3D;&#x3D;true,wordDict.contains(s.substring(i,j))&#x3D;&gt; dp[j]&#x3D;true<br>$$<br>也即<code>dp[i]==true</code>:表示在当前这个字符串之前都能由字典中的字符串组成</p>
<p><code>wordDict.contains(s.substring(i,j))</code>:表示当前字符串在字典中找得到，也即<code>j</code>背包长度下都可以由字典中字符串组成</p>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0]=true</code>：参照字符串为空的情况下为<code>true</code>，以便后序字符串推导</p>
</li>
<li><p>遍历顺序：求<strong>排列</strong>（先背包后物品）：假设字符串<code>s=&quot;leetcode&quot;</code>，字典<code>wordDict=&#123;&quot;leet&quot;,&quot;code&quot;&#125;</code>所以一定是第一个物品<code>&quot;leet&quot;</code>先于第二个物品<code>&quot;code&quot;</code>装入背包，这样才能组成字符串<code>s</code></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String str : wordDict) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> str.length();</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= j                            <span class="comment">//背包要装得下这个字符串长度</span></span><br><span class="line">                        &amp;&amp; dp[i - j] == <span class="literal">true</span>          <span class="comment">//在这个间隔前也要是能由wordDict组成</span></span><br><span class="line">                        &amp;&amp; str.equals(s.substring(i - j, i))<span class="comment">//这个间隔能在这个字典中找到</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>



<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B9.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D/image-20231114164631944.png"  alt="单词拆分">
      </p>

        <h3 id="多重背包"   >
          <a href="#多重背包" class="heading-link"><i class="fas fa-link"></i></a><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3>
      <p>你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 </p>
<p>给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。</p>
<p><strong>输入描述</strong></p>
<p>输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。 </p>
<p>接下来的三行，每行包含 N 个正整数。具体如下： </p>
<p>第二行包含 N 个整数，表示 N 种矿石的重量。 </p>
<p>第三行包含 N 个整数，表示 N 种矿石的价格。 </p>
<p>第四行包含 N 个整数，表示 N 种矿石的可用数量上限。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1066" >卡码网.56题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-17"   >
          <a href="#第一次做-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-17" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;15</p>

        <h5 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> bagSize=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> kind=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] number=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            weight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            value[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            number[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=bagSize;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(number[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(weight[i]&lt;=j)&#123;</span><br><span class="line">                    <span class="type">int</span> temp=dp[j];</span><br><span class="line">                    dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">                    <span class="keyword">if</span>(temp!=dp[j])</span><br><span class="line">                    number[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-13"   >
          <a href="#提交失败-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-13" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-17"   >
          <a href="#题解-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-17" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题（多重背包）也即一个物品既然不止只有一个，但是又不是能无限选，所以我们可以将这些物品分开成一个个物品，每个物品只能选一个，也即2拆分成1+1,3拆分成1+1+1，所以这就是01背包的一种类型</p>
<ul>
<li><p>关键在于将多个物品拆分成一个个物品，所以我们可以先获取每一个物品的总个数，然后将重量和价值重新对齐每一个物品</p>
</li>
<li><p>确定dp数组以及对应下标含义：dp数组用于表示重量j下的可以存放最大价值，j对应的背包容量</p>
</li>
<li><p>确定递推公式：因为也就两个状态要么装下要么装下，那么<code>dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i])</code><br>$$<br>dp[j]&#x3D;Math.max(dp[j],dp[j-weight[i]]+value[i])<br>$$</p>
</li>
<li><p>初始化dp数组：因为当j&#x3D;0的时候物品都装不下，那么初始化dp[0]&#x3D;0,那么以后的状态都需要跟当前状态对比，所以我们默认以后状态数据都是0，那么初始化dp数组都为0</p>
</li>
<li><p>遍历顺序：</p>
<ul>
<li>第一层for循环遍历物品，从0到M-1</li>
<li>第二层for循环遍历背包，从背包的最大容量开始到需要的重量<code>weight[i]</code>，这样是为了防止一个物品被添加了两次</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> bagSize=sc.nextInt();</span><br><span class="line">        <span class="type">int</span> kind=sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] firstWeight=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] firstValue=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="type">int</span>[] number=<span class="keyword">new</span> <span class="title class_">int</span>[kind];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            firstWeight[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            firstValue[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            number[i]=sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取总个数</span></span><br><span class="line">        <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:number) size+=i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//展开</span></span><br><span class="line">        <span class="type">int</span>[] weight=<span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span>[] value=<span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;kind;i++)&#123;</span><br><span class="line">            <span class="comment">//重复的物品将它分开成单独的物品</span></span><br><span class="line">            <span class="keyword">while</span>(number[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                weight[index]=firstWeight[i];</span><br><span class="line">                value[index]=firstValue[i];</span><br><span class="line">                index++;</span><br><span class="line">                number[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[bagSize+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="comment">//倒序遍历防止一个物品被添加两次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=bagSize;j&gt;=weight[i];j--)&#123;</span><br><span class="line">                dp[j]=Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[bagSize]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="打家劫舍"   >
          <a href="#打家劫舍" class="heading-link"><i class="fas fa-link"></i></a><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2>
      
        <h3 id="198-打家劫舍"   >
          <a href="#198-打家劫舍" class="heading-link"><i class="fas fa-link"></i></a><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a>198.打家劫舍</h3>
      <p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/description/" >Leetcode.198题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-18"   >
          <a href="#第一次做-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-18" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;16</p>

        <h5 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>] ? nums[<span class="number">0</span>]: nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[i+<span class="number">2</span>] &gt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                max+=nums[i]+nums[i+<span class="number">2</span>];</span><br><span class="line">                i+=<span class="number">4</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max+=nums[i+<span class="number">1</span>];</span><br><span class="line">                i+=<span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-14"   >
          <a href="#提交失败-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-14" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>] ? nums[<span class="number">0</span>]: nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&gt;nums[i])&#123;</span><br><span class="line">                max-=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    max+=nums[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                max+=nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                max+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-15"   >
          <a href="#提交失败-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-15" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>]=<span class="literal">false</span>;</span><br><span class="line">                dp[i]=<span class="literal">true</span>;</span><br><span class="line">                dp[i+<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i]==<span class="literal">false</span>)</span><br><span class="line">                dp[i+<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i+<span class="number">1</span>]==<span class="literal">true</span>) max+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-16"   >
          <a href="#提交失败-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-16" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-18"   >
          <a href="#题解-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-18" class="headerlink" title="题解"></a>题解</h4>
      <ul>
<li><p>明确dp数组以及下标含义：dp数组表示在下标i的时候能偷到的最大金钱数量，假如i&#x3D;&#x3D;3，那么就表示在三间房子的情况下所能偷到的最大金额，<code>dp[3]</code>不一定会偷第三间屋子，因为可能偷了第二件能保证金额最大就不会偷第三间</p>
</li>
<li><p>明确递推公式</p>
<p>当前屋子的情况只有偷和不偷两种，只有当满足最大金额数量的时候才确定状态，所以也要前两间屋子的状态</p>
<ul>
<li>因为偷了的时候要考虑前两家中第一家屋子偷的金额以及当前屋子偷的金额总价值</li>
<li>如果不偷则要考虑前一家屋子偷的金额最大数量</li>
</ul>
<p>$$<br>dp[i]&#x3D;Math.max(dp[i-1],dp[i-2]+nums[i])<br>$$</p>
<p>解释一下公式：</p>
<ul>
<li><p><code>dp[i-1]</code>表示不偷当前这家，前面一家屋子就能满足最大金额，不一定会偷前一家屋子只是满足前一家的最大金额数量</p>
</li>
<li><p><code>dp[i-2]+nums[i]</code>表示偷当前这家，当前这家的金额为<code>nums[i]</code>，而一定不能偷前面一家，所以之前偷的金额为<code>dp[i-2]</code></p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0]=nums[0]</code>：就一家屋子偷完完事</p>
<p><code>dp[1]=nums[0]&gt;nums[1]? nums[0]:nums[1]</code>：两家偷钱多的一家</p>
</li>
<li><p>遍历顺序</p>
<p>当<code>i=2</code>开始遍历，因为前两家状态确定了，所以从第三家开始递推</p>
</li>
<li><p>打印dp数组</p>
</li>
<li><p>返回<code>dp[nums.length-1]</code>：返回最后一家屋子偷的最大金额为本题题解</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];  <span class="comment">//如果只有一间屋子偷完就结束了</span></span><br><span class="line">    	</span><br><span class="line">    </span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>]? nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);<span class="comment">//dp[i-1]是前一间房子偷的钱最大值（不一定会偷第i-1间)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="213-打家劫舍II"   >
          <a href="#213-打家劫舍II" class="heading-link"><i class="fas fa-link"></i></a><a href="#213-打家劫舍II" class="headerlink" title="213.打家劫舍II"></a>213.打家劫舍II</h3>
      <p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-ii/description/" >Leetcode.213(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-19"   >
          <a href="#第一次做-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-19" class="headerlink" title="第一次做"></a>第一次做</h4>
      
        <h5 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>] &gt;nums[<span class="number">1</span>] ? nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=nums.length-<span class="number">1</span>)</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]-nums[<span class="number">0</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-17"   >
          <a href="#提交失败-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-17" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-19"   >
          <a href="#题解-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-19" class="headerlink" title="题解"></a>题解</h4>
      <p>因为这道题是一个环状数组，所以我们考虑环状数组的时候不知道哪里是头结点，所以我们可以把环状数组撕开，变成线性数组的情况</p>
<p>环状数组的情况有两种：</p>
<ul>
<li>考虑头结点，不考虑尾结点：也即[1,2,3,4,5]只考虑[1,2,3,4]数组的线性问题，头结点不一定就被选中，只要变成这样就变成了打家劫舍I类型的题目</li>
<li>考虑尾结点，不考虑头结点：也即[1,2,3,4,5]只考虑[2,3,4,5]数组的线性问题，尾结点不一定就一定被选中</li>
</ul>
<p>这两种情况下的最大结果就是我们这道题的题解</p>
<p>我们可以把打家劫舍I的答案封装成一段函数，所以我们<strong>传入数组以及起始和结束位置</strong>，就能获得两个线性数组</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">2</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>]? nums[<span class="number">0</span>]:nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//考虑头结点，不考虑尾结点</span></span><br><span class="line">    	<span class="type">int</span> head=robRow(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//考虑尾结点，不考虑头结点</span></span><br><span class="line">        <span class="type">int</span> tail=robRow(nums,<span class="number">1</span>,nums.length);</span><br><span class="line">        <span class="keyword">return</span> head &gt; tail? head: tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打家劫舍I中的线性数组代码封装成的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robRow</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="comment">//获取线性数组（起始位置，结束位置）</span></span><br><span class="line">        <span class="type">int</span>[] num=<span class="keyword">new</span> <span class="title class_">int</span>[end-start];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            num[i]=nums[start++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[num.length];</span><br><span class="line">        dp[<span class="number">0</span>]=num[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=Math.max(num[<span class="number">0</span>],num[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;num.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[num.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="337-打家劫舍III"   >
          <a href="#337-打家劫舍III" class="heading-link"><i class="fas fa-link"></i></a><a href="#337-打家劫舍III" class="headerlink" title="337.打家劫舍III"></a>337.打家劫舍III</h3>
      <p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/" >Leetcode.337题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-20"   >
          <a href="#第一次做-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-20" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;18</p>

        <h5 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=backtracking(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">backtracking</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=backtracking(root.left);</span><br><span class="line">        <span class="type">int</span> right=backtracking(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> leftVal=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightVal=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)</span><br><span class="line">            leftVal=left-root.left.val;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">            rightVal=right-root.right.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(left+right,leftVal-rightVal+root.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-18"   >
          <a href="#提交失败-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-18" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-20"   >
          <a href="#题解-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-20" class="headerlink" title="题解"></a>题解</h4>
      <p>我们可以用一个一维的dp数组来表示当前结点偷还是不偷，<code>dp[0]</code>用于表示不偷当前结点可以获取的最大金币，<code>dp[1]</code>用于表示偷当前结点可以获取的最大金币</p>
<p><strong>递归三部曲部分</strong></p>
<ul>
<li><p>递归函数的参数与返回值</p>
<ul>
<li>返回值:一维dp数组，每一层都会有一个dp数组用于表示当前结点状态</li>
<li>参数：root,根节点</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当遍历到空结点返回，返回初始化为0的dp数组</p>
</li>
<li><p>递归函数的单层逻辑</p>
<p>每一层结点的状态由dp数组表示，<code>dp[0]</code>表示不偷当前结点可以获取的最大金额，<code>dp[1]</code>表示偷当前结点可以获取的最大金额</p>
<p>我们需要采用<strong>后序遍历</strong>，处理完两边子节点再处理根节点</p>
</li>
</ul>
<p><strong>动态规划部分</strong></p>
<ul>
<li><ul>
<li>明确dp数组及其下标含义：dp数组表示当前结点偷与不偷可以获取的最大金额</li>
<li><code>dp[0]</code>：表示不偷当前结点可以获取的最大金额</li>
<li><code>dp[1]</code>：表示偷当前结点可以获取的最大金额</li>
</ul>
</li>
<li><ul>
<li><p>明确递推公式</p>
<p>当前结点状态只有两个，一个是偷当前结点，一个是不偷当前结点，分别对应dp[1]和dp[0]</p>
<ul>
<li>偷当前结点：<code>dp[1]=root.val+leftDp[0]+rightDp[0]</code><ul>
<li>root.val：表示当前结点值</li>
<li>leftDp:表示左孩子递归后返回的dp数组，leftDp[0]意味着左孩子不偷的情况下最大金额</li>
<li>rightDp:表示右孩子递归后返回的dp数组，rightDp[0]意味着左孩子不偷的情况下最大金额</li>
</ul>
</li>
<li>不偷当前结点：<code>dp[0]=Math.max(leftDp[0],leftDp[1])+Math.max(rightDp[0],rightDp[1])</code><ul>
<li>leftDp：当不偷当前结点，则获取左子树的偷与不偷分别获取到的金额的最大金额</li>
<li>rightDp:当不偷当前结点，则获取右子树的偷与不偷分别获取到的金额的最大金额</li>
</ul>
</li>
</ul>
</li>
<li><p>当前结点的状态就是<code>dp[0]</code>和<code>dp[1]</code>的最大值</p>
</li>
</ul>
</li>
<li><ul>
<li><p>初始化dp数组</p>
<p>当遇到空节点的时候返回初始化为0的dp数组</p>
</li>
</ul>
</li>
<li><ul>
<li>遍历顺序：后序遍历</li>
</ul>
</li>
<li><ul>
<li>打印dp数组</li>
</ul>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[] dp=backTracking(root);</span><br><span class="line">       <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>],dp[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] backTracking(TreeNode root)&#123;</span><br><span class="line">       <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="type">int</span>[] leftDp=backTracking(root.left);</span><br><span class="line">       <span class="type">int</span>[] rightDp=backTracking(root.right);</span><br><span class="line">	</span><br><span class="line">       <span class="comment">//偷当前结点dp[0]</span></span><br><span class="line">       dp[<span class="number">1</span>]=root.val+leftDp[<span class="number">0</span>]+rightDp[<span class="number">0</span>];</span><br><span class="line">       <span class="comment">//不偷当前结点dp[0]</span></span><br><span class="line">       dp[<span class="number">0</span>]=Math.max(leftDp[<span class="number">0</span>],leftDp[<span class="number">1</span>])+Math.max(rightDp[<span class="number">0</span>],rightDp[<span class="number">1</span>]);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> dp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="股票问题"   >
          <a href="#股票问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h2>
      
        <h3 id="121-买卖股票的最佳时机"   >
          <a href="#121-买卖股票的最佳时机" class="heading-link"><i class="fas fa-link"></i></a><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h3>
      <p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" >LeetCode.121题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-21"   >
          <a href="#第一次做-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-21" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;19</p>

        <h5 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> lowIndex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;low)&#123;</span><br><span class="line">                low=prices[i];</span><br><span class="line">                lowIndex=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high=low;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=lowIndex+<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;high)&#123;</span><br><span class="line">                high=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> high-low;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-19"   >
          <a href="#提交失败-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-19" class="headerlink" title="提交失败"></a>提交失败</h6>
      <p>CASE:prices&#x3D;[2,4,1] </p>

        <h5 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> low=Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> cul=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//记录一开始买的价格</span></span><br><span class="line">                low=prices[i];</span><br><span class="line">                high=prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cul=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(cul&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//当前是股价下跌</span></span><br><span class="line">                    <span class="keyword">if</span>(prices[i]&lt;low)&#123;</span><br><span class="line">                        <span class="comment">//如果跌出最低价，记录从买入到这次跌之间最大的卖出价格</span></span><br><span class="line">                        <span class="type">int</span> tempMax=high-low;</span><br><span class="line">                        <span class="keyword">if</span>(tempMax&gt;max ) max=tempMax;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//重新购入最低价股票</span></span><br><span class="line">                        low=prices[i];</span><br><span class="line">                        high=low;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当前是股价不跌</span></span><br><span class="line">                    <span class="keyword">if</span>(prices[i]&gt;high)&#123;</span><br><span class="line">                        high=prices[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//到最后没卖出股票，所以我们卖出去</span></span><br><span class="line">        <span class="keyword">if</span>(high!=low)&#123;</span><br><span class="line">            <span class="keyword">if</span>(high-low&gt;max) max=high-low;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//返回这期间的最大值</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-10"   >
          <a href="#提交成功-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-10" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-21"   >
          <a href="#题解-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-21" class="headerlink" title="题解"></a>题解</h4>
      <p>我们可以用一个二维dp数组来表示股票的每一天买卖情况，<code>dp[i][0]</code>表示持有当前股票现金，而<code>dp[i][1]</code>表示当前不持股现金，我们要知道的是这一题中这支股票<strong>只能买卖一次</strong></p>
<ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<ul>
<li>持股的情况下：<ul>
<li>前一天就买入股票：<code>dp[i-1][0]</code>，表示前一天买入股票的最大金额</li>
<li>当天买入股票：<code>-prices[i]</code>，表示今天买入股票，需要支付金额</li>
</ul>
</li>
<li>不持股的情况下：<ul>
<li>前一天就卖出了股票：<code>dp[i-1][1]</code>：表示前一天就卖出了股票</li>
<li>前天持股并且当天把股票卖出：<code>dp[i-1][0]+prices[i]</code>：表示今天卖出股票，所能获取的最大金额</li>
</ul>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],-prices)</code>：表示当天持股所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices)</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=-prices[i]</code>：第一天就买入股票，所以持有股票最大金额是<code>-prices[i]</code></p>
<p><code>dp[0][1]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
<p><del>也即不炒股就不会亏</del></p>
</li>
<li><p>遍历顺序：因为后一天的最大金额需要前一天的最大金额确定，所以<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一天持有股票，支付prices[0]现金</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//第一天不持有股票，持有现金数</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="comment">//持有股票（前一天持股，买入当前股票）之间最大现金</span></span><br><span class="line">        dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//不持有股票（前一天就卖出去，前一天持股并且当天卖出股票）之间最大现金</span></span><br><span class="line">        dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回最后一天卖出股票的价格(因为最后一天卖出去才能赚钱)</span></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>








        <h3 id="122-买卖股票的最佳时机II"   >
          <a href="#122-买卖股票的最佳时机II" class="heading-link"><i class="fas fa-link"></i></a><a href="#122-买卖股票的最佳时机II" class="headerlink" title="122.买卖股票的最佳时机II"></a>122.买卖股票的最佳时机II</h3>
      <p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" >Leetcode.122题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-22"   >
          <a href="#第一次做-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-22" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>这道题其实在贪心算法部分做过了一遍</p>

        <h4 id="第二次做"   >
          <a href="#第二次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次做" class="headerlink" title="第二次做"></a>第二次做</h4>
      <p>第二次做于23&#x2F;11&#x2F;20</p>

        <h5 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>]!=dp[i][<span class="number">1</span>] &amp;&amp;dp[i][<span class="number">1</span>]&gt;<span class="number">0</span>) max=dp[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-20"   >
          <a href="#提交失败-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-20" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-22"   >
          <a href="#题解-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-22" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题和买卖股票I的时候的思路是一样的，但是那支股票只能买卖一次，而这里股票可以买卖多次，所以我们的买卖股票的状态会有所不同</p>
<ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<ul>
<li>持股的情况下：<ul>
<li>前一天就买入股票：<code>dp[i-1][0]</code>，表示前一天买入股票的最大金额</li>
<li>当天买入股票：<code>dp[i-1][1]-prices[i]</code>，表示今天买入股票，需要支付金额，前一天不持有股票的现金减去买入股票价格</li>
</ul>
</li>
<li>不持股的情况下：<ul>
<li>前一天就卖出了股票：<code>dp[i-1][1]</code>：表示前一天就卖出了股票</li>
<li>前天持股并且当天把股票卖出：<code>dp[i-1][0]+prices[i]</code>：表示今天卖出股票，所能获取的最大金额</li>
</ul>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices)</code>：表示当天持股所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices)</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=-prices[i]</code>：第一天就买入股票，所以持有股票最大金额是<code>-prices[i]</code></p>
<p><code>dp[0][1]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
</li>
<li><p>遍历顺序：因为后一天的最大金额需要前一天的最大金额确定，所以<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">       dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">           <span class="comment">//持有股票，可能是前一天就持有股票以及前一天不持有股票的金额-购买股票价格</span></span><br><span class="line">           dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">           <span class="comment">//不持有股票</span></span><br><span class="line">           dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="123-买卖股票的最佳时机III"   >
          <a href="#123-买卖股票的最佳时机III" class="heading-link"><i class="fas fa-link"></i></a><a href="#123-买卖股票的最佳时机III" class="headerlink" title="123.买卖股票的最佳时机III"></a>123.买卖股票的最佳时机III</h3>
      <p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/" >Leetcode.123题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-23"   >
          <a href="#第一次做-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-23" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;21</p>

        <h5 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i];</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length &amp;&amp; num&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max)&#123;</span><br><span class="line">                max=dp[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>]!=dp[i][<span class="number">0</span>])<span class="comment">//同一只股票</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    result=max;</span><br><span class="line">                    max=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-21"   >
          <a href="#提交失败-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-21" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length &amp;&amp; num&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max)&#123;</span><br><span class="line">                max=dp[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>]!=dp[i][<span class="number">0</span>])<span class="comment">//同一只股票</span></span><br><span class="line">                &#123;</span><br><span class="line">                    num++;</span><br><span class="line">                    result+=max;</span><br><span class="line">                    max=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">2</span> &amp;&amp; max!=<span class="number">0</span>) result+=max;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-22"   >
          <a href="#提交失败-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-22" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-23"   >
          <a href="#题解-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-23" class="headerlink" title="题解"></a>题解</h4>
      <p>我们可以用二维数组来表示买卖两次股票的状态，我们把所有状态都推导出来，然后返回卖出股票的最大值即可</p>
<ul>
<li><p>明确dp数组及其下标含义：<code>dp[i][.]</code>表示第<code>i</code>天的金额状态，例如<code>dp[1][0]</code>表示第一天的不操作股票的金额数量</p>
<ul>
<li><code>dp[i][j]</code>：下标<code>j</code>的含义有五种状态，分别对应股票的操作五种状态<ul>
<li><code>dp[i][0]</code>：表示第<code>i</code>天不操作股票，也即不卖入也不卖出，那么现金数应该是0</li>
<li><code>dp[i][1]</code>：表示第一次持有(买入)股票</li>
<li><code>dp[i][2]</code>：表示第一次不持有(卖出)股票</li>
<li><code>dp[i][3]</code>：表示第二次持有(买入)股票</li>
<li><code>dp[i][4]</code>：表示第二次不持有(卖出)股票</li>
</ul>
</li>
</ul>
</li>
<li><p>明确递推公式：因为第<code>i</code>天的状态都可以由第<code>i-1</code>天推导并且操作而来</p>
<ul>
<li><p><code>dp[i][0]</code>：不操作，也即现金一定是0</p>
</li>
<li><p><code>dp[i][1]</code>：第一次买入股票，可以是前一天买入当天持有：<code>dp[i-1][1]</code>，也可以是前一天不操作，当天买入:</p>
<p><code>dp[i-1][0]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2]</code>：第一次卖出股票，可以是前一天卖出：<code>dp[i-1][2]</code>，也可以是前一天持有，第二天卖出： </p>
<p><code>dp[i-1][1]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code></p>
</li>
<li><p><code>dp[i][3]</code>：第二次买入股票，可以是前一天第二次买入：<code>dp[i-1][3]</code>，也可以是前一天第二次卖出，当天买入： </p>
<p><code>dp[i-1][2]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][3]=Math.max(dp[i-1][3],dp[i-1][2]-prices[i])</code></p>
</li>
<li><p><code>dp[i][4]</code>：第二次卖出股票，可以是前一天卖出：<code>dp[i-1][4]</code>，也可以是前一天第二次买入，当天卖出:</p>
<p><code>dp[i-1][3]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][4]=Math.max(dp[i-1][4],dp[i-1][3]+prices[i])</code></p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：第一天不操作，现金为0</p>
<p><code>dp[0][1]=-prices[0]</code>：第一天第一次买入股票，现金为<code>-prices[i]</code></p>
<p><code>dp[0][2]=0</code>：第一次卖出，可以认为是第一次买入然后卖出，现金为0</p>
<p><code>dp[0][3]=-prices[0]</code>：第一天第二次买入股票，可以看成是买卖过一次之后再买入现金为<code>-prices[i]</code></p>
<p><code>dp[0][4]=0</code>：第一天第二次卖出，可以是看成第二次买入之后再卖出，现金为0</p>
</li>
<li><p>遍历顺序：因为<code>i</code>天状态由<code>i-1</code>天推导出来，所以遍历顺序是从前往后</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line">    	<span class="comment">//初始化dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">4</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//都由前一天状态推导而来</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">3</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">4</span>],dp[i-<span class="number">1</span>][<span class="number">3</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//一定是第二次卖出价格更高（因为可以同一天买卖两次，第二次结果包含了第一次）</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="188-买卖股票的最佳时机IV"   >
          <a href="#188-买卖股票的最佳时机IV" class="heading-link"><i class="fas fa-link"></i></a><a href="#188-买卖股票的最佳时机IV" class="headerlink" title="188.买卖股票的最佳时机IV"></a>188.买卖股票的最佳时机IV</h3>
      <p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" >Leetcode.188题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-24"   >
          <a href="#第一次做-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-24" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;22</p>

        <h5 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][(<span class="number">2</span>*k) +<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-11"   >
          <a href="#提交成功-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-11" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-24"   >
          <a href="#题解-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-24" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题和上一题<em>买卖股票的最佳时机III</em>是相似的，因为上一题的买卖次数是两次，而这题的买卖次数为K次，这里是区别</p>
<p>我们可以用二维数组来表示买卖k次股票的状态，我们把所有状态都推导出来，然后返回卖出股票的最大值即可</p>
<ul>
<li><p>明确dp数组及其下标含义：<code>dp[i][.]</code>表示第<code>i</code>天的金额状态，例如<code>dp[1][0]</code>表示第一天的不操作股票的金额数量</p>
<ul>
<li><code>dp[i][j]</code>：下标<code>j</code>的含义有<code>2*k+1</code>种状态，分别对应股票的操作<code>2*k+1</code>种状态<ul>
<li><code>dp[i][0]</code>：表示第<code>i</code>天不操作股票，也即不卖入也不卖出，那么现金数应该是0</li>
<li><code>dp[i][1]</code>：表示第一次持有(买入)股票</li>
<li><code>dp[i][2]</code>：表示第一次不持有(卖出)股票</li>
<li><code>...</code></li>
<li><code>dp[i][2k-1]</code>：表示第k次持有(买入)股票</li>
<li><code>dp[i][2k]</code>：表示第k次不持有(卖出)股票</li>
</ul>
</li>
</ul>
</li>
<li><p>明确递推公式：因为第<code>i</code>天的状态都可以由第<code>i-1</code>天推导并且操作而来</p>
<ul>
<li><p><code>dp[i][0]</code>：不操作，也即现金一定是0</p>
</li>
<li><p><code>dp[i][1]</code>：第一次买入股票，可以是前一天买入当天持有：<code>dp[i-1][1]</code>，也可以是前一天不操作，当天买入:</p>
<p><code>dp[i-1][0]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2]</code>：第一次卖出股票，可以是前一天卖出：<code>dp[i-1][2]</code>，也可以是前一天持有，第二天卖出： </p>
<p><code>dp[i-1][1]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code></p>
</li>
<li><p><code>...</code></p>
</li>
<li><p><code>dp[i][2k-1]</code>：第k次买入股票，可以是前一天第k次买入：<code>dp[i-1][2k-1]</code>，也可以是前一天第k-1次卖出，当天买入： </p>
<p><code>dp[i-1][2k-2]-prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2k]=Math.max(dp[i-1][2k-1],dp[i-1][2k-2]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2k]</code>：第k次卖出股票，可以是前一天卖出：<code>dp[i-1][2k]</code>，也可以是前一天第k次买入，当天卖出:</p>
<p><code>dp[i-1][2k-1]+prices[i]</code></p>
<p>也即这两种状态的最大值：<code>dp[i][2k]=Math.max(dp[i-1][2k],dp[i-1][2k-1]+prices[i])</code></p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：第一天不操作，现金为0</p>
<p><code>dp[0][1]=-prices[0]</code>：第一天第一次买入股票，现金为<code>-prices[i]</code></p>
<p><code>dp[0][2]=0</code>：第一次卖出，可以认为是第一次买入然后卖出，现金为0</p>
<p><code>...</code></p>
<p><code>dp[0][2k-1]=-prices[0]</code>：第一天第k次买入股票，可以看成是买卖过k-1次之后再买入现金为<code>-prices[i]</code></p>
<p><code>dp[0][2k]=0</code>：第一天第k次卖出，可以是看成第k次买入之后再卖出，现金为0</p>
</li>
<li><p>遍历顺序：因为<code>i</code>天状态由<code>i-1</code>天推导出来，所以遍历顺序是从前往后</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p>定义dp数组:<code>int[][] dp=new int[prices.length][2*k+1]</code></p>
<ul>
<li>下标i长度：<code>prices.length</code>，下标i对应股市的i+1天，所以一共有股市几天就定义多长dp数组</li>
<li>下标j长度:<code>2k+1</code>：一共要交易k次股票，每一次交易股票对应(买入，卖出)两种状态，所以一共有2k种状态，而不操作股票对应下标0</li>
</ul>
</li>
<li><p>递推公式实现</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第2天开始遍历股市，因为第一天被初始化完了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    <span class="comment">//从第一次买卖股票，到第k次买卖股票</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">        <span class="comment">//如果j是偶数，说明对应不持有股票(前一天第n次不持有，前一天第n-1次持有)最大值</span></span><br><span class="line">        <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//相反j是奇数，说明持有股票</span></span><br><span class="line">            dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：表示不操作股票</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">    <span class="comment">//如果i是偶数说明不持有 股票，应该初始化为0</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">//i是偶数，初始化为-第0天股票价格</span></span><br><span class="line">    dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][(<span class="number">2</span>*k) +<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    	<span class="comment">//初始化第0天的股票状态</span></span><br><span class="line">    	dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果i是偶数说明不持有股票，应该初始化为0</span></span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//i是偶数，初始化为-第0天股票价格</span></span><br><span class="line">            dp[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//j是偶数，不持有股票</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+prices[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//j是奇数，持有股票</span></span><br><span class="line">                    dp[i][j]=Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]-prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][dp[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="309-买卖股票的最佳时机含冷冻期"   >
          <a href="#309-买卖股票的最佳时机含冷冻期" class="heading-link"><i class="fas fa-link"></i></a><a href="#309-买卖股票的最佳时机含冷冻期" class="headerlink" title="309.买卖股票的最佳时机含冷冻期"></a>309.买卖股票的最佳时机含冷冻期</h3>
      <p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" >Leetcode.309(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-25"   >
          <a href="#第一次做-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-25" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;23</p>

        <h5 id="第一次代码-15"   >
          <a href="#第一次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-15" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Mat</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-23"   >
          <a href="#提交失败-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-23" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h6 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//冷冻期(不操作)</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//持有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">0</span>],dp[prices.length-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-12"   >
          <a href="#提交成功-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-12" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h5 id="题解-25"   >
          <a href="#题解-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-25" class="headerlink" title="题解"></a>题解</h5>
      <ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天不操作股票含有的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][2]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<p>因为股票一共分成三个状态：1、不操作（冷冻期）2、持有股票 3、不持有股票，所以我们对这三个状态逐个分析</p>
<ul>
<li><p><code>dp[i][0]</code>冷冻期（不操作股票）：因为不操作的状态由可能有两个状态</p>
<ul>
<li>前一天是冷冻期，当天不操作：<code>dp[i-1][0]</code></li>
<li>前一天卖出股票，当天是冷冻期:<code>dp[i-1][2]</code></li>
</ul>
<p>因此是这两个状态之间的最大值:<code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2])</code></p>
</li>
<li><p><code>dp[i][1]</code>持有股票：持有股票也有两个状态推导而来</p>
<ul>
<li>前一天持有股票，当天不卖出：<code>dp[i-1][1]</code></li>
<li>前一天是冷冻期（不操作股票），当天买入:<code>dp[i-1][0]-prices[i]</code></li>
</ul>
<p>因此是这两个状态之间的最大值:<code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code></p>
</li>
<li><p><code>dp[i][2]</code>不持有股票：不持有股票也有两个状态</p>
<ul>
<li>前一天不持有股票，当天也不持有：<code>dp[i-1][2]</code></li>
<li>前一天持有股票，当天卖出:<code>dp[i-1][1]+prices[i]</code></li>
</ul>
<p>因此i这两个状态之间的最大值:<code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code></p>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][2])</code>：表示当天不操作股票所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])</code>：表示当天持股所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][2]=Math.max(dp[i-1][2],dp[i-1][1]+prices[i])</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=0</code>：第一天不操作股票，所以持有金额是0</p>
<p><code>dp[0][1]=-prices[i]</code>：第一天买入股票，持股的最大金额是-股价</p>
<p><code>dp[0][2]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
</li>
<li><p>遍历顺序：<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    		<span class="comment">//冷冻期(不操控股票)</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//持有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//不持有股票</span></span><br><span class="line">            dp[i][<span class="number">2</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">2</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length-<span class="number">1</span>][<span class="number">0</span>],dp[prices.length-<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="714-买卖股票的最佳时机含手续费"   >
          <a href="#714-买卖股票的最佳时机含手续费" class="heading-link"><i class="fas fa-link"></i></a><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a>714.买卖股票的最佳时机含手续费</h3>
      <p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" >Leetcode.714(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-26"   >
          <a href="#第一次做-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-26" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;24</p>

        <h5 id="第一次代码-16"   >
          <a href="#第一次代码-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-16" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>]-fee;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-13"   >
          <a href="#提交成功-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-13" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-26"   >
          <a href="#题解-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-26" class="headerlink" title="题解"></a>题解</h4>
      <ul>
<li><p>明确dp数组以及下标含义：二维的dp数组用于表示这支股票的持有情况，<code>dp[i][0]</code>表示第<code>i</code>天持有该股的最大金额，<code>dp[i][1]</code>表示第<code>i</code>天不持有该股的最大金额</p>
</li>
<li><p>明确递推公式：</p>
<ul>
<li>持股的情况下：<ul>
<li>前一天就买入股票：<code>dp[i-1][0]</code>，表示前一天买入股票的最大金额</li>
<li>当天买入股票：<code>dp[i-1][1]-prices[i]-fee</code>，表示今天买入股票，需要支付金额并且支付手续费</li>
</ul>
</li>
<li>不持股的情况下：<ul>
<li>前一天就卖出了股票：<code>dp[i-1][1]</code>：表示前一天就卖出了股票</li>
<li>前天持股并且当天把股票卖出：<code>dp[i-1][0]+prices[i]</code>：表示今天卖出股票，所能获取的最大金额</li>
</ul>
</li>
</ul>
<p>因此</p>
<ul>
<li><p><code>dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]-prices)-fee</code>：表示当天持股支付完手续费后所能拥有的最大金额</p>
</li>
<li><p><code>dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]+prices)</code>：表示当天不持股所能拥有的最大金额</p>
</li>
</ul>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=-prices[i]-fee</code>：第一天就买入股票，并且付完手续费，所以持有股票最大金额是<code>-prices[i]</code></p>
<p><code>dp[0][1]=0</code>：第一天不买股票，不持有股票的最大金额是0</p>
</li>
<li><p>遍历顺序：<strong>从前往后</strong></p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    	<span class="comment">//第一天持股，付完手续费</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=-prices[<span class="number">0</span>]-fee;</span><br><span class="line">    	<span class="comment">//第一天不持股</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="comment">//第i天持股（前一天持股，前一天不持股今天买入【需要付手续费】）</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]-fee);</span><br><span class="line">            <span class="comment">//第i天不持股</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="子序列问题"   >
          <a href="#子序列问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2>
      
        <h3 id="300-最长递增子序列"   >
          <a href="#300-最长递增子序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#300-最长递增子序列" class="headerlink" title="300.最长递增子序列"></a>300.最长递增子序列</h3>
      <p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></div></figure>

<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" >Leetcode.300(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-27"   >
          <a href="#第一次做-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-27" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;25</p>

        <h5 id="第一次代码-17"   >
          <a href="#第一次代码-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-17" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];    </span><br><span class="line">        <span class="type">int</span> max=-<span class="number">10001</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;dp[i-<span class="number">1</span>])&#123;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span>(num&gt;max)&#123;</span><br><span class="line">                    max=num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;max) max=num;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-24"   >
          <a href="#提交失败-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-24" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h5 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][<span class="number">2</span>];    </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=nums[i];</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][<span class="number">0</span>]&lt;dp[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>]=Math.max(dp[j][<span class="number">1</span>]+<span class="number">1</span>,dp[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max) max=dp[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="题解-27"   >
          <a href="#题解-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-27" class="headerlink" title="题解"></a>题解</h4>
      <ul>
<li><p>明确dp数组及其下标含义：我们用一个二维的dp数组表示每一个元素为结尾的子序列长度</p>
<ul>
<li><code>dp[i][0]=nums[i]</code>：我们用下标0表示当前元素的数值</li>
<li><code>dp[i][1]</code>：我们用下标1表示以当前元素结尾的递增子序列的最大子序列长度</li>
</ul>
</li>
<li><p>明确递推公式：因为下标<code>i</code>为最长子序列的结尾，所以我们要从<code>i-1</code>的状态开始推断出</p>
<p>我们用<code>j</code>来遍历<code>0~i-1</code>个元素，当<code>nums[j]&lt;nums[i]</code>也即<code>j</code>结尾的子序列到<code>i</code>是递增的也即<br>$$<br>if(dp[j][0]&lt;dp[i][0])&#x3D;&gt;dp[i][1]&#x3D;Math.max(dp[j][1]+1,dp[i][1])<br>$$<br><code>dp[j][0]&lt;·dp[i][0]</code>：表示以<code>j</code>为结尾的最长递增子序列加上<code>i</code>为结尾，一样是递增的</p>
<p><code>dp[j][1]+1</code>：表示将<code>j</code>为结尾的最长子序列+1</p>
<p><code>dp[i][1]</code>：表示当前<code>i</code>为结尾的最长子序列</p>
</li>
<li><p>初始化dp数组</p>
<p><code>dp[0][0]=nums[0]</code>：存储第1个元素数值，用于后面比对</p>
<p><code>dp[0][1]=1</code>：表示将第一个元素添加进子序列的首位</p>
<p><code>dp[i][1]=1</code>：表示每一个元素都可以是子序列的首位</p>
</li>
<li><p>遍历顺序</p>
<ul>
<li>第一个遍历从前往后：<code>0-i-1</code></li>
<li>第二个遍历从前往后也可以从后往前：用于遍历<code>i</code>之前的每一个元素为结尾的子序列状态</li>
</ul>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length][<span class="number">2</span>];    </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//存储数据</span></span><br><span class="line">            dp[i][<span class="number">0</span>]=nums[i];</span><br><span class="line">            <span class="comment">//将每一个子序列设为首位</span></span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="comment">//如果可以是递增的</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j][<span class="number">0</span>]&lt;dp[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    dp[i][<span class="number">1</span>]=Math.max(dp[j][<span class="number">1</span>]+<span class="number">1</span>,dp[i][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//再遍历一遍，用于获取最长子序列长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">1</span>]&gt;max) max=dp[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>因为之前的每一个数值都存在nums数值中，所以可以用一维数组压缩掉数值</p>
<p><strong>压缩状态代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];    </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    dp[i]=Math.max(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="674-最长连续递增序列"   >
          <a href="#674-最长连续递增序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#674-最长连续递增序列" class="headerlink" title="674.最长连续递增序列"></a>674.最长连续递增序列</h3>
      
        <h4 id="第一次做-28"   >
          <a href="#第一次做-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-28" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;26</p>

        <h5 id="第一次代码-18"   >
          <a href="#第一次代码-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-18" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                dp[i]=Math.max(dp[i],dp[i-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交成功-14"   >
          <a href="#提交成功-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-14" class="headerlink" title="提交成功"></a>提交成功</h6>
      
        <h4 id="题解-28"   >
          <a href="#题解-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-28" class="headerlink" title="题解"></a>题解</h4>
      <p>这道题和300那道最长递增子序列关键在于是否是<strong>连续</strong>的，如果是连续的只需要比较当前i位置之前i-1位置元素</p>
<ul>
<li><p>明确dp数组及其下标含义：<code>dp[i]</code>表示以第<code>i</code>个元素为结尾的最长<strong>连续</strong>递增子序列的长度为<code>dp[i]</code>个</p>
</li>
<li><p>明确递推公式：因为<code>i</code>元素比<code>i-1</code>的元素大，也即当前元素为结尾的时候是连续递增的，所以<code>dp[i]=dp[i-1]+1</code>，反之不是连续的，<code>dp[i]=1</code><br>$$<br>dp[i]&#x3D;dp[i-1]+1<br>$$</p>
</li>
<li></li>
<li><p>初始化dp数组：</p>
<p><code>dp[i]=1</code>：表示如果不是连续递增的，则当前元素是连续递增子序列的第一个元素</p>
</li>
<li><p>遍历顺序：从前往后，因为后面的元素需要前面的元素推导而出</p>
</li>
<li><p>打印dp数组</p>
</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//是连续的子序列</span></span><br><span class="line">                dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="718-最长重复子数组"   >
          <a href="#718-最长重复子数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#718-最长重复子数组" class="headerlink" title="718.最长重复子数组"></a>718.最长重复子数组</h3>
      <p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/" >Leetcode.718题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h4 id="第一次做-29"   >
          <a href="#第一次做-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-29" class="headerlink" title="第一次做"></a>第一次做</h4>
      <p>第一次做于23&#x2F;11&#x2F;27</p>

        <h5 id="第一次代码-19"   >
          <a href="#第一次代码-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-19" class="headerlink" title="第一次代码"></a>第一次代码</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums1.length&gt;nums2.length)&#123;</span><br><span class="line">            len=nums1.length;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            len=nums2.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums2.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j ==<span class="number">0</span> )dp[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums1[i-<span class="number">1</span>]==nums2[j-<span class="number">1</span>]&amp;&amp;nums1[i]==nums2[j]) dp[i]=dp[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;max) max=dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="提交失败-25"   >
          <a href="#提交失败-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-25" class="headerlink" title="提交失败"></a>提交失败</h6>
      
        <h4 id="题解-29"   >
          <a href="#题解-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-29" class="headerlink" title="题解"></a>题解</h4>
      
        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/29/%E7%9F%A5%E5%85%B6%E7%84%B6,%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E4%B9%8BJAVA%E8%99%9A%E6%8B%9F%E6%9C%BA-JVM%E7%AF%87%5B1%5D/">知其然,知其所以然之JAVA虚拟机-JVM篇[1]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-29</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">63</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><h1 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h1>
        <h2 id="字节码篇"   >
          <a href="#字节码篇" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节码篇" class="headerlink" title="字节码篇"></a>字节码篇</h2>
      <p>说说JVM的生命周期？</p>
<p>什么是JAVA虚拟机?</p>
<p>jvm的组成-》尽量手能画出来</p>
<p>为什么要使用JVM虚拟机？</p>
<p>说说Java虚拟机的体系结构？  </p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/29/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B6-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%5D/">深入剖析并发编程-JUC篇[6.并发容器]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-29</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">0</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/26/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B8.%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%5D/">死之前要做完的算法手册-[8.贪心算法]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-26</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.3k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">145分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="贪心算法"   >
          <a href="#贪心算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1>
      
        <h2 id="贪心算法理论基础"   >
          <a href="#贪心算法理论基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#贪心算法理论基础" class="headerlink" title="贪心算法理论基础"></a>贪心算法理论基础</h2>
      <p>贪心算法就是由<strong>局部最优解推出全局最优解</strong>，并且没有反例。</p>
<p>比如取钞票取十张，那么怎么样才能取到总数最大的呢？</p>
<p>也即每次都取最大面额(100)的钞票，那么一共取十张就是一个总数最大的一个结果</p>
<p>贪心也类似于我们的常识性的解决方案，所以实际上没有一个必然的套路，我们从题目开始做起学习</p>

        <h2 id="455-分发饼干"   >
          <a href="#455-分发饼干" class="heading-link"><i class="fas fa-link"></i></a><a href="#455-分发饼干" class="headerlink" title="455.分发饼干"></a>455.分发饼干</h2>
      <p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/" >Leetcode.455(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;27</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g.length&amp;&amp;i&lt;s.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[i])</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:g&#x3D;[10,9,8,7] s&#x3D;[5,6,7,8] 输出0 预期输出2</p>
<p>原因是这饼干小的时候没有发出饼干，然后直接把这个对应的小朋友i给丢弃了，而后面有符合胃口大小的饼干</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;g.length &amp;&amp; j&lt;s.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：将小孩按胃口从小到大排序，饼干大小从大到小排序。然后喂小孩的时候就喂最小能满足胃口的饼干即可</p>
<blockquote>
<p>局部最优解：每个小孩只吃比自己胃口相等或者比胃口大的饼干，并且是从小胃口开始投喂，大胃口就一直饿着</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">     	<span class="comment">//小孩和饼干排序</span></span><br><span class="line">    	Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    		循环</span></span><br><span class="line"><span class="comment">    			参数i控制的是小孩</span></span><br><span class="line"><span class="comment">    			参数j控制的是饼干</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;g.length &amp;&amp; j&lt;s.length;)&#123;</span><br><span class="line">            <span class="comment">//判断饼干大小是否满足小孩胃口</span></span><br><span class="line">            <span class="keyword">if</span>(g[i]&lt;=s[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//满足胃口则投喂成功，指向下一个小孩</span></span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//指向下一个饼干</span></span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="376-摆动序列"   >
          <a href="#376-摆动序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#376-摆动序列" class="headerlink" title="376.摆动序列"></a>376.摆动序列</h2>
      <p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/" >Leetcode.376题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;27</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span>  )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入nums[0,0] ,输出2 预期输出1</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">if</span>(nums.length!=<span class="number">1</span> &amp;&amp; nums[i+<span class="number">1</span>]-nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span>  )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输出nums&#x3D;[3,3,3,2,5]，输出2，预期输出3</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span>  )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[51,226,208,165,202,286,190,212,219,271,36,245,20,238,238,89,105,66,73,9,254,206,221,237,203,33,249,253,150,102,57,249,203,10,123,178,85,203,35,276,129,116,37,163,99,142,187,249,134,77,217,298,29,127,174,115,122,178,12,80,122,76,16,41,115,84,104,121,127,40,287,129,9,172,112,51,40,135,205,53,259,196,248,5,123,184,209,130,271,42,18,143,24,101,10,273,252,50,173,80,119,129,45,257,299,78,278,78,190,215,284,129,200,232,103,97,167,120,49,298,141,146,154,233,214,196,244,50,110,48,152,82,226,26,254,276,292,286,215,56,128,122,82,241,222,12,272,192,224,136,116,70,39,207,295,49,194,90,210,123,271,18,276,87,177,240,276,33,155,200,51,6,212,36,149,202,48,114,58,91,83,221,175,148,278,300,284,86,191,95,77,215,113,257,153,135,217,76,85,269,126,194,199,195,20,204,194,50,220,228,90,221,256,87,157,246,74,156,9,196,16,259,234,79,31,206,148,12,223,151,96,229,165,9,144,26,255,201,33,89,145,155,1,204,37,107,80,212,88,186,254,9,158,180,24,45,158,100,52,131,71,174,229,236,296,299,184,168,41,45,76,68,122,85,292,238,293,179,143,128,47,87,267,53,187,76,292,0,160,70,172,292,9,64,156,153,26,145,196,222]</p>
<p>输出201 预期输出202</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">while</span>(i&lt;nums.length-<span class="number">1</span> &amp;&amp; nums[i+<span class="number">1</span>]==nums[i])&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(i==nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">               </span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>( (nums[i]-nums[i-<span class="number">1</span>])*(nums[i+<span class="number">1</span>]-nums[i])&lt;<span class="number">0</span> )&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; nums[i]!=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">               count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>没能自己做出来</p>

        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们只要手机前后坡度不一样的结点，也即波峰或者波谷，然后统计波峰波谷的个数，最后返回个数即可</p>
<blockquote>
<p>局部最优解：每次统计的结点都在波峰或者波谷</p>
</blockquote>
<ul>
<li>情形1：具有单调坡，比如[3,7,2,5,6,8,3]，那么本题解的个数也即5，在单调坡上的元素不能算在内</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927194251615.png"  alt="具有单调坡">
      </p>
<ul>
<li>情形2：只有两个元素，而这又分两种情况<ul>
<li>两个元素不同，如[3,4]，那么摆动序列的长度为2</li>
</ul>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927194627710.png"  alt="两个元素不同">
      </p>
<ul>
<li><ul>
<li>两个元素相同，如[3,3]，那么摆动序列的长度为1</li>
</ul>
</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927194906277.png"  alt="两个元素相同">
      </p>
<p>也即我们当<strong>碰到坡度为0的元素的时候只要处理最后一个元素即可</strong></p>
<ul>
<li><p>情况3：单调坡有平坡的情况</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230927195612985.png"  alt="单调坡有平坡">
      </p>
<p>我们在更新prediff的时候一定要在拐点更新，这样我们后面再统计的时候才不会将5统计进去</p>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>设置长度count&#x3D;1，也即nums最后一个元素默认算一个长度</li>
<li>设置前坡度prediff&#x3D;0，假设第一个元素之前坡度为0</li>
<li>循环遍历(i,nums.length-1)，因为最后一个元素默认算一个长度<ul>
<li>计算当前坡度culdiff&#x3D;nums[i+1]-nums[i]</li>
<li>当峰值的时候统计个数，并且将前坡度更新成当前坡度<ul>
<li>prediff&lt;&#x3D;0 &amp;&amp; culdiff&gt;0 也即前面是下坡或者平坡后面是上坡，也即峰谷</li>
<li>prediff&gt;&#x3D;0 &amp;&amp; culdiff&lt;0 也即前面是上坡或者平坡后面是下坡，也即峰顶</li>
</ul>
</li>
</ul>
</li>
<li>返回count</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">1</span>; <span class="comment">//默认最后一个元素也算一个</span></span><br><span class="line">      	<span class="comment">//默认前面坡度为0</span></span><br><span class="line">    	<span class="type">int</span> prediff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//计算当前结点后面坡度</span></span><br><span class="line">            <span class="type">int</span> culdiff=nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//满足峰值的结点</span></span><br><span class="line">            <span class="keyword">if</span>((prediff&lt;=<span class="number">0</span> &amp;&amp; culdiff&gt;<span class="number">0</span>) ||(prediff&gt;=<span class="number">0</span> &amp;&amp; culdiff&lt;<span class="number">0</span>) )&#123;</span><br><span class="line">                count++;</span><br><span class="line">   				<span class="comment">//将当前坡度更新到前面坡度</span></span><br><span class="line">                prediff=culdiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="53-最大子数组和"   >
          <a href="#53-最大子数组和" class="heading-link"><i class="fas fa-link"></i></a><a href="#53-最大子数组和" class="headerlink" title="53.最大子数组和"></a>53.最大子数组和</h2>
      <p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/" >Leetcode.53(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;28</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> prediff=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="type">int</span> culdiff=nums[i+<span class="number">1</span>]-nums[i];</span><br><span class="line">            <span class="keyword">if</span>(prediff&gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                    max=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(culdiff&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prediff=culdiff;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                    max=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i+<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>题意理解错误，这道题是连续子数组，也即可以是负数算在内</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次代码-1"   >
          <a href="#第四次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-1" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> Nmax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                sum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(i!=j&amp;&amp;Nmax+nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    i=j;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;Nmax)&#123;</span><br><span class="line">                    j=i;</span><br><span class="line">                    Nmax=nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;max)&#123;</span><br><span class="line">                    max=sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(sum,max);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums[-2，-1]，输出0，预期输出-1</p>
<p>没做出来</p>

        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题在第一次做的第三次代码中差一点写出来了，只是还差了一些思路上的问题，也许当时不该看2023年杭州亚运会的英雄联盟项目</p>
<p>思路：当我们在获取连续和为负数的情况，我们不妨让连续和置零，让下一个数成为我们连续子数组和的起始位置，也即<strong>当连续和已经小于0了那么无论怎么样它都会拖累我们后面的数，只能让后面的数字变小</strong>，所以我们当连续和为负数的时候不妨直接丢弃，取下一个数的数值成为连续和</p>
<blockquote>
<p>局部最优解：当连续和为正数的时候继续积累，当连续和为负数的时候丢弃</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>定义变量sum：用于统计当前连续和</p>
</li>
<li><p>定义变量max：用于记录连续和的最大值，注意：<strong>这里max初始化为Integer.MIN_VALUE，当最大连续和是负数的时候也会统计</strong></p>
</li>
<li><p>循环遍历数组</p>
<ul>
<li>取得当前连续和sum+&#x3D;num[i]</li>
<li>如果sum&gt;max，也即是当前连续和最大，将max&#x3D;sum</li>
<li>如果sum&lt;0，说明sum会拖累以后的元素，让后面的连续和变小，所以直接丢弃，sum&#x3D;0</li>
</ul>
</li>
<li><p>返回统计值max</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            <span class="comment">//记录最大的连续和</span></span><br><span class="line">            <span class="keyword">if</span>(sum&gt;max) max=sum;</span><br><span class="line">            <span class="comment">//当连续和为负数</span></span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="122-买卖股票的最佳时机-II"   >
          <a href="#122-买卖股票的最佳时机-II" class="heading-link"><i class="fas fa-link"></i></a><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122.买卖股票的最佳时机 II"></a>122.买卖股票的最佳时机 II</h2>
      <p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" >Leetcode.122题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;30，中秋节快乐！</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buy==<span class="number">0</span>)&#123;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                sell=prices[i+<span class="number">1</span>];</span><br><span class="line">                sum+=sell-buy;</span><br><span class="line">                buy=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:prices:[7,1,5,3,6,4],输出-1，预期输出7</p>
<p>我每次卖股票的时候都是卖掉了当天的，而实际上理论应该是下一天减去这一天，所以我当下一天贵的时候应该卖掉下一天的价格。如果下一天低的时候卖掉当天的价钱</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buy==<span class="number">0</span>)&#123;</span><br><span class="line">                buy=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                sell=prices[i+<span class="number">1</span>];</span><br><span class="line">                sum+=sell-buy;</span><br><span class="line">                buy=<span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sell=prices[i];</span><br><span class="line">                buy=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以假设每天都买卖股票，当下一天股票的价值超过当天价值，那么我们就卖出股票，然后记录下一天卖出股票的利润</p>
<p>如果下一天的股票没有超过当天的价值，那么我们当天就卖出当天购买的股票，也即利润为0，当利润大于0的时候我们记录利润，于是我们的最大利润就是每一天大于0的利润之和</p>
<blockquote>
<p>局部最优解：我们每一天利润大于0的时候统计利润，那么利润最大就是所有利润大于0的总和</p>
</blockquote>
<p><strong>实现</strong></p>
<p>我们获取每一天的股票价格和下一天的股票价格进行比较</p>
<ul>
<li>price[i+1]&gt;price[i]：说明利润大于0，我们要下一天卖出股票并且记录在总利润和之中</li>
<li>price[i+1]&lt;&#x3D;price[i]：说明利润小于等于0，我们每一天就卖出当天自己的股票即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sell=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prices.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//每一天买股票</span></span><br><span class="line">            buy=prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[i+<span class="number">1</span>]&gt;prices[i])&#123;</span><br><span class="line">                <span class="comment">//卖出价为下一天的股票价格，统计利润</span></span><br><span class="line">                sell=prices[i+<span class="number">1</span>];</span><br><span class="line">                sum+=sell-buy;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//卖出价为当天的股票价格</span></span><br><span class="line">                sell=prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//卖出股票</span></span><br><span class="line">            buy=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>简化之后</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//从第二天开始每天都卖前一天股票，当利润大于0的时候就记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>) sum+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="55-跳跃游戏"   >
          <a href="#55-跳跃游戏" class="heading-link"><i class="fas fa-link"></i></a><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h2>
      <p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/description/" >Leetcode.55题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;30</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> step=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(step==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(--i==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sum+=step;</span><br><span class="line">            i+=step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超过时间限制</p>

        <h4 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//记录最大可以跳跃数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;step)&#123;</span><br><span class="line">                step=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果跳跃数为0且值为0那么就说明最大能到达的位置就是这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; step==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           	</span><br><span class="line">            <span class="comment">//向后跳一格，sum++ , step--，i++</span></span><br><span class="line">            sum++;</span><br><span class="line">            step--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以用一个step记录我们能跳的范围，然后我们一步一步跳，如果当前值大于step我们就更新我们的最大跳跃次数，如果我们跳到0的位置并且不能往后跳了就说明最大只能跳到0的位置</p>
<blockquote>
<p>局部最优解：我们每一次获取最大跳跃次数，如果能跳到最后就说明为true</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>定义变量sum:用于记录跳跃了总范围</li>
<li>定义变量step：用于还可以跳几步</li>
<li>循环<ul>
<li>当sum+nums[i]&gt;nums.length-1也即一定能跳到最后位置，返回true</li>
<li>当nums[i]&gt;step:更新最大跳跃次数</li>
<li>当step&#x3D;&#x3D;0&amp;&amp;nums[i]&#x3D;&#x3D;0,也即跳到0的位置也没能力继续往后跳则返回false</li>
<li>sum++,step–,i++:一次跳一格，确保不遗漏</li>
</ul>
</li>
<li>循环结束还没跳到返回false</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(sum+nums[i]&gt;=nums.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//记录最大可以跳跃数</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;step)&#123;</span><br><span class="line">                step=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果跳跃数为0且值为0那么就说明最大能到达的位置就是这里</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">0</span> &amp;&amp; step==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           	</span><br><span class="line">            <span class="comment">//向后跳一格，sum++ , step--，i++</span></span><br><span class="line">            sum++;</span><br><span class="line">            step--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="45-跳跃游戏II"   >
          <a href="#45-跳跃游戏II" class="heading-link"><i class="fas fa-link"></i></a><a href="#45-跳跃游戏II" class="headerlink" title="45.跳跃游戏II"></a>45.跳跃游戏II</h2>
      <p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code> </li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;01</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dept=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+dept&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;dept)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                dept=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            dept--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[7,0,9,6,9,6,1,7,9,0,1,2,9,0,3],输出4，预期输出2</p>

        <h4 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+nums[i]&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i+=nums[i];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交失败-12"   >
          <a href="#提交失败-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-12" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> cover=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=i;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;cover;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+nums[cover]&gt;max)&#123;</span><br><span class="line">                    max=j+nums[cover];</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            i=i+index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-13"   >
          <a href="#提交失败-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-13" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次代码-2"   >
          <a href="#第四次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-2" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;)&#123;</span><br><span class="line">            <span class="type">int</span> cover=nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i+cover&gt;=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> max=i;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=cover;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j+nums[j]&gt;max)&#123;</span><br><span class="line">                    max=j+nums[j];</span><br><span class="line">                    index=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            i=index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-14"   >
          <a href="#提交失败-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-14" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超出时间限制</p>
<p>CASE:nums[1,1,1,1] </p>

        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们用两个覆盖范围，cul来代表当前一跳能到达的位置，next代表下一跳能达到的最大位置，在当前跳的范围中记录下一跳最大位置，如果当前跳能跳到数组的末尾，直接break返回result结果即可，如果当前跳跳不到末尾，那么就启动下一跳的最大位置</p>
<p><strong>实现</strong></p>
<ul>
<li>定义变量<ul>
<li>result：用于记录一共跳了几次</li>
<li>cul：用于表示当前跳的最大覆盖范围</li>
<li>next：用于表示下一跳的最大覆盖范围</li>
</ul>
</li>
<li>当nums.length&#x3D;&#x3D;1，也即只有一个元素，那么不用跳就能跳到末尾，return 0;</li>
<li>循环<ul>
<li>统计当前跳中下一跳能达到的最大覆盖位置next&#x3D;Math.max(i+nums[i],next)<ul>
<li>i+nums[i]表示当前i位置下的最大覆盖范围，和next比较，也即更新最大的覆盖范围给next</li>
</ul>
</li>
<li>如果i&#x3D;&#x3D;cul，也即跳到了当前跳的末尾<ul>
<li>如果cul!&#x3D;nums.length-1，也即当前跳跃跳不到数组的末尾，那么就启动下一跳<ul>
<li>cul&#x3D;next，更新cul为下一跳的最大覆盖范围</li>
<li>result++，表示多跳了一次</li>
<li>判断next是否能跳到数组末尾，如果是则break即可</li>
</ul>
</li>
<li>如果cul&#x3D;&#x3D;nums.length,也即当前跳跃能跳到数组的末尾，break</li>
</ul>
</li>
</ul>
</li>
<li>返回result</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    	<span class="comment">//如果数组只有一个元素，那么不用跳</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//result用于统计跳跃次数，cul用于当前覆盖范围，next表示下一跳覆盖范围</span></span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cul=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> next=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//统计当前跳中最大的覆盖范围，作为下一跳的覆盖范围</span></span><br><span class="line">            next=Math.max(i+nums[i],next);</span><br><span class="line">            <span class="keyword">if</span>(i==cul)&#123;</span><br><span class="line">                <span class="comment">//没有覆盖数组的最后一个元素，也即当前一跳跳不到末尾</span></span><br><span class="line">                <span class="keyword">if</span>(cul!=nums.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    cul=next;</span><br><span class="line">                    result++;</span><br><span class="line">                    <span class="comment">//如果下一跳跳到了break;</span></span><br><span class="line">                    <span class="keyword">if</span>(next&gt;=nums.length-<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果当前跳跳到了就break;</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="1005-K次取反后最大化的数组和"   >
          <a href="#1005-K次取反后最大化的数组和" class="heading-link"><i class="fas fa-link"></i></a><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005.K次取反后最大化的数组和"></a>1005.K次取反后最大化的数组和</h2>
      <p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>
</ul>
<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>
<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/" >Leetcode.1005题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;02</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span> &amp;&amp; k!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i]=-<span class="number">1</span> * nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    count--;</span><br><span class="line">                    nums[i]=-<span class="number">1</span> *nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:nums &#x3D;[-8,3,-5,-3,-5,-2],k&#x3D;6，输出20，预期输出22</p>

        <h4 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span> &amp;&amp;k%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            nums[<span class="number">0</span>]=-<span class="number">1</span>*nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(count==<span class="number">0</span> &amp;&amp; k!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    k=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    k=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                        k=<span class="number">0</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        nums[i-<span class="number">1</span>]=-<span class="number">1</span>*nums[i-<span class="number">1</span>];</span><br><span class="line">                        sum+=<span class="number">2</span>*nums[i-<span class="number">1</span>];</span><br><span class="line">                        k--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    k--;</span><br><span class="line">                    count--;</span><br><span class="line">                    nums[i]=-<span class="number">1</span> *nums[i];         </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-15"   >
          <a href="#提交失败-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-15" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums &#x3D;[8,-7,-3,-9,1,9,-6,-9,3],k&#x3D;8，输出49，预期输出53</p>

        <h4 id="第三次代码-3"   >
          <a href="#第三次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-3" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//如果count&gt;=k,说明不能反转完所有负数</span></span><br><span class="line">        <span class="keyword">if</span>(count&gt;=k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[i]=-<span class="number">1</span>*nums[i];</span><br><span class="line">                    count--;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">                sum+=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//说明能反转完所有负数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    nums[i]=-<span class="number">1</span>*nums[i];</span><br><span class="line">                    count--;</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="comment">//如果还有奇数次要反转，那么就反转正数第一个</span></span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                nums[<span class="number">0</span>]=-<span class="number">1</span>*nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//相加</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们这里的贪心就是，我们尝试将nums数组的所有负数都反转，并且是从绝对值大的负数开始反转，然后反转之后再排序，判断反转次数有没有用完，如果反转次数还没有用完，那么就反转第一个元素，最后统计元素之和</p>
<p><strong>实现</strong></p>
<ul>
<li><p>第一次排序，使数组从小到大排序，例如[-3,-1,0,1,3],那么绝对值越大就越小，<strong>保证反转从绝对值大的负数开始</strong></p>
</li>
<li><p>统计负数个数count，for循环，一旦nums[i]&lt;0，那么count++</p>
</li>
<li><p>尝试将所有负数反转，有两种可能：</p>
<ul>
<li><p>count&gt;k，那么也即所有负数不能反转完，那么我们保证绝对值大的负数先反转</p>
</li>
<li><p>count&lt;k，那么当所有负数反转完毕之后，还有反转次数k没能用完</p>
<p>也即count&#x3D;&#x3D;0 ||k&#x3D;&#x3D;0，那么就反转结束</p>
<p><strong>count&#x3D;&#x3D;0，说明全部负数反转完,break;</strong></p>
<p><strong>k&#x3D;&#x3D;0，说明反转次数用完,break;</strong></p>
<p><em><em>k&gt;0 &amp;&amp; count&gt;0，说明还有负数可以反转,count–,k–,nums</em>&#x3D;-1</em>*</p>
</li>
</ul>
</li>
<li><p>反转完之后再将数组排序，保证从小到大</p>
</li>
<li><p>判断反转次数是否用完</p>
<ul>
<li><p>k%2&#x3D;&#x3D;1,说明还有奇数次，那么只要反转第一个元素即可</p>
</li>
<li><p>k%2&#x3D;&#x3D;0,说明还有偶数次(也可能是0次)，那么不做处理即可</p>
</li>
</ul>
</li>
<li><p>统计数组和sum，for循环遍历nums</p>
</li>
<li><p>返回sum</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//对数组排序，统计小于0的元素个数</span></span><br><span class="line">    	Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//尝试将所有负数反转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>||k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                count--;</span><br><span class="line">                k--;</span><br><span class="line">                nums[i] *=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//对反转之后的数组再排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//说明k大于count，全部反转完还有奇数次未反转</span></span><br><span class="line">        <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">1</span>) nums[<span class="number">0</span>]*=-<span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//统计之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="134-加油站"   >
          <a href="#134-加油站" class="heading-link"><i class="fas fa-link"></i></a><a href="#134-加油站" class="headerlink" title="134.加油站"></a>134.加油站</h2>
      <p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/description/" >Leetcode.134题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;03</p>

        <h4 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=gas.length;</span><br><span class="line">        <span class="type">int</span> length=gas.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-16"   >
          <a href="#提交失败-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-16" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:gas&#x3D;[5,1,2,3,4] cost&#x3D;[4,4,1,5,1] 输出2 预期输出4</p>

        <h4 id="第二次代码-7"   >
          <a href="#第二次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-7" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=gas.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n=gas.length;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-17"   >
          <a href="#提交失败-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-17" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:gas&#x3D;[2],cost&#x3D;[2],输出2,预期输出0</p>

        <h4 id="第三次代码-4"   >
          <a href="#第三次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-4" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> length=gas.length;</span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>]&gt;=<span class="number">0</span> ? <span class="number">0</span>: -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n=gas.length;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>暴力法</strong></p>
<p>思想：每遇到一个站就搜索能不能加够油，然后如果能转一圈到达i，那么就返回i</p>
<p>这里主要是说<strong>贪心算法</strong>的做法，所以这个暴力法只是提一嘴</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">//记录总站数</span></span><br><span class="line">    	<span class="type">int</span> length=gas.length;</span><br><span class="line">    	<span class="comment">//如果只有一站判断能不能出发</span></span><br><span class="line">        <span class="keyword">if</span>(length==<span class="number">1</span>) <span class="keyword">return</span> gas[<span class="number">0</span>]-cost[<span class="number">0</span>]&gt;=<span class="number">0</span> ? <span class="number">0</span>: -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="comment">//记录总油数，当前指向站index，需要走的总站数n</span></span><br><span class="line">            <span class="type">int</span> gap=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n=gas.length;</span><br><span class="line">            <span class="type">int</span> index=i;</span><br><span class="line">            <span class="comment">//如果当前站能走到下一站</span></span><br><span class="line">            <span class="keyword">if</span>(gap+gas[index]&gt;cost[index])&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//尝试走n站，n为总站数长度</span></span><br><span class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    gap+=gas[index%length];</span><br><span class="line">                    <span class="comment">//如果走不到下一站</span></span><br><span class="line">                    <span class="keyword">if</span>(gap-cost[index%length]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    gap-=cost[index%length];</span><br><span class="line">                    n--;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>贪心算法</strong></p>
<p>思路：我们判断一个站的存量和耗油量做一个宏观上的判断，如果gas&gt;cost那么就是增油，如果gas&lt;cost就是耗油，然后当存油量小于0的时候那么就一定不可能重来一遍</p>
<blockquote>
<p>局部最优解：如果油量走到某个位置i小于0，说明要从这个位置之后(i+1)才可能使其能重新跑一遍</p>
</blockquote>
<p>也即我们宏观的判断这个站点是加油还是少油</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231003194034342.png"  alt="加油站">
      </p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义变量start：用于记录第一个站的位置</p>
</li>
<li><p>定义变量cul：用于记录当前油量</p>
</li>
<li><p>定义变量totalCost：用于记录全程旅程总共的油耗量，如果totalCost&lt;0说明怎么走都不可能从头到尾走一遍</p>
</li>
<li><p>循环统计totalCost，如果totalCost小于0则直接返回-1</p>
</li>
<li><p>循环</p>
<ul>
<li>统计总油量cul+&#x3D;gas[i]-cost[i]</li>
<li>如果cul小于0说明到这一站之后不可能继续往后走了<ul>
<li>所以将cul置为0，并且将起始位置start更新成i之后也即start&#x3D;i+1</li>
</ul>
</li>
</ul>
</li>
<li><p>循环之后返回start</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cul=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalCost=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果总耗油量大于存油量那么就不可能重来一遍</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            totalCost+=gas[i]-cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(totalCost&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            cul+=gas[i]-cost[i];</span><br><span class="line">            <span class="comment">//如果当前油量小于0，说明无法从i位置走回i</span></span><br><span class="line">            <span class="keyword">if</span>(cul&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                start=i+<span class="number">1</span>;</span><br><span class="line">                cul=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="135-分发糖果"   >
          <a href="#135-分发糖果" class="heading-link"><i class="fas fa-link"></i></a><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h2>
      <p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/description/" >Leetcode.135题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;04</p>

        <h4 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ratings[<span class="number">0</span>]&gt;ratings[<span class="number">1</span>])&#123;</span><br><span class="line">                    give++;</span><br><span class="line">                &#125;</span><br><span class="line">                total+=give;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-18"   >
          <a href="#提交失败-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-18" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>输入ratings&#x3D;[1,3,2,2,1] 输出6，预期输出7</p>

        <h4 id="第二次代码-8"   >
          <a href="#第二次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-8" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ratings[<span class="number">0</span>]&gt;ratings[<span class="number">1</span>])&#123;</span><br><span class="line">                    give++;</span><br><span class="line">                &#125;</span><br><span class="line">                total+=give;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==ratings.length-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    give++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]==ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    give=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]&lt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    give= give==<span class="number">1</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                total+=give;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-19"   >
          <a href="#提交失败-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-19" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums&#x3D;[1,2,87,87,87,2,1],输出11，预期输出13</p>

        <h4 id="第三次代码-5"   >
          <a href="#第三次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-5" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123;</span><br><span class="line">                        total+=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]==ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]&lt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(give-<span class="number">1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                give= give-<span class="number">1</span>==<span class="number">0</span>? <span class="number">1</span>: give-<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=count;i++)&#123;</span><br><span class="line">                total+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-20"   >
          <a href="#提交失败-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-20" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:ratings&#x3D;[1,3,4,5,2]，输出13，预期输出11</p>

        <h4 id="第四次代码-3"   >
          <a href="#第四次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-3" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> give=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give++;</span><br><span class="line">                <span class="keyword">if</span>(give&gt;max) max=give;</span><br><span class="line">                <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=count;j++)&#123;</span><br><span class="line">                        total+=j;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">1</span>+count&gt;=max &amp;&amp; max!=<span class="number">2</span>) &#123;</span><br><span class="line">                        max=<span class="number">1</span>+count-max+<span class="number">1</span>;</span><br><span class="line">                        total+=<span class="number">1</span>+count-max+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]==ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ratings[i]&lt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(give-<span class="number">1</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                give=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            total+=give;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=count;i++)&#123;</span><br><span class="line">                total+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span>+count&gt;=max &amp;&amp; max!=<span class="number">2</span>) total+=<span class="number">1</span>+count-max+<span class="number">1</span>;</span><br><span class="line">            count=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-21"   >
          <a href="#提交失败-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-21" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>没能做出来</p>

        <h3 id="题解-8"   >
          <a href="#题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们每个小孩最少要有一颗糖，我们可以定义一个candys数组来模拟要分发的小孩糖果个数，并将其初始化为1.</p>
<p>然后我们<strong>从左向右判断</strong>，当右孩子比左孩子大的时候那么右孩子糖果个数应该是左孩子糖果个数+1</p>
<p>不仅如此我们还要<strong>从右向左判断</strong>，当左孩子比右孩子大的时候那么左孩子糖果个数应该是右孩子糖果个数+1</p>
<blockquote>
<p>局部最优解:</p>
<p>当我们第一次从左向右获取了右孩子比左孩子大情况下的最小糖果个数分发情况</p>
<p>当我们第二次从右向左获取了左孩子比右孩子大情况下的最小糖果个数分发情况</p>
<p>我们将这两种情况合并，就是我们的最小糖果分发情况</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>初始化数组candys，初始化数值为1，表示每个小孩最小能分发一颗糖果</p>
</li>
<li><p>遍历，从前往后遍历(i&#x3D;1;i&lt;candys.length;i++)</p>
<p>当右孩子比左孩子大，那么右孩子应该比左孩子多一个糖果也即(ratings[i]&gt;ratings[i-1]时，candys[i]&#x3D;candys[i-1]+1)</p>
<p><em>我们这样就获取了右孩子比左孩子大的分发糖果情况</em></p>
</li>
<li><p>遍历，从后往前遍历(i&#x3D;candys.length-2;i&gt;&#x3D;0;i–)</p>
<p>当左孩子比右孩子大的时候，那么左孩子要比右孩子多一个糖果也即(ratings[i]&gt;rating[i+1])时</p>
<p>candys&#x3D;Math.max(<strong>candys[i],candys[i+1]+1</strong>)，我们在第一次循环获取的分发个数和右孩子糖果个数+1之间取最大值。这样保证了这个糖果个数必然考虑了右孩子比左孩子大也考虑了左孩子比右孩子大的情况</p>
</li>
<li><p>遍历candys数组，获取最终个数result</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candys=<span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="comment">//初始化数组，每个小孩至少一颗糖</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;candys.length;i++)&#123;</span><br><span class="line">            candys[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//右孩子比左孩子大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;ratings.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i-<span class="number">1</span>])&#123;</span><br><span class="line">                candys[i]=candys[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//左孩子比右孩子大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=ratings.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//取原来candys的数量与右孩子数量+1的最大值</span></span><br><span class="line">                candys[i]=Math.max(candys[i],candys[i+<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//统计总数</span></span><br><span class="line">        <span class="type">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:candys)&#123;</span><br><span class="line">            result+=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="860-柠檬水找零"   >
          <a href="#860-柠檬水找零" class="heading-link"><i class="fas fa-link"></i></a><a href="#860-柠檬水找零" class="headerlink" title="860.柠檬水找零"></a>860.柠檬水找零</h2>
      <p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/description/" >Leetcode.860题(easy)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;05</p>

        <h4 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] billsCount=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">if</span>(bills[<span class="number">0</span>]!=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bills.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (bills[i]-<span class="number">5</span>) / <span class="number">5</span> ;</span><br><span class="line">            <span class="keyword">if</span>( result == <span class="number">0</span> )&#123;</span><br><span class="line">                <span class="comment">//支付5 则直接收下</span></span><br><span class="line">                billsCount[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( result ==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//支付10 则要返回一张5</span></span><br><span class="line">                <span class="keyword">if</span>(billsCount[<span class="number">0</span>]==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                billsCount[<span class="number">0</span>]--;</span><br><span class="line">                billsCount[<span class="number">1</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( result ==<span class="number">3</span>)&#123;</span><br><span class="line">                <span class="comment">//支付20则要返回一张10一张5，或者三张5</span></span><br><span class="line">                <span class="keyword">if</span>(billsCount[<span class="number">1</span>]!=<span class="number">0</span> &amp;&amp; billsCount[<span class="number">0</span>] !=<span class="number">0</span>)&#123;</span><br><span class="line">                    billsCount[<span class="number">1</span>]--;</span><br><span class="line">                    billsCount[<span class="number">0</span>]--;</span><br><span class="line">                    billsCount[<span class="number">2</span>]++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(billsCount[<span class="number">0</span>]&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    billsCount[<span class="number">0</span>]-=<span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-9"   >
          <a href="#题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题的情形其实一下子就能想明白，我们只要做好找零的规划就可以解出这道题，支付5元则直接收下，支付10元则找一张5元，支付20元则找一张10元一张五元或者三张五元，而在取舍先找10元还是直接付3张五元的时候要先将面额大的10元支付出去</p>
<blockquote>
<p>局部最优解：在客户支付20的时候优先支付10+5的组合，因为5元更为通用</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>变量five：记录五元钞票的张数，用于找零</li>
<li>变量ten：记录十元钞票的张数，用于找零</li>
<li>遍历接待客人<ul>
<li>如果客人支付五元，直接收下</li>
<li>如果客人支付十元，则找一张五块，如果找不出来则return false</li>
<li>如果客人支付二十元，则优先找10+5元，如果不行再找三张5元，如果都找不出来则return false</li>
</ul>
</li>
<li>遍历结束，说明客人都接待成功了，return true</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> five=<span class="number">0</span>; <span class="type">int</span> ten=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;bills.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i]==<span class="number">5</span>)&#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                five--;</span><br><span class="line">                ten++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i]==<span class="number">20</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(five != <span class="number">0</span> &amp;&amp; ten != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//找一张五块一张10块</span></span><br><span class="line">                    five--;</span><br><span class="line">                    ten--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(five&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="comment">//找三张五块</span></span><br><span class="line">                    five-=<span class="number">3</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//找不出钱</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="406-根据身高重建队列"   >
          <a href="#406-根据身高重建队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#406-根据身高重建队列" class="headerlink" title="406.根据身高重建队列"></a>406.根据身高重建队列</h2>
      <p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/description/" >Leetcode.406(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;06</p>

        <h4 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span>[][] result=<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//排序</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;people.length;j++)&#123;</span><br><span class="line">               <span class="type">int</span> oldNum=people[i][<span class="number">0</span>];</span><br><span class="line">               <span class="type">int</span> newNum=people[j][<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">if</span>(newNum&lt;oldNum)&#123;</span><br><span class="line">                   <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                   people[i]=people[j];</span><br><span class="line">                   people[j]=temp;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNum==oldNum)&#123;</span><br><span class="line">                   <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                   <span class="keyword">if</span>(people[i][<span class="number">1</span>]&gt;people[j][<span class="number">1</span>])&#123;</span><br><span class="line">                       people[i]=people[j];</span><br><span class="line">                       people[j]=temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">           <span class="type">int</span>[] arr=people[i];</span><br><span class="line">           <span class="type">int</span> prev=arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">           <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span>(count!=prev &amp;&amp; j&lt;people.length)&#123;</span><br><span class="line">               <span class="keyword">if</span>(result[j][<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; result[j][<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">               count++;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span>(result[j][<span class="number">0</span>]&gt;=arr[<span class="number">0</span>])</span><br><span class="line">               count++;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>(j&lt;people.length &amp;&amp;(result[j][<span class="number">0</span>]!=<span class="number">0</span> || result[j][<span class="number">1</span>]!=<span class="number">0</span>))&#123;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(j==people.length)&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">           result[j]=arr;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-22"   >
          <a href="#提交失败-22" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-22" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:people：[[0,0],[6,2],[5,5],[4,3],[5,2],[1,1],[6,0],[6,3],[7,0],[5,1]]</p>
<p>输出[[6,0],[1,1],[5,1],[5,2],[4,3],[7,0],[6,2],[5,5],[6,3],[0,0]]</p>
<p>预期输出[[0,0],[6,0],[1,1],[5,1],[5,2],[4,3],[7,0],[6,2],[5,5],[6,3]]</p>

        <h4 id="第二次代码-9"   >
          <a href="#第二次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-9" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] result=<span class="keyword">new</span> <span class="title class_">int</span>[people.length][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> zeroCount=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;people.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldNum=people[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newNum=people[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(newNum&lt;oldNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                    people[i]=people[j];</span><br><span class="line">                    people[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newNum==oldNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                    <span class="keyword">if</span>(people[i][<span class="number">1</span>]&gt;people[j][<span class="number">1</span>])&#123;</span><br><span class="line">                        people[i]=people[j];</span><br><span class="line">                        people[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] arr=people[i];</span><br><span class="line">            <span class="comment">//统计身高为0并且序号为0的元素个数</span></span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; arr[<span class="number">1</span>]==<span class="number">0</span>) zeroCount++;</span><br><span class="line">            <span class="type">int</span> prev=arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//统计一共有多少个位置</span></span><br><span class="line">            <span class="keyword">while</span>(count!=prev &amp;&amp; j&lt;people.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(result[j][<span class="number">0</span>]==<span class="number">0</span> &amp;&amp; result[j][<span class="number">1</span>]==<span class="number">0</span>)</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(result[j][<span class="number">0</span>]&gt;=arr[<span class="number">0</span>])</span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当所在位置j不为空</span></span><br><span class="line">            <span class="keyword">while</span>(j&lt;people.length &amp;&amp;(result[j][<span class="number">0</span>]!=<span class="number">0</span> || result[j][<span class="number">1</span>]!=<span class="number">0</span>))&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==people.length)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            result[j]=arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当身高为0并且排名为0的个数不为1，则将最末尾的元素移到前面</span></span><br><span class="line">        <span class="keyword">if</span>(zeroCount!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span>[][] copyResult=<span class="keyword">new</span> <span class="title class_">int</span>[result.length][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.length-zeroCount;i++)&#123;</span><br><span class="line">                copyResult[zeroCount+i]=result[i];</span><br><span class="line">            &#125;</span><br><span class="line">            result=copyResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-6"   >
          <a href="#提交成功-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-6" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-10"   >
          <a href="#题解-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题也是要考虑两个维度，一个是身高另一个是排在其前面人数，我们不妨确认一个维度身高，身高相同的根据Kj从小到大排序，因为这样就能保证最大身高顺序不会错，然后从小的身高中不断插入到大的队列中</p>
<blockquote>
<p>局部最优解：当身高顺序保证了的时候，矮的插入到高的并不会对原有顺序造成影响</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>先对排队队列排序</p>
<p>排列规则：</p>
<ul>
<li>身高由高到低排序</li>
<li>身高相同的按照kj由小到大排序</li>
</ul>
</li>
<li><p>定义一个集合，用于存放之后正确顺序的身高队形</p>
</li>
<li><p>遍历数组</p>
<ul>
<li>获取index，也即kj代表的是将要插入的位置</li>
<li>插入到集合中</li>
</ul>
</li>
<li><p>将集合变成二维数组返回</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">    	sortQueue(people);</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> index=people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//插入到集合中</span></span><br><span class="line">            list.add(index,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.toArray(people);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortQueue</span><span class="params">(<span class="type">int</span>[][]people)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;people.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;people.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldNum=people[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newNum=people[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldNum&lt;newNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                    people[i]=people[j];</span><br><span class="line">                    people[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldNum==newNum)&#123;</span><br><span class="line">                    <span class="type">int</span> oldQ=people[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> newQ=people[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(oldQ&gt;newQ)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=people[i];</span><br><span class="line">                        people[i]=people[j];</span><br><span class="line">                        people[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231006215439956.png"  alt="根据身高重建队列">
      </p>

        <h2 id="452-用最少数量的箭引爆气球"   >
          <a href="#452-用最少数量的箭引爆气球" class="heading-link"><i class="fas fa-link"></i></a><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452.用最少数量的箭引爆气球"></a>452.用最少数量的箭引爆气球</h2>
      <p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/description/" >Leetcode.452题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;07</p>

        <h4 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        sortShots(points);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] point=points[i];</span><br><span class="line">            <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(shotStart&lt;=END||shotEnd&lt;=END) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(shotEnd&gt;END)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                END=shotEnd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldStart=points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newStart=points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(newStart&lt;oldStart)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                    points[i]=points[j];</span><br><span class="line">                    points[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldStart==newStart)&#123;</span><br><span class="line">                    <span class="type">int</span> oldEnd=points[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> newEnd=points[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(newEnd&lt;oldEnd)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                        points[i]=points[j];</span><br><span class="line">                        points[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-23"   >
          <a href="#提交失败-23" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-23" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:Points[[-2147483648,2147483647]]</p>
<p>输出：0</p>
<p>预期输出：1</p>

        <h4 id="第二次代码-10"   >
          <a href="#第二次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-10" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">       sortShots(points);</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">       <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">           <span class="type">int</span>[] point=points[i];</span><br><span class="line">           <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">           <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(shotStart&lt;= END || shotEnd&lt;=END) <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(shotEnd&gt;END)&#123;</span><br><span class="line">               count++;</span><br><span class="line">               END=shotEnd;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">               <span class="type">int</span> oldStart=points[i][<span class="number">0</span>];</span><br><span class="line">               <span class="type">int</span> newStart=points[j][<span class="number">0</span>];</span><br><span class="line">               <span class="keyword">if</span>(newStart&lt;oldStart)&#123;</span><br><span class="line">                   <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                   points[i]=points[j];</span><br><span class="line">                   points[j]=temp;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldStart==newStart)&#123;</span><br><span class="line">                   <span class="type">int</span> oldEnd=points[i][<span class="number">1</span>];</span><br><span class="line">                   <span class="type">int</span> newEnd=points[j][<span class="number">1</span>];</span><br><span class="line">                   <span class="keyword">if</span>(newEnd&lt;oldEnd)&#123;</span><br><span class="line">                       <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                       points[i]=points[j];</span><br><span class="line">                       points[j]=temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-24"   >
          <a href="#提交失败-24" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-24" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第三次代码-6"   >
          <a href="#第三次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-6" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        sortShots(points);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] point=points[i];</span><br><span class="line">            <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(shotStart&lt;=END &amp;&amp; shotEnd&gt;=END) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span>(END==Integer.MIN_VALUE)&#123;</span><br><span class="line">                    END=shotEnd;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    END=shotStart;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldGap=points[i][<span class="number">1</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newGap=points[j][<span class="number">1</span>]-points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldGap&gt;newGap)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                    points[i]=points[j];</span><br><span class="line">                    points[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-25"   >
          <a href="#提交失败-25" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-25" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第四次提交"   >
          <a href="#第四次提交" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次提交" class="headerlink" title="第四次提交"></a>第四次提交</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        sortShots(points);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> END=Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; hasShot=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] point=points[i];</span><br><span class="line">            <span class="type">int</span> shotStart=point[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> shotEnd=point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(hasShot.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> x:hasShot)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(shotStart&lt;=x &amp;&amp; shotEnd&gt;=x )&#123;</span><br><span class="line">                        flag=<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                count++;</span><br><span class="line">                hasShot.add((shotEnd-shotStart)/<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                hasShot.add((shotEnd-shotStart)/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortShots</span><span class="params">(<span class="type">int</span>[][]points)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;points.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldNum=points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newNum=points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldNum&gt;newNum)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                    points[i]=points[j];</span><br><span class="line">                    points[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldNum==newNum)&#123;</span><br><span class="line">                    <span class="type">int</span> oldGap=points[i][<span class="number">1</span>]-points[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> newGap=points[j][<span class="number">1</span>]-points[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">if</span>(oldGap&gt;newGap)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=points[i];</span><br><span class="line">                        points[i]=points[j];</span><br><span class="line">                        points[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-26"   >
          <a href="#提交失败-26" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-26" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h3 id="题解-11"   >
          <a href="#题解-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们先对气球进行排序，我们就从左边界由小到大排序，进而我们比较的时候只需要将<strong>前一个气球的右边界和当前气球的左边界比较</strong>即可，当不重叠的时候射出一支箭，当重叠的时候则更新最小右边界，保证一支箭能射爆全部重叠气球</p>
<blockquote>
<p>局部最优解：尽量将气球重叠在一起射，这样可以获取最小射箭数</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>排序，对气球数组的左边界从小到大排序</p>
</li>
<li><p>定义变量count用于记录射出的剪数</p>
</li>
<li><p>遍历气球数组</p>
<ul>
<li><p>如果i&#x3D;&#x3D;0，说明是第一个气球，那么必然需要射出一支箭</p>
</li>
<li><p>如果i!&#x3D;0，那么比较当前气球是否和上一个气球重合</p>
<ul>
<li><p>如果当前气球的左边界大于上一个气球的右边界，说明不重合</p>
<p>需要射出一箭</p>
</li>
<li><p>如果当前气球的左边界小于上一个气球的右边界，说明重合</p>
<p>更新当前气球的右边界，使其成为重叠气球中的<strong>最小右边界</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回count</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//用内置函数进行排序</span></span><br><span class="line">        Arrays.sort(points,(a,b)-&gt; Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;points.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">//如果左边界大于前一个右边界说明不重叠</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>]&gt;points[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//更新右边界</span></span><br><span class="line">                points[i][<span class="number">1</span>]=Math.min(points[i-<span class="number">1</span>][<span class="number">1</span>],points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-1"   >
          <a href="#图解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3>
      <p><strong>题意分析</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007045358730.png"  alt="题意分析">
      </p>
<p>我们再举出一个例子如【1,2】，【1,10】，【3,6】，【5,9】，【10,12】</p>
<p>进而来分析需要几支箭</p>
<p><strong>用例排序之后</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007045920353.png"  alt="用例排序之后">
      </p>
<p><strong>求得箭数量过程</strong></p>
<p>因此我们在比较当前气球和上一个气球是否重叠的时候，比较<strong>当前气球的左边界是否大于前一个气球右边界</strong></p>
<p>如果气球左边界大于前一个气球右边界，说明不重叠直接count++</p>
<p>如果气球左边界小于前一个气球右边界，<strong>更新重叠气球最小右边界</strong>，保证一支箭能射爆全部重叠气球</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007050516435.png"  alt="求得箭数量过程">
      </p>

        <h3 id="踩坑点"   >
          <a href="#踩坑点" class="heading-link"><i class="fas fa-link"></i></a><a href="#踩坑点" class="headerlink" title="踩坑点"></a>踩坑点</h3>
      <p>1.在对气球数组的左边界进行排序的时候，如果自己写一个<strong>冒泡排序</strong>，那么就会导致<strong>时间超时！</strong>，所以需要用内置的函数，或者选择其它排序算法排序！</p>
<p>2.如果用内置的函数<code>Arrays.sort()</code>，那么直接用<code>Arrays.sort(points,(a,b)-&gt; a[0]-b[0])</code>在进行Integer边界的数据进行排序，会导致数据溢出而排序出错，所以我们要用内置的排序方式<code>Arrays.sort(points,(a,b)-&gt;Integer.compare(a[0],b[0]))</code></p>

        <h2 id="435-无重叠区间"   >
          <a href="#435-无重叠区间" class="heading-link"><i class="fas fa-link"></i></a><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h2>
      <p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/description/" >Leetcode.435题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;08</p>

        <h4 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        sortErea(intervals);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortErea</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> val=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newVal=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(val&gt;newVal)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-27"   >
          <a href="#提交失败-27" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-27" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:intervals &#x3D;[[1,100],[11,22],[1,11],[2,12]]，输出3，预期输出2</p>

        <h4 id="第二次代码-11"   >
          <a href="#第二次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-11" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        sortErea(intervals);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                intervals[i][<span class="number">1</span>]=intervals[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortErea</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> val=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newVal=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(val&gt;newVal)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(val==newVal)&#123;</span><br><span class="line">                    <span class="type">int</span> oldEnd=arr[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> newEnd=arr[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(oldEnd&gt;newEnd)&#123;</span><br><span class="line">                        <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                        arr[i]=arr[j];</span><br><span class="line">                        arr[j]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-28"   >
          <a href="#提交失败-28" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-28" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:intervals&#x3D;[[-52,31],[-73,-26],[82,97],[-65,-11],[-62,-49],[95,99],[58,95],[-31,49],[66,98],[-63,2],[30,47],[-40,-26]]，输出8，预期输出7</p>
<p>没做出来</p>

        <h3 id="题解-12"   >
          <a href="#题解-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和上一道用射爆气球的题目相似，都是求取相同重叠区间，所以这道题本质上和那个题一样，求取消除重叠区间个数，也即<strong>求取重叠区间个数</strong></p>
<blockquote>
<p>局部最优解：通过左区间排序，这样尽量让区间都重叠在一起，这样就能判断出重叠区间的个数也即消除重叠区间个数</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>对区间排序，通过左区间排序</p>
</li>
<li><p>统计重叠区间个数count</p>
</li>
<li><p>遍历从1开始，和前一个区间比较。当前区间的左区间小于前一个区间的右区间，说明重叠，个数++，并且更新重叠区间的右区间(使其成为<strong>最小右区间</strong>)</p>
</li>
<li><p>返回count</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">       Arrays.sort(intervals,(a,b)-&gt;&#123; <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="comment">//更新重叠区间的最小右区间</span></span><br><span class="line">                intervals[i][<span class="number">1</span>]=Math.min(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="763-划分字母区间"   >
          <a href="#763-划分字母区间" class="heading-link"><i class="fas fa-link"></i></a><a href="#763-划分字母区间" class="headerlink" title="763.划分字母区间"></a>763.划分字母区间</h2>
      <p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/" >Leetcode.763(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;09</p>

        <h4 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> usedCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                used[c-<span class="string">&#x27;a&#x27;</span>]=usedCount;</span><br><span class="line">                usedCount++;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                usedCount=used[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used.length;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[j]&gt;usedCount)&#123;</span><br><span class="line">                        used[j]=usedCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> size=list.size()-usedCount+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                usedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> prex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">            result.add(i-prex);</span><br><span class="line">            prex=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-29"   >
          <a href="#提交失败-29" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-29" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:s&#x3D;”ababcbacadefegdehijhklij”，输出[8,7,8],预期输出[9,7,8]</p>

        <h4 id="第二次代码-12"   >
          <a href="#第二次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-12" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> usedCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=arr[i];</span><br><span class="line">            <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                used[c-<span class="string">&#x27;a&#x27;</span>]=usedCount;</span><br><span class="line">                usedCount++;</span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                usedCount=used[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used.length;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[j]&gt;usedCount)&#123;</span><br><span class="line">                        used[j]=usedCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> size=list.size()-usedCount+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(i);</span><br><span class="line">                usedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> prex=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prex==<span class="number">0</span>)</span><br><span class="line">            result.add(i-prex+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            result.add(i-prex);</span><br><span class="line">            prex=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-30"   >
          <a href="#提交失败-30" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-30" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:s&#x3D;”caedbdedda”</p>
<p>输出[1,10]</p>
<p>预期输出[1,9]</p>

        <h4 id="第三次代码-7"   >
          <a href="#第三次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-7" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    	<span class="comment">//used数组用于表示当前字母属于第几个字符串</span></span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">    	<span class="comment">//list用于表示每个字符串的结束索引</span></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//用于统计字符串个数</span></span><br><span class="line">        <span class="type">int</span> usedCount=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c=arr[i];</span><br><span class="line">            <span class="comment">//如果前面字符串没有包含这个字符，尝试成为新的字符串</span></span><br><span class="line">            <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//更新字符所在字符串个数</span></span><br><span class="line">                used[c-<span class="string">&#x27;a&#x27;</span>]=usedCount;</span><br><span class="line">                <span class="comment">//字符串个数++</span></span><br><span class="line">                usedCount++;</span><br><span class="line">                <span class="comment">//记录结束索引</span></span><br><span class="line">                list.add(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(used[c-<span class="string">&#x27;a&#x27;</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//说明这个字符在前面字符串包括了，那么就要将这个字符串的所有出现字母包括在前一个字符串中</span></span><br><span class="line">                usedCount=used[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;used.length;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(used[j]&gt;usedCount)&#123;</span><br><span class="line">                        used[j]=usedCount;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> size=list.size()-usedCount+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                    list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录前一个字符串的结束索引</span></span><br><span class="line">                list.add(i);</span><br><span class="line">                usedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//用于记录结果，从list中获取每一个字符串的结束位置，转换成字符串长度保存在result中</span></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] resultArr=<span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;resultArr.length;i++)&#123;</span><br><span class="line">            resultArr[i]=list.get(i)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;resultArr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                result.add(resultArr[i]-<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(resultArr[i]-resultArr[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-7"   >
          <a href="#提交成功-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-7" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-13"   >
          <a href="#题解-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们可以用给一个哈希表来统计每个字母的<strong>最远出现位置</strong>，那么<strong>每个字符串维持每个字符的最远出现位置都小于等于该字符串的结束位置</strong>，这样我们可以划分出多个字符串</p>
<blockquote>
<p>局部最优解：我们取得的每个字符串的结束位置一定要大于等于每个字母的最远出现位置</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>定义一个哈希表used，用于记录每个字母的最远结束位置</p>
</li>
<li><p>遍历第一遍字符数组，记录每一个字母的最远出现位置：<code>used[sArr[i]-&#39;a&#39;]=i</code></p>
</li>
<li><p>定义两个变量left和right，left用于表示字符串的起始位置，right用于表示字符串的结束位置</p>
</li>
<li><p>定义结果集result，用于记录每个字符串的长度</p>
</li>
<li><p>遍历第二遍字符数组</p>
<ul>
<li>维持<strong>字符串的结束位置一定大于等于每个字母的最远出现位置</strong>：<code>right=Math.max(right,used[sArr[i]-&#39;a&#39;])</code>，记录right要在right和当前字母最远出现位置的最大值</li>
<li>如果i&#x3D;&#x3D;right，说明遍历到字符的结束位置，那么就该收获字符串<ul>
<li>获取每个字符串的长度，收获到结果集中：<code>result.add(right-left+1)</code></li>
<li>更新下一个字符串的起始位置：left&#x3D;i+1</li>
</ul>
</li>
</ul>
</li>
<li><p>返回结果集result</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] sArr=s.toCharArray();</span><br><span class="line">        <span class="comment">//记录每个字母出现的最远下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sArr.length;i++)&#123;</span><br><span class="line">            used[sArr[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//定义结果集    </span></span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    	<span class="comment">//字符串起始位置left和结束位置right</span></span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;<span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sArr.length;i++)&#123;</span><br><span class="line">            <span class="comment">//保证在字符串中每个字母的最远出现位置right</span></span><br><span class="line">            right=Math.max(right,used[sArr[i]-<span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(right==i)&#123;</span><br><span class="line">                <span class="comment">//如果搜索到最远位置，那么就说明这个字符串的所有字母不会出现再其他位置</span></span><br><span class="line">                <span class="comment">//记录字符串长度，更新下一个字符串的起始位置</span></span><br><span class="line">                result.add(right-left+<span class="number">1</span>);</span><br><span class="line">                left=i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="56-合并区间"   >
          <a href="#56-合并区间" class="heading-link"><i class="fas fa-link"></i></a><a href="#56-合并区间" class="headerlink" title="56.合并区间"></a>56.合并区间</h2>
      <p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/" >Leetcode.56题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;11</p>

        <h4 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        sortMerge(intervals);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[] &gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                intervals[i][<span class="number">0</span>]=Math.min(intervals[i-<span class="number">1</span>][<span class="number">0</span>],intervals[i][<span class="number">0</span>]);</span><br><span class="line">                intervals[i][<span class="number">1</span>]=Math.max(intervals[i-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i==intervals.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortMerge</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldStart=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newStart=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldStart&gt;newStart)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-8"   >
          <a href="#提交成功-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-8" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-14"   >
          <a href="#题解-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和452射爆气球以及435无重叠区间都是同一个解法，当遇到重叠区间的时候这里将重叠区间进行<strong>合并</strong></p>
<blockquote>
<p>局部最优解：按照左边界从小打大排序使其重叠区间放在一起，那么当遇到不重叠区间的时候添加到新的结果集即可</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li>对原数组进行排序，按照左区间从小打大排序</li>
<li>定义一个结果集合Result，用于接收单个区间(局部最大的重叠区间)</li>
<li>遍历数组，判断区间是否重叠，由<strong>下一个区间判断和前一个区间的状态</strong><ul>
<li>当前区间的左区间小于等于上个区间的右边界：<strong>重叠</strong>，更新重叠区间的左边界和最大右边界</li>
<li>当前区间的左边界大于上个区间的右边界：<strong>不重叠</strong>，将上个重叠区间添加到结果集result中</li>
<li>如果当前区间是最后一个区间，那么添加到结果集中:<code>if(i==intervals.length-1) result.add(intervals[i])</code></li>
</ul>
</li>
<li>将结果集result转为二维数组输出:<code>return result.toArray(new int[result.size()][2]);</code></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        sortMerge(intervals);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">int</span>[] &gt; result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;intervals.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//当前区间和上一个区间重叠</span></span><br><span class="line">                intervals[i][<span class="number">0</span>]=intervals[i-<span class="number">1</span>][<span class="number">0</span>]; <span class="comment">//更新左边界(重叠区间的最左边界)</span></span><br><span class="line">                intervals[i][<span class="number">1</span>]=Math.max(intervals[i-<span class="number">1</span>][<span class="number">1</span>],intervals[i][<span class="number">1</span>]);<span class="comment">//更新右边界(重叠区间的最右边界)</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//当前区间不是上一个区间的重叠部分，将上一个区间添加到结果集中</span></span><br><span class="line">                result.add(intervals[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是最后一个区间那么就添加到结果集中</span></span><br><span class="line">            <span class="keyword">if</span>(i==intervals.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    result.add(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//左区间从小打大排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortMerge</span><span class="params">(<span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="type">int</span> oldStart=arr[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> newStart=arr[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(oldStart&gt;newStart)&#123;</span><br><span class="line">                    <span class="type">int</span>[] temp=arr[i];</span><br><span class="line">                    arr[i]=arr[j];</span><br><span class="line">                    arr[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>






        <h2 id="738-单调递增的数字"   >
          <a href="#738-单调递增的数字" class="heading-link"><i class="fas fa-link"></i></a><a href="#738-单调递增的数字" class="headerlink" title="738.单调递增的数字"></a>738.单调递增的数字</h2>
      <p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/description/" >Leetcode.738题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-15"   >
          <a href="#第一次做-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-15" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;12</p>

        <h4 id="第一次代码-15"   >
          <a href="#第一次代码-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-15" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="type">int</span> result=n;</span><br><span class="line">       <span class="keyword">while</span>(!isValid(result))&#123;</span><br><span class="line">           result--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> result)</span>&#123;</span><br><span class="line">       <span class="type">int</span> old=result%<span class="number">10</span>;</span><br><span class="line">       result/=<span class="number">10</span>;</span><br><span class="line">       <span class="keyword">while</span>(result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="type">int</span> newValue=result%<span class="number">10</span>;</span><br><span class="line">           <span class="keyword">if</span>(newValue&gt;old) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           result/=<span class="number">10</span>;</span><br><span class="line">           old=newValue;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-31"   >
          <a href="#提交失败-31" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-31" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>BF法超出时间限制</p>
<p>CASE:输入n&#x3D;853567367</p>

        <h4 id="第二次代码-13"   >
          <a href="#第二次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-13" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public int monotoneIncreasingDigits(int n) &#123;</span><br><span class="line">        int result=n;</span><br><span class="line">        if(Valid(result))&#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int temp=n;</span><br><span class="line">        int old=n%10;</span><br><span class="line">        int count=0;</span><br><span class="line">        while(temp&gt;0)&#123;</span><br><span class="line">            old=temp%10;</span><br><span class="line">            temp/=10;</span><br><span class="line">            count++;</span><br><span class="line">            if(temp==0) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result=0;</span><br><span class="line">        for(int i=0;i&lt;count;i++)&#123;</span><br><span class="line">            result+=old;</span><br><span class="line">            result*=10;</span><br><span class="line">        &#125;</span><br><span class="line">        if(Valid(result) &amp;&amp;result&lt;=n) return result;</span><br><span class="line"></span><br><span class="line">        result=old-1;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;count;i++)&#123;</span><br><span class="line">            result*=10;</span><br><span class="line">            result+=9;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean Valid(int n)&#123;</span><br><span class="line">        int old=n%10;</span><br><span class="line">        n/=10;</span><br><span class="line">        while(n&gt;0)&#123;</span><br><span class="line">            int newValue=n%10;</span><br><span class="line">            if(newValue&gt;old) return false;</span><br><span class="line">            n/=10;</span><br><span class="line">            old=newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="提交失败-32"   >
          <a href="#提交失败-32" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-32" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE：n&#x3D;120，输出99，预期输出119</p>

        <h4 id="第三次代码-8"   >
          <a href="#第三次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-8" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=n;</span><br><span class="line">        <span class="keyword">if</span>(Valid(result))&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp=n;</span><br><span class="line">        <span class="type">int</span> old=n%<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            old=temp%<span class="number">10</span>;</span><br><span class="line">            temp/=<span class="number">10</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result=old;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            result*=<span class="number">10</span>;</span><br><span class="line">            result+=<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Valid(result) || result&gt;n)&#123;</span><br><span class="line">            result--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Valid(result)) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        result=old-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;count;i++)&#123;</span><br><span class="line">            result*=<span class="number">10</span>;</span><br><span class="line">            result+=<span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">Valid</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> old=n%<span class="number">10</span>;</span><br><span class="line">        n/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> newValue=n%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(newValue&gt;old) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">            old=newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-33"   >
          <a href="#提交失败-33" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-33" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超出时间限制</p>
<p>输入n&#x3D;963856657</p>

        <h4 id="第四次代码-4"   >
          <a href="#第四次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-4" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String str=<span class="string">&quot;&quot;</span>+n;</span><br><span class="line">        <span class="type">char</span>[] arr=str.toCharArray();</span><br><span class="line">        <span class="type">int</span> diffValue=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> equalsValue=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                diffValue=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                equalsValue=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i-<span class="number">1</span>==equalsValue)&#123;</span><br><span class="line">                    arr[diffValue]--;</span><br><span class="line">                    <span class="keyword">while</span>(equalsValue&lt;=arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(equalsValue==<span class="number">0</span>)&#123;</span><br><span class="line">                            equalsValue++;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        arr[equalsValue++]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    arr[i-<span class="number">1</span>]--;</span><br><span class="line">                    arr[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span>(arr[i]&gt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        diffValue=i;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                        equalsValue=i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                arr[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result=Integer.parseInt(sb.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-34"   >
          <a href="#提交失败-34" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-34" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入n&#x3D;89888</p>
<p>输出88889</p>
<p>预期输出88999</p>
<p>没做出来</p>

        <h3 id="题解-15"   >
          <a href="#题解-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题因为从<strong>后往前</strong>遍历，这样才能更新数据也不会导致前往后遍历多次频繁更新数据，以至于搞混大小关系</p>
<blockquote>
<p>局部最优解：当出现i位置数字小于i-1位置数字时，i-1位置数字减减，i位置数字更新成9</p>
<p>例如  72,i-1为7,i为2，那么要更新成 i-1为6,i为9 也即72&#x3D;&gt;69</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>先将数字转成字符数组方便对每一位操作</p>
</li>
<li><p>定义一个flag，标记需要转换成9的起始下标，初始化为Integer.MAX_VALUE，如果flag没变动说明最初的n就符合单调递增数字要求</p>
<ul>
<li>例如1000，那么flag为1，也即1之后需要转成9也即1000&#x3D;&gt;0999</li>
</ul>
</li>
<li><p>从后往前遍历字符数组</p>
<ul>
<li>当位置i数字小于位置i-1数字时候，将i-1位置数字减减，更新flag标记为i：<code>arr[i-1]--;flag=i;</code></li>
</ul>
</li>
<li><p>当遍历完数组，则开始更新flag下标之后的数字变成9：<code>for(int i=flag;i&lt;arr.length;i++) arr[i]=&#39;9&#39;</code></p>
</li>
<li><p>将字符数组转换回数字返回：<code>Integer.parseInt(String.valueOf(arr))</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">        String s=<span class="string">&quot;&quot;</span>+n;</span><br><span class="line">        <span class="type">char</span>[] arr=s.toCharArray();</span><br><span class="line">		<span class="comment">//定义一个标记flag，初始化为一个最大值，表示需要更新成9的下标索引</span></span><br><span class="line">        <span class="type">int</span> flag=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;arr[i-<span class="number">1</span>])&#123;</span><br><span class="line">                arr[i-<span class="number">1</span>]--;</span><br><span class="line">                <span class="comment">//将flag记录</span></span><br><span class="line">                flag=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//将需要更新的下标flag之后的数字都更新成9</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=flag;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     	<span class="comment">//将char[]数组转成String然后转成Integer返回   </span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(String.valueOf(arr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="968-监控二叉树"   >
          <a href="#968-监控二叉树" class="heading-link"><i class="fas fa-link"></i></a><a href="#968-监控二叉树" class="headerlink" title="968.监控二叉树"></a>968.监控二叉树</h2>
      <p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/description/" >Leetcode.968题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-16"   >
          <a href="#第一次做-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-16" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;10&#x2F;12</p>

        <h4 id="第一次代码-16"   >
          <a href="#第一次代码-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-16" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="type">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        searchTree(root);</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftResult=searchTree(root.left);</span><br><span class="line">        <span class="type">int</span> rightResult=searchTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是子结点是叶子节点，那么本结点加入监控</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">0</span> || rightResult==<span class="number">0</span>)&#123;</span><br><span class="line">            root.val=<span class="number">1</span>;</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-35"   >
          <a href="#提交失败-35" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-35" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h4 id="第二次代码-14"   >
          <a href="#第二次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-14" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//需要监控器数量</span></span><br><span class="line">	<span class="type">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=searchTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根节点没被监控，那么就将根节点监控</span></span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>) need++;</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftResult=searchTree(root.left);</span><br><span class="line">        <span class="type">int</span> rightResult=searchTree(root.right);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是叶子结点，那么添加本结点作为监控</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">0</span> || rightResult==<span class="number">0</span>)&#123;</span><br><span class="line">            root.val=<span class="number">2</span>;</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是监控结点，并且当前结点不是监控结点，那么就更新成为被监控的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">2</span> || rightResult==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;<span class="number">2</span>) root.val=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-9"   >
          <a href="#提交成功-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-9" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-16"   >
          <a href="#题解-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们遍历二叉树的时候需要<strong>后序遍历</strong>，从叶子节点开始增加摄像头，尽量要隔两个结点放一个摄像头</p>
<blockquote>
<p>局部最优解：从叶子结点开始，让叶子结点的父节点持有摄像头，然后尽量每隔两个结点放置一个摄像头</p>
</blockquote>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量need：需要的监控器数量</p>
</li>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>参数root：当前处理的根节点</li>
<li>返回值<ul>
<li>-1：说明是空节点，遍历到空节点向上返回即可目的是结束递归</li>
<li>0：说明是没有被监控的结点</li>
<li>1：说明是监控器结点的父节点(被监控)</li>
<li>2：说明是监控器结点</li>
</ul>
</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当root&#x3D;&#x3D;null，也即空结点时候返回-1</p>
</li>
<li><p>单层递归的逻辑</p>
<ul>
<li>向左搜索结果，记录返回值为leftResult</li>
<li>向右搜索结果，记录返回值为rightResult</li>
<li>左右子结点有一个结点是0，那么该节点就应该添加监控器，状态修改为2：<code>if(leftResult==0 || rightResult==0)&#123;root.val=2;need++;&#125;</code></li>
<li>左右子结点有一个结点是监视器，并且当前结点不是监视器那么就更新结点状态为1：<code>if(leftResult==2||rightResult==2)&#123;if(root.val&lt;2) root.val=1;&#125;</code></li>
<li>返回结点的状态值，如果没被监控那么应该返回的值是0</li>
</ul>
</li>
<li><p>递归函数结束，判断根节点返回值是多少，如果根节点为0也即未被监控，那么根节点应该添加一个监控器：</p>
<p><code>if(result==0) need++;</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//需要监控器数量</span></span><br><span class="line">	<span class="type">int</span> need=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> result=searchTree(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果根节点没被监控，那么就将根节点监控</span></span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>) need++;</span><br><span class="line">        <span class="keyword">return</span> need;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="comment">//如果结点为空返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftResult=searchTree(root.left);  <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> rightResult=searchTree(root.right);<span class="comment">//右</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是叶子结点，那么添加本结点作为监控</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">0</span> || rightResult==<span class="number">0</span>)&#123;</span><br><span class="line">            root.val=<span class="number">2</span>;</span><br><span class="line">            need++;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果子结点是监控结点，并且当前结点不是监控结点，那么就更新成为被监控的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(leftResult==<span class="number">2</span> || rightResult==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;<span class="number">2</span>) root.val=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>贪心算法也就是类似<strong>常识性</strong>的解题，从思考方向要从<strong>局部最优解</strong>出发，然后在局<strong>部最优解推出全局最优解的时候没有反例</strong>，那么就假设认为<strong>局部最优解往全局推出的全局解就是全局最优解</strong>，下一章节进入<strong>动态规划</strong></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/13/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-JUC%E7%AF%87%5B5-AQS%E3%80%81ReentrantLock%E3%80%81ReentrantReadWriteLock%5D/">深入剖析并发编程-JUC篇[5-AQS、ReentrantLock、ReentrantReadWriteLock]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">22.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">158分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>AQS、ReentrantLock、ReentrantReadWriteLock、JUC并发工具包</strong></p>
<hr>
<ul>
<li>第一篇是JUC并发编程基础</li>
<li>第二篇是JMM、Volatile关键字、synchronize锁详解</li>
<li>第三篇是CAS机制原理、Unsafe魔法类、LockSupport工具类、ThreadLocal线程变量</li>
<li>第四篇是Atomic原子包源码详解</li>
<li>第五篇是AQS源码以及机制详解、ReentrantLock可重入锁、ReentrantReadWriteLock读写锁、JUC并发工具包</li>
<li>第六篇是并发容器</li>
<li>第七篇是进程、线程、线程池</li>
</ul>
<hr>
<p><strong>本篇前言</strong></p>
<p>在并发编程中，我们学习到了JUC的并发编程基础，了解了变量在计算机中的存储方式以及内存一致性协议，然后引入了JMM内存模型，并且了解了Volatile关键字怎么将变量可见性，然后为了不加锁我们引入了CAS乐观锁机制，通过Unsafe实现CAS机制，同时有了Atomic原子操作包，而后面乐观锁之后还有Synchronized悲观锁，但是Synchronized悲观锁又是隐式锁，再加锁和释放锁都不需要我们自己手动操作。于是接下来的就是悲观锁中的显式锁Lock，需要我们自己手动加锁和释放锁流程。</p>
<p>但是在提显式锁之前我们先得提一个AQS机制，一个锁再竞争失败之后需要一个容器来接受等待锁的线程，而这个就是AQS</p>

        <h1 id="AQS"   >
          <a href="#AQS" class="heading-link"><i class="fas fa-link"></i></a><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1>
      <p>AQS：AbstractQueuedSynchronizer也即抽象队列同步器，它是Java并发包的核心组件</p>
<p>我们直接从源码开始看起</p>

        <h2 id="成员变量以及内部类"   >
          <a href="#成员变量以及内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984972572414691L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步队列的头指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步队列的尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="comment">//Unsafe类以及对应偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> stateOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> tailOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> waitStatusOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> nextOffset;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>又因为AbstractQueuedSynchronizer继承了<strong>AbstractOwnableSynchronizer</strong>所以还有一个成员变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//持锁线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></div></figure>

<p>也即AQS成员变量有<strong>队列头指针、队列尾指针、锁的状态字以及持锁线程</strong></p>
<p>而内部类有<strong>Node</strong>以及<strong>ConditionObject</strong></p>

        <h3 id="Node"   >
          <a href="#Node" class="heading-link"><i class="fas fa-link"></i></a><a href="#Node" class="headerlink" title="Node"></a>Node</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//共享模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="comment">//独占模式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是四个信号量 </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;	<span class="comment">//表示线程已经结束</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;	<span class="comment">//表示等待被唤醒</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;	<span class="comment">//表示在条件队列中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;	<span class="comment">//表示共享模式下同步行为会被传播</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前结点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾结点指针</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的状态</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">Node nextWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空参构造用于创建队列的头或者共享标记</span></span><br><span class="line">Node() &#123;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于添加Node</span></span><br><span class="line">Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">      <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">      <span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于Condition创建Node</span></span><br><span class="line">Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>也即Node的成员变量有<strong>锁的模式、锁的状态字、锁的信号量、前一结点指针、下一结点指针、线程、nextWaiter</strong></p>
<p>而Node中的方法我们会具体碰到的时候再进行展开</p>

        <h3 id="ConditionObject"   >
          <a href="#ConditionObject" class="heading-link"><i class="fas fa-link"></i></a><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头结点指针 firstWaiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾结点指针	lastWaiter</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是两个中断标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REINTERRUPT</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THROW_IE</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>因此目前已知情报可公开的数据可能如图所示(<strong>假设</strong>)，我们带着这个假设的模型去进行学习也许可能会更简单一些</p>
<p><em>猜想模型有误，只是提供一个最初印象的模型图，仅供参考</em></p>
<p><strong>同步队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230928181044445.png"  alt="同步队列猜测模型">
      </p>
<p><strong>条件队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230928181742497.png"  alt="条件队列猜测模型">
      </p>
<p>又因为Reentrantlock中的加锁调用了acquire方法，而这个方法在AQS中声明，所以我们要了解加锁过程必然要从acquire方法入手</p>

        <h2 id="同步队列"   >
          <a href="#同步队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2>
      
        <h3 id="acquire"   >
          <a href="#acquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>我们按照总分总的顺序拆分一点点理解代码</p>
<p>1.先调用tryAcquire方法，返回结果为true的时候，直接判断为false也即不会进行逻辑与后面的方法</p>
<p>2.当调用tryAcquire方法，返回结果为false的时候，调用acquireQueued方法</p>
<p>也即：先调用tryAcquire，当tryAcquire不成功则进行acquireQueued方法</p>
<p>进入if语句的情况：</p>
<ul>
<li><strong>tryAcquire失败并且acquireQueued成功</strong></li>
</ul>

        <h3 id="tryAcquire"   >
          <a href="#tryAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试以独占模式获取锁，具体操作由对应子类实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>当tryAcquire失败，也即获取锁失败，那么说明锁被独占了，<strong>也即进入acquireQueued方法说明获取锁失败有线程竞争</strong></p>

        <h3 id="acquireQueued"   >
          <a href="#acquireQueued" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里传参中还调用了一个addWaiter(Node.EXCLUSIVE), arg)</span></span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断标志位为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前结点的前一个结点p</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句中先判断前一个结点p是否是头结点</span></span><br><span class="line"><span class="comment">                	只有是头结点才会去尝试加锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功获取锁，更新AQS同步器头结点，移动同步队列，将failed置为false</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//return 中断标志位</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句判断为false就来到第二个if语句，而第一个if失败的可能有</span></span><br><span class="line"><span class="comment">                		1.前一个结点p不是头结点，所以没有资格获取锁</span></span><br><span class="line"><span class="comment">                		2.前一个结点是p但是没有获取锁成功</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//失败获取锁之后阻塞，阻塞线程并检查中断位，如果中断位为true则更新中断标志位为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           		因为finally方法一定会执行，而acquireQueued方法什么时候会结束</span></span><br><span class="line"><span class="comment">           			1.当获取锁成功，failed==false</span></span><br><span class="line"><span class="comment">           			2.当try中的方法报错，而当try中的方法报错有什么情况</span></span><br><span class="line"><span class="comment">           				2-1.锁的状态state&gt;Integer.MAX_VALUE,也即可重入次数超过上限</span></span><br><span class="line"><span class="comment">           				2-2.当子类的tryAcquire方法报错</span></span><br><span class="line"><span class="comment">            	也即:情况1则说明正常结束，不会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            		情况2则说明报错结束，会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">//怎么都获取不到锁，移除当前线程结点，唤醒之后的线程</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>因为先调用了addWaiter方法所以我们先看向addWaiter方法，看完之后再来具体看acquireQueued方法做了什么事</p>

        <h3 id="addWaiter"   >
          <a href="#addWaiter" class="heading-link"><i class="fas fa-link"></i></a><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    	<span class="comment">//new一个Node对象，传入参数有当前线程和锁的模式</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">		<span class="comment">//将尾结点指针赋值给pred</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断尾结点是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当尾结点不为空，说明有同步队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将new出来的对象的前驱结点指向pred</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//CAS更新尾结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//如果更新尾结点成功，将pred指向node结点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//也即更新AQS尾指针，并且更新同步队列</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    	运行到这里有两个情况：</span></span><br><span class="line"><span class="comment">    		1.同步队列为空，调用enq方法</span></span><br><span class="line"><span class="comment">    		2.CAS更新尾结点失败，说明线程竞争入同步队列失败</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>那么我们接下来要看向enq方法，看看具体怎么入队</p>

        <h3 id="enq"   >
          <a href="#enq" class="heading-link"><i class="fas fa-link"></i></a><a href="#enq" class="headerlink" title="enq"></a>enq</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//死循环不断尝试入队</span></span><br><span class="line">    	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取尾指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="comment">//当尾指针为空说明队列为空，则需要对同步队列初始化</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//同步队列初始化，初始化成功之后tail！=null</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//说明同步队列存在，将node入队</span></span><br><span class="line">                <span class="comment">//原先尾结点设置为当前结点的前驱结点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//CAS设置尾指针，设置尾指针成功再更新队列</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="comment">//返回t，尾结点的前一个结点(也即原先的尾结点)</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法做了两件事</p>
<ul>
<li>1.当队列为空的时候，初始化队列，并且队列的头结点为新的node结点(空参构造)</li>
<li>2.当队列不为空的时候，将node结点入队，更新AQS同步器也更新同步队列</li>
</ul>
<p>返回了<strong>当前结点的前一个结点</strong></p>

        <h4 id="enq方法流程图"   >
          <a href="#enq方法流程图" class="heading-link"><i class="fas fa-link"></i></a><a href="#enq方法流程图" class="headerlink" title="enq方法流程图"></a>enq方法流程图</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230929131807036.png"  alt="enq方法流程图">
      </p>
<p><strong>enq方法当同步队列为空时</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230929132619749.png"  alt="同步队列初始化">
      </p>
<p><strong>enq方法当同步队列不为空时</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930202252236.png"  alt="当同步队列不为空">
      </p>
<p>也即同步队列如果存在，那么<strong>同步队列的第一个结点是空参构造的结点</strong>，可以把它看成当前持锁线程</p>
<p>enq方法将队列初始化或者将新结点添加到队尾，于是我们反过头来看<strong>acquireQueued</strong>方法做了什么事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//中断标志位为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前结点的前一个结点p</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句中先判断前一个结点p是否是头结点</span></span><br><span class="line"><span class="comment">                	只有是头结点才会去尝试加锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//成功获取锁，更新AQS同步器头结点，移动同步队列，将failed置为false</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//return 中断标志位</span></span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                	第一个if语句判断为false就来到第二个if语句，而第一个if失败的可能有</span></span><br><span class="line"><span class="comment">                		1.前一个结点p不是头结点，所以没有资格获取锁</span></span><br><span class="line"><span class="comment">                		2.前一个结点是p但是没有获取锁成功</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//失败获取锁之后阻塞，阻塞线程并检查中断位，如果中断位为true则更新中断标志位为true</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           	<span class="comment">/**</span></span><br><span class="line"><span class="comment">           		因为finally方法一定会执行，而acquireQueued方法什么时候会结束</span></span><br><span class="line"><span class="comment">           			1.当获取锁成功，failed==false</span></span><br><span class="line"><span class="comment">           			2.当try中的方法报错，而当try中的方法报错有什么情况</span></span><br><span class="line"><span class="comment">           				2-1.锁的状态state&gt;Integer.MAX_VALUE,也即可重入次数超过上限</span></span><br><span class="line"><span class="comment">           				2-2.当子类的tryAcquire方法报错</span></span><br><span class="line"><span class="comment">            	也即:情况1则说明正常结束，不会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            		情况2则说明报错结束，会走 cancelAcquire方法</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">//怎么都获取不到锁，移除当前线程结点，唤醒之后的线程</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node中的方法，目的是获取当前结点的前一个结点</span></span><br><span class="line"><span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">            <span class="comment">//获取当前结点的前一个结点</span></span><br><span class="line">    		<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>当请求结点是头结点的下一个结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930202739393.png"  alt="更新结点前">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930202812518.png"  alt="更新结点后">
      </p>
<p><strong>当请求结点前一个结点不是头结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930203116496.png"  alt="请求结点前一个结点不是头结点">
      </p>

        <h3 id="shouldParkAfterFailedAcquire"   >
          <a href="#shouldParkAfterFailedAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#shouldParkAfterFailedAcquire" class="headerlink" title="shouldParkAfterFailedAcquire"></a>shouldParkAfterFailedAcquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">        <span class="comment">//获取pred中的锁的状态字</span></span><br><span class="line">    	<span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">//当ws==Node.SIGNAL也即ws==-1，意思是当前结点已经阻塞</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当ws&gt;0 也即ws==Node.CANCELLED==1，也即这个结点无效需要退出同步队列</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将pred移除同步队列</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	将pred指向前一个结点，将node的前一个结点指向pred</span></span><br><span class="line"><span class="comment">            	也即删除同步队列的pred结点</span></span><br><span class="line"><span class="comment">            	直到pred.waitStatus&lt;=0 说明结点有效</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到有效结点，链接双向链表更新pred结点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当ws==0 || ws==-2 || ws==-3</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//说明pred结点是需要更新成SINGAL状态，也即将状态字置为-1表示阻塞</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>shouldParkAfterFailedAcquire方法就是更新waitStatus状态字</p>
<blockquote>
<p>ws&#x3D;pred.waitStatus</p>
<p>static final int CANCELLED &#x3D;  1;	&#x2F;&#x2F;表示线程已经结束</p>
<p>static final int SIGNAL    &#x3D; -1;	&#x2F;&#x2F;表示等待被唤醒</p>
<p>static final int CONDITION &#x3D; -2;	&#x2F;&#x2F;表示在条件队列中 </p>
<p>static final int PROPAGATE &#x3D; -3;	&#x2F;&#x2F;在共享状态表示同步状态会被传播</p>
</blockquote>
<ul>
<li><p>ws &#x3D;&#x3D; -1(ws &#x3D;&#x3D; Node.SIGNAL)</p>
<p>意思是当前已经在阻塞队列中，所以不用操作直接返回true</p>
</li>
<li><p>ws &gt; 0 (ws &#x3D;&#x3D; Node.CANCELLED)</p>
<p>意思是这个结点线程已经结束或者无效，所以需要删除这个结点，直到结点指向一个正常的结点</p>
</li>
<li><p>ws &#x3D;&#x3D; 0 || ws &#x3D;&#x3D; -2 ||ws&#x3D;&#x3D;-3</p>
<p>用CAS更新ws状态成-1</p>
<ul>
<li>ws &#x3D;&#x3D; 0 :表示线程在活跃中</li>
<li>ws &#x3D;&#x3D; -2:表示线程在条件队列中</li>
<li>ws &#x3D;&#x3D; -3:表示线程在共享模式下的同步状态会被传播</li>
</ul>
</li>
</ul>
<p>当更新状态字成功，要调用pardAndCheckInterrupt方法</p>

        <h3 id="parkAndCheckInterrupt"   >
          <a href="#parkAndCheckInterrupt" class="heading-link"><i class="fas fa-link"></i></a><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt"></a>parkAndCheckInterrupt</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用LockSupport工具类下的park方法阻塞当前线程，然后返回线程的中断标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="cancelAcquire"   >
          <a href="#cancelAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#cancelAcquire" class="headerlink" title="cancelAcquire"></a>cancelAcquire</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//如果node为空则结束，肯定不在同步队列中</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//将node的线程置为空</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取node的前一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//将node的前驱结点指向一个有效的结点</span></span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//predNext记录移动后的pred指针的下一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//将node的ws设置成1</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">		如果node结点是尾结点，则进入if语句中移除尾结点</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line"></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//node在中间结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	进入下方if语句有两种情况</span></span><br><span class="line"><span class="comment">        	1.pred不是头结点并且pred的线程存在以及ws==SIGNAL</span></span><br><span class="line"><span class="comment">        	2.pred不是头结点并且pred的线程存在以及ws被设置成SIGNAL</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">           ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将next指向下一个结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//next是有效结点，则设置pred的后继结点是next</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	运行到这里有几种可能性</span></span><br><span class="line"><span class="comment">            	1.pred是头结点，也即前驱结点是头结点</span></span><br><span class="line"><span class="comment">            	2.pred的线程不存在</span></span><br><span class="line"><span class="comment">            	3.pred的状态不是SIGNAL</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//唤醒线程</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//后继结点指向自己</span></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>Node结点在队尾，移除队尾元素</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930180647588.png"  alt="Node结点在队尾">
      </p>
<p><strong>Node结点在队中，移除Node结点</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230930180804316.png"  alt="Node结点在队中">
      </p>

        <h3 id="unparkSuccessor"   >
          <a href="#unparkSuccessor" class="heading-link"><i class="fas fa-link"></i></a><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Node结点的waitStatus</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node有效将ws置为0，意思为活跃中</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	从同步队列的后面往前找，第一个靠近node的结点s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里也即Acquire方法的全部流程，由此我们也可得出一个结论</p>
<p><strong>AQS是一个非公平同步器，当线程需要加锁的时候会直接进行tryAcquire加锁，只有加锁失败才会进入同步队列中</strong></p>
<p>接下来加完锁就要看解锁，所以我们看向release方法</p>

        <h3 id="release"   >
          <a href="#release" class="heading-link"><i class="fas fa-link"></i></a><a href="#release" class="headerlink" title="release"></a>release</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//尝试解锁成功进入下面语句，尝试唤醒其他线程</span></span><br><span class="line">    	<span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//获取头结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">            	当头结点不为空，也即存在同步队列</span></span><br><span class="line"><span class="comment">            	并且ws.waitStatus不为0，说明有线程在等待唤醒</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//唤醒h之后的第一个需要被唤醒的线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Node结点的waitStatus</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node有效将ws置为0，意思为活跃中</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	从同步队列的后面往前找，第一个靠近node的结点s</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="tryRelease"   >
          <a href="#tryRelease" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryRelease" class="headerlink" title="tryRelease"></a>tryRelease</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由子类去重写</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>释放锁流程</strong></p>
<ul>
<li>尝试tryRelease，如果锁的statu为0，说明解锁成功返回true<ul>
<li>获取AQS同步器的头结点<ul>
<li>同步器头结点如果为null，说明没有同步队列也即没有等待线程直接返回true即可</li>
<li>同步器头结点不为空，并且ws!&#x3D;0,说明有线程在等待，唤醒离头结点最近的第一个需要被唤醒的线程</li>
</ul>
</li>
</ul>
</li>
<li>解锁失败返回false</li>
</ul>
<p>而上面我们有返回中断标志位，这是让我们自己去响应中断返回结果，而有没有能帮我们抛出异常而不用我们来反应中断的呢？</p>
<p>当然是有的，那就是acquireInterruptibly方法</p>

        <h3 id="acquireInterruptibly"   >
          <a href="#acquireInterruptibly" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly"></a>acquireInterruptibly</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">   	<span class="comment">//线程中断标志位为true那么就抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//尝试去加锁，加锁失败之后走doAcquireInterruptibly方法加锁</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="doAcquireInterruptibly"   >
          <a href="#doAcquireInterruptibly" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireInterruptibly" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取当前线程的前一个线程，只有前一个线程是头结点才允许加锁</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//检查中断标志位为true则抛出异常，而不用我们自己处理</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这一段方法逻辑和acquireQueued方法逻辑是一致的，只是在响应中断方面，acquireQueued方法会返回中断标志位交给我们自己处理，而这个方法是出现中断之后会抛出异常，而不用我们自己处理中断</p>
<p>而上面都在说独占锁的过程，而我们知道共享锁，所以我们接下来看共享锁的获取流程</p>

        <h3 id="acquireShared"   >
          <a href="#acquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="comment">//获取共享锁</span></span><br><span class="line">    	<span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果加锁失败</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="tryAcquireShared"   >
          <a href="#tryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试加锁，由子类去实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="doAcquireShared"   >
          <a href="#doAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireShared" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个模式为共享模式的结点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取前驱结点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">//如果前驱结点是头指针结点，那么就尝试进行加锁，如果加锁成功则将头结点更新，并将头结点移除</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//记录一下可以获取共享锁的资源数，也即拿到锁r将大于0</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//如果加锁成功</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">//将p的下一个结点置空</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">//判断中断</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否阻塞和处理响应中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	如果failed为false，说明获取到了锁结束方法</span></span><br><span class="line"><span class="comment">        	如果failed为true，说明获取不到锁，将当前线程移除同步队列</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="setHeadAndPropagate"   >
          <a href="#setHeadAndPropagate" class="heading-link"><i class="fas fa-link"></i></a><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="comment">//记录老的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//设置新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**以下IF语句有五种情况</span></span><br><span class="line"><span class="comment">    	1.当前结点node获取锁成功，也即propagate＞0</span></span><br><span class="line"><span class="comment">    	2.原来的头结点为空，也即同步队列头结点为空</span></span><br><span class="line"><span class="comment">    	3.原来的头结点不为空但是锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    	4.将当前结点更新成头结点为空</span></span><br><span class="line"><span class="comment">    	5.将当前结点更新成头结点之后锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前结点的下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//判断下一个结点如果是共享模式则进入唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="doReleaseShared"   >
          <a href="#doReleaseShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//死循环一直去唤醒</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//当h不为空并且不为尾结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//如果头结点没有变化则退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这里有一个关键点在于每一次循环都会获取头结点<code>Node h = head</code>,并且最后每次还会判断<code>if( h == head ) break;</code></p>
<p>这是因为当头结点不为空，并且不是尾结点的时候都会将其唤醒，如果CAS更新失败则会continue，只有CAS成功进入唤醒状态或者ws从0更新成-3，那么才会进入h&#x3D;&#x3D;head的判断</p>
<p>而每次成功唤醒之后，应该会进行doAcquireShared方法去尝试获取锁，也即当获取锁成功则head还会被重新设置，只有头结点没有改变才会跳出循环</p>
<p>理想状态下：</p>
<p><strong>当第一个获取共享锁的线程成功，则会不断唤醒排在其身后连在一起的共享模式线程</strong></p>

        <h3 id="doAcquireSharedInterruptibly"   >
          <a href="#doAcquireSharedInterruptibly" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireSharedInterruptibly" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//抛出中断异常</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败取消线程任务</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个方法和doAcquireShared方法的唯一区别就在于响应中断的方式不同，这个则是直接抛出中断异常，而那个方法是返回上层我们程序员自己手动处理中断状态</p>
<p>至此，AQS的同步队列中获取锁的方式已经全部说完，我们下一个就是看条件队列</p>

        <h2 id="条件队列"   >
          <a href="#条件队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h2>
      <p>条件队列也是阻塞队列，在线程等待某个资源的释放然后唤醒，也即<strong>当条件不成立的时候线程进入条件队列，当条件成立则将线程从条件队列移除并继续执行</strong></p>
<p>而条件队列也主要依靠两个方法，一个是<strong>await方法</strong>(使线程进入条件队列等待资源)，另一个则是<strong>signal方法</strong>(使线程从阻塞唤醒，从条件队列中移除)</p>
<p>我们一开始也将带着条件队列猜测模型学习</p>
<p><em>猜想模型有误，只是提供一个最初印象的模型图，仅供参考</em></p>
<p><strong>条件队列猜测模型</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230928181742497.png"  alt="条件队列猜测模型">
      </p>

        <h3 id="await"   >
          <a href="#await" class="heading-link"><i class="fas fa-link"></i></a><a href="#await" class="headerlink" title="await"></a>await</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果线程中断了则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">//添加新的结点入条件队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前线程获取的锁全部释放，记录重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="comment">//中断模式为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	进入while循环的条件：不在同步队列中</span></span><br><span class="line"><span class="comment">    	退出while循环的情景：</span></span><br><span class="line"><span class="comment">    		1.因为中断唤醒线程，所以设置中断模式</span></span><br><span class="line"><span class="comment">    		2.因为signal唤醒线程也即资源满足条件，所以结点一定在同步队列中不符合while循环条件</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//如果结点不在同步队列中(在条件队列中)=&gt;阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线程唤醒如果是因为中断过，那么就设置中断模式并且跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新争抢锁成功，并且不是因为中断唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//那么就设置中断模式为REINTERRUPT，需要本线程自己中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果条件队列中的下一个结点不为空，那么清除条件队列的失效结点</span></span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果中断模式不为0，也即发生过中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="addConditionWaiter"   >
          <a href="#addConditionWaiter" class="heading-link"><i class="fas fa-link"></i></a><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//获取条件队列最后一个Waiter</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后一个Waiter存在但是状态不是条件队列状态(-2)，那么并且重新获取LastWaiter</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建当前线程的结点，状态为条件队列状态(-2)</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最后一个Waiter为空，也即条件队列为空，那么当前结点就是条件队列的头结点</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">//将条件队列的头结点修改成node</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//条件队列不为空，将node加入到条件队列的尾部</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">//将尾指针指向最后一个结点</span></span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="unlinkCancelledWaiters方法"   >
          <a href="#unlinkCancelledWaiters方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlinkCancelledWaiters方法" class="headerlink" title="unlinkCancelledWaiters方法"></a>unlinkCancelledWaiters方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlinkCancelledWaiters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//t为第一个Waiter</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="comment">//跟踪指针trail，用于记录操作的结点前一个结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">trail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//当t不为空也即同步队列不为空</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> t.nextWaiter;</span><br><span class="line">        <span class="comment">//当前结点的状态不为条件队列状态，也即要移除出条件队列</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            <span class="comment">//将t指向下一个结点设置为空</span></span><br><span class="line">            t.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//如果trail为空也即taril还没被设置值也即头结点就是不合法，则更新头指针</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="literal">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//trail不为空，则更新trail的下一个结点为当前结点的下一个结点</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果下一个结点为空，也即到了队列的末尾则更新尾指针</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            trail = t; <span class="comment">//当前结点状态是条件队列状态(-2)则保留 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//移动指针t向后遍历</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="条件队列新增结点和移除结点图解"   >
          <a href="#条件队列新增结点和移除结点图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#条件队列新增结点和移除结点图解" class="headerlink" title="条件队列新增结点和移除结点图解"></a>条件队列新增结点和移除结点图解</h5>
      <p><strong>新增结点</strong>，判断尾结点是否是条件队列状态，如果不是则进行<strong>删除不合法结点</strong>，如果是则将当前结点添加到条件队列尾部</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007182801004.png"  alt="条件队列新增结点">
      </p>
<p><strong>移除结点</strong>，从<strong>头结点开始</strong>判断是否满足条件队列要求</p>
<ul>
<li>当头结点不合法</li>
</ul>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007183346412.png"  alt="删除结点，头结点不合法">
      </p>
<p>删除头结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007183935160.png"  alt="删除头结点">
      </p>
<ul>
<li><p>当中间结点不合法</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007184327495.png"  alt="当中间结点不合法">
      </p>
</li>
</ul>
<p>移除不合法的中间结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007184610289.png"  alt="移除不合法的中间结点">
      </p>
<ul>
<li><p>当尾结点不合法</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007184847981.png"  alt="尾结点不合法">
      </p>
</li>
</ul>
<p>移除尾结点</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231007185104698.png"  alt="移除尾结点">
      </p>

        <h4 id="fullyRelease"   >
          <a href="#fullyRelease" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullyRelease" class="headerlink" title="fullyRelease"></a>fullyRelease</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullyRelease</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//失败解锁标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁的重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            <span class="comment">//将failed标志位置为false，意思是全部解锁成功</span></span><br><span class="line">            failed = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//没有全部解锁成功，那么就将此节点置为失效结点</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="release-1"   >
          <a href="#release-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#release-1" class="headerlink" title="release"></a>release</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//尝试解锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//成功唤醒同步队列中头结点的下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="isOnSyncQueue"   >
          <a href="#isOnSyncQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h4>
      <p>判断当前结点是不是在同步队列中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回true说明在同步队列中，返回false说明不在同步队列中</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isOnSyncQueue</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果结点等待状态为-2(条件队列)，或者结点的前驱结点为空，说明不在同步队列中</span></span><br><span class="line">  	<span class="comment">//也即同步队列的结点状态不能为-2，并且前驱结点不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//后继结点不为空，说明在同步队列中(也即：同步队列除了尾结点后继结点不为空)</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果后继节点为空判断是不是在同步队列的尾结点</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="findNodeFromTail"   >
          <a href="#findNodeFromTail" class="heading-link"><i class="fas fa-link"></i></a><a href="#findNodeFromTail" class="headerlink" title="findNodeFromTail"></a>findNodeFromTail</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾结点开始搜索结点node，遍历结点</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">findNodeFromTail</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果尾结点是当前结点node，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果搜索结点为空，说明搜索完同步队列还没找到结点node，说明node不在同步队列中</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//向前搜索</span></span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p><strong>checkInterruptWhileWaiting方法</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">	<span class="comment">//如果中断过，那么返回值要么是THROW_IE(-1)要么是REINTERRUPT(1)</span></span><br><span class="line">    <span class="comment">//没有中断过则返回0</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//也即返回值有 -1(THROW_IE),0,1(REINTERRUPT)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="transferAfterCancelledWait"   >
          <a href="#transferAfterCancelledWait" class="heading-link"><i class="fas fa-link"></i></a><a href="#transferAfterCancelledWait" class="headerlink" title="transferAfterCancelledWait"></a>transferAfterCancelledWait</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferAfterCancelledWait</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//CAS设置结点状态标志位从-2到0(也即这是中断唤醒线程再导致添加在同步队列中，所以设置中断模式为THROW_IE)</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//CAS成功，添加结点到同步队列，返回true</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果结点不在同步队列中，那么就让出CPU，直到它在同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="reportInterruptAfterWait"   >
          <a href="#reportInterruptAfterWait" class="heading-link"><i class="fas fa-link"></i></a><a href="#reportInterruptAfterWait" class="headerlink" title="reportInterruptAfterWait"></a>reportInterruptAfterWait</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reportInterruptAfterWait</span><span class="params">(<span class="type">int</span> interruptMode)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//如果中断模式是THROW_IE，也即条件队列线程唤醒是因为线程中断，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        <span class="comment">//如果中断模式是REINTERRUPT说明是SSignal唤醒线程，则线程自己中断</span></span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h3 id="signal"   >
          <a href="#signal" class="heading-link"><i class="fas fa-link"></i></a><a href="#signal" class="headerlink" title="signal"></a>signal</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//判断是否是持锁线程唤醒，如果当前线程不是持锁线程那么则抛错</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            </span><br><span class="line">    		<span class="comment">//持锁线程可以去唤醒条件队列的结点</span></span><br><span class="line">    </span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取条件队列的第一个Waiter</span></span><br><span class="line">    		<span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">            <span class="comment">//如果条件线程不为空那么尝试从第一个结点开始Signal唤醒</span></span><br><span class="line">    		<span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="isHeldExclusively"   >
          <a href="#isHeldExclusively" class="heading-link"><i class="fas fa-link"></i></a><a href="#isHeldExclusively" class="headerlink" title="isHeldExclusively"></a>isHeldExclusively</h4>
      <p>方法由子类实现，如果当前线程不是持锁线程则抛错</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="doSignal"   >
          <a href="#doSignal" class="heading-link"><i class="fas fa-link"></i></a><a href="#doSignal" class="headerlink" title="doSignal"></a>doSignal</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将条件队列队首开始，尝试将一个结点从条件队列移到同步队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//将第一个结点移出条件队列(无论是否成功移到同步队列)</span></span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//将头结点指针更新成第一个结点的下一个结点，如果下一个结点为空同时也更新条件队列尾指针</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">            lastWaiter = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//将第一个结点指针更新为空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;  <span class="comment">//将第一个结点尝试移到同步队列中，当成功则返回true，失败返回false</span></span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果第一个结点移到同步队列失败，则重新获取第一个结点直到同步队列为空或者成功移动一个结点到同步队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="transferForSignal"   >
          <a href="#transferForSignal" class="heading-link"><i class="fas fa-link"></i></a><a href="#transferForSignal" class="headerlink" title="transferForSignal"></a>transferForSignal</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回false:通过Signal转移到同步队列失败</span></span><br><span class="line"><span class="comment">//返回true:通过Signal转移到同步队列成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">//如果CAS更新结点状态失败，则返回false</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//CAS成功，结点状态更新成0</span></span><br><span class="line">    <span class="comment">//将结点入同步队列尾部，enq返回原先的尾结点(此时同步队列的倒数第二个结点)</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果p状态大于0(结点P失效)或者p状态更新成-1失败(0-&gt;-1) 那么唤醒结点线程</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        <span class="comment">//唤醒结点线程，让它去争抢一次锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	因为AQS同步队列中只有前一个结点的是头结点才能争锁成功</span></span><br><span class="line"><span class="comment">        	这里可能是让本线程更新同步队列结点的状态</span></span><br><span class="line"><span class="comment">        	或者移除不合法结点之后此节点前一个结点是头结点，于是能尝试争锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回true，也即通过Signal添加到同步队列成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="signalAll"   >
          <a href="#signalAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="comment">//判断是否是持锁线程进行全部唤醒，不是则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    		<span class="comment">//获取同步队列的头指针</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    		<span class="comment">//如果同步队列存在则唤醒全部</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                doSignalAll(first);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>








        <h4 id="doSignalAll"   >
          <a href="#doSignalAll" class="heading-link"><i class="fas fa-link"></i></a><a href="#doSignalAll" class="headerlink" title="doSignalAll"></a>doSignalAll</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignalAll</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    		<span class="comment">//将同步队列的首尾指针指向空</span></span><br><span class="line">            lastWaiter = firstWaiter = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//将原先的头结点向后遍历，尝试唤醒全部条件队列线程</span></span><br><span class="line">    		<span class="keyword">do</span> &#123;</span><br><span class="line">          	</span><br><span class="line">                <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> first.nextWaiter;</span><br><span class="line">                first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">                transferForSignal(first);</span><br><span class="line">                first = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (first != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h2>
      <p>AQS是一个<strong>非公平锁</strong>，当需要加锁的时候都是先尝试获取一把锁，如果获取失败才会进入AQS同步队列中。又因为AQS分有独占锁和共享锁，以及同步队列和条件队列，所以这里单独对加锁、解锁以及两个队列再进行一个知识性总结</p>

        <h3 id="独占锁"   >
          <a href="#独占锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h3>
      
        <h4 id="加锁"   >
          <a href="#加锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4>
      
        <h5 id="acquire-1"   >
          <a href="#acquire-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire-1" class="headerlink" title="acquire"></a>acquire</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  <span class="comment">//先尝试获取锁</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) <span class="comment">//获取锁失败添加到同步队列中</span></span><br><span class="line">        selfInterrupt();   <span class="comment">//获取锁失败后添加到同步队列成功自身中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="acquireQueued-1"   >
          <a href="#acquireQueued-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireQueued-1" class="headerlink" title="acquireQueued"></a>acquireQueued</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步队列尝试获取锁，当出现中断唤醒时，不会抛出异常</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">//只有前一个结点是持锁线程(头结点)才能获取锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>; <span class="comment">//更新中断标志位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//怎么都获取不到锁，同步队列中移除该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="doAcquireInterruptibly-1"   >
          <a href="#doAcquireInterruptibly-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireInterruptibly-1" class="headerlink" title="doAcquireInterruptibly"></a>doAcquireInterruptibly</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步队列尝试获取锁，当出现中断唤醒时，会抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">//只有前一个结点是持锁线程(头结点)才能获取锁</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();<span class="comment">//出现中断，抛出中断异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);<span class="comment">//怎么都获取不到锁，同步队列中移除该结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="await-1"   >
          <a href="#await-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#await-1" class="headerlink" title="await"></a>await</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	进入while循环的条件：不在同步队列中</span></span><br><span class="line"><span class="comment">    	退出while循环的情景：</span></span><br><span class="line"><span class="comment">    		1.因为中断唤醒线程，所以设置中断模式</span></span><br><span class="line"><span class="comment">    		2.因为signal唤醒线程也即资源满足条件，所以结点一定在同步队列中不符合while循环条件</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//如果结点不在同步队列中(在条件队列中)=&gt;阻塞</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//线程唤醒如果是因为中断过，那么就设置中断模式并且跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重新争抢锁成功，并且不是因为中断唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        <span class="comment">//那么就设置中断模式为REINTERRUPT，需要本线程自己中断</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>因此AQS独占锁的获取锁流程：</p>
<ul>
<li><p>先判断锁是否获取(非公平锁)-&gt;失败则进入同步队列中-&gt;同步队列中只有前一个结点是头结点的结点才能获取锁</p>
</li>
<li><p>条件队列时，先将结点入条件队列，并且阻塞 -&gt; 唤醒之后结点在同步队列中尝试去同步队列方法获取锁</p>
</li>
</ul>

        <h4 id="解锁"   >
          <a href="#解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4>
      
        <h5 id="release-2"   >
          <a href="#release-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#release-2" class="headerlink" title="release"></a>release</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//释放锁成功，唤醒持锁线程的下一个线程</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>因此AQS独占锁的释放锁流程：</p>
<ul>
<li>如果释放锁成功，当同步队列不为空的时候则会唤醒头结点的下一个线程</li>
</ul>

        <h3 id="共享锁"   >
          <a href="#共享锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3>
      
        <h4 id="加锁-1"   >
          <a href="#加锁-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4>
      
        <h5 id="acquireShared-1"   >
          <a href="#acquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquireShared-1" class="headerlink" title="acquireShared"></a>acquireShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    	<span class="comment">//先尝试获取共享锁，获取锁失败则进入同步队列中等待获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="doAcquireShared-1"   >
          <a href="#doAcquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireShared-1" class="headerlink" title="doAcquireShared"></a>doAcquireShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg); <span class="comment">//获取共享锁的资源数</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r); <span class="comment">//设置头结点并且尝试唤醒下一个共享模式线程</span></span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>; <span class="comment">//设置中断标志位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node); <span class="comment">//怎么都获取不到锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="setHeadAndPropagate-1"   >
          <a href="#setHeadAndPropagate-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#setHeadAndPropagate-1" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="comment">//记录老的头结点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="comment">//设置新的头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**以下IF语句有五种情况</span></span><br><span class="line"><span class="comment">    	1.当前结点node获取锁成功，也即propagate＞0</span></span><br><span class="line"><span class="comment">    	2.原来的头结点为空，也即同步队列头结点为空</span></span><br><span class="line"><span class="comment">    	3.原来的头结点不为空但是锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    	4.将当前结点更新成头结点为空</span></span><br><span class="line"><span class="comment">    	5.将当前结点更新成头结点之后锁的状态字小于等于0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取当前结点的下一个结点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//判断下一个结点如果是共享模式则进入唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="doReleaseShared-1"   >
          <a href="#doReleaseShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared-1" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">             <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果头结点没有变化则结束(唤醒之后要去获取锁，获取锁会更新头结点)</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="doAcquireSharedInterruptibly-1"   >
          <a href="#doAcquireSharedInterruptibly-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#doAcquireSharedInterruptibly-1" class="headerlink" title="doAcquireSharedInterruptibly"></a>doAcquireSharedInterruptibly</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); </span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg); <span class="comment">//当资源大于0的时候</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>(); <span class="comment">//抛出中断异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node); <span class="comment">//取消获取锁任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>因此共享锁加锁流程：</p>
<p>先尝试能不能获取共享锁（非公平锁）-&gt; 加锁失败则进入同步队列中-&gt; 同步队列中获取锁成功那么尝试将下一个共享结点唤醒（共享锁认为当资源合适的时候那么共享线程都能获取锁）</p>

        <h4 id="解锁-1"   >
          <a href="#解锁-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#解锁-1" class="headerlink" title="解锁"></a>解锁</h4>
      
        <h5 id="releaseShared"   >
          <a href="#releaseShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">//如果释放锁成功，那么就唤醒下一个线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="doReleaseShared-2"   >
          <a href="#doReleaseShared-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#doReleaseShared-2" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">             <span class="comment">//获取状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">//如果ws==-1,也即等待信号唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">//如果CAS更新h的ws从-1到0失败，则continue再来一遍</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//CAS成功则唤醒同步队列中离结点h最近的结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果ws为0那么就更新成传播状态-3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">				<span class="comment">//CAS失败则重新再来一遍设置h状态</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果头结点没有变化则结束(唤醒之后要去获取锁，获取锁会更新头结点)</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>因此共享锁释放锁流程：</p>
<p>先尝试释放锁，如果释放锁成功那么唤醒同步队列的结点</p>

        <h1 id="ReentrantLock"   >
          <a href="#ReentrantLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1>
      <p>讲完AQS(抽象队列同步器)，那么我们必须要讲到它的落地，也即它的子类，我们常用的可重入锁ReentrantLock</p>

        <h2 id="成员变量以及内部类-1"   >
          <a href="#成员变量以及内部类-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-1" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h2>
      <p><strong>成员变量</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化Id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>


        <h3 id="Sync"   >
          <a href="#Sync" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5179523762034025860L</span>;</span><br><span class="line">        <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//非公平获取锁，因为AQS同步器本身就是非公平锁</span></span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有持锁线程，那么尝试获取锁</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    <span class="comment">//设置持锁线程是当前线程</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">             	<span class="comment">//持锁线程是当前线程，所以是锁的重入，更新锁的重入次数   </span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加锁失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//解锁</span></span><br><span class="line">    	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="comment">//如果当前线程不是持锁线程则抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果释放锁之后锁的重入次数为0也即完全释放锁</span></span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新锁的状态</span></span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//..省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="NonfairSync"   >
          <a href="#NonfairSync" class="heading-link"><i class="fas fa-link"></i></a><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非公平同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//加锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           	<span class="comment">//尝试获取锁，如果获取锁成功则更新锁的持锁线程为当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//加锁失败走AQS的获取锁流程</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//尝试加锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="FairSync"   >
          <a href="#FairSync" class="heading-link"><i class="fas fa-link"></i></a><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公平同步器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">    	<span class="comment">//尝试加锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果锁状态为0也即无人持锁，如果同步队列没有线程等待才尝试加锁</span></span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//锁的重入</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>hasQueuedPredecessors</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断同步队列中是否有线程等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">hasQueuedPredecessors</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="literal">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    	<span class="comment">//如果头结点不等于尾结点并且</span></span><br><span class="line">    	<span class="comment">//	头结点的下一个结点不是当期结点则返回true也即同步队列存在</span></span><br><span class="line">    	<span class="comment">//  头结点的下一个结点不存在说明有其他线程在添加到同步队列中且不是当前线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造，默认构造一个非公平同步器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//有参构造，根据传入参数来构造一个公平同步器或者非公平同步器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="常用方法"   >
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2>
      
        <h3 id="lock"   >
          <a href="#lock" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock" class="headerlink" title="lock"></a>lock</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.lock(); <span class="comment">//调用同步器的lock方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="非公平同步器"   >
          <a href="#非公平同步器" class="heading-link"><i class="fas fa-link"></i></a><a href="#非公平同步器" class="headerlink" title="非公平同步器"></a>非公平同步器</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加锁</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">         	<span class="comment">//尝试获取锁，如果获取锁成功则更新锁的持锁线程为当前线程</span></span><br><span class="line">          <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">              setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="comment">//加锁失败走AQS的获取锁流程，会进入子类的tryAcquire方法</span></span><br><span class="line">              acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> nonfairTryAcquire(acquires); <span class="comment">//调用同步器的尝试获取锁，如果获取锁失败继续acquire方法添加到同步队列中</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="公平同步器"   >
          <a href="#公平同步器" class="heading-link"><i class="fas fa-link"></i></a><a href="#公平同步器" class="headerlink" title="公平同步器"></a>公平同步器</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//先进AQS的acquire方法，然后再回来进行tryAcquire方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">          acquire(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//尝试加锁</span></span><br><span class="line">      <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">          <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//如果锁状态为0也即无人持锁，如果同步队列没有线程等待才尝试加锁</span></span><br><span class="line">              <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                  compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//锁的重入</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">              <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">	<span class="comment">//如果同步队列存在那么就直接加锁失败，然后继续acquire方法进入同步队列中            </span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="tryLock"   >
          <a href="#tryLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>); <span class="comment">//调用同步器的nonfairTryAcquire</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="unlock"   >
          <a href="#unlock" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>); <span class="comment">//调用同步器的解锁方法，最后是AQS的解锁方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="ReentrantReadWriteLock"   >
          <a href="#ReentrantReadWriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1>
      <p>可重入读写锁，首先我们先要看到它实现的接口ReadWriteLock</p>

        <h2 id="ReadWriteLock"   >
          <a href="#ReadWriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">	<span class="comment">//读锁</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="成员变量以及内部类-2"   >
          <a href="#成员变量以及内部类-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-2" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">//写锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">//同步器</span></span><br><span class="line">   <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">//魔法类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="comment">//tid位移偏移量    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TID_OFFSET;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">           Class&lt;?&gt; tk = Thread.class;</span><br><span class="line">           TID_OFFSET = UNSAFE.objectFieldOffset</span><br><span class="line">               (tk.getDeclaredField(<span class="string">&quot;tid&quot;</span>));</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="Sync-1"   >
          <a href="#Sync-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync-1" class="headerlink" title="Sync"></a>Sync</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds; <span class="comment">//ThreadLocalHoldCounter 线程本地变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">Thread</span> <span class="variable">firstReader</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//第一个读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> firstReaderHoldCount;  <span class="comment">//第一个读锁持锁次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;	<span class="comment">//最后一个操作读锁的线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//16位是写锁和读锁的分界线，高16位为记录共享锁，低16位用于记录独占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共享锁，高16位，高16位用于记录共享锁(读锁)的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁的最大重入次数为65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//独占锁，低16位，用于计算独占锁（写锁）的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>; <span class="comment">//EXCLUSIVE_MASK 1111 1111 1111 1111</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//...省略部分代码</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="HoldCounter"   >
          <a href="#HoldCounter" class="heading-link"><i class="fas fa-link"></i></a><a href="#HoldCounter" class="headerlink" title="HoldCounter"></a>HoldCounter</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">    		<span class="comment">//锁次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="ThreadLocalHoldCounter"   >
          <a href="#ThreadLocalHoldCounter" class="heading-link"><i class="fas fa-link"></i></a><a href="#ThreadLocalHoldCounter" class="headerlink" title="ThreadLocalHoldCounter"></a>ThreadLocalHoldCounter</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalHoldCounter封装了一下ThreadLocal，为了增加线程tid以及锁的重入次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;</span><br><span class="line">            <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="sharedCount"   >
          <a href="#sharedCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#sharedCount" class="headerlink" title="sharedCount"></a>sharedCount</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取读锁的重入次数 直接将状态字无符号右移16位(高位补0)</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;	</span><br></pre></td></tr></table></div></figure>


        <h5 id="exclusiveCount"   >
          <a href="#exclusiveCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#exclusiveCount" class="headerlink" title="exclusiveCount"></a>exclusiveCount</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写锁的重入次数（低16位），也即写锁的重入次数最大为65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="NonfairSync-1"   >
          <a href="#NonfairSync-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#NonfairSync-1" class="headerlink" title="NonfairSync"></a>NonfairSync</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">8159625535654395037L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//非公平锁可以尝试CAS取锁，不需要判断同步队列是否存在</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="FairSync-1"   >
          <a href="#FairSync-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#FairSync-1" class="headerlink" title="FairSync"></a>FairSync</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2274990926593161451L</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//公平锁如果同步队列中存在则阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//公平锁如果同步队列中存在则阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="ReadLock"   >
          <a href="#ReadLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReadLock" class="headerlink" title="ReadLock"></a>ReadLock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5992448646407690164L</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//写操作是否需要阻塞，在非公平同步器中，写操作可以不用在乎是否存在同步队列，所以返回false表示不需要阻塞</span></span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	</span><br><span class="line">    	<span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//调用AQS中的方法判断是否读操作需要阻塞</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...省略部分代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	AQS中的方法，当返回true的时候需要以下几个条件：</span></span><br><span class="line"><span class="comment">		1.同步队列头结点不为空</span></span><br><span class="line"><span class="comment">		2.同步队列头结点的下一个结点存在(也即有等待锁的线程存在)</span></span><br><span class="line"><span class="comment">		3.等待锁的线程是独占模式</span></span><br><span class="line"><span class="comment">		4.同步队列头结点的下一个结点的线程不为空</span></span><br><span class="line"><span class="comment">	也即同步队列中的能够抢锁的第一个线程必须存在并且是独占模式，也即获取读锁要被阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> &#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="literal">null</span> &amp;&amp;	<span class="comment">//同步队列存在头结点不为空</span></span><br><span class="line">            (s = h.next)  != <span class="literal">null</span> &amp;&amp;	<span class="comment">//同步队列的头结点的下一个结点也存在</span></span><br><span class="line">            !s.isShared()         &amp;&amp;	<span class="comment">//同步队列的头结点的下一个结点是独占模式</span></span><br><span class="line">            s.thread != <span class="literal">null</span>;			<span class="comment">//同步队列的头结点的下一个结点的线程不为空</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="WriteLock"   >
          <a href="#WriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#WriteLock" class="headerlink" title="WriteLock"></a>WriteLock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">4992448646407690164L</span>;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">protected</span> <span class="title function_">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">           sync = lock.sync;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           sync.acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	<span class="comment">//...省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="构造方法-1"   >
          <a href="#构造方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造，默认会构造非公平读写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//有参构造，根据传入参数构造公平读写锁或者非公平读写锁</span></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">       sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">       readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">       writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//给读写锁初始化</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line">   <span class="keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="title function_">readLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="写锁-写锁"   >
          <a href="#写锁-写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#写锁-写锁" class="headerlink" title="写锁+写锁"></a>写锁+写锁</h3>
      
        <h4 id="lock-1"   >
          <a href="#lock-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-1" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>); <span class="comment">//调用AQS的acquire方法，acquire方法会走tryAcquire方法由子类实现</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquire-1"   >
          <a href="#tryAcquire-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire-1" class="headerlink" title="tryAcquire"></a>tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行写锁+写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁)</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果锁状态不为0，也即有线程拥有锁(这里假设是写锁)</span></span><br><span class="line">                </span><br><span class="line">               	<span class="comment">//因为是写锁，所以w！=0,判断持锁线程是否是当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">//如果持锁线程不是当前线程，所以不能加锁(写锁互斥)</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//反之是持锁线程的写锁重入，判断重入次数是否大于最大重入次数65535</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//锁重入成功，设置锁的状态值返回true</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//writerShouldBlock()判断写锁是否要阻塞</span></span><br><span class="line">    		<span class="comment">//公平锁要判断同步队列是否存在，非公平锁直接返回false，认为可以去CAS加锁</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果公平锁需要入同步队列或者CAS加锁失败则加锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//反之是第一次加锁成功</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>写锁+写锁</p>
<ul>
<li>未被加锁：根据锁的类型判断是否能抢锁<ul>
<li>公平锁：如果AQS同步队列不存在那么就可以尝试获取锁，如果存在则要进入AQS同步队列</li>
<li>非公平锁：无论AQS同步队列存在不存在那么都可以尝试获取锁</li>
</ul>
</li>
<li>已被加锁：判断锁是否是当前线程加锁（也即锁的重入）<ul>
<li>不是当前线程：那么就是别的线程来抢锁，而写锁是独占锁，返回加锁失败：<code>return false;</code></li>
<li>是当前线程<ul>
<li>判断锁的重入次数是否达到上限：上限为(1&lt;&lt;16)-1，也即65535<ul>
<li>达到上限则抛出异常</li>
<li>没有达到上限则成功加锁，返回加锁成功:<code>return true;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="写锁-读锁"   >
          <a href="#写锁-读锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#写锁-读锁" class="headerlink" title="写锁+读锁"></a>写锁+读锁</h3>
      
        <h4 id="lock-2"   >
          <a href="#lock-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-2" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//共享锁加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);<span class="comment">//调用AQS的acquireShared方法，会进行tryAcquireShared方法由子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-1"   >
          <a href="#tryAcquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-1" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行写锁+读锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取锁的重入次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    	因为持锁是写锁，所以写锁重入次数!=0，那么就分两种：</span></span><br><span class="line"><span class="comment">    		1.是当前线程持有写锁要加读锁  =&gt;锁的降级</span></span><br><span class="line"><span class="comment">    		2.不是当前线程持写锁			=&gt;加锁失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="comment">//如果不是当前线程持有写锁，那么就返回-1表示加锁失败</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//运行到这里是因为是本线程持有写锁，所以可以进行获取读锁(锁的降级)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);   <span class="comment">//获取共享锁的加锁次数</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">//根据锁的公平/非公平性判断是否需要读操作阻塞</span></span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;		<span class="comment">//如果加锁次数没有达到上限</span></span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;	<span class="comment">//CAS加共享读锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; </span><br><span class="line">        	<span class="comment">//如果共享锁的加锁次数为0，那么就记录第一个加锁线程，并缓存第一个读锁加锁次数为1</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">//如果缓存中第一个读锁线程是当前线程，那么就将缓存读锁加锁次数++</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//因为这里是写锁+读锁，所以是同一个线程内进行，不会走到这个if语句，以下暂且不看</span></span><br><span class="line">            <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回1表示加锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**如果加锁失败,也即上方if判断语句为false，那么就有三种情况：</span></span><br><span class="line"><span class="comment">    	1.同步队列的头结点的下一个结点不是共享模式</span></span><br><span class="line"><span class="comment">    	2.共享锁的加锁次数达到了最大上限(65535)</span></span><br><span class="line"><span class="comment">    	3.CAS加锁失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="fullTryAcquireShared"   >
          <a href="#fullTryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">    <span class="comment">//ThreadLcocal的封装HoldCounter，封装了一个count，用于记录锁的重入次数</span></span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取锁的状态字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个if语句，如果锁是独占锁则进入if条件语句中，我们这个条件下一开始是独占锁所以这里会进入第一个条件语句中</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//走到这里也即写锁(独占锁)重入次数不为0，也即一开始有独占锁存在</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">//如果持锁线程不是本线程则返回-1，如果是本线程则进入下方第二个if语句判断</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//是共享锁，且共享锁需要被阻塞，这里先暂且不谈，因为这里一开始独占锁标记就不为0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个if语句，判断共享锁是否达到上限</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="comment">//达到上限则抛出共享锁达到上限错误</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三个if语句，则尝试CAS加锁，如果CAS失败则死循环再进行CAS判断</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">/**CAS成功，以下有三种情况:</span></span><br><span class="line"><span class="comment">            	1.本线程是第一次获取共享锁的线程</span></span><br><span class="line"><span class="comment">            	2.本线程是第一个获取共享锁的线程重入</span></span><br><span class="line"><span class="comment">            	3.本线程不是第一个获取共享锁的线程 （在写锁+读锁的情况下不存在，因为读锁一定是当前写锁线程)</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//情况1，是第一次获取共享锁，那么就缓存第一个读线程，并且更新共享锁重入次数为1</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">//情况2，是第一个获取共享锁的线程重入，那么就更新共享锁重入次数++</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//情况3，本线程不是第一个获取共享锁的线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//如果缓存rh为空，那么就指向读锁最后一个线程的缓存(也即最后一个获取读锁的线程)</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">//如果缓存rh为空或者rh的线程不是本线程，那么就将rh跟踪当前线程情况</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果最后一个读线程是当前线程并且计数器为0，说明当前线程曾经获取过读锁后面释放完了锁</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//更新一下本地线程变量，将当前线程持锁计数0以及当前线程id的rh重新写入readHolds中</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//缓存rh的锁重入次数++,并且更新最后一个获取读锁线程缓存cacheHoldCounter为当前线程</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//返回1表示加锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>写锁+读锁</p>
<p>判断写锁是否是本线程拥有</p>
<ul>
<li>写锁不是本线程持有，想要加读锁：<strong>不允许</strong>，因为写锁是排它锁，所以其他线程请求读锁会失败</li>
<li>写锁是本线程持有，想要加读锁（<strong>锁的降级</strong>）<ul>
<li>尝试添加读锁成功：<ul>
<li>是第一次添加读锁，更新第一个读锁线程缓存（FirstReader）以及重入次数（FirstReaderHoldCounter）</li>
<li>不是第一次添加读锁，更新第一个读锁线程的重入次数（FirstReaderHolderCounter）</li>
</ul>
</li>
<li>尝试添加读锁失败：<ul>
<li>同步队列的下一个结点不是共享模式，需要阻塞；</li>
<li>共享锁的重入次数达到上限65535：抛出达到共享锁上限错误</li>
<li>CAS失败，进入循环中再次尝试CAS获取读锁</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="读锁-写锁"   >
          <a href="#读锁-写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读锁-写锁" class="headerlink" title="读锁+写锁"></a>读锁+写锁</h3>
      
        <h4 id="lock-3"   >
          <a href="#lock-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-3" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>); <span class="comment">//调用AQS的acquire方法，acquire方法会走tryAcquire方法由子类实现</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquire-2"   >
          <a href="#tryAcquire-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire-2" class="headerlink" title="tryAcquire"></a>tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行读锁+写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁)</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//在进行持读锁想要加写锁的情况下，c！= 0 &amp;&amp; w == 0</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">//也即当持读锁(共享锁)的情况下加写锁(独占锁)会直接返回false，不允许加锁</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>读锁+写锁</p>
<ul>
<li>持有读锁的情况下<code>c != 0</code>，<code>w == 0</code>，走到第一个分支就会加锁失败，也即<strong>持有读锁不允许加写锁</strong>（<strong>不允许锁升级</strong>）</li>
</ul>

        <h3 id="读锁-读锁"   >
          <a href="#读锁-读锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读锁-读锁" class="headerlink" title="读锁+读锁"></a>读锁+读锁</h3>
      
        <h4 id="lock-4"   >
          <a href="#lock-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock-4" class="headerlink" title="lock"></a>lock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReadLock加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;   	</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>AQS中的获取共享锁方法(acquireShared)</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    	<span class="comment">//先尝试获取共享锁，获取锁失败则进入同步队列中等待获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-2"   >
          <a href="#tryAcquireShared-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-2" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">      <span class="comment">//获取当前线程</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">//获取锁的状态</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">      <span class="comment">//获取独占锁的重入次数，因为一开始加的是读锁，所以独占锁次数为0</span></span><br><span class="line">      <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;	<span class="comment">//0==0也即第一个判断中返回false</span></span><br><span class="line">          getExclusiveOwnerThread() != current)</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//获取共享锁的重入次数</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果读锁操作允许，并且读锁重入次数小于上限，并且CAS成功</span></span><br><span class="line">      <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp; <span class="comment">//根据同步器的公平/非公平判断是否需要阻塞</span></span><br><span class="line">          r &lt; MAX_COUNT &amp;&amp;		<span class="comment">//读锁重入次数小于上限(65535)</span></span><br><span class="line">          compareAndSetState(c, c + SHARED_UNIT)) &#123;	<span class="comment">//CAS</span></span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">//如果共享锁的加锁次数为0，那么就记录第一个加锁线程，并缓存第一个读锁加锁次数为1</span></span><br><span class="line">              firstReader = current;</span><br><span class="line">              firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">              <span class="comment">//如果缓存中第一个读锁线程是当前线程，那么就将缓存读锁加锁次数++</span></span><br><span class="line">              firstReaderHoldCount++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//获取rh，是最后一个读锁操作线程缓存</span></span><br><span class="line">              <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">              <span class="comment">//如果最后一个操作线程缓存不存在，或者最后一个线程不是本线程</span></span><br><span class="line">              <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                  <span class="comment">//那么就更新本线程成为最后一个线程</span></span><br><span class="line">                  cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                  <span class="comment">//本线程就是最后一个操作读锁线程，并且本线程计数器为0，那么更新通用计数器</span></span><br><span class="line">                  readHolds.set(rh);</span><br><span class="line">              <span class="comment">//更新本线程重入次数++</span></span><br><span class="line">              rh.count++;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//返回1表示加锁成功</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/**如果加锁失败,也即上方if判断语句为false，那么就有三种情况：</span></span><br><span class="line"><span class="comment">	1.同步队列的头结点的下一个结点不是共享模式</span></span><br><span class="line"><span class="comment">	2.共享锁的加锁次数达到了最大上限(65535)</span></span><br><span class="line"><span class="comment">	3.CAS加锁失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="fullTryAcquireShared-1"   >
          <a href="#fullTryAcquireShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#fullTryAcquireShared-1" class="headerlink" title="fullTryAcquireShared"></a>fullTryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">fullTryAcquireShared</span><span class="params">(Thread current)</span> &#123;</span><br><span class="line">    <span class="comment">//先将通用计数器置空</span></span><br><span class="line">    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//死循环，持续获取读锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//获取锁的状态字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//因为这里是读锁+读锁，所以独占锁的重入次数为0，会进入下方第一个if语句的else判断中</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一个if语句，判断是否是独占锁，else语句是共享锁或者无锁执行路线</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">			<span class="comment">//是共享锁或者无锁，但是如果读操作需要被阻塞</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果第一个读线程是当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">//那么什么都不做</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果第一个读线程不是当前线程</span></span><br><span class="line">                </span><br><span class="line">              	<span class="comment">//如果通用计数器rh为空</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//那么就更新rh成为最后一个操作线程缓存</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    	进入下方分支有两个情况：</span></span><br><span class="line"><span class="comment">                    		1.最后一个读锁线程缓存为空，也即本线程是第一个获取读锁的线程，此时rh==null</span></span><br><span class="line"><span class="comment">                    		2.最后一个读锁线程缓存不为空，也即读锁有线程获取了rh不为空，但不是本线程</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        <span class="comment">//将rh跟踪当前线程</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                        	对应情况1，因为此时线程是第一个获取读锁的线程失败，所以将本地线程变量移除</span></span><br><span class="line"><span class="comment">                        	对应情况2，因为本线程是第一次获取读锁，但是获取失败，所以本地线程变量移除</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();<span class="comment">//将本地线程变量移除</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果是情况1，本线程是第一个获取读锁的线程失败，所以返回-1给上层方法表示需要阻塞获取读锁失败防止死锁</span></span><br><span class="line">                <span class="comment">//如果是情况2，本线程是第一次获取读锁失败，返回-1表示需要阻塞获取读锁失败防止死锁</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**运行到这里有几种可能去竞争锁：</span></span><br><span class="line"><span class="comment">        	1.是共享锁/无锁，获取读锁操作不需要被阻塞</span></span><br><span class="line"><span class="comment">        	2.获取锁操作需要被阻塞，但是因为本线程还持有读锁，可以继续尝试获取读锁,直到获取锁成功返回1</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二个if语句，判断共享锁次数是否达到上限</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);<span class="comment">//达到上限则抛出Error</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">//如果CAS</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果共享锁次数为0，说明该线程是第一个获取读锁线程</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">//如果本线程是第一个持读锁线程，那么更新第一个读锁重入次数</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//如果rh==null，那么跟踪最后一个获取读锁线程</span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">//如果最后一个获取读锁线程不是本线程，那么则将rh跟踪本线程</span></span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                   	</span><br><span class="line">                    <span class="comment">//如果本线程的持锁数量为0，那么更新readHolds</span></span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                <span class="comment">//本线程读锁重入次数++</span></span><br><span class="line">                rh.count++;</span><br><span class="line">                <span class="comment">//更新最后一个操作读锁缓存</span></span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>读锁+读锁，当持锁是读锁或者无锁的情况下：</p>
<ul>
<li>简单加锁成功：<strong>获取读锁不被阻塞</strong>、<strong>读锁重入次数不达到上限</strong>、<strong>CAS成功</strong><ul>
<li>是第一次添加读锁，更新第一个读锁线程缓存（FirstReader）以及重入次数（FirstReaderHoldCounter）</li>
<li>当前线程是第一个读锁线程，更新第一个读锁线程的重入次数（FirstReaderHolderCounter）</li>
<li>当前线程不是第一个获取读锁线程，那么就将rh跟踪到当前线程，也即最后一个操作读锁线程是本线程<ul>
<li>假如当前线程的读锁重入次数为零（rh.count&#x3D;&#x3D;0)，那么更新readHolds，重入次数++</li>
<li>假如当前读锁的读锁重入次数不为0，更新重入次数++</li>
</ul>
</li>
</ul>
</li>
<li>简单加锁失败，进入完整加锁流程：<ul>
<li>如果锁是独占锁，那么就加锁失败返回-1</li>
<li>如果锁是无锁或者共享锁<ul>
<li>如果获取读锁操作被阻塞：<ul>
<li>如果该线程是第一个获取读锁或者第一次获取读锁被阻塞，那么返回-1表示获取读锁失败，防止死锁</li>
<li>如果该线程不是第一次获取读锁，那么会不断获取读锁直到成功</li>
</ul>
</li>
<li>如果锁的重入次数达到上限：上限65535，会抛出错误！</li>
<li>不断获取读锁，该情况有：1.获取读锁操作不被阻塞。2.获取读锁操作被阻塞，但是本线程不是第一次获取读锁<ul>
<li>是第一次添加读锁，更新第一个读锁线程缓存（FirstReader）以及重入次数（FirstReaderHoldCounter）</li>
<li>当前线程是第一个读锁线程，更新第一个读锁线程的重入次数（FirstReaderHolderCounter）</li>
<li>当前线程不是第一个获取读锁线程，那么就将rh跟踪到当前线程，也即最后一个操作读锁线程是本线程<ul>
<li>假如当前线程的读锁重入次数为零（rh.count&#x3D;&#x3D;0)，那么更新readHolds，重入次数++</li>
<li>假如当前读锁的读锁重入次数不为0，更新重入次数++</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        <h3 id="特例-写锁-读锁-写锁"   >
          <a href="#特例-写锁-读锁-写锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#特例-写锁-读锁-写锁" class="headerlink" title="特例(写锁+读锁+写锁)"></a>特例(写锁+读锁+写锁)</h3>
      <p>我们要知道，在读锁存在的时候获取写锁会失败，也即读锁<strong>不能升级</strong>，但是写锁<strong>可以降级</strong>，那么当降级后的写锁是什么锁？能不能获取写锁呢?答案是<strong>肯定</strong>的，当降级之后的写锁仍然能获取<strong>写锁</strong></p>
<p>在<strong>同一个线程</strong>内获取写锁+读锁+写锁可以成立，这个时候我称之为读写锁</p>
<blockquote>
<p>举例：先获取一次写锁，再获取一次读锁，最后再获取一次写锁</p>
</blockquote>

        <h4 id="第一次写锁tryAcquire"   >
          <a href="#第一次写锁tryAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次写锁tryAcquire" class="headerlink" title="第一次写锁tryAcquire"></a>第一次写锁tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次获取写锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁) c==0,w==0</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//写不被阻塞，并且因为是一个线程在竞争CAS成功</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>执行完CAS操作之后c&#x3D;0000 0000 0000 0000 | 0000 0000 0000 0001 也即c&#x3D;&#x3D;1表示写锁重入次数1，执行完这里表示已经拥有了<strong>写锁</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201615367.png"  alt="第一次加写锁">
      </p>

        <h4 id="第一次读锁tryAcquireShared"   >
          <a href="#第一次读锁tryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次读锁tryAcquireShared" class="headerlink" title="第一次读锁tryAcquireShared"></a>第一次读锁tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次获取读锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();<span class="comment">//获取锁的状态字c=1</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; <span class="comment">//独占锁重入次数为1，并且持有读锁线程为本线程，进行锁降级</span></span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);	<span class="comment">//读锁次数为0</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">//CAS成功</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//因为本线程是第一个获取读锁线程，所以更新第一个读锁线程以及第一个读锁重入次数</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取读锁成功表示返回1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>执行完CAS之后，c&#x3D;0000 0000 0000 0001 | 0000 0000 0000 0001 也即c&#x3D;65537，执行完这里表示该线程拥有了<strong>读锁</strong>，也即表示现在拥有了<strong>读写锁</strong></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201709342.png"  alt="第一次加读锁">
      </p>

        <h4 id="第二次写锁tryAcquire"   >
          <a href="#第二次写锁tryAcquire" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次写锁tryAcquire" class="headerlink" title="第二次写锁tryAcquire"></a>第二次写锁tryAcquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二次获取写锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取锁的重入次数c以及独占锁的重入次数w(写锁) c==65537,w==1</span></span><br><span class="line">    		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//独占锁重入次数不为0，又因为是当前线程，所以可以获取写锁</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//独占锁次数没有超过上限</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">//设置状态字加锁成功</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    	</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p>执行完CAS之后，c&#x3D;0000 0000 0000 0001| 0000 0000 0000 0010，也即c&#x3D;65538，也即执行完操作之后线程还拥有读写锁</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201804965.png"  alt="第二次加读锁">
      </p>

        <h3 id="写锁解锁"   >
          <a href="#写锁解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#写锁解锁" class="headerlink" title="写锁解锁"></a>写锁解锁</h3>
      
        <h4 id="unlock-1"   >
          <a href="#unlock-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock-1" class="headerlink" title="unlock"></a>unlock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写锁解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);<span class="comment">//会走AQS的逻辑，然后走到tryRelease由子类实现回到读写锁中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="tryRelease-1"   >
          <a href="#tryRelease-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryRelease-1" class="headerlink" title="tryRelease"></a>tryRelease</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="comment">//判断该线程是否是持锁线程，如果不是持锁线程想要释放锁那么会抛出异常</span></span><br><span class="line">    		<span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">//获取释放锁之后的状态字nextc</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    		<span class="comment">//如果本次释放锁是完全释放锁，那么free为true，反之还有锁的重入free为false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)	<span class="comment">//如果是完全释放锁，那么会更新持锁线程为空</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    		<span class="comment">//更新锁的状态字</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<ul>
<li><p>写锁解锁：</p>
<ul>
<li><p>判断本线程是否是持锁线程：不是则抛出异常</p>
</li>
<li><p>判断本次释放锁是否是完全释放锁：是完全释放会设置锁的持有线程为空</p>
</li>
<li><p>更新锁的状态字</p>
</li>
<li><p>返回是否完全释放锁</p>
</li>
</ul>
</li>
</ul>

        <h3 id="读锁解锁"   >
          <a href="#读锁解锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#读锁解锁" class="headerlink" title="读锁解锁"></a>读锁解锁</h3>
      
        <h4 id="unlock-2"   >
          <a href="#unlock-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock-2" class="headerlink" title="unlock"></a>unlock</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读锁解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="tryReleaseShared"   >
          <a href="#tryReleaseShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReleaseShared" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">//如果当前线程是第一个读锁线程</span></span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">//如果当前线程的共享锁重入次数缓存为1，那么本次释放锁之后就完全释放锁</span></span><br><span class="line">            firstReader = <span class="literal">null</span>;	<span class="comment">//将第一个持锁线程置空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则，说明当前持锁线程没能完全释放锁，重入次数缓存--</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//反之当前线程不是第一个持锁线程</span></span><br><span class="line">        <span class="comment">//获取最后一个获取读锁线程</span></span><br><span class="line">        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">//如果最后一个获取读锁线程不是当前线程，那么rh指向当前线程</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="comment">//获取当前线程的读锁重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果重入次数等于1，那么就说明本线程释放锁之后就完全释放了锁</span></span><br><span class="line">            readHolds.remove();<span class="comment">//本地线程副本移除当前线程(释放之后不持锁了)</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)<span class="comment">//如果小于等于0也即非加锁线程要解锁，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读锁重入次数--</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取锁的状态字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">//如果获取释放锁之后共享锁的重入次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c - SHARED_UNIT;</span><br><span class="line">        <span class="comment">//如果CAS成功也即释放锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">			<span class="comment">//返回是否完全释放锁，如果是返回true，如果没有完全释放锁，返回false</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>也即</strong></p>
<p>读锁解锁：</p>
<ul>
<li>判断本线程是否是第一个持锁线程<ul>
<li>是第一个持锁线程，对第一个持锁线程的重入次数判断<ul>
<li>如果本次解锁之后重入次数为0，说明完全释放锁，将第一个持锁线程缓存置空：<code>firstReader=null</code></li>
<li>如果本次解锁之后重入次数不为0，说明没有完全释放锁，直接将第一个持锁线程重入次数–</li>
</ul>
</li>
<li>不是第一个持锁线程<ul>
<li>获取最后一个操作读锁线程，如果最后一个操作读锁线程不是本线程，那么rh指向本线程</li>
<li>获取rh的重入次数<ul>
<li>如果rh的重入次数&#x3D;&#x3D;1，那么本次释放锁之后移出本地线程变量副本</li>
<li>如果rh的重入次数小于等于0，说明是非持锁线程想要释放锁，抛出异常</li>
</ul>
</li>
<li>读锁重入次数–</li>
</ul>
</li>
</ul>
</li>
<li>循环，直到CAS成功，返回是否完全释放锁<ul>
<li>nextc&#x3D;&#x3D;0返回true，说明完全释放了读锁</li>
<li>nextc!&#x3D;0返回false，说明没有完全释放读锁</li>
</ul>
</li>
</ul>

        <h3 id="额外知识-自己总结"   >
          <a href="#额外知识-自己总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#额外知识-自己总结" class="headerlink" title="额外知识(自己总结)"></a>额外知识(自己总结)</h3>
      
        <h4 id="1-为什么需要HoldCount"   >
          <a href="#1-为什么需要HoldCount" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-为什么需要HoldCount" class="headerlink" title="1.为什么需要HoldCount"></a>1.为什么需要HoldCount</h4>
      <p><strong>原因1</strong>：在线程上下文中我们知道可以用本地线程变量ThreadLocal来存放线程变量副本，而这个锁的重入次数也是一个变量，于是HoldCount记录了线程tid以及锁的重入次数，那么用ThreadLocalHoldCount就封装了ThreadLocal，那么锁的重入次数就能保存在ThreadLocal中</p>
<p><strong>原因2</strong>：在锁的状态字中，因为高16位表示共享锁的重入次数，而低16位表示了独占锁的重入次数</p>
<p>当独占锁在加锁32767次也即0111 1111 1111 1111之后，也即再加一次锁32768次需要进位变成1000 0000 0000 0000 而导致了符号位的溢出，采用记录HoldCount来避免进位的符号位溢出造成的影响</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20231016201506534.png"  alt="共享锁和独占锁重入次数表示">
      </p>

        <h4 id="2-为什么当readholds-count-0还要重新设置readHolds-set-rh-？"   >
          <a href="#2-为什么当readholds-count-0还要重新设置readHolds-set-rh-？" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-为什么当readholds-count-0还要重新设置readHolds-set-rh-？" class="headerlink" title="2.为什么当readholds.count&#x3D;&#x3D;0还要重新设置readHolds.set(rh)？"></a>2.为什么当readholds.count&#x3D;&#x3D;0还要重新设置readHolds.set(rh)？</h4>
      <p>原因：</p>
<p>在<code>fullTryAcquireShared</code>方法中，readholds.count&#x3D;&#x3D;0也即rh.count&#x3D;&#x3D;0,<code>rh.count</code>表示的是读锁的重入次数，那么当rh.count&#x3D;&#x3D;0有两种情况：</p>
<ul>
<li>1.该线程没有获取过读锁，那么初始化rh.count&#x3D;&#x3D;0</li>
<li>2.该线程曾经获取过读锁，并且完全释放了读锁，那么rh.count&#x3D;&#x3D;0</li>
</ul>
<p>而我们已知<code>readHolds</code>是封装了<code>ThreadLocal</code>，并添加了两个属性tid以及count,在count&#x3D;&#x3D;0并且tid&#x3D;&#x3D;current的情况下还要设置<code>readHolds.set(rh)</code>,目的是：<strong>更新ThreadLocal的数据</strong>，保证ThreadLocal一致不会对其他方法造成影响而带来数据的不一致</p>
<p>也即：如果线程曾经获取过读锁并且完全释放了读锁情况不能等同于线程从未获取过读锁</p>
<blockquote>
<p>我们可以把这个方法看成冗余，因为表面上什么都没有更新，但是实际上维护了ThreadLocal的数据安全</p>
</blockquote>

        <h4 id="3-在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？"   >
          <a href="#3-在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？" class="headerlink" title="3.在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？"></a>3.在fullTryAcquireShared方法中，当获取读锁操作被阻塞的时候为什么没有持读锁的线程直接返回-1表示失败，而已经拥有读锁的线程能自旋不断尝试获取读锁？</h4>
      <ul>
<li><p>不能继续获取锁(会被阻塞)</p>
<ul>
<li>本线程是第一个获取读锁的线程，但是获取读锁失败，那么也即<code>rh.count==0</code>,读锁重入次数为0，要执行<code>readHolds.remove();</code>并且要返回-1不能继续竞争读锁，表示获取读锁失败</li>
<li>本线程不是第一个获取读锁的线程，但是是本线程的第一次获取读锁线程并且获取读锁失败，那么也即<code>rh.count==0</code>,读锁重入次数为0，要执行<code>readHolds.remove();</code>并且要返回-1不能继续竞争读锁，表示获取读锁失败</li>
</ul>
<p>首先readHolds.remove()是因为本线程不持有读锁移除ThreadLocal中，保证ThreadLocal的数据安全</p>
<p>其次，因为都是该线程的第一次获取读锁失败并被阻塞，那么为了<strong>防止死锁</strong>，而等待写锁释放而不会自旋重复不断获取读锁</p>
</li>
<li><p>能继续获取锁</p>
<ul>
<li>本线程已经获取过读锁，这次申请读锁是读锁的重入，不会返回-1，因为无论是否阻塞，如果一直都不能获取到读锁，那么它拥有的读锁一直不能释放，又因为读锁不能升级，可能会引起死锁。为了<strong>防止死锁</strong>让线程自旋竞争获取读锁</li>
</ul>
</li>
</ul>

        <h1 id="Java并发工具类"   >
          <a href="#Java并发工具类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java并发工具类" class="headerlink" title="Java并发工具类"></a>Java并发工具类</h1>
      
        <h2 id="Semaphore-信号量"   >
          <a href="#Semaphore-信号量" class="heading-link"><i class="fas fa-link"></i></a><a href="#Semaphore-信号量" class="headerlink" title="Semaphore-信号量"></a>Semaphore-信号量</h2>
      <p>Semaphore用于控制同时访问同一组资源的时候的并发工具，主要目标是控制并发访问的数量</p>

        <h3 id="应用场景"   >
          <a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3>
      <p>1.假设一个餐厅有五个餐桌，那么餐桌总量为5个也即Semaphore(信号量)资源为5个，当餐桌总量为0的时候未能就餐的客人只能等待已经就餐的客人吃完，每有一个客人吃完那么就能迎接新的客人就餐</p>
<p>2.假设一个停车场只有五个车位，也即车位总量为5个，Semaphore(信号量)资源为5个，当车位为0的时候未能停车的客人只能等待已经停完车的客人挪车空出车位，每一个车辆离开停车场就放开一个车位</p>
<p>3.限制并发访问，当一个接口或者服务需要被保护，我们可以用Semaphore(信号量)来限制访问次数，Semaphore将超出限制次数的请求阻塞或者延迟</p>

        <h3 id="demo"   >
          <a href="#demo" class="heading-link"><i class="fas fa-link"></i></a><a href="#demo" class="headerlink" title="demo"></a>demo</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化有1个停车位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">initSemaphoreResources</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//模拟场景：1.A、B、C三个线程来竞争停车位，因为停车位只有一个，那么只能有一个车获取到车位</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">TestDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">parking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(initSemaphoreResources);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//线程A来竞争车位，假设它一共来回五次</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//等待两秒，等别的线程启动</span></span><br><span class="line">                    parking.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">1</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//模拟停车</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场&quot;</span>);</span><br><span class="line">                    parking.release();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//线程B来竞争车位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//等待两秒，等别的线程启动</span></span><br><span class="line">                    parking.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">1</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场&quot;</span>);</span><br><span class="line">                    parking.release();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程C来竞争车位</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//等待两秒，等别的线程启动</span></span><br><span class="line">                    parking.acquire();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到车位&quot;</span>);</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">1</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;离开了停车场&quot;</span>);</span><br><span class="line">                    parking.release();<span class="comment">//释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//死循环，让主线程停在这里目的是让上面线程能完整完成任务</span></span><br><span class="line">        <span class="keyword">for</span>(;;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>





<p>测试结果：一个线程一个线程交替获得到车位，每隔一秒会释放车位，每次只能有一个线程获取到资源(因为初始化资源数为1)</p>
<p>例如</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A获取到车位</span><br><span class="line">线程A离开了停车场</span><br><span class="line">线程C获取到车位</span><br><span class="line">线程C离开了停车场</span><br><span class="line">线程B获取到车位</span><br><span class="line">线程B离开了停车场</span><br></pre></td></tr></table></div></figure>


        <h3 id="源码"   >
          <a href="#源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码" class="headerlink" title="源码"></a>源码</h3>
      
        <h4 id="成员变量以及内部类-3"   >
          <a href="#成员变量以及内部类-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-3" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h4>
      
        <h5 id="成员变量"   >
          <a href="#成员变量" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">3222578661600680210L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>


        <h5 id="Sync-2"   >
          <a href="#Sync-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync-2" class="headerlink" title="Sync"></a>Sync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化共享资源个数</span></span><br><span class="line">	Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            setState(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取资源</span></span><br><span class="line">        		<span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        		<span class="comment">//获取剩余资源量</span></span><br><span class="line">        		<span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        		<span class="comment">//如果余量为0(抢资源失败)或者CAS成功(抢资源成功)则结束循环</span></span><br><span class="line">        		<span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            		compareAndSetState(available, remaining))</span><br><span class="line">            </span><br><span class="line">            	<span class="comment">//当抢锁成功则返回大于等于0，如果抢锁是啊比则返回负数</span></span><br><span class="line">            	<span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前资源的状态字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//获取释放资源之后的下一个状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果释放资源之后资源还更少，那么就抛出错误</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS成功，则返回true结束死循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h5 id="NonfairSync-2"   >
          <a href="#NonfairSync-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#NonfairSync-2" class="headerlink" title="NonfairSync"></a>NonfairSync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">        NonfairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);<span class="comment">//会走同步器中的非公平尝试获取资源方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h5 id="FairSync-2"   >
          <a href="#FairSync-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#FairSync-2" class="headerlink" title="FairSync"></a>FairSync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">        FairSync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="keyword">permits</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="构造方法-2"   >
          <a href="#构造方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>)</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="acquire-2"   >
          <a href="#acquire-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#acquire-2" class="headerlink" title="acquire"></a>acquire</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);<span class="comment">//走AQS中的方法，然后tryAcquireShared会由子类实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-3"   >
          <a href="#tryAcquireShared-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-3" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      
        <h5 id="非公平同步器-1"   >
          <a href="#非公平同步器-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#非公平同步器-1" class="headerlink" title="非公平同步器"></a>非公平同步器</h5>
      
        <h6 id="tryAcquireShared-4"   >
          <a href="#tryAcquireShared-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-4" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h6 id="nonfairTryAcquireShared"   >
          <a href="#nonfairTryAcquireShared" class="heading-link"><i class="fas fa-link"></i></a><a href="#nonfairTryAcquireShared" class="headerlink" title="nonfairTryAcquireShared"></a>nonfairTryAcquireShared</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//死循环不断抢锁</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取剩余资源量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//如果余量为0(抢资源失败)或者CAS成功(抢资源成功)则结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当抢锁成功则返回大于等于0，如果抢锁是啊比则返回负数</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="公平同步器-1"   >
          <a href="#公平同步器-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#公平同步器-1" class="headerlink" title="公平同步器"></a>公平同步器</h5>
      
        <h6 id="tryAcquireShared-5"   >
          <a href="#tryAcquireShared-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-5" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h6>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果同步队列存在，那么不能获取资源</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取资源</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取剩余资源量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">//如果余量为0(抢资源失败)或者CAS成功(抢资源成功)则结束循环</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当抢锁成功则返回大于等于0，如果抢锁是啊比则返回负数</span></span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>






        <h4 id="release-3"   >
          <a href="#release-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#release-3" class="headerlink" title="release"></a>release</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);<span class="comment">//调用同步器的释放共享锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="tryReleaseShared-1"   >
          <a href="#tryReleaseShared-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReleaseShared-1" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前资源的状态字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//获取释放资源之后的下一个状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果释放资源之后资源还更少，那么就抛出错误</span></span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果CAS成功，则返回true结束死循环</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="CountDownLatch-闭锁"   >
          <a href="#CountDownLatch-闭锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#CountDownLatch-闭锁" class="headerlink" title="CountDownLatch-闭锁"></a>CountDownLatch-闭锁</h2>
      <p>CountDownLatch可以叫闭锁，也是一个倒计数器。用于等待多个线程完成后继续执行的工具，主要用于多个线程完成执行后执行，如并行结果的手机</p>

        <h3 id="应用场景-1"   >
          <a href="#应用场景-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景-1" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3>
      <p>1.假设有一个考场，那么有五个考生和一个考官，那么可以用CountDownLatch来模拟这个场景，当所有考生都交卷离开考场之后考官才能离开考场</p>
<p>2.假如你有一个公司，其中有四个员工并且只有你有钥匙，那么你只能等所有人都下班离开公司之后再锁门</p>
<p>3.假如一个测试有四个测试用例，那么只有当所有测试用例都执行完之后，主线程才能生成测试用例报告</p>
<p>4.假如你要办理资金申请，那么需要三个证明你能够有能力还清债务，只有当出示完全三个证明之后，贷款方才能给你提供资金</p>

        <h3 id="demo-1"   >
          <a href="#demo-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#demo-1" class="headerlink" title="demo"></a>demo</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">totalTeacher</span> <span class="operator">=</span> <span class="number">1</span>;	<span class="comment">//监考老师个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">totalStudent</span> <span class="operator">=</span> <span class="number">5</span>;	<span class="comment">//参加考试考生个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟场景：一个考场有五个学生一个老师，老师只有等所有考生都交卷之后才能收卷完成并且离开考场</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CountDownLatchDemoTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalTeacher);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalStudent);</span><br><span class="line">		<span class="comment">//老师线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经进入考场&quot;</span>);</span><br><span class="line">                LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);<span class="comment">//老师准备考场，并花时间等学生在考场外排队</span></span><br><span class="line">                teacher.countDown();<span class="comment">//表示老师已经进场</span></span><br><span class="line">                student.await();<span class="comment">//等待所有学生进场考试交卷</span></span><br><span class="line">                System.out.println(<span class="string">&quot;所有学生已经交卷,&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot;开始收卷&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,<span class="string">&quot;老师&quot;</span>).start();</span><br><span class="line">		<span class="comment">//五个学生线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">6</span> ; i++) &#123;</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            	<span class="keyword">try</span> &#123;</span><br><span class="line">                	teacher.await();<span class="comment">//等待老师进场</span></span><br><span class="line">                	LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000L</span>);<span class="comment">//模拟学生做题，准备交卷</span></span><br><span class="line">                	student.countDown();</span><br><span class="line">                	System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经交卷，正在离开考场&quot;</span>);</span><br><span class="line">            	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                	e.printStackTrace();</span><br><span class="line">            	&#125;</span><br><span class="line">        	&#125;,<span class="string">&quot;学生&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//死循环不让主线程结束</span></span><br><span class="line">        <span class="keyword">for</span> (;;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>测试结果：一个考场中有一名老师和五名学生，那么只有当五名学生都交卷之后，老师才能收卷离场，如果没有学生交卷那么老师就不能离场</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">老师已经进入考场</span><br><span class="line">学生<span class="number">2</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">3</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">5</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">4</span>已经交卷，正在离开考场</span><br><span class="line">学生<span class="number">1</span>已经交卷，正在离开考场</span><br><span class="line">所有学生已经交卷,老师开始收卷</span><br></pre></td></tr></table></div></figure>


        <h3 id="源码-1"   >
          <a href="#源码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3>
      
        <h4 id="成员变量以及内部类-4"   >
          <a href="#成员变量以及内部类-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-4" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>


        <h5 id="Sync-3"   >
          <a href="#Sync-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync-3" class="headerlink" title="Sync"></a>Sync</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//设置资源数</span></span><br><span class="line">        Sync(<span class="type">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="构造方法-3"   >
          <a href="#构造方法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    	<span class="comment">//如果资源小于0，那么就报错资源不能小于0</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="countDown"   >
          <a href="#countDown" class="heading-link"><i class="fas fa-link"></i></a><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//调用Sync中的释放共享资源</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryReleaseShared-2"   >
          <a href="#tryReleaseShared-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReleaseShared-2" class="headerlink" title="tryReleaseShared"></a>tryReleaseShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取资源数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果资源数等于0，那么就说明没有资源无法释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取倒计时的下一个状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果CAS成功则返回最后CountDownLatch是否到达0</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="await-2"   >
          <a href="#await-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#await-2" class="headerlink" title="await"></a>await</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);<span class="comment">//会走到AQS的方法，然后走tryAcquireShared从子类实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>AQS中</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared-6"   >
          <a href="#tryAcquireShared-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared-6" class="headerlink" title="tryAcquireShared"></a>tryAcquireShared</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">//返回是否倒计时到0，如果倒计时数到0返回1，不是0返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="CyclicBarrier-循环栅栏"   >
          <a href="#CyclicBarrier-循环栅栏" class="heading-link"><i class="fas fa-link"></i></a><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier-循环栅栏"></a>CyclicBarrier-循环栅栏</h2>
      <p>CyclicBarrier通常用于多个线程达到一个同步点之后，再一起执行后续操作。主要目标是等待多个线程在同一个同步点集合后再继续进行</p>

        <h3 id="应用场景-2"   >
          <a href="#应用场景-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用场景-2" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3>
      <p>1.假如五个人去爬山，那么有人爬得快有人爬的慢，当爬到半山腰的时候所有人都集合，等待五个人到齐之后再往上爬山</p>
<p>2.假如四个人去购物，那么规定一个集合点，当四个人都到齐的情况之后再一起去逛街</p>
<p>3.假如一场田径比赛，按照离中心跑道越远的跑道在起跑的时候就会分到不同的起跑距离，当所有运动员、以及裁判都在自己对应的起跑线落位之后，裁判才能够吹哨发起比赛</p>
<p>4.假如一场音乐会演出，一个乐队有四个人家住不同地区，那么四个人都必须先到演唱会后台集合之后才能开始表演节目</p>
<p>5.假如进行一场王者荣耀或者英雄联盟，在发起比赛之前必须要五个人都点准备，那么才能进行游戏，如果人数不到五个人则不能进行游戏，需要重新匹配</p>

        <h3 id="demo-2"   >
          <a href="#demo-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#demo-2" class="headerlink" title="demo"></a>demo</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">totalNum</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">//一共五个人去购物</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟一行人达到某个集合点之后才一起去购物</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">CyclicBarrierDemoTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(totalNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalNum; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LockSupport.parkNanos(<span class="number">2</span>*<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">1000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;已经到达集合点，等待集合&quot;</span>);</span><br><span class="line">                    barrier.await();<span class="comment">//等待人集合</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;说集合完毕，一起去购物！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,<span class="string">&quot;美女&quot;</span>+(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//死循环，不让主线程结束</span></span><br><span class="line">        <span class="keyword">for</span>(;;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>测试结果：五个人一起去购物，那么只有当五个人都达到集合点之后，那么才会<strong>一起出发</strong>进行同样要做的事</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">美女<span class="number">2</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">3</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">4</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">5</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">1</span>已经到达集合点，等待集合</span><br><span class="line">美女<span class="number">1</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">2</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">5</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">4</span>说集合完毕，一起去购物！</span><br><span class="line">美女<span class="number">3</span>说集合完毕，一起去购物！</span><br></pre></td></tr></table></div></figure>


        <h3 id="源码-2"   >
          <a href="#源码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3>
      
        <h4 id="成员变量以及内部类-5"   >
          <a href="#成员变量以及内部类-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#成员变量以及内部类-5" class="headerlink" title="成员变量以及内部类"></a>成员变量以及内部类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义还未达到集合点的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个生成器，用于表示栅栏</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一共参赛的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取trip条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></div></figure>


        <h5 id="Generation"   >
          <a href="#Generation" class="heading-link"><i class="fas fa-link"></i></a><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="构造方法-4"   >
          <a href="#构造方法-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="built_in">this</span>.parties = parties;</span><br><span class="line">     </span><br><span class="line">        <span class="built_in">this</span>.count = parties;</span><br><span class="line">        <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="await-3"   >
          <a href="#await-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#await-3" class="headerlink" title="await"></a>await</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用dowait方法</span></span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="dowait"   >
          <a href="#dowait" class="heading-link"><i class="fas fa-link"></i></a><a href="#dowait" class="headerlink" title="dowait"></a>dowait</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span><br><span class="line">           TimeoutException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取栅栏</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">			</span><br><span class="line">        <span class="comment">//如果栅栏已经被打断，那么抛出栅栏异常打断异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果发生线程中断，那么自己断开栅栏，抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//index表示还需等待的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">//如果还需要等待个数为0，也即马上可以出发</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//如果任务不为空，那么执行任务</span></span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//这次任务结束，唤醒条件队列所有结点，创建新的栅栏</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               </span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();<span class="comment">//断开栅栏</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    <span class="comment">//条件队列等待</span></span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="breakBarrier"   >
          <a href="#breakBarrier" class="heading-link"><i class="fas fa-link"></i></a><a href="#breakBarrier" class="headerlink" title="breakBarrier"></a>breakBarrier</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">    generation.broken = <span class="literal">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">//唤醒条件队列中的全部线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="nextGeneration"   >
          <a href="#nextGeneration" class="heading-link"><i class="fas fa-link"></i></a><a href="#nextGeneration" class="headerlink" title="nextGeneration"></a>nextGeneration</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//唤醒条件队列的全部结点</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="reset"   >
          <a href="#reset" class="heading-link"><i class="fas fa-link"></i></a><a href="#reset" class="headerlink" title="reset"></a>reset</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重新重置栅栏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  	<span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<p>到此关于AQS的所有内容已经结束</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/09/07/%E6%AD%BB%E4%B9%8B%E5%89%8D%E8%A6%81%E5%81%9A%E5%AE%8C%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%8B%E5%86%8C-%5B7.%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%5D/">死之前要做完的算法手册-[7.回溯算法]</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">18.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">165分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="回溯算法理论基础"   >
          <a href="#回溯算法理论基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#回溯算法理论基础" class="headerlink" title="回溯算法理论基础"></a>回溯算法理论基础</h1>
      <p>回溯法又称回溯搜索法，是一种<strong>暴力搜索法</strong></p>
<blockquote>
<p>回溯的本质就是穷举，穷举所有可能，选出想要的结果</p>
</blockquote>
<p>回溯法可以抽象成一个N叉树，在集合递归中寻找结果，而<strong>集合长度为树的宽度，递归的深度构成了树的深度</strong></p>
<p><em>回溯法的模板</em></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(终止条件)&#123;</span><br><span class="line">        收获结果集; </span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(集合长度)&#123;</span><br><span class="line">        处理结点;</span><br><span class="line">        递归;</span><br><span class="line">        回溯;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="组合"   >
          <a href="#组合" class="heading-link"><i class="fas fa-link"></i></a><a href="#组合" class="headerlink" title="组合"></a>组合</h1>
      
        <h2 id="77-组合"   >
          <a href="#77-组合" class="heading-link"><i class="fas fa-link"></i></a><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2>
      <p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/" >Leetcode.77题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做"   >
          <a href="#第一次做" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;08</p>

        <h4 id="第一次代码"   >
          <a href="#第一次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtarcking(list,n,i+<span class="number">1</span>,k-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtarcking</span><span class="params">(List&lt;Integer&gt; list,<span class="type">int</span> n,<span class="type">int</span> index,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> || index&gt;n)&#123;</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            list.add(index);</span><br><span class="line">            backtarcking(list,n,index+<span class="number">1</span>,k-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败"   >
          <a href="#提交失败" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入n&#x3D;4，k&#x3D;2，输出[[1,2,2],[1,2,2],[2,3,3],[2,3,3],[3,4,4],[3,4,4],[4]] ，预期输出[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</p>

        <h4 id="第二次代码"   >
          <a href="#第二次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtarcking(list,n,i+<span class="number">1</span>,k-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtarcking</span><span class="params">(List&lt;Integer&gt; list,<span class="type">int</span> n,<span class="type">int</span> index,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> || index&gt;n)&#123;</span><br><span class="line">            result.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            list.add(index);</span><br><span class="line">            backtarcking(list,n,index+<span class="number">1</span>,k-<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-1"   >
          <a href="#提交失败-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-1" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入n&#x3D;4，k&#x3D;2，输出[[1],[1],[2],[2],[3],[3],[4]] ，预期输出[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</p>
<p><em>未能自己做出来</em></p>

        <h3 id="题解"   >
          <a href="#题解" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：定义两个全局变量，一个result收集结果集，一个list用于收集单个路径(组合)，当list的长度等于k的时候就收获结果</p>
<p><em>如果还没能看懂可以看这部分中的图解，改成N叉树之后分析</em></p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的参数和返回值</p>
<ul>
<li><p>返回值void:因为整个过程都收获到结果集result中</p>
</li>
<li><p>参数n:集合的长度(组合能取值的范围)</p>
</li>
<li><p>参数k:组合的个数</p>
</li>
<li><p>参数index：每次开始的搜索的索引值，第一次传入1表示从1开始搜索</p>
</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当list.size&#x3D;&#x3D;k也即组合个数达到要求，可以收获结果集。 <strong>result.add(new ArrayList(list))</strong>;</p>
<blockquote>
<p>如果result直接添加list，会后面递归中改变list值导致结果集中的数据也改变</p>
</blockquote>
</li>
<li><p>单层递归的处理逻辑</p>
<p>从index到n开始搜索，每一次递归前添加当前元素，然后递归结束之后<strong>回溯</strong></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    	<span class="comment">//收获结果集</span></span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解"   >
          <a href="#图解" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230908122504278.png"  alt="回溯法组合思路(1)">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230908122912662.png"  alt="回溯法思路(2)">
      </p>
<p>也即我们需要收获叶子结点，并且每次搜索都是从当前搜索位置之后开始</p>
<blockquote>
<p>第一次搜索为1  所以要搜索234</p>
<p>第二次搜索为2 所以要搜索34</p>
<p>..</p>
</blockquote>
<p>我们通过index来保证搜索以后的位置</p>

        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <p>这道题其实我自己做的时候也差一点能写出来，因为没能写在笔记上我做这道题的具体过程，因为很多次的过程都是因为添加数据之后然后修改过list，导致最后的数值多了或者少了，因为list一直是一个地址，所以result通常添加的值就是一个list。</p>
<p>而经过视频学习之后发现，这个<strong>存入数据的时候可以new ArrayList(list)</strong> ，copy一个新的ArrayList。</p>
<p>同时这道题有回溯的思想是值得我们学习到的，list添加数据之后单层递归要回溯pop出元素</p>

        <h2 id="77-组合-优化"   >
          <a href="#77-组合-优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#77-组合-优化" class="headerlink" title="77.组合(优化)"></a>77.组合(优化)</h2>
      <p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combinations/description/" >Leetcode.77题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="题解-1"   >
          <a href="#题解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3>
      <p>在这里我们进行一个剪枝的优化</p>
<p><strong>假设</strong></p>
<p>假如n&#x3D;4，k&#x3D;4的时候，我们可以简单知道唯一的答案就是[1,2,3,4]。而我们之前的穷举除了要查找1，还要查找2、3、4，但是这个时候无论如何都不能达到需要的k值，也即我们当集合中剩余的元素不可能达到组合的个数的时候就可以进行剪枝</p>
<p>也即我们可以求进行组合搜索的时候至多索引的位置</p>
<p><strong>实现</strong></p>
<ul>
<li><p>获取至多索引的长度</p>
<p>**k-list.size()**为还需要的元素个数</p>
<p><strong>n-(k-list.size())+1</strong>为至多索引的位置，我们可以假设极端情况来判断这个是否要加1</p>
<blockquote>
<p>假设n为4 k为3  list中元素为0  所以4-(3-0)+1 也即最多索引为2</p>
</blockquote>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtracking(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//具体剪枝的逻辑就在循环中条件的判断中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=(n-(k-list.size())+<span class="number">1</span>);i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracking(n,k,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="216-组合总合-III"   >
          <a href="#216-组合总合-III" class="heading-link"><i class="fas fa-link"></i></a><a href="#216-组合总合-III" class="headerlink" title="216.组合总合 III"></a>216.组合总合 III</h2>
      <p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-iii/" >Leetcode.216(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-1"   >
          <a href="#第一次做-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-1" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;09</p>

        <h4 id="第一次代码-1"   >
          <a href="#第一次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-1" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracking(k,n,i);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-2"   >
          <a href="#提交失败-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-2" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:k&#x3D;3,n&#x3D;7，输出[[1,1,5],[1,2,4],[1,3,3],[2,2,3]]，预期输出[1,2,4]</p>
<p>递归遍历的时候因为一个元素只能用一次，所以后面将递归下次的索引值改了</p>

        <h4 id="第二次代码-1"   >
          <a href="#第二次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-1" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i:list)&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracking(k,n,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功"   >
          <a href="#提交成功" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-2"   >
          <a href="#题解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和之前做的组合题相似，不过是要满足组合数之和要满足n，所以我们在收获结果集的时候改变一下条件，当满足条件的收获即可</p>
<p><strong>实现</strong></p>
<ul>
<li><p>递归函数的参数和返回值</p>
<ul>
<li><p>返回值void：无返回值，整个结果集被全局变量result收获</p>
</li>
<li><p>参数k：需要的组合元素个数</p>
</li>
<li><p>参数n：目标总数</p>
</li>
<li><p>参数sum：当前list集合中的元素之和</p>
</li>
<li><p>参数index：下次搜索的索引下标</p>
</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当list.size&#x3D;&#x3D;k，也即达到符合组合数，判断是否组合之和符合条件如果是收获，如果不是则直接结束</p>
</li>
<li><p>单层递归的逻辑</p>
<ul>
<li>从index到n开始搜索，每一次递归前添加当前元素到list，并且统计集合之和到sum，然后递归结束之后<strong>回溯</strong>，不仅仅回溯集合还回溯sum</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(k,n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> sum,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">           <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">               result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">			<span class="comment">//元素添加之后总和增加，增加list元素</span></span><br><span class="line">            sum+=i;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracking(k,n,sum,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯，回溯sum也回溯list</span></span><br><span class="line">            sum-=i;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="剪枝"   >
          <a href="#剪枝" class="heading-link"><i class="fas fa-link"></i></a><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3>
      <p>在这里我们能进行一个剪枝的操作，为了就是在不可能达到的情况下不会再去搜索</p>
<ul>
<li><p>第一部分</p>
<ul>
<li><p>当递归的时候sum&gt;n的时候，无论怎么样后面的分支都不会产生目标集，所以直接返回即可</p>
<blockquote>
<p>例如此时sum&#x3D;9 n为5，那无论后面怎么加数据都不会导致sum&#x3D;&#x3D;n</p>
</blockquote>
</li>
</ul>
</li>
<li><p>第二部分</p>
<ul>
<li><p>当剩下的索引位置无法满足k的时候</p>
<blockquote>
<p>例如索引为8，K为3，那么怎么样都不会有后面满足条件的组合</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>第一部分剪枝，当递归结束的判断条件，if(sum&gt;n) return;</li>
<li>第二部分剪枝，循环的判断条件，9-(k-list.size())+1，为<strong>至多满足组合的索引下标</strong></li>
</ul>
<p><strong>剪枝代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(k,n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n ,<span class="type">int</span> sum,<span class="type">int</span> index)</span>&#123;</span><br><span class="line"> 		<span class="comment">//剪枝部分1</span></span><br><span class="line">        <span class="keyword">if</span>(sum&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==k)&#123;</span><br><span class="line">           <span class="keyword">if</span>(sum==n)&#123;</span><br><span class="line">               result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剪枝部分2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=<span class="number">9</span>-(k-list.size())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            sum+=i;</span><br><span class="line">            list.add(i);</span><br><span class="line">            backtracking(k,n,sum,i+<span class="number">1</span>);</span><br><span class="line">            sum-=i;</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="17-电话号码的字母组合"   >
          <a href="#17-电话号码的字母组合" class="heading-link"><i class="fas fa-link"></i></a><a href="#17-电话号码的字母组合" class="headerlink" title="17.电话号码的字母组合"></a>17.电话号码的字母组合</h2>
      <p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" >Leetcode.17题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-2"   >
          <a href="#第一次做-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-2" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;11</p>

        <h4 id="第一次代码-2"   >
          <a href="#第一次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-2" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] hash=&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    <span class="type">char</span>[] table;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        table=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123; table[i]=(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] str=<span class="keyword">new</span> <span class="title class_">int</span>[digits.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            str[i]=Integer.parseInt(digits.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        backtracking(str,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] str,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==str.length)&#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;hash[str[i]]) index=hash[str[i]];</span><br><span class="line">            list.add(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=hash[str[i]-<span class="number">1</span>];j&lt;index;j++)&#123;</span><br><span class="line">                StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                sb.append(table[j]);</span><br><span class="line">                path.add(sb.toString());</span><br><span class="line">                </span><br><span class="line">                backtracking(str,i+<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);    </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-3"   >
          <a href="#提交失败-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-3" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入[“23”] 输出[“[a, c]”,”[a, d]”,”[a, e]”,”[b]”,”[c]”,”[d]”,”[e]”]，预期输出[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>

        <h4 id="第二次代码-2"   >
          <a href="#第二次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-2" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] hash=&#123;-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">18</span>,<span class="number">21</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    <span class="type">char</span>[] table;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        table=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123; table[i]=(<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] str=<span class="keyword">new</span> <span class="title class_">int</span>[digits.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            str[i]=Integer.parseInt(digits.charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        backtracking(str,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] str,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size()==str.length)&#123;</span><br><span class="line">            result.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;str.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;hash[str[i]]) index=hash[str[i]];</span><br><span class="line">            list.add(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=hash[str[i]-<span class="number">1</span>]+<span class="number">1</span>;j&lt;=index;j++)&#123;</span><br><span class="line">                StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                sb.append(table[j]);</span><br><span class="line">                path.add(sb.toString());</span><br><span class="line">                </span><br><span class="line">                backtracking(str,i+<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);    </span><br><span class="line">            &#125;     </span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);      </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-4"   >
          <a href="#提交失败-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-4" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:输入[“23”] 输出[“[a, d]”,”[a, e]”,”[a, f]”,”[b, d]”,”[b, e]”,”[b, f]”,”[c, d]”,”[c, e]”,”[c, f]”,”[d, d]”,”[d, e]”,”[d, f]”,”[e, d]”,”[e, e]”,”[e, f]”,”[f, d]”,”[f, e]”,”[f, f]”]，预期输出[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p>
<p>没做出来</p>

        <h3 id="题解-3"   >
          <a href="#题解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3>
      <p><strong>思路</strong></p>
<p>我们用一个hashTable做映射表，然后用index指向正在处理的位置，如果index等于digits的最后字符位置，说明已经到收获结果的时候</p>
<p><strong>实现</strong></p>
<ul>
<li><p>初始化，List<String> result用于接收结果集，List<String> path用于接收单层路径，</p>
<p>hashTable&#x3D;{“”,””,”abc”,”def”,”ghi”,”jkl”,”mno”,”pqrs”,”tuv”,”wxyz”}用于做映射数组</p>
</li>
<li><p>递归函数的参数和返回值</p>
<ul>
<li><p>返回值void：所有的结果集都接收在result中</p>
</li>
<li><p>参数digits：电话字母组合的字符串</p>
</li>
<li><p>参数index：表示当前处理的字符位置</p>
<blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如 digits=<span class="string">&quot;23&quot;</span>   index=<span class="number">0</span>  说明当前处理<span class="string">&quot;2&quot;</span>字符</span><br><span class="line">				  index=<span class="number">1</span>  说明当前处理<span class="string">&quot;3&quot;</span>字符</span><br><span class="line">				  index=<span class="number">2</span>  说明当前字符串已经全部被处理了可以收获结果集</span><br></pre></td></tr></table></div></figure></blockquote>
</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当index&#x3D;&#x3D;digits.length():也即处理完每个字符，收获结果</p>
</li>
<li><p>单层递归的逻辑</p>
<ul>
<li>获取当前字符所对应的数字：int num&#x3D;digits[index];</li>
<li>通过hashTable映射，遍历每个数字对应的数组</li>
<li>将每个数组中的元素依次添加到path路径中</li>
<li>递归调用函数，处理下一个位置字符</li>
<li>回溯</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    String[] hashTable=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化result和path集合</span></span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果digits为空或者为空串，则直接返回空集合</span></span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(digits)) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//digits不为空串则进行回溯搜索</span></span><br><span class="line">        backtarcking(digits,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtarcking</span><span class="params">(String digits,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//参数index指向的是正在处理的个数，当指向digtis.length()也即指向最后一个字符后面说明可以收获结果</span></span><br><span class="line">        <span class="keyword">if</span>(index==digits.length())&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="comment">//拼接path路径，收获结果到result中</span></span><br><span class="line">            <span class="keyword">for</span>(String s:path)&#123;</span><br><span class="line">                sb.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//获取当前index位置下的数，例如”23“ index为 0  则num为2</span></span><br><span class="line">        <span class="comment">//								index为 1  则num为3  </span></span><br><span class="line">        <span class="type">int</span> num=digits.charAt(index)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历hashTable中映射对应的数组，</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;hashTable[num].length();i++)&#123;</span><br><span class="line">            <span class="comment">//添加数组中对应的字符</span></span><br><span class="line">            path.add(hashTable[num].charAt(i)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//操作下一个位置字符</span></span><br><span class="line">            backtarcking(digits,index+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-1"   >
          <a href="#图解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-1" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230911225341797.png"  alt="电话号码的字母组合">
      </p>

        <h2 id="39-组合总和"   >
          <a href="#39-组合总和" class="heading-link"><i class="fas fa-link"></i></a><a href="#39-组合总和" class="headerlink" title="39.组合总和"></a>39.组合总和</h2>
      <p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/" >Leetcode.39题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-3"   >
          <a href="#第一次做-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-3" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;12</p>

        <h4 id="第一次代码-3"   >
          <a href="#第一次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-3" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i]);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误"   >
          <a href="#提交错误" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:candidates &#x3D;[2,3,5] target&#x3D;7,输出[[2,2,2,2],[2,3,3],[3,2,3],[3,3,2],[3,5],[5,3]]，预期输出[[2,2,2,2],[2,3,3],[3,5]]</p>

        <h4 id="第二次代码-3"   >
          <a href="#第二次代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-3" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-1"   >
          <a href="#提交成功-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-1" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>传入一个index参数，可以确定每次开始的位置，如果当前结点并没有完全结束之前可以重复使用，所以递归传入的i为当前位置。为的是index以后位置的结果不会重复</p>

        <h3 id="题解-4"   >
          <a href="#题解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：利用全局变量result收获结果集，以及全局变量path来获取单层路径，然后当所需的值小于等于0的时候做一个收获结果集的操作。如果等于0则收获，如果小于0就结束。然后这个取完一个元素之后，这个位置的元素可以重复取，所以我们对index传参的过程中可以不断的使用当前位置，而当前位置结束之后就不能再使用，防止组合的重复</p>
<p><strong>实现</strong></p>
<ul>
<li>递归函数的参数和返回值<ul>
<li>返回值void：所有的结果都在result集合中</li>
<li>参数candidates：用于遍历的数组</li>
<li>参数target：<strong>目前所需的值</strong></li>
<li>参数index：遍历的起始位置</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当target&lt;0，说明总和已经超过了，结束递归</li>
<li>当target&#x3D;&#x3D;0，说明当前组合是需要的，添加到result集合中再结束递归</li>
</ul>
</li>
<li>单层递归的逻辑<ul>
<li>添加当前结点值到path中</li>
<li>递归，从当前位置开始，以便可以取相同元素</li>
<li>回溯</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-2"   >
          <a href="#图解-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-2" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230912092618756.png"  alt="组合总和">
      </p>

        <h3 id="剪枝-1"   >
          <a href="#剪枝-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#剪枝-1" class="headerlink" title="剪枝"></a>剪枝</h3>
      <p><strong>思想</strong></p>
<ul>
<li><p>先对数组进行<strong>排序</strong></p>
<blockquote>
<p>不排序的话如果数组为2534，target&#x3D;4，那么就会错过结果集</p>
</blockquote>
</li>
<li><p>再判断当前位置元素是否大于target，如果大于了就可以剪枝不再遍历后面元素</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target==<span class="number">0</span>) result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//剪枝逻辑就在for循环的条件中，添加了candidates[i]&lt;=target</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length&amp;&amp; candidates[i]&lt;=target;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="40-组合总和II"   >
          <a href="#40-组合总和II" class="heading-link"><i class="fas fa-link"></i></a><a href="#40-组合总和II" class="headerlink" title="40.组合总和II"></a>40.组合总和II</h2>
      <p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p><strong>注意：</strong>解集不能包含重复的组合。 </p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum-ii/" >Leetcode.40(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-4"   >
          <a href="#第一次做-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-4" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;13</p>

        <h4 id="第一次代码-4"   >
          <a href="#第一次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-4" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-5"   >
          <a href="#提交失败-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-5" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:candidates &#x3D;[10,1,2,7,6,1,5]，target&#x3D;8，输出[[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]，预期输出[[1,1,6],[1,2,5],[1,7],[2,6]]</p>

        <h4 id="第二次代码-4"   >
          <a href="#第二次代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-4" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; candidates[i-<span class="number">1</span>]==candidates[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-6"   >
          <a href="#提交失败-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-6" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:candidates &#x3D;[10,1,2,7,6,1,5]，target&#x3D;8，输出[[1,2,5],[1,7],[1,6,1],[2,6],[2,1,5],[7,1]]，预期输出[[1,1,6],[1,2,5],[1,7],[2,6]]</p>

        <h4 id="第三次代码"   >
          <a href="#第三次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(List&lt;Integer&gt; list:result)&#123;</span><br><span class="line">                <span class="keyword">if</span>(list.size()!=path.size()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(list.equals(path)) <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-7"   >
          <a href="#提交失败-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-7" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:candidates&#x3D;[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],target &#x3D;30 超出时间限制</p>

        <h4 id="第四次代码"   >
          <a href="#第四次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i!=candidates.length-<span class="number">1</span>&amp;&amp;candidates[i]==candidates[i+<span class="number">1</span>])&#123;</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-8"   >
          <a href="#提交失败-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-8" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:candidates&#x3D;[2,2,2]，target&#x3D;2，输出[[2],[2]],预期输出[2]</p>

        <h4 id="第五次代码"   >
          <a href="#第五次代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五次代码" class="headerlink" title="第五次代码"></a>第五次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//给数组排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯之后指针移到下一个元素位置，如果下一个元素和当前元素相同，说明下一个组合中以下一个元素开始的组合已经重复了</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;i&lt;candidates.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i-<span class="number">1</span>]==candidates[i]) i++;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交通过"   >
          <a href="#提交通过" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交通过" class="headerlink" title="提交通过"></a>提交通过</h5>
      
        <h3 id="题解-5"   >
          <a href="#题解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和之前的题目不一样的点在于数组中有相同数值的元素，并且规定组合中元素不能重复取，但是取相同值的元素，</p>
<p>我们利用一个used数组来对原数组使用元素的情况进行判断，如果used[i]&#x3D;&#x3D;1说明这个位置元素已经取过，如果used[i]&#x3D;&#x3D;0说明这个位置元素还没取过</p>
<p><strong>实现</strong></p>
<ul>
<li><p>全局变量</p>
<ul>
<li>List&lt;List<Integer>&gt; result :用于统计结果集</li>
<li>List<Integer> path :用于记录单个路径</li>
<li>int[] used :用来标记这个位置元素是否使用</li>
</ul>
</li>
<li><p>初始化并且将candidates数组进行<strong>排序</strong>（使其相同值元素能在一起，方便进行<strong>层次维度</strong>的去重）</p>
</li>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>返回值void：所有结果集都在result中</li>
<li>参数candidates：数组</li>
<li>参数target：目标和</li>
<li>参数start：搜索的开始索引值</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li>当target&lt;0，说明当前path中元素和超过了所需，直接结束递归</li>
<li>当target&#x3D;&#x3D;0，说明path中的元素就是当前需要的组合，result.add(new ArrayList(path))，收获结果</li>
</ul>
</li>
<li><p>单层递归的处理逻辑</p>
<ul>
<li><p><strong>去重处理</strong></p>
</li>
<li><ul>
<li><p>判断当(i!&#x3D;0 &amp;&amp; candidates[i-1]&#x3D;&#x3D;candidates[i] &amp;&amp; used[i-1]&#x3D;&#x3D;0时，直接跳过不处理</p>
</li>
<li><p>i！&#x3D;0 第一个元素不进行判断</p>
</li>
<li><p>candidates[i-1]&#x3D;&#x3D;candidates[i]  说明当前元素和前一个元素值相同，要准备进行去重(如果是层次上的相同则去除，如果是深度上的相同则保留)</p>
</li>
<li><p>used[i-1]&#x3D;&#x3D;0，说明前一个元素没有用过，如果 candidates[i-1]&#x3D;&#x3D;candidates[i] &amp;&amp;used[i-1]&#x3D;&#x3D;0 说明当前的组合是前一个位置元素的<strong>子组合</strong></p>
</li>
</ul>
</li>
<li><p>添加路径到path中，将used[i]置为1</p>
</li>
<li><p>递归搜索i+1的位置</p>
</li>
<li><p>回溯，回溯path也回溯used[i]，将used[i]置为0，表示这个位置元素没有用过</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong>(利用used数组)</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="type">int</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">int</span>[candidates.length];</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; candidates[i-<span class="number">1</span>]==candidates[i] &amp;&amp; used[i-<span class="number">1</span>]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            used[i]=<span class="number">1</span>;</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            used[i]=<span class="number">0</span>;</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>代码(不用used数组去重)</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//给数组排序</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtracking(candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> target,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.length;)&#123;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtracking(candidates,target-candidates[i],i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯之后指针移到下一个元素位置，如果下一个元素和当前元素相同，说明下一个组合中以下一个元素开始的组合已经重复了</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">while</span>(i!=<span class="number">0</span>&amp;&amp;i&lt;candidates.length)&#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i-<span class="number">1</span>]==candidates[i]) i++;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-3"   >
          <a href="#图解-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-3" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230913122948179.png"  alt="组合总和II">
      </p>

        <h1 id="分割"   >
          <a href="#分割" class="heading-link"><i class="fas fa-link"></i></a><a href="#分割" class="headerlink" title="分割"></a>分割</h1>
      
        <h2 id="131-分割回文串"   >
          <a href="#131-分割回文串" class="heading-link"><i class="fas fa-link"></i></a><a href="#131-分割回文串" class="headerlink" title="131.分割回文串"></a>131.分割回文串</h2>
      <p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/" >Leetcode.131题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-5"   >
          <a href="#第一次做-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-5" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;10</p>

        <h4 id="第一次代码-5"   >
          <a href="#第一次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-5" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==s.length())&#123;</span><br><span class="line">            <span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">                StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                sb.append(str);</span><br><span class="line">                sb.reverse();</span><br><span class="line">                <span class="keyword">if</span>(!sb.toString().equals(str))<span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;s.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">if</span>(start!=<span class="number">0</span>)&#123; sb.append(s.substring(<span class="number">0</span>,start));&#125;</span><br><span class="line"></span><br><span class="line">            sb.append(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            backtracking(s,i+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-9"   >
          <a href="#提交失败-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-9" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:s&#x3D;”aab” 输出[[“b”]] 预期结果[[“a”,”a”,”b”],[“aa”,”b”]]</p>
<p>没能做出来卡了一个多小时</p>

        <h3 id="题解-6"   >
          <a href="#题解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题的解法是，start指向的是切割位置，切割位置前就为一个子串，然后用substring方法切割，范围是[start，I+1）,因为start是不变的所以就能不断切割出子串，然后是子串的添加到list中</p>
<p><strong>实现</strong></p>
<ul>
<li>递归函数的参数和返回值<ul>
<li>返回值void，所有的结果都在结果集result中</li>
<li>参数s：用于切割的回文串</li>
<li>参数start，标记切割位置</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当start&#x3D;&#x3D;s.length() 也即切割点到了回文串的最后一个字符，也就没有切割下的子串了，能收获已经正在result中的数据</li>
</ul>
</li>
<li>单层递归的逻辑<ul>
<li>每层循环从start，开始start传入0，代表的切割位置</li>
<li>对切割下的子串进行一个判断（isBackString方法）<ul>
<li>如果是回文串返回true，<strong>则添加到list结果集中</strong></li>
<li>如果不是回文串则返回false，则continue</li>
<li>函数的逻辑是利用StringBuilder进行一个字符串反转，如果反转后相同则是回文串</li>
</ul>
</li>
<li>递归，切割i+1的位置</li>
<li>回溯，将结果集添加的元素回溯出去</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==s.length())&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(list));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isBackString(s,start,i+<span class="number">1</span>))&#123;</span><br><span class="line">                list.add(s.substring(start,i+<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            backtracking(s,i+<span class="number">1</span>);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBackString</span><span class="params">(String s,<span class="type">int</span> start,<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        String str=s.substring(start,i);</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(str);</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> str.equals(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="93-复原IP地址"   >
          <a href="#93-复原IP地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h2>
      <p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>&#39;.&#39;</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code> &quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>&#39;.&#39;</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/" >Leetcode.93题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-6"   >
          <a href="#第一次做-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-6" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;14</p>

        <h4 id="第一次代码-6"   >
          <a href="#第一次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-6" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123; </span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==s.length())&#123;</span><br><span class="line">            <span class="keyword">for</span>(String str:path)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.length()!=<span class="number">1</span>&amp;&amp;str.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(str)&gt;<span class="number">255</span>) <span class="keyword">return</span> ;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==path.size()-<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sb.append(path.get(i));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(path.get(i)+<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sb.length()!=<span class="number">0</span>) result.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;s.length();i++)&#123;</span><br><span class="line">            path.add(s.substring(index,i+<span class="number">1</span>));</span><br><span class="line">            backtracking(s,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-10"   >
          <a href="#提交失败-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-10" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:java.lang.NumberFormatException: For input string: “5525511135”</p>

        <h4 id="第二次代码-5"   >
          <a href="#第二次代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-5" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123; </span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtracking(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index==s.length())&#123;</span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==path.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                    sb.append(path.get(i));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(path.get(i)+<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;s.length();i++)&#123;</span><br><span class="line">            path.add(s.substring(index,i+<span class="number">1</span>));</span><br><span class="line">            backtracking(s,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-11"   >
          <a href="#提交失败-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-11" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>没能做出来</p>

        <h3 id="题解-7"   >
          <a href="#题解-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：用一个sum来统计多少个逗号’.’，index代表分割线，然后分割出来的子串要符合条件的时候才会递归去搜索，然后最后用StringBuilder拼接结果集</p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量</p>
<ul>
<li><p>result：用于收获结果集</p>
</li>
<li><p>path:用于统计切割的字符串路径</p>
</li>
</ul>
</li>
<li><p>初始化，并且对s做一个初步的验证保证s只能有数字</p>
</li>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>返回值void：所有的结果都收获在结果集中</li>
<li>参数index：表示切割的字符位置</li>
<li>参数sum：表示已经切割过后有几个逗号</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li><p>当sum&#x3D;&#x3D;3说明已经切割了三次：则path中有三个字符串，而从index到s.length()-1为最后一个字符串</p>
<p>判断最后一个字符串是否符合要求，如果符合要求则需要收获结果集</p>
</li>
</ul>
</li>
<li><p>单层递归逻辑</p>
<ul>
<li><p>判断从index到i切割的字符串是否符合要求</p>
<ul>
<li><p>如果不符合要求则不需要继续回溯，继续遍历切割</p>
</li>
<li><p>如果符合要求则需要将切割子串添加到path数组中，并将sum+1，表示该位置已经切割出字符串了，然后递归去切割子串</p>
<p>递归结束之后回溯</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>验证要求合法性函数(isvalid)</p>
<ul>
<li>区间是左闭右闭，切割str&#x3D;s.substring(begin,end+1)</li>
<li>验证子串str是否为空或者为空串，如果是则不合法返回false</li>
<li>验证子串str是否长度超过4，如果是则不合法返回false</li>
<li>验证子串str是否长度不为1并且头字符是0，如果是则不合法，返回false</li>
<li>验证子串str转换成Integer类型之后数值是否大于255，如果是则不合法，返回false</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123; </span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">4</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="comment">//验证对IP地址是否有其他字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        backtracking(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s,<span class="type">int</span> index,<span class="type">int</span> sum)</span>&#123;</span><br><span class="line">        <span class="comment">//当sum==3说明切割了三次</span></span><br><span class="line">       <span class="keyword">if</span>(sum==<span class="number">3</span>)&#123;</span><br><span class="line">           <span class="comment">//验证第三个逗号之后的字符串是否合法，如果合法则收集结果集</span></span><br><span class="line">           <span class="keyword">if</span>(isvalid(s,index,s.length()-<span class="number">1</span>))&#123;</span><br><span class="line">               StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">               <span class="keyword">for</span>(String str:path)&#123;</span><br><span class="line">                   sb.append(str+<span class="string">&quot;.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               sb.append(s.substring(index,s.length()));</span><br><span class="line">               result.add(sb.toString());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;s.length();i++)&#123;</span><br><span class="line">          <span class="comment">//判断切割出来的第一个子串是否符合条件，如果是则才能继续递归</span></span><br><span class="line">          <span class="keyword">if</span>(isvalid(s,index,i))&#123;</span><br><span class="line">              path.add(s.substring(index,i+<span class="number">1</span>));</span><br><span class="line">              <span class="comment">//向i之后搜索，将逗号总数+1,递归之后会回溯</span></span><br><span class="line">              backtracking(s,i+<span class="number">1</span>,sum+<span class="number">1</span>);</span><br><span class="line">              path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//验证子串的合法性，方法是左闭右闭的子串区间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isvalid</span><span class="params">(String s,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">		</span><br><span class="line">        String str=s.substring(begin,end+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(str)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()!=<span class="number">1</span> &amp;&amp; str.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;=<span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(Integer.parseInt(str)&gt;<span class="number">255</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="子集"   >
          <a href="#子集" class="heading-link"><i class="fas fa-link"></i></a><a href="#子集" class="headerlink" title="子集"></a>子集</h1>
      
        <h2 id="78-子集"   >
          <a href="#78-子集" class="heading-link"><i class="fas fa-link"></i></a><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2>
      <p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p> <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/" >Leetcode.78题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-7"   >
          <a href="#第一次做-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-7" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;15</p>

        <h4 id="第一次代码-7"   >
          <a href="#第一次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-7" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-12"   >
          <a href="#提交失败-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-12" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:超过内存限制</p>
<p>原因是每次递归之后i还是0，导致死循环</p>

        <h4 id="第二次代码-6"   >
          <a href="#第二次代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-6" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-2"   >
          <a href="#提交成功-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-2" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-8"   >
          <a href="#题解-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3>
      <p>思想：我们这道题收获结果集和之前的问题不一样，之前的收获结果集都是在<strong>叶子结点</strong>收获，而这道题的结果在每个结点中，也即结果集在<strong>每个结点</strong>收获，具体可以看图解</p>
<p><strong>实现</strong></p>
<ul>
<li>定义全局变量<ul>
<li>result：用于收获结果集</li>
<li>path：用于存放单条路径</li>
</ul>
</li>
<li>递归函数的参数和返回值<ul>
<li>返回值void：所有结果都收获到结果集中</li>
<li>参数nums：要获取子集的数组</li>
<li>参数index：当前循环开始的搜索位置索引</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当index&gt;&#x3D;nums.length，也即收获到最后的元素就结束条件</li>
</ul>
</li>
<li>递归函数的单层逻辑<ul>
<li>收获结果(每个结点都是结果)</li>
<li>递归搜索剩下子集</li>
<li>回溯</li>
</ul>
</li>
</ul>
<p><em>这里可以没有递归结束条件，当搜索到最后的时候index&#x3D;nums.length就会结束递归</em></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="comment">//收获结果集</span></span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-4"   >
          <a href="#图解-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-4" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230915105009585.png"  alt="子集树形结构">
      </p>

        <h2 id="90-子集II"   >
          <a href="#90-子集II" class="heading-link"><i class="fas fa-link"></i></a><a href="#90-子集II" class="headerlink" title="90.子集II"></a>90.子集II</h2>
      <p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/" >Leetcode.90题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-8"   >
          <a href="#第一次做-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-8" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;16</p>

        <h4 id="第一次代码-8"   >
          <a href="#第一次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-8" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-13"   >
          <a href="#提交失败-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-13" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums &#x3D;[4,4,4,1,4]，输出[[],[4],[4,4],[4,4,4],[4,4,4,1],[4,4,4,1,4],[4,4,4,4],[4,4,1],[4,4,1,4],[4,4,4],[4,1],[4,1,4],[4,4],[1],[1,4],[4]]，预期输出：[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]</p>
<p>原因忘记排序，要对数组进行排序，将相同值放在一起，这样才好判断子集是否使用过这个元素</p>

        <h4 id="第二次代码-7"   >
          <a href="#第二次代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-7" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-3"   >
          <a href="#提交成功-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-3" class="headerlink" title="提交成功"></a>提交成功</h5>
      
        <h3 id="题解-9"   >
          <a href="#题解-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题就是78.子集问题以及40.组合总和II的一个结合，对每一个结点的结果都进行收获，对重复组合的一个去重操作</p>
<p><strong>实现</strong></p>
<ul>
<li>定义全局变量<ul>
<li>result: 收获结果集的集合</li>
<li>path：单条结果的路径</li>
</ul>
</li>
<li>递归函数的参数和返回值<ul>
<li>返回值void：所有结果递归时都收获在结果集中，所以没有返回值</li>
<li>参数nums:用于求得子集的数组</li>
<li>参数start：表示当前操作的索引下标</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当start&gt;&#x3D;nums.length;也即遍历到最后一个元素那么就该结束递归</li>
</ul>
</li>
<li>单层递归的逻辑<ul>
<li>收获结果，每一个结点都是一个结果</li>
<li>递归去获取子集<ul>
<li>树层方面的去重：当i&gt;start说明已经经过递归回溯之后，并且nums[i]&#x3D;&#x3D;nums[i-1]，也即这是层次方面的重复，所以直接跳过这个层结点</li>
</ul>
</li>
<li>回溯</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> 		<span class="comment">//对数组进行排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="comment">//收获结果</span></span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前元素和前一个元素相同并且是层次方面的重合，那么就要跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="排序"   >
          <a href="#排序" class="heading-link"><i class="fas fa-link"></i></a><a href="#排序" class="headerlink" title="排序"></a>排序</h1>
      
        <h2 id="46-全排列"   >
          <a href="#46-全排列" class="heading-link"><i class="fas fa-link"></i></a><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2>
      <p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/" >Leetcode.46题(medium)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-9"   >
          <a href="#第一次做-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-9" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;19</p>

        <h4 id="第一次代码-9"   >
          <a href="#第一次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-9" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    HashSet&lt;Integer&gt; set;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(set.contains(nums[j])) <span class="keyword">continue</span>;</span><br><span class="line">                backtracking(nums,j);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                set.remove(set.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-14"   >
          <a href="#提交失败-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-14" class="headerlink" title="提交失败"></a>提交失败</h5>
      
        <h3 id="题解-10"   >
          <a href="#题解-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和组合问题以及子集问题有所不同，因为排序问题主要讲究的是<strong>顺序</strong>，而不是元素。</p>
<blockquote>
<p> 当(1,2)两个元素只有(1,2)这个组合但是排序有(1,2),(2,1)这两个结果</p>
</blockquote>
<p>所以排序问题我们对数据的重复操作并不能通过startindex控制，我们可以引入一个set集合</p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量</p>
<ul>
<li>result：收获结果集合</li>
<li>path：单个结果的路径集合</li>
<li>set：用于防止重复数据的set集合</li>
</ul>
</li>
<li><p>递归函数的参数和返回值</p>
<ul>
<li>返回值void：所有结果都在结果集中，所以没有返回值</li>
<li>参数nums，用于获取全排列的数组</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当path.size()&#x3D;&#x3D;nums.length，也即叶子结点收获结果</p>
</li>
<li><p>单层递归的实现逻辑</p>
<ul>
<li>每次递归的循环开始都是从0开始，因为要遍历整个数组</li>
<li>当set包含当前元素则跳过</li>
<li>set不包含当前元素则添加到path以及set中，递归</li>
<li>回溯，回溯path集合也set集合</li>
</ul>
<p>循环代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果包含则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            backtracking(nums);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            set.remove(nums[i]);            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关键在于每次从0开始，以便对整个数组的全排列</span></span><br><span class="line"><span class="comment">//每次递归先判断当前元素是否被使用过，如果是则跳过</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    HashSet&lt;Integer&gt; set;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果包含则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            backtracking(nums);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            set.remove(nums[i]);            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="47-全排列II"   >
          <a href="#47-全排列II" class="heading-link"><i class="fas fa-link"></i></a><a href="#47-全排列II" class="headerlink" title="47.全排列II"></a>47.全排列II</h2>
      
        <h3 id="第一次做-10"   >
          <a href="#第一次做-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-10" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;20</p>

        <h4 id="第一次代码-10"   >
          <a href="#第一次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-10" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    HashSet&lt;Integer&gt; hashSet;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=nums.length) <span class="keyword">return</span>;</span><br><span class="line">        HashSet set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; hashSet.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(path.size()!=<span class="number">0</span> &amp;&amp; nums[i]&lt;path.get(path.size()-<span class="number">1</span>) || set.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            hashSet.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            hashSet.remove(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-15"   >
          <a href="#提交失败-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-15" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:nums[1,1,2],输出[1,1,2]，预期输出[[1,1,2],[1,2,1],[2,1,1]]</p>

        <h4 id="第二次代码-8"   >
          <a href="#第二次代码-8" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-8" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    HashSet&lt;Integer&gt; hashSet;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            hashSet.add(i);</span><br><span class="line">            backtracking(nums);</span><br><span class="line">            hashSet.remove(i);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-4"   >
          <a href="#提交成功-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-4" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>hashset来判断是否索引下标被用过(类似于Used数组)，set用来判断当前元素是否层次上的重复</p>

        <h3 id="题解-11"   >
          <a href="#题解-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3>
      <p>这道题和46.全排列相似，不同点在于数组中是有重复的元素的，所以我们要对数组的相同元素进行一个去重的一个操作，将收获结果中没有层次上的重复</p>
<p>思路：我们用两个set来对数据的一个去重，第一个去重层次方面上的去重，当数组不能相同元素获取，第二个是深度上面的去重</p>
<p><strong>实现</strong>：</p>
<ul>
<li>定义全局变量<ul>
<li>result：用于收获结果集</li>
<li>path：用于单层路径上的获取</li>
<li>hashset：用于深度上的去重，用索引i作为深度上的重复判断</li>
</ul>
</li>
<li>将nums进行排序，相同值的元素可以排在一起，主要用于对层次方面的处理</li>
<li>递归函数的参数和返回值<ul>
<li>返回值void：所有的结果都在result结果集中，所以没有额外的返回值</li>
<li>参数nums：用于需要获取全排列的参数</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当path.size()&#x3D;&#x3D;nums.length，也就是获取了一个全排列则需要添加结果到结果集中，然后结束</li>
</ul>
</li>
<li>递归函数的单层逻辑<ul>
<li>定义一个变量Hashset<Integer> set：用于层次方面上的去重</li>
<li>循环，获取全排列<ul>
<li>每次排列从0开始</li>
<li>判断set中是否有nums[i]，如果包含说明这是经过回溯之后的，然后出现了相同大小元素(层次相同)</li>
<li>判断hashset中是否包含i，如果包含说明在前面已经用过i索引下标的元素，所以不能重复获取，于是要continue</li>
<li>path添加nums[i],set添加num[i],hashset添加i</li>
<li>递归</li>
<li>回溯，回溯hashset和path</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">   	<span class="comment">//用于深度上面的去重</span></span><br><span class="line">    HashSet&lt;Integer&gt; hashSet;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hashSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==nums.length)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//set数组是用于层次上的去重</span></span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(hashSet.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            hashSet.add(i);</span><br><span class="line">            backtracking(nums);</span><br><span class="line">            <span class="comment">//hashset回溯</span></span><br><span class="line">            hashSet.remove(i);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="棋盘问题"   >
          <a href="#棋盘问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#棋盘问题" class="headerlink" title="棋盘问题"></a>棋盘问题</h1>
      
        <h2 id="51-N皇后"   >
          <a href="#51-N皇后" class="heading-link"><i class="fas fa-link"></i></a><a href="#51-N皇后" class="headerlink" title="51.N皇后"></a>51.N皇后</h2>
      <p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/description/" >Leetcode.51题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-11"   >
          <a href="#第一次做-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-11" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;24</p>

        <h4 id="第一次代码-11"   >
          <a href="#第一次代码-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-11" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       backtracking(<span class="number">0</span>,n);        </span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==n)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//初始化数组</span></span><br><span class="line">        <span class="type">char</span>[] arr=<span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            arr[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//循环获取路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//如果path中无字符串</span></span><br><span class="line">            <span class="keyword">if</span>(path.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                arr[i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="comment">//拼接char[] 数组</span></span><br><span class="line">                StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                &#125;</span><br><span class="line">                path.add(sb.toString());</span><br><span class="line">                <span class="comment">//递归搜索</span></span><br><span class="line">                backtracking(start+<span class="number">1</span>,n);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                arr[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果path中有字符，判断i是否符合要求</span></span><br><span class="line">                <span class="comment">//默认flag为false</span></span><br><span class="line">                <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//从path中获取每一个字符串</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;path.size();j++)&#123;</span><br><span class="line">                    <span class="comment">//获取gap也即i的规矩，当Q的同一列和斜角都不符合要求</span></span><br><span class="line">                    <span class="type">int</span> gap=start-j;</span><br><span class="line">                    <span class="type">char</span>[] pre=path.get(j).toCharArray();</span><br><span class="line">                    <span class="comment">//获取Q的字符下标</span></span><br><span class="line">                    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(;k&lt;pre.length;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(pre[k]==<span class="string">&#x27;Q&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果i==k+gap || i==k ||i==k-gap  也即同一列，右斜线，左斜线</span></span><br><span class="line">                    <span class="keyword">if</span>(i==k+gap||i==k||i==k-gap)&#123;</span><br><span class="line">                        flag=<span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                	<span class="comment">//如果flag==true，也即不符合要求</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                	<span class="comment">//符合要求添加到path中</span></span><br><span class="line">                    arr[i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                    StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> c:arr)&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    path.add(sb.toString());</span><br><span class="line">                    backtracking(start+<span class="number">1</span>,n);</span><br><span class="line">                    path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                    arr[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="题解-12"   >
          <a href="#题解-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：我们每一层都用Char[]数组来表示，然后检验皇后合法性的时候用char[]来判断，这道题重要的是在<strong>检验皇后合法性</strong></p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量</p>
<ul>
<li>result：用于收获结果集</li>
<li>path：用于单次棋盘搜索结果</li>
</ul>
</li>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>返回值void：所有结果都在result中</li>
<li>参数row：判断现在要在path操作第几行，也即棋盘的第几行</li>
<li>参数n：判断总的棋盘是n*n的</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li>当row&#x3D;&#x3D;n，也即操作n行都操作过，说明收获结果集</li>
</ul>
</li>
<li><p>递归函数的单层逻辑</p>
<ul>
<li>创建char[] line，用于记录每一行的元素，初始化都为’.’</li>
<li>循环，每次从0开始，遍历n次<ul>
<li>检验当前位置i是否符合n皇后的题意：<strong>不能在同一行、不能在同一列、不能在同一斜线</strong></li>
<li>如果符合题意则递归搜索下一个结果集</li>
</ul>
</li>
<li>回溯</li>
</ul>
</li>
<li><p>检验位置i是否符合N皇后要求的函数valid：</p>
<ul>
<li>当path为空则返回true：也即第一行都符合要求</li>
<li>当path不为空：<ul>
<li>循环i遍历path，获取path中已经符合要求的行</li>
<li>获取当前层与path中行的距离：<strong>int gap&#x3D;row-i</strong>；</li>
<li>找到path.get(i)中的n皇后位置：int k；</li>
<li>判断k与当前格子数index以及行数的距离gap之间的关系，只要存在以下任意关系都返回false<ul>
<li><strong>当index&#x3D;&#x3D;k，也即在已经存在的某一行的皇后同一列</strong></li>
<li><strong>当index&#x3D;&#x3D;k+gap，也即在已经存在的某一行的右下斜线</strong></li>
<li><strong>当index&#x3D;&#x3D;k-gap，也即在已经存在的某一行的左下斜线</strong></li>
</ul>
</li>
<li>如果循环到最后，则返回true，说明当前位置index符合要求</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> row,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==n)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] line=<span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;line.length;i++) line[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(i,n,row))&#123;</span><br><span class="line">                StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                line[i]=<span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c: line) sb.append(c);</span><br><span class="line">                path.add(sb.toString());</span><br><span class="line">                backtracking(row+<span class="number">1</span>,n);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                line[i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> n,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">            <span class="comment">//gap用于标记当前层到搜索path层的数</span></span><br><span class="line">            <span class="type">int</span> gap=row-i;</span><br><span class="line">            <span class="type">char</span>[] pathStr=path.get(i).toCharArray();</span><br><span class="line">           	<span class="comment">//找到这层皇后位置</span></span><br><span class="line">            <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;k&lt;pathStr.length;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pathStr[k]==<span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检验当前位置放皇后是否符合标准</span></span><br><span class="line">            <span class="keyword">if</span>(k==index || k==index-gap || k==index+gap) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="图解-5"   >
          <a href="#图解-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-5" class="headerlink" title="图解"></a>图解</h3>
      <p>检验当前位置index，与k，与row的关系图解</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230925093903694.png"  alt="检验当前位置index，与k，与row的关系图解">
      </p>

        <h2 id="37-解数独"   >
          <a href="#37-解数独" class="heading-link"><i class="fas fa-link"></i></a><a href="#37-解数独" class="headerlink" title="37.解数独"></a>37.解数独</h2>
      <p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/" >Leetcode.37题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-12"   >
          <a href="#第一次做-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-12" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;26</p>

        <h4 id="第一次代码-12"   >
          <a href="#第一次代码-12" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-12" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;HashSet&lt;Character&gt;&gt; xList;</span><br><span class="line">    List&lt;HashSet&lt;Character&gt;&gt; yList;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        xList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        yList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;board.length;x++)&#123;</span><br><span class="line">            <span class="type">char</span>[] arr=board[x];</span><br><span class="line">            HashSet&lt;Character&gt; xSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;arr.length;y++)&#123;</span><br><span class="line">                xSet.add(arr[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            xList.add(xSet);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            HashSet&lt;Character&gt; ySet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board.length;j++)&#123;</span><br><span class="line">                ySet.add(board[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            yList.add(ySet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        backtracking(board,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==board.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(valid(i,row))&#123;</span><br><span class="line">                board[row][i]=(<span class="type">char</span>) (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                xList.get(row).add((<span class="type">char</span>)(i-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                yList.get(i).add((<span class="type">char</span>)(i-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                backtracking(board,row+<span class="number">1</span>);</span><br><span class="line">                xList.get(row).remove((<span class="type">char</span>)(i-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                yList.get(i).remove((<span class="type">char</span>)(i-<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">                board[row][i]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="type">char</span> num=(<span class="type">char</span>) (i-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(xList.get(row).contains(num)||yList.get(i).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span> &amp;&amp; row&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">3</span> &amp;&amp; i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">3</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">6</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(row&gt;=<span class="number">3</span> &amp;&amp; row&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">3</span> &amp;&amp; i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">3</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">6</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=<span class="number">3</span> &amp;&amp; i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">3</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">6</span>;j&lt;=<span class="number">8</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(xList.get(j).contains(num)||yList.get(j).contains(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-16"   >
          <a href="#提交失败-16" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-16" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:</p>
<p>输入board &#x3D;</p>
<p>[[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]</p>
<p>输出</p>
<p>[[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]</p>
<p>预期输出</p>
<p>[[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]</p>
<p>没做出来</p>

        <h3 id="题解-13"   >
          <a href="#题解-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题和N皇后的问题的题解的过程，这个不仅仅只是填一个数而是要将棋盘填满，所以这个循环应该是两个循环嵌套，这道题还有对棋盘数独落子的校验，满足行不同数字，列不同数字，同时九宫格内也不能有重复数字</p>
<p><strong>实现</strong></p>
<ul>
<li>递归函数的参数和返回值<ul>
<li>参数board：棋盘，需要填满的数独棋盘</li>
<li>返回值boolean：如果找到一个填满的棋盘就可以返回，而不需要继续搜索</li>
</ul>
</li>
<li>递归函数的结束条件<ul>
<li>当棋盘被填满也即两层for循环结束之后没有返回false，说明找到一个被填满的棋盘</li>
</ul>
</li>
<li>递归函数的单层逻辑<ul>
<li>第一层for循环，遍历行，从第一行到最后一行（0~board.length)<ul>
<li>第二层for循环，遍历列，从第一列到最后一列(0~board.length)<ul>
<li>判断当前（i，j）是否是空字符串，也即如果有数字则continue<ul>
<li>第三层for循环，遍历1-9尝试填进当前(i，j)位置<ul>
<li>如果当前位置符合要求，则填进数字</li>
<li>递归搜索下一个数字</li>
<li>回溯</li>
</ul>
</li>
<li>如果1-9都失败了，则返回false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>如果两层循环结束还没有返回返回false，说明已经落满数字返回true</li>
</ul>
</li>
<li>校验数字是否符合要求<ul>
<li>需要行中不能有重复数字</li>
<li>需要列中不能有重复数字</li>
<li>需要在九宫格中不能有重复数字<ul>
<li>解决行中重复数字<ul>
<li>遍历当前行的0-9列，如果board(row)(j)&#x3D;&#x3D;val，返回false</li>
</ul>
</li>
<li>解决列中不能有重复数字<ul>
<li>遍历当前列的0-9行，如果board(i)(col)&#x3D;&#x3D;val，返回false</li>
</ul>
</li>
<li>解决九宫格中重复数字<ul>
<li>获取当前在九宫格的启示位置<ul>
<li>int startX&#x3D; (row&#x2F;3) *3;</li>
<li>int startY&#x3D;(col&#x2F;3) *3;</li>
<li>所以（startX，startY）就是当前九宫格第一个元素位置</li>
<li>第一层for循环从startX到startX+3<ul>
<li>第二层for循环从startY到startY+3<ul>
<li>if(board(m,n)&#x3D;&#x3D;val) return false，说明九宫格内有相同的数字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        backtracking(board);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> row=<span class="number">0</span>;row&lt;board.length;row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> col=<span class="number">0</span>;col&lt;board.length;col++)&#123;</span><br><span class="line">                <span class="comment">//如果是空格字符</span></span><br><span class="line">                <span class="keyword">if</span>(board[row][col]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">char</span> j=<span class="string">&#x27;1&#x27;</span>;j&lt;=<span class="string">&#x27;9&#x27;</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(valid(board,row,col,j))&#123;</span><br><span class="line">                            board[row][col]=j;</span><br><span class="line">                            <span class="comment">//如果找到第一个子结果则返回</span></span><br><span class="line">                            <span class="keyword">if</span>(backtracking(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            board[row][col]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//说明1-9都不合适返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明循环结束，把棋盘都填满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">char</span>[][] board,<span class="type">int</span> row, <span class="type">int</span> col ,<span class="type">char</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//同一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==board[row][i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//同一列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==board[i][col]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//求得九宫格</span></span><br><span class="line">        <span class="type">int</span> startX=(row/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> startY=(col/<span class="number">3</span>)*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=startX;i&lt;startX+<span class="number">3</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=startY;k&lt;startY+<span class="number">3</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==board[i][k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="其他"   >
          <a href="#其他" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他" class="headerlink" title="其他"></a>其他</h1>
      
        <h2 id="491-递增子序列"   >
          <a href="#491-递增子序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#491-递增子序列" class="headerlink" title="491.递增子序列"></a>491.递增子序列</h2>
      <p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/" >Leetcode.491(题)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-13"   >
          <a href="#第一次做-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-13" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;18</p>

        <h4 id="第一次代码-13"   >
          <a href="#第一次代码-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-13" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> MIN;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        MIN=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==start &amp;&amp; nums[i]&gt;=MIN)&#123;</span><br><span class="line">                MIN=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;MIN)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-17"   >
          <a href="#提交失败-17" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-17" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: nums&#x3D;[4,6,7,7] 输出[[4,6],[4,6,7],[4,6,7,7],[4,6,7],[4,7],[4,7,7],[4,7],[7,7]]，预期输出[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</p>

        <h4 id="第二次代码-9"   >
          <a href="#第二次代码-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-9" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] used;</span><br><span class="line">    <span class="type">int</span> MIN;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        MIN=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==start &amp;&amp; nums[i]&gt;=MIN)&#123;</span><br><span class="line">                MIN=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;MIN)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;start&amp;&amp;used[<span class="number">100</span>+nums[i]]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used[<span class="number">100</span>+nums[i]]=<span class="number">1</span>;</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                MIN=nums[i];</span><br><span class="line">                used[<span class="number">100</span>+nums[i]]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-18"   >
          <a href="#提交失败-18" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-18" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: nums&#x3D;[4,6,7,7] 输出[[4,6],[4,6,7],[4,6,7,7] 预期输出[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</p>

        <h4 id="第三次代码-1"   >
          <a href="#第三次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-1" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt; used;</span><br><span class="line">    <span class="type">int</span> min=Integer.MAX_VALUE+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;=min)&#123;</span><br><span class="line">                min=nums[i];</span><br><span class="line">                <span class="keyword">if</span>(i&gt;start &amp;&amp; used.containsKey(nums[i]) &amp;&amp;used.get(nums[i])==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                used.put(nums[i],used.getOrDefault(nums[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                used.put(nums[i],used.getOrDefault(nums[i],<span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                min=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-19"   >
          <a href="#提交失败-19" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-19" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE: nums&#x3D;[4,6,7,7] 输出[[4,6],[4,6,7],[4,6,7,7] 预期输出[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]</p>
<p>这道题在去重没能写出来</p>

        <h3 id="题解-14"   >
          <a href="#题解-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3>
      <p>思想，这道题和组合总和II和子集II有相似之处又有不同之处</p>
<ul>
<li>相似：这道题同组合总和II一样，需要对数据去重，也是层次上的去重而非深度上的去重，同子集II一样对收获结果是在满足条件的结点，而不是全在叶子结点上收获，同时函数的结束条件也在循环判断中的结束条件一般</li>
<li>不同：这道题不能对数组进行排列，不然会对受过结果集造成影响</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量</p>
<ul>
<li>result:用于收获结果集集合</li>
<li>path：用于记录单个结果路径</li>
</ul>
</li>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>返回值void：所有的结果都保存在result集合中，所以不需要返回值</li>
<li>参数nums：用于求得子序列的数组</li>
<li>参数start，表示此时操作的位置索引下标</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<p>当start&gt;&#x3D;nums.length,也即操作到数组的最后位置(最后一个元素之后)，也即完成了本次深度上的搜索</p>
<p><del>(可以不用写结束条件，因为单层递归的时候的for循环结束条件也就是递归函数的结束条件)</del></p>
</li>
<li><p>函数的单层逻辑</p>
<ul>
<li><p>声明一个set集合，用于表示已经遍历过的元素，对相同数据的<strong>去重</strong>需要</p>
</li>
<li><p>对数据进行判断是否能添加到path路径中</p>
<ul>
<li><p>当path.size()!&#x3D;0 &amp;&amp; nums[i]小于path集合中最后一个元素(path集合是一个非递减集合)</p>
<p>也即当现在元素小于路径中最后一个元素则continue跳过</p>
</li>
<li><p>当set.contains(nums[i])&#x3D;&#x3D;true，也即这个元素已经收获过(层次上的重复)，则continue跳过</p>
<blockquote>
<p>因为Set是每层中定义的一个去重集合，深度搜索的时候不会对重复元素判断，而只有层次相同的情况下并且已经收获到结果集中的元素才需要跳过</p>
</blockquote>
</li>
</ul>
</li>
<li><p>添加到path路径和set去重集合中</p>
</li>
<li><p>递归遍历搜索下一个路径</p>
</li>
<li><p>回溯(只需要回溯path集合不用回溯set去重集合【set集合是每层new出来的，不需要对其去重】)</p>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(path.size()!=<span class="number">0</span>&amp;&amp; nums[i]&lt;path.get(path.size()-<span class="number">1</span>) || set.contains(nums[i])) <span class="keyword">continue</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">            backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="图解-6"   >
          <a href="#图解-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#图解-6" class="headerlink" title="图解"></a>图解</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230918174610627.png"  alt="递增子序列">
      </p>

        <h2 id="332-重新安排行程"   >
          <a href="#332-重新安排行程" class="heading-link"><i class="fas fa-link"></i></a><a href="#332-重新安排行程" class="headerlink" title="332.重新安排行程"></a>332.重新安排行程</h2>
      <p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/" >Leetcode.332题(hard)</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="第一次做-14"   >
          <a href="#第一次做-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次做-14" class="headerlink" title="第一次做"></a>第一次做</h3>
      <p>第一次做于23&#x2F;09&#x2F;22</p>

        <h4 id="第一次代码-14"   >
          <a href="#第一次代码-14" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一次代码-14" class="headerlink" title="第一次代码"></a>第一次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    HashSet&lt;List&lt;String&gt;&gt; used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(tickets);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(used.size()==tickets.size())&#123;</span><br><span class="line">            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tickets.size();i++)&#123;</span><br><span class="line">            List&lt;String&gt; ticket=tickets.get(i);</span><br><span class="line">            <span class="keyword">if</span>(used.contains(ticket)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(path.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(<span class="string">&quot;JFK&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">0</span>));</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                backtracking(tickets);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                used.remove(ticket);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(path.get(path.size()-<span class="number">1</span>)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                backtracking(tickets);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                used.remove(ticket);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交错误-1"   >
          <a href="#提交错误-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交错误-1" class="headerlink" title="提交错误"></a>提交错误</h5>
      <p>CASE:tickets &#x3D;[[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]，输出[“JFK”,”ATL”,”SFO”,”ATL”,”JFK”,”SFO”]，预期输出[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]</p>
<p>这并不是字典拍戏的最短行程</p>

        <h4 id="第二次代码-10"   >
          <a href="#第二次代码-10" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二次代码-10" class="headerlink" title="第二次代码"></a>第二次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    HashSet&lt;List&lt;String&gt;&gt; used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(tickets);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(used.size()==tickets.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used.size() == tickets.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                String oldStr=result.get(i);</span><br><span class="line">                String newStr=path.get(i);</span><br><span class="line">                <span class="keyword">if</span>(oldStr.equals(newStr)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(oldStr.length()-newStr.length()&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(oldStr.length()-newStr.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(path);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">char</span> oldChar=oldStr.charAt(j);</span><br><span class="line">                        <span class="type">char</span> newChar=newStr.charAt(j);</span><br><span class="line">                        <span class="keyword">if</span>(oldChar-newChar&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(oldChar-newChar&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            j++;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tickets.size();i++)&#123;</span><br><span class="line">            List&lt;String&gt; ticket=tickets.get(i);</span><br><span class="line">            <span class="keyword">if</span>(used.contains(ticket)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(path.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(<span class="string">&quot;JFK&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">0</span>));</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                backtracking(tickets);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                used.remove(ticket);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(path.get(path.size()-<span class="number">1</span>)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                backtracking(tickets);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                used.remove(ticket);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-20"   >
          <a href="#提交失败-20" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-20" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>CASE:tickets&#x3D;[[“EZE”,”AXA”],[“TIA”,”ANU”],[“ANU”,”JFK”],[“JFK”,”ANU”],[“ANU”,”EZE”],[“TIA”,”ANU”],[“AXA”,”TIA”],[“TIA”,”JFK”],[“ANU”,”TIA”],[“JFK”,”TIA”]]，输出[]，预期输出[“JFK”,”ANU”,”EZE”,”AXA”,”TIA”,”ANU”,”JFK”,”TIA”,”ANU”,”TIA”,”JFK”]</p>

        <h4 id="第三次代码-2"   >
          <a href="#第三次代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三次代码-2" class="headerlink" title="第三次代码"></a>第三次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    HashSet&lt;Integer&gt; hashTable;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hashTable=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(tickets);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==tickets.size()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                String oldStr=result.get(i);</span><br><span class="line">                String newStr=path.get(i);</span><br><span class="line">                <span class="keyword">if</span>(oldStr.equals(newStr)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(oldStr.length()-newStr.length()&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(oldStr.length()-newStr.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>(path);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">char</span> oldChar=oldStr.charAt(j);</span><br><span class="line">                        <span class="type">char</span> newChar=newStr.charAt(j);</span><br><span class="line">                        <span class="keyword">if</span>(oldChar-newChar&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(oldChar-newChar&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            j++;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;List&lt;String&gt;&gt; used= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tickets.size();i++)&#123;</span><br><span class="line">            List&lt;String&gt; ticket=tickets.get(i);</span><br><span class="line">            <span class="keyword">if</span>(hashTable.contains(i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(used.contains(ticket)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(path.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(<span class="string">&quot;JFK&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">0</span>));</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                hashTable.add(i);</span><br><span class="line">                backtracking(tickets);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                hashTable.remove(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(path.get(path.size()-<span class="number">1</span>)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                hashTable.add(i);</span><br><span class="line">                backtracking(tickets);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                hashTable.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交失败-21"   >
          <a href="#提交失败-21" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交失败-21" class="headerlink" title="提交失败"></a>提交失败</h5>
      <p>超出时间限制</p>
<p>要对数据进行剪枝</p>

        <h4 id="第四次代码-1"   >
          <a href="#第四次代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四次代码-1" class="headerlink" title="第四次代码"></a>第四次代码</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result;</span><br><span class="line">    List&lt;String&gt; path;</span><br><span class="line">    HashSet&lt;Integer&gt; hashTable;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hashTable=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        path=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.sort(tickets,(a,b)-&gt;a.get(<span class="number">1</span>).compareTo(b.get(<span class="number">1</span>)));</span><br><span class="line">        backtracking(tickets);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size()==tickets.size()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;path.size();i++)&#123;</span><br><span class="line">                String oldStr=result.get(i);</span><br><span class="line">                String newStr=path.get(i);</span><br><span class="line">                <span class="keyword">if</span>(oldStr.equals(newStr)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                    </span><br><span class="line">                        <span class="type">char</span> oldChar=oldStr.charAt(j);</span><br><span class="line">                        <span class="type">char</span> newChar=newStr.charAt(j);</span><br><span class="line">                        <span class="keyword">if</span>(oldChar-newChar&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(oldChar-newChar&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                            result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path);</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            j++;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;List&lt;String&gt;&gt; used= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tickets.size();i++)&#123;</span><br><span class="line">            List&lt;String&gt; ticket=tickets.get(i);</span><br><span class="line">            <span class="keyword">if</span>(hashTable.contains(i)|| used.contains(ticket)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(path.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(<span class="string">&quot;JFK&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">0</span>));</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                hashTable.add(i);</span><br><span class="line">                <span class="keyword">if</span>(backtracking(tickets)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                hashTable.remove(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(path.get(path.size()-<span class="number">1</span>)))<span class="keyword">continue</span>;</span><br><span class="line">                path.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">                used.add(ticket);</span><br><span class="line">                hashTable.add(i);</span><br><span class="line">                <span class="keyword">if</span>(backtracking(tickets))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">                hashTable.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="提交成功-5"   >
          <a href="#提交成功-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#提交成功-5" class="headerlink" title="提交成功"></a>提交成功</h5>
      <p>关键在于对原机票进行排序，然后我们只要获取第一个最小路径的结果就可以结束</p>

        <h3 id="题解-15"   >
          <a href="#题解-15" class="heading-link"><i class="fas fa-link"></i></a><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3>
      <p>思路：这道题是综合性很强的一道题，不仅要对层次方面去重，还要求得排序问题，并且这道题与之前做的题有很大不同的点就在于如何做一个剪枝的操作，这道题可以在递归的时候获取到最小路径之后结束递归做剪枝</p>
<p><strong>实现</strong></p>
<ul>
<li><p>定义全局变量</p>
<ul>
<li>result：存放的是路径(最小路径)</li>
<li>used：存放的是已经使用过的索引下标，用于深度上的排序去重</li>
</ul>
</li>
<li><p>初始化数据</p>
<ul>
<li>创建result和used对象</li>
<li><strong>对tickets进行排序</strong>：这一步相当重要，在提前排序好之后，我们结果集收获到的第一个结果就是最短路径，之后就可以不再收集！</li>
<li>对result数组添加初始化值:“JFK”，这是机场的起始位置，也可以不初始化只是要在第一张机票的时候添加起飞机场和目的机场两个，在这里只是为了后面添加结果的时候<strong>只需要添加目的机场</strong>即可。</li>
</ul>
</li>
<li><p>递归函数的返回值和参数</p>
<ul>
<li>返回值boolean：当找到最短路径为true，当没有找到最短路径为false</li>
</ul>
<blockquote>
<p>返回true之后之后递归可以不用进行了，这一步会在代码体现</p>
</blockquote>
<ul>
<li>参数tickets，总的机票集合</li>
</ul>
</li>
<li><p>递归函数的结束条件</p>
<ul>
<li>当result.size()&#x3D;&#x3D;tickets.size()+1,说明收获到一个结果集，此第一个结果集就是<strong>最短路径，返回true为了让所有递归结束</strong></li>
</ul>
</li>
<li><p>递归函数的单层逻辑</p>
<ul>
<li><p>定义一个set集合，用于层次上的去重</p>
</li>
<li><p>循环每次从0开始</p>
<ul>
<li><p>当used包含索引i，说明这个元素在深度上重复选择，continue</p>
</li>
<li><p>当set包含ticket，说明层次上这个元素重复，continue</p>
</li>
<li><p>也即!used.contains（i）&amp;&amp;!set.contains(ticket) 说明这个机票没被用过</p>
<ul>
<li>如果result.size()&#x3D;&#x3D;1，说明是刚起飞，判断当前机票ticket是否起始站为”JFK”，如果不是则continue</li>
<li>如果result.size()！&#x3D;1，判断当前机票ticket是否起始站和result中最后一个元素相等，如果不相等则continue</li>
<li>result添加目的站</li>
<li>used添加索引i，set添加当前机票</li>
<li>进行递归<ul>
<li>if(backtracking(tickets)){ return true},如果递归中返回true就不需要继续搜索了</li>
</ul>
</li>
<li>回溯</li>
</ul>
</li>
<li><p>当循环遍历到最后位置则返回false</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result; <span class="comment">//结果集</span></span><br><span class="line">    HashSet&lt;Integer&gt; used; <span class="comment">//索引i的深度去重</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">        result=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        used=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对机票排序（由小到大）为的是最短路径</span></span><br><span class="line">        Collections.sort(tickets,(a,b)-&gt;a.get(<span class="number">1</span>).compareTo(b.get(<span class="number">1</span>)));</span><br><span class="line">        <span class="comment">//初始化result集合</span></span><br><span class="line">        result.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">        backtracking(tickets);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.size()==tickets.size()+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//set用于层次上的去重</span></span><br><span class="line">        HashSet&lt;List&lt;String&gt;&gt; set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tickets.size();i++)&#123;</span><br><span class="line">            <span class="comment">//获取当前机票</span></span><br><span class="line">            List&lt;String&gt; ticket=tickets.get(i);</span><br><span class="line">           	<span class="comment">//如果i包含于used中或者ticket机票包含于set中说明重复</span></span><br><span class="line">            <span class="keyword">if</span>(used.contains(i) || set.contains(ticket)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(result.size()==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//当result.size()==1说明为起飞站，判断当前机票是否起始站是&quot;JFK&quot;，如果不是则continue</span></span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(<span class="string">&quot;JFK&quot;</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//判断机票的起始站和result的最后一站是否相同，不相同则continue</span></span><br><span class="line">                <span class="keyword">if</span>(!ticket.get(<span class="number">0</span>).equals(result.get(result.size()-<span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(ticket.get(<span class="number">1</span>));</span><br><span class="line">            used.add(i);</span><br><span class="line">            set.add(ticket);</span><br><span class="line">            <span class="comment">//递归去获取返回值，如果返回true就说明收获到最短路径，可以不要再搜索了，进行剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(backtracking(tickets))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            result.remove(result.size()-<span class="number">1</span>);</span><br><span class="line">            used.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>回溯法主要就是一个<strong>暴力搜索法</strong>，当需要多次for循环遍历元素，然后搜索最终的结果，就可以从回溯法开始出发</p>
<p>下一个算法将进入贪心算法部分</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">47</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>KkkerAn</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>