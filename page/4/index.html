<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Kkker1&#39;s Blog">
<meta property="og:url" content="https://username.github.io/page/4/index.html">
<meta property="og:site_name" content="Kkker1&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kkker1">
<meta name="twitter:card" content="summary"><title>Kkker1's Blog</title><link ref="canonical" href="https://username.github.io/page/4/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/19/%E6%9F%90%E5%A4%A7%E5%8E%82%E7%9A%84%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BA%BF%E4%B8%8B%E9%9D%A2%E8%AF%95/">某大厂的实习生线下面试</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>一开始约的是两点面试，然后我是一点半就到了，搞来搞去变得直接上去在别人办公室里，等上一个哥们面试结束，然后直接就开始了。</p>
<h2 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><p>1.简单介绍一下自己的家庭情况和学校的实习、学习情况，主修的课程、技能等</p>
<p>2.看你简历上有一个仿今日头条的项目?是出于什么目的进行开发的呢？</p>
<p>3.项目是几个人组成的小组?每个人的成员构成和职责是什么样的？</p>
<p>4.你负责的是哪个角色？</p>
<p>5.你应该也有在网上学习java，能说一下你在互联网是通过什么渠道学习的呢？</p>
<p>6.你了解前端开发吗？</p>
<p>7.有了解过集合吗？看过底层源码吗？</p>
<p>8.ArrayList底层是怎么进行创建和扩容的呢？</p>
<p>9.集合是怎么处理哈希碰撞的？</p>
<p>10.有了解过锁吗?Lock和Sychorized那些</p>
<p>11.final修饰符有学习过吗？它有什么使用场景</p>
<p>12.final修饰方法会怎么样？final修饰类会怎么样?</p>
<p>13.Integer和int能直接进行比较吗？</p>
<p>14.Integer底层有一个缓冲数组，在这个缓冲数组边界能直接使用吗？</p>
<p>15.&#x3D;&#x3D;和equals方法的区别</p>
<p>16.有了解过Volatile关键字吗？</p>
<p>17.说说SpringMVC的执行流程</p>
<p>18.说说你对Vue和H5的理解</p>
<p>19.V-show和V-if的使用场景</p>
<p>20.有了解过垃圾回收机制吗？</p>
<p>21.jdk1.8之后默认的GC是哪个？</p>
<p>22.有了解过主流的数据库吗？</p>
<p>23.说说你对Mysql优化的理解</p>
<p>24.有了解过范式和反范式吗？</p>
<p>25.你在项目中有使用过Redis，能说说你基于什么情况考虑使用的Redis呢?</p>
<p>26.Redis常用的数据类型有哪些？</p>
<p>27.你在Redis的环境下有没有开发部署过项目</p>

        <h2 id="-1"   >
          <a href="#-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#-1" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2>
      <p>技术面部分结束了，然后hr问我有没有想对公司了解的情况</p>
<p>我当时问的是1.实习的时间段，是否支持转正</p>
<p>​						2.上班工作的时间段</p>
<p>然后这个时候技术面试官追问了一条能不能接收996的情况</p>
<p>总结和复盘：</p>
<p>首先，我要感谢这个公司能给我一个这个时间段的一个技术线下面试，在目前我所在的阶段，这个机会是千载难逢的，这是不可否认的。</p>
<p>其次，我因为是第一次线下面试，经过这个技术面才能知道学习到的东西和当时在小房子里面能想起来的东西真的差距很大。</p>
<p>我进去脑子一片空白，和技术面试官大眼瞪小眼，你看着我我看着你，然后他问的东西有些其实我都知道也系统学习过看过源码，但是在当时的环境下，我脑子里面什么都不知道，所有的都是基于平常的理解再一点点一点点的复述出来。</p>
<p>第三，因为第一个问题就把我问爆了有点，我自己答得不对，甚至有可能是全错，这个面试官眉头一皱，我就知道这次其实噶了，但是万幸的是在这个时间段失败是可以接受的事，因为只有经过这次面试，我才知道在日常学习和真的面试中你能脑子里想出来的东西是不一样的，我得加强对面试情况的测试。</p>
<p>真得重新准备准备下EE的内容，因为基础有点忘记了搞得答出来很没有底气，我都不知道是对是错，等校招的时候好好发挥一下，在这个时间段就应该多投实习面试，去多尝试面试，锻炼面试经验</p>
<p>可以说很多准备的东西都没有问到，问到的都是偏向基础和底层，而这块确实是我现在目前尚未发现的问题。</p>
<p>输一场也不一定是坏事，是吧</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/19/JavaSE%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%90%E6%BA%90%E7%A0%81%E7%AF%87%E3%80%91/">JavaSE基础-并发编程【源码篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">0</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/15/JavaSE%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E3%80%90%E6%BA%90%E7%A0%81%E7%AF%87%E3%80%91/">JavaSE基础-集合【源码篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">19.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">165分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="集合"   >
          <a href="#集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合" class="headerlink" title="集合"></a>集合</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集合与数组的区别：1.集合的长度可变，而数组的长度不可变</span><br><span class="line">			   2.集合只能存引用数据类型，而数组能存基本数据类型和引用数据类型</span><br><span class="line">			   3.集合可以存放多种数据类型，而数组在定义是只能存放同一种的数据类型</span><br></pre></td></tr></table></div></figure>

<p>集合分为两种，一种是继承Collection的单列集合List和Set，另一种就是实现Map接口的双列集合</p>

        <h2 id="Collection的子接口"   >
          <a href="#Collection的子接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Collection的子接口" class="headerlink" title="Collection的子接口"></a>Collection的子接口</h2>
      
        <h3 id="1-List接口"   >
          <a href="#1-List接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-List接口" class="headerlink" title="(1)List接口"></a>(1)List接口</h3>
      <p>list的特性是：可重复、有序、有索引、可插入Null</p>
<p>实现List接口的实现类是ArrayList、LinkedList、Vector</p>

        <h4 id="1、ArrayList"   >
          <a href="#1、ArrayList" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h4>
      <p>ArrayList底层：</p>
<p>变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//默认长度</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//空数组</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认初始化情况下的空数组</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">创建ArrayList的时候：</span><br><span class="line"><span class="number">1.</span>无参构造 </span><br><span class="line">    <span class="comment">//  Constructs an empty list with an initial capacity of ten. 构建一个空的list并且将初始容量为10</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    //  The array buffer into which the elements of the ArrayList are stored. 这个缓冲区被用于存储ArrayList对象</span></span><br><span class="line"><span class="comment">    //  The capacity of the ArrayList is the length of this array buffer.  ArrayList的容量取决于这个缓冲区长度</span></span><br><span class="line"><span class="comment">    //  Any empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA will be expanded to DEFAULT_CAPACITY when the first element is added. </span></span><br><span class="line"><span class="comment">    	任何空的ArrayList当缓冲区等于空的地址与默认为空的实例相等时将会扩容默认的容量当第一次元素添加</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">		transient Object[] elementData;   </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	//	Shared empty array instance used for default sized empty instances.  用于默认大小的空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">	//  We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.</span></span><br><span class="line"><span class="comment">		我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">总结 空参构造就是创建一个大小为<span class="number">0</span>的Object数组  它会当第一次元素添加的时候扩容</span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity. 构造一个指定大小容量的空List</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list   参数：这个List的容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity is negative</span></span><br><span class="line"><span class="comment">     	抛出异常当这个指定的容量为负数时</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">       共享一个空的数组实例用来代表空数组</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">       private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  <span class="comment">//传入参数：指定的容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">            <span class="comment">//如果这个参数大于0 则将创建一个这个参数大小的Object数组 并且赋值给缓冲区</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个参数等于0 则将空数组实例赋值给缓冲区</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果这个参数为负数 则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">    参数大于<span class="number">0</span>的时候会创建一个这个参数大小的数组 </span><br><span class="line">    参数等于<span class="number">0</span>的时候会创建一个大小为<span class="number">0</span>的数组</span><br><span class="line">    参数小于<span class="number">0</span>的时候会抛出异常</span><br><span class="line">有参构造<span class="number">2</span>：</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified collection, in the order they are returned by the collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment">     * 创建一个List，该List包含参数集合中的元素，按参数集合的迭代器返回的顺序排列。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list  </span></span><br><span class="line"><span class="comment">       参数c是一个要被放入这个新list中的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">       当参数集合是空集合的时候抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">    	<span class="comment">//先将C数组化放到对象数组a中</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果数组a的长度不等于0的话，即这个传入进来的集合非空</span></span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">        <span class="comment">//如果集合C也是一个ArrayList 就将a传入缓存区的指针中</span></span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果集合C不是ArrayList,就用Arrays.copy这个数组存入一个对象数组中，再传入ElementData中</span></span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当数组长度为0的时候，为空List</span></span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">总结：这个有参构造就是将集合的全部拷贝</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>

<p>不仅如此，现在只是了解了ArrayList怎么创建的数组，但是空参构造会调用父类的构造方法，所以我们要看一下父类的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>父类AbstractList</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="number">2.</span>父类AbstractCollection</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line"> <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>但是问题来了，ArrayList已知创建一个大小为0的Object数组，并且提到会在第一次添加元素的时候进行扩容，这个扩容又是怎么处理的呢？我们重点要关注一下Add方法，且由于ArrayList的父类是抽象类，所以我们只要关注本身的Add方法即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list. 添加一个元素进入这个list的尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list 参数：一个将要被添加到list中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)  </span></span><br><span class="line"><span class="comment">   返回true </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">   私有化一个size 用来表示这个ArrayList的长度(包含元素的个数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//用来记录集合操作的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>; 定义数组的最大长度</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//调用ensureCapacityInternal() 方法 传入size(现在这个ArrayList元素个数)+1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="comment">//将size自增后将E插入进这个Object数组(缓存区) ==&gt; 插入数组尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;							</span><br><span class="line">    <span class="comment">//返回Ture</span></span><br><span class="line">&#125;																	  </span><br><span class="line">																	  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入参数 minCapacity即需要的最小长度</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    <span class="comment">//先看参数calculateCapacity(elementData, minCapacity)   </span></span><br><span class="line">    <span class="comment">//这个calculateCapacity()方法会返回一个数据，即扩容的大小</span></span><br><span class="line">    <span class="comment">//调用 ensureExplicitCapacity()方法，将计算出的大小传入进去</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入参数:是经过计算之后算出的长度(默认长度10或者是大于10且是需要的最小长度)</span></span><br><span class="line">	</span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="comment">//modCount是用来记录集合被操作过的次数  自增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//说明这段代码是考虑过溢出的</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//如果需要的长度减去数组长度&gt;0的话 触发生长函数</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//将缓冲区数组和需要最小长度传入</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="comment">//如果这个缓冲区是等于默认的空数组实例 即空数组</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    <span class="comment">/*返回一个最大值(在默认大小和最小需要长度之间)</span></span><br><span class="line"><span class="comment">    	已知默认长度为10，假如目前数组中有0个数据一次性插入12个数据</span></span><br><span class="line"><span class="comment">    	那么minCapacity应该为12  最小长度为现在数组个数+需要插入个数</span></span><br><span class="line"><span class="comment">    	于是最终返回12</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当缓存区数组是存在数据的，那么直接返回需要的最小集合长度</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入参数：默认10或者是大于10但是需要的最小长度</span></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//定义一个变量 记录老数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个变量 记录新数组的长度  新数组的长度等于老数组的长度+老数组右移一位</span></span><br><span class="line"><span class="comment">    	如： 老数组长度为10  则二进制是1010  右移一位就是101  ==&gt; 5</span></span><br><span class="line"><span class="comment">    	    所以新数组的长度是10+5  即新数组的长度是老数组的1.5倍  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">    	<span class="comment">//如果新数组长度比需要的最小长度还小 则将新数组长度直接设为需要的最小长度</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    	<span class="comment">//如果新数组长度比数组最大长度还大 则调用hugeCapacity()方法</span></span><br><span class="line">    	<span class="comment">//这个方法会1.抛出堆栈溢出错误2.返回定义的数组最大长度\整数的最大长度</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    	最后将老数组拷贝到新数组中，再赋值回老数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入需要的最小长度</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">    <span class="comment">//如果是小于0 则抛出异常  堆栈溢出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">    	<span class="comment">//如果最小长度比定义的最大数组长度还大，则直接返回整数的最大长度，否则返回定义的数组最大长度</span></span><br><span class="line">        Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>所以关注子类的构造方法即可</p>

        <h4 id="2、LinkedList"   >
          <a href="#2、LinkedList" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、LinkedList" class="headerlink" title="2、LinkedList"></a>2、LinkedList</h4>
      <p>linkedList底层:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">结构:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">	<span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//定义LinkedList的首结点</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//定义LinkedList的尾结点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里是Node的结构</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>因此我们可以得出LinkedList的Node结构示意图</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">Node<E> prev</th>
<th align="center">element</th>
<th align="center">Node<E> next</th>
</tr>
</thead>
</table></div>
<p>并且LinkedList是一个双端链表，它记录了头结点和尾结点的位置</p>
<p>我们接下来也要探究一下构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list. 创建一个空list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified collection, in the order they are returned by the collection&#x27;s  iterator.</span></span><br><span class="line"><span class="comment">     创建一个list，新list包含传入参数集合的元素和构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();   <span class="comment">//调用空参构造</span></span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c); <span class="comment">//返回调用函数的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        checkPositionIndex(index); </span><br><span class="line">        <span class="comment">//将LinkedList的容量传入</span></span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();  <span class="comment">//将传入的集合C进行数组化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;     <span class="comment">//记录C中的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)           <span class="comment">//如果C是空集合则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;        <span class="comment">//定义两个节点</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;       <span class="comment">//如果index==size 即添加的位置在链表的尾部</span></span><br><span class="line">            succ = <span class="literal">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">            <span class="comment">//设置index前结点为LinkedList的尾结点,尾结点设为空</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;				   <span class="comment">//如果index!=size，说明添加的索引位置不在链表尾部，而是在队中	</span></span><br><span class="line">            <span class="comment">//如果不位链表的尾部 </span></span><br><span class="line">            <span class="comment">//取出index结点的数据。</span></span><br><span class="line">            <span class="comment">//将succ置为index结点的数据，并将succ的前置结点信息交给pred，即pred指向index的前置结点</span></span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//遍历数组a</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">            <span class="comment">//@SuppressWarnings(&quot;unchecked&quot;) 告诉编译器不要出现警告信息 E e =(E) o 强制类型转换成E</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建新结点newNode 将前驱结点设为pred 传入数据 尾结点置空 </span></span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//如果前驱结点为空  则第一个节点就是newNode; 即这是链表第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//反之，前驱结点的后继结点设为新结点</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将前驱结点的指针往后移动到新节点上</span></span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//循环结束</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">/*在循环开始之前,对index和size进行了判断</span></span><br><span class="line"><span class="comment">        	如果index==size，说明这是链表尾部添加的数据。则将succ=null,pred=last即将pred置为链表尾部</span></span><br><span class="line"><span class="comment">        		循环结束之后pred=newNode即说明pred指向的是新结点的位置</span></span><br><span class="line"><span class="comment">        	如果index!=size，说明这不是尾部添加的数据，而是在链表中间添加的数据</span></span><br><span class="line"><span class="comment">        		我们将index索引位置的结点取出来了并将其保存于succ中，前置结点的信息保存在pred中</span></span><br><span class="line"><span class="comment">        		当循环结束之后pred中的位置指向新结点的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">            <span class="comment">//说明这是链表尾部添加的数据，当循环结束之后我们只要把last指针指向pred 即尾指针指向最后添加的结点即可</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之这是队中的数据</span></span><br><span class="line">            <span class="comment">//将新结点的后继结点置为succ 即置为原本index索引位置上的结点</span></span><br><span class="line">            <span class="comment">//将succ的前置结点设为新结点，保证双向链表的建立</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//将C中元素个数加入到size中</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">//modCount++ 指的是记录这个链表操作次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="comment">//如果返回False 则抛出异常</span></span><br><span class="line">            <span class="comment">//这个函数在有参构造时调用会返回True，不会进入IF语句中</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">        <span class="comment">/*当index大于等于0并且index小于等于size 时返回True   </span></span><br><span class="line"><span class="comment">           有参构造调用方法的时候传入的index==size，所以这个方法调用时会返回true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>除了关注LinkedList本身的构造函数我们也要关注一下父类的构造</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>父类AbstractSequentialList</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">AbstractSequentialList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>父类AbstractList</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">AbstractList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="number">3.</span>父类AbstractCollection</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以关注子类的构造方法即可</p>

        <h4 id="3、Vector"   >
          <a href="#3、Vector" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、Vector" class="headerlink" title="3、Vector"></a>3、Vector</h4>
      <p>Vector属性:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;    <span class="comment">//定义一个Object数组</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> elementCount;		   <span class="comment">//定义变量记录元素个数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;   <span class="comment">//定义容器应该增长时的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>; <span class="comment">//序列化ID</span></span><br><span class="line">   </span><br></pre></td></tr></table></div></figure>

<p>Vector的添加方法:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">        modCount++;  </span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = obj;</span><br><span class="line">     	<span class="comment">//记录操作数+1 确保容量大小 然后将数据存放到新的索引位置中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	<span class="comment">//记录操作数+1 确保容量大小 然后将数据存放到新的索引位置中 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        elementCount += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//记录操作数++  当index为负或者大于容量个数时抛出索引越界异常</span></span><br><span class="line">    	<span class="comment">//扩容，拷贝原数组到扩容后的新数组</span></span><br><span class="line">    	<span class="comment">//当参数中的集合元素不为0的时候返回true反之false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>分析ArrayList、LinkedList和Vector的不同点某过于Vector方法中都带有Synchronized锁</p>
<p>即说明Vector是同步的，是线程安全的而ArrayList、LinkedList是不同步的，是线程不安全的</p>

        <h3 id="2-Set接口"   >
          <a href="#2-Set接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Set接口" class="headerlink" title="(2)Set接口"></a>(2)Set接口</h3>
      <p>Set的特性有:不可重复、无序、无索引、可以存NULL【只能存一个】</p>

        <h4 id="1、HashSet"   >
          <a href="#1、HashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、HashSet" class="headerlink" title="1、HashSet"></a>1、HashSet</h4>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>; <span class="comment">//序列化ID</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; 					<span class="comment">//HashMap</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        <span class="comment">//一个Objectg对象</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     //构造一个空的set,HashMap初始容量为16并且负载因子0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个HashMap，容量为<span class="number">16</span>并且负载因子为<span class="number">0.75</span>    </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">【<span class="number">1</span>】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new set containing the elements in the specified collection.</span></span><br><span class="line"><span class="comment">        The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor(0.75) and an initial capacity sufficient to contain the elements in the specified collection.</span></span><br><span class="line"><span class="comment">	 //创建一个set包含了这个传入集合的元素，这个HashMap将是默认的负载因子0.75，创建的容量大小足够包含传入参数集合的元素</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    	<span class="comment">//将会调用HashSet(int initialCapacity)方法  </span></span><br><span class="line">    	<span class="comment">//调用方法传入参数为 c的大小/0.75后+1 与 16的最大值</span></span><br><span class="line">        addAll(c);  </span><br><span class="line">    	<span class="comment">//调用父类的addAll()方法 传入指定集合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)                      <span class="comment">//遍历集合的每一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="literal">true</span>;			</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        <span class="comment">//这个方法返回True说明集合因此改变，如果集合由于任何原因而拒绝添加特定元素，而不是因为它已经包含该元素，那么它必须抛出异常（而不是返回false）。此实现总是抛出UnsupportedOperationException。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">即创建一个HashMap，初始负载因子为<span class="number">0.75</span>,初始容量可以容下原本集合的元素或者<span class="number">16</span>个    </span><br><span class="line">【<span class="number">2</span>】</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment">     //构建一个HashMap,负载因子和容量都需要作为参数传入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个HashMap，负载因子和容量都需要作为参数传入       </span><br><span class="line">【<span class="number">3</span>】</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个HashMap，负载因子为<span class="number">0.75</span>，容量需要作为参数传入</span><br><span class="line">【<span class="number">4</span>】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty linked hash set.  (This package private constructor is only used by LinkedHashSet.)</span></span><br><span class="line"><span class="comment">     //这个构造方法专属于LinkedHashSet</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     The backingHashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      dummy             ignored (distinguishes this constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment">     //dummy参数表示被忽略(与其他构造函数相比)</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个LinkedHashMap(多态的关系)</span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>

<p>同时因为HashSet有父类，所以我们也要看一下父类的构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、父类AbstractSet</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractSet</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、父类AbstractCollection</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></div></figure>

<p>所以关注子类的构造方法即可</p>
<p>所以HashSet底层都是创建了一个HashMap或者LinkedHashMap实现</p>

        <h4 id="2、LinkedHashSet"   >
          <a href="#2、LinkedHashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、LinkedHashSet" class="headerlink" title="2、LinkedHashSet"></a>2、LinkedHashSet</h4>
      <p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	调用父类HashSet的方法</span></span><br><span class="line"><span class="comment">	HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span></span><br><span class="line"><span class="comment">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span></span><br><span class="line"><span class="comment">        //传入参数容量16和负载因子0.75  </span></span><br><span class="line"><span class="comment">        //调用LinkedHashMap&lt;&gt;(initialCapacity, loadFactor)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>LinkedHashSet的构造方法最后都是调用父类HashSet的有参构造，即HashSet(int initialCapacity, float loadFactor, boolean dummy)</p>
<p>所以要一探究竟这LinkedHashSet到底是什么实现还得等到双端链表中的LinkedHashMap</p>
<p>所以先不谈</p>

        <h4 id="3、TreeSet"   >
          <a href="#3、TreeSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、TreeSet" class="headerlink" title="3、TreeSet"></a>3、TreeSet</h4>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></div></figure>

<p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、无参构造</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">创建一个TreeMap对象</span><br><span class="line"><span class="number">2</span>、有参构造</span><br><span class="line">	TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br><span class="line">创建TreeMap对象</span><br></pre></td></tr></table></div></figure>

<p>所以TreeSet底层是封装了TreeMap对象来实现效果</p>

        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>底层原理</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>底层实际上是Object数组,开始初始容量为10,扩容为原来的1.5倍,因为是数组结构所以利于查找不利增删</td>
<td>有序、可重复、有索引、非线程安全</td>
</tr>
<tr>
<td>LinkedList</td>
<td>底层是双端链表,所以利于增删不利于查找</td>
<td>有序、可重复、有索引、非线程安全</td>
</tr>
<tr>
<td>Vector</td>
<td>底层是Object数组,但是因为方法中加有synchronized关键字,所以多线程下线程安全,但是效率低下</td>
<td>有序、可重复、有索引、线程安全</td>
</tr>
<tr>
<td>HashSet</td>
<td>底层封装了HashMap，本质上就是一个HashMap，默认初始容量为16，负载因子为0.75,每次扩容为原来容量的两倍。因为底层是HashMap所以线程不安全</td>
<td>无序、不可重复、没有索引、非线程安全</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>底层封装了LinkedHashMap，默认初始容量为16，负载因子为0.75,线程不安全</td>
<td>无序、不可重复、没有索引</td>
</tr>
<tr>
<td>TreeSet</td>
<td>底层封装了TreeMap，TreeMap底层是二叉树(红黑树),所以线程不安全</td>
<td>无序、不可重复、没有索引、非线程安全</td>
</tr>
</tbody></table></div>

        <h2 id="Map的子接口"   >
          <a href="#Map的子接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map的子接口" class="headerlink" title="Map的子接口"></a>Map的子接口</h2>
      
        <h3 id="1、HashMap"   >
          <a href="#1、HashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、HashMap" class="headerlink" title="1、HashMap"></a>1、HashMap</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个默认的容量   1左移4位 即二进制1 ==&gt; 10000 则初始容量为16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个最大的容量   1左移30位即二进制1 ==&gt;100000000000000000000000000000 即最大容量为1073741824</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义默认的负载因子  0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个链表的长度,当链表的长度达到这个长度会转化成红黑树      链表转化长度阈值为8</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个退化的阈值，当红黑树的链表长度低于这个数则会转化为链表  红黑树退化长度阈值为6</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个数组的长度，当数组的长度大于64的时候才会转化成红黑树   数组转化长度阈值为64</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Node数组 用于存放结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个entrySet 存放键值对</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个变量记录Map数量</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个变量用于记录集合的操作次数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> modCount;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//（javadoc描述在序列化时为true。此外，如果表数组尚未分配，则此字段将保留初始数组容量，或零表示DEFAULT_initial_capacity。）</span></span><br><span class="line"><span class="comment">//数组扩容阈值</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法："   >
          <a href="#1、构造方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法：" class="headerlink" title="1、构造方法："></a>1、构造方法：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    	<span class="comment">//将默认的加载因子为0.75给成员变量loadFactor中</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    	<span class="comment">//传入一个初始容量和一个默认的负载因子0.75 </span></span><br><span class="line">    	<span class="comment">//然后调用public HashMap(int initialCapacity, float loadFactor) </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//如果容量是负数，则抛出异常</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//如果容量超过了设定的最大容量 则将最大容量给变量init</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">//如果负载因子小于等于0，或者负载因子为空则抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//将这个传入的负载因子传入成员变量loadFactor中</span></span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">     	<span class="comment">//调用tableSizeFor(int cap) 将结果给threshold 即调用结果就是数组扩容的阈值   </span></span><br><span class="line">        <span class="comment">//调用这个方法就知道下次数组该什么时候扩容，但是这个数据是1:最大容量:n+1</span></span><br><span class="line">        <span class="comment">//我们后续会在resize()方法将阈值进行调整</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设传入的数cap=11 则n会等于10 </span></span><br><span class="line"><span class="comment">        因为执行到最后n |= n &gt;&gt;&gt; 16  n会无符号右移16位所以二进制位表示会是32位的</span></span><br><span class="line"><span class="comment">        【无符号右移】高位补零</span></span><br><span class="line"><span class="comment">        n的二进制数字为0000 0000 0000 0000 0000 0000 0000 1010</span></span><br><span class="line"><span class="comment">        n | = n &gt;&gt;&gt;1  即 n = 0000 1010 | 0000 0101  ==&gt; 0000 1111</span></span><br><span class="line"><span class="comment">        n | = n &gt;&gt;&gt;2  即 n = 0000 1111 | 0000 0011  ==&gt; 0000 1111</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">        因此我们可以知道这个结果n最后一定会是二进制的倍数-1  我们这里假设得到的数就是15        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当n&lt;0时返回1 否则n&gt;=0会进入判断n是否大于等于最大的容量 如果是则返回最大容量 反之则返回n+1</span></span><br><span class="line">        <span class="comment">//所以我们最后返回的数据就是16</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">//将默认的加载因子0.75赋值给成员变量loadFactor</span></span><br><span class="line">        </span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//调用PutMapEntries()方法  传入一个已经存在的map</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	形参:</span></span><br><span class="line"><span class="comment">		m – the map</span></span><br><span class="line"><span class="comment">		evict – false when initially constructing this map, else true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">        <span class="comment">//用s记录集合m的大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">//s&gt;0 且table ==null 说明传入的集合非空但是接收的集合为空</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="comment">//将s除以负载因子后+1 用ft记录下来</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">//用变量t记录结果：如果ft小于最大的容量则为ft 反之则为最大的容量  【用于限制ft的最大大小】</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">                    <span class="comment">//如果t大于数组扩容因子，调用数组扩容函数计算出需要的容量并且记录在threshold中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            	<span class="comment">//s&gt;0但是table不是null 说明传入的集合非空且接收的集合非空  </span></span><br><span class="line">                <span class="comment">//s&gt;threshold 说明超过了数组的阈值，需要对数组扩容 调用resize()方法</span></span><br><span class="line">                resize();  <span class="comment">//resize()方法到扩容那方面在展开说</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">//遍历entryset然后调用putval()方法，简单说就是将数据传入新的集合中</span></span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">                <span class="comment">//put方法后面再展开说</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></div></figure>

<p>小结：HashTable底层是用Node[]数组和链表+红黑树组成</p>
<p>我们来说说刚刚忽略的内部类</p>

        <h4 id="2、内部类"   >
          <a href="#2、内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、内部类" class="headerlink" title="2、内部类"></a>2、内部类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//指向下一个结点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//重写了HashCode方法，返回值是对象key哈希值和Value哈希值异或结果</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//SetValue方法会将老数据进行返回 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">/*重写了Equals方法 1.当地址相同直接返回tree</span></span><br><span class="line"><span class="comment">    					  2.地址不同则比较Entry实体，如果元素相同则返回True</span></span><br><span class="line"><span class="comment">    					  反之都不同则返回False</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       </span><br><span class="line">    	TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       	<span class="comment">//记录红黑树的父节点</span></span><br><span class="line">    	</span><br><span class="line">    	TreeNode&lt;K,V&gt; left;</span><br><span class="line">    	<span class="comment">//记录左子节点</span></span><br><span class="line">    </span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">    	<span class="comment">//记录右子节点</span></span><br><span class="line">    </span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    	<span class="comment">//记录前一个结点 【HashMap由数组+链表+红黑树构成，红黑树是链表转化而成的，所以数组中有结点用于挂载红黑树】 </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    	<span class="type">boolean</span> red;</span><br><span class="line">    	<span class="comment">//记录结点是红还是黑</span></span><br><span class="line">    	</span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3、常用方法"   >
          <a href="#3、常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">Put方法:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//将Key,Value传入 然后调用putVal()进行返回;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		参数</span></span><br><span class="line"><span class="comment">    			1:hash值  这个是调用了hash()方法之后的结果</span></span><br><span class="line"><span class="comment">    		   	2:key值   这个是传入的Key</span></span><br><span class="line"><span class="comment">    		   	3:Value值 这个是传入的Value值</span></span><br><span class="line"><span class="comment">    		   	4:onlyIfAbsent  表示如果存在键相同时是否更新旧值为新值 true是不更新旧值 false是更新旧值为新值</span></span><br><span class="line"><span class="comment">    		   	5:evict         传入true</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		定义一个Node[]数组 tab </span></span><br><span class="line"><span class="comment">    		定义一个Node结点 p</span></span><br><span class="line"><span class="comment">    		定义一个变量n  用于记录数组长度</span></span><br><span class="line"><span class="comment">    		定义一个变量i  用于记录索引</span></span><br><span class="line"><span class="comment">    	*/</span> </span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//先将本地的table数组赋值给tab 再把tab的长度赋值给n  </span></span><br><span class="line">            <span class="comment">//如果tab为空或者长度为0，将tab进行resize()方法扩容之后的长度赋值给n</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    		<span class="comment">//将n-1和hash值做与运算 赋值给索引i 如果再将结点p指向tab[i] 并且判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果tab[i]为空即这个位置为空 则调用newNode()方法，将hash值，K,V，和下一个结点为NULL传入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">        	return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    	Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            this.hash = hash;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">            this.value = value;</span></span><br><span class="line"><span class="comment">            this.next = next;</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之  tab[i]不为空 即这个位置有元素了 下面第一个IF有三种情况</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="comment">//1.如果这个位置p的hash和传入的hash相同 并且 (p的key和传入的k地址相同||p的key和key值相同)</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//则将这个位置p赋值给结点e，并且跳出第一个if语句</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//反之位置P和传入的数据不同 ，判断 p instanceof TreeNode 即判断p是否为树(红黑树)</span></span><br><span class="line">                <span class="comment">//如果是则添加到红黑树里面 调用putTreeVal()方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最终位置P和传入的数据不同也不是红黑树结构 ==&gt;那么应该是链表结构</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//死循环 用一个变量binCount记录链表长度</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//当p不指向下一个结点，则将这个数据变成新的结点插入p的后继节点中</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//对循环次数做判断 </span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        <span class="comment">//当binCount&gt;=7的时候说明已经至少循环7次,即添加此次数据之后链表长度应该到8了,调用treeifyBin()方法，尝试转化成红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果e的hash值相同且key相同(地址或值)相同 则直接跳出循环 </span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//将指针p指向下一个结点 [在if ((e = p.next) == null) &#123;...&#125;判断时e指向了p的下一个结点]</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//-------------这里结束第一个IF语句---------------------------</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//如果e不为空 即说明e和新值发生了哈希碰撞，e为老结点</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//onlyIfAbsent是用来判断是否更新旧值的，为False时说明更新旧值为新值</span></span><br><span class="line">                    <span class="comment">//支持更新旧值或者老值为NUll时，新值代替旧值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">    			   void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; 这个方法仅允许LinkedHashMap调用</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//返回老值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//操作记录数++</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断添加操作之后数组是否需要进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();  </span><br><span class="line">    	<span class="comment">//调用resize()方法扩容</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//空实现</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	void afterNodeInsertion(boolean evict) &#123; &#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//是红黑树则添加到红黑树里，这里是红黑树调整的规则，暂不做分析</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法是用来链表尝试转换成红黑树的  </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">//当数组长度小于64的时候我们进行扩容，将链表的值散落的落在数组上来提高查找效率而不转化成红黑树</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resize()方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	变量用处：1.oldTab :记录老的数组</span></span><br><span class="line"><span class="comment">    			2.oldCap:记录老的容量，老数组为空则为0</span></span><br><span class="line"><span class="comment">    			3.oldThr:记录原扩容阈值</span></span><br><span class="line"><span class="comment">    			4.newcap:记录新的容量</span></span><br><span class="line"><span class="comment">    			5.newThr:记录新的扩容阈值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当老数组中存在元素时走这个分支</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">                <span class="comment">//如果老数组大于等于最大限制容量，则扩容阈值为Integer最大值</span></span><br><span class="line">                <span class="comment">//这个情况下数组已经达到了最大值，不能再扩容</span></span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">           			<span class="comment">//newCap是oldCap左移一位即newCap是oldCap的两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//如果老数组扩大两倍还小于数组最大限制，并且老数组大于等于默认容量 </span></span><br><span class="line">                <span class="comment">//则设置新的阈值：为老阈值两倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//当老数组不存在元素时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//如果老数组阈值大于0，则新数组的容量就是老数组的阈值</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">//如果老数组阈值小于等于0  就进行默认的方式进行扩容</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">            <span class="comment">//新数组的容量为默认的数值(16)</span></span><br><span class="line">            <span class="comment">//新数组的扩容阈值为(扩容因子*初始容量)= 0.75*16=12</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			newThr==0有两种情况 1.oldCap&gt;=MAXIMUM_CAPACITY 即老数组的容量达到极限</span></span><br><span class="line"><span class="comment">							  2.oldCap&lt;=0&amp;&amp;oldThr&gt;0 即老数组不存在元素，且老数组阈值不为0</span></span><br><span class="line"><span class="comment">			当老数组不存在元素但是老数组阈值不为0则说明  它经过tableSizeFor()方法设置过初始阈值</span></span><br><span class="line"><span class="comment">			我们通过这个resize方法这个分支调整新的阈值  </span></span><br><span class="line"><span class="comment">			例如tableSizeFor()之后初始阈值为16,经过这个调整会变成16*0.75=12</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//ft=新数组容量*加载因子  用来记录新数组的扩容阈值</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="comment">//如果新数组容量没达到极限并且扩容阈值小于极限 则新数组的扩容阈值为计算出的ft 反之阈值则是Integer的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//将新阈值传入变量threshold中</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        <span class="comment">//创建Node[]数组，传入newTab中  我们在构造方法中没有见到创建数组的操作，而在resize()中见到了创造数组</span></span><br><span class="line">    	<span class="comment">//第一次put的时候调用resize方法创建数组 为了延时加载，提高效率</span></span><br><span class="line">    </span><br><span class="line">    	table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果老数组非空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                <span class="comment">//遍历老数组  j作为索引值，当j小于老数组容量时条件成立</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果老数组索引位置上有元素 则交给中间变量e记录  然后将这个位置置为空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果e的后继结点为null，因为e的位置是在数组上所以这个条件成立时说明这个位置只有一个元素</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">                    		则将e.hash&amp;(newCap-1)计算出索引值index，将e存入newTab[index]中</span></span><br><span class="line"><span class="comment">                    		这个index很熟悉我们好像在哪里见过？</span></span><br><span class="line"><span class="comment">                    		if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                    		put方法中的条件判断中出现了这个索引计算公式</span></span><br><span class="line"><span class="comment">                    		说明新索引值和老索引值用的是同一个计算公式</span></span><br><span class="line"><span class="comment">                    	*/</span></span><br><span class="line">                    	<span class="comment">//将e存入新数组的新下标位置即可</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//如果e是红黑树结构 则拆分红黑树 </span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//反之e是链表</span></span><br><span class="line">                        </span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">                      		变量</span></span><br><span class="line"><span class="comment">                      			lohead:记录链表旧位置的头结点</span></span><br><span class="line"><span class="comment">                      			loTail:记录链表旧位置的尾结点</span></span><br><span class="line"><span class="comment">                      			hihead:记录链表新位置的头结点</span></span><br><span class="line"><span class="comment">                      			hitial:记录链表新位置的尾结点</span></span><br><span class="line"><span class="comment">                      	*/</span>  </span><br><span class="line">                        </span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//将next指向e的后置节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果当前位置哈希和老数组容量做与运算等于0</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//如果旧链表尾结点为空</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                	<span class="comment">//则将e置为头结点</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将尾结点的后置结点置为e</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//则链表旧位置的尾结点为e</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                	这段好像有点字都认识，但是合在一起就不知道什么意思了</span></span><br><span class="line"><span class="comment">                                	再重新读一遍，如果经过运算等于0条件成立</span></span><br><span class="line"><span class="comment">                                		如果旧链表尾结点没数据，则将e置于头结点</span></span><br><span class="line"><span class="comment">                                		如果旧链表结尾有数据，则将e插入链表尾部</span></span><br><span class="line"><span class="comment">                                		比如第一次插入就是没数据，e插入链表中作为头结点和尾结点</span></span><br><span class="line"><span class="comment">                                			第二次插入数据时，e插入链表尾部，并将尾结点指针往后移动</span></span><br><span class="line"><span class="comment">                                			---</span></span><br><span class="line"><span class="comment">                                	这段代码的意思是如果当前位置哈希和老数组容量做与运算等于0 则保持位置不变</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//反之则说明要变动位置，这里与上面原理一样，不过是在新的位置</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      	</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                            <span class="comment">//结束循环之后旧链表位置不变的存入同一个下标中</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                            <span class="comment">//结束循环之后，链表要变动位置的要存入下标为:老下标+老数组容量</span></span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line">小结:</span><br><span class="line">	这里告诉我们数组扩容的原理以及元素位置的处理:</span><br><span class="line">			<span class="number">1.</span>数组    存入下标为e.hash &amp; (newCap - <span class="number">1</span>)中</span><br><span class="line">			<span class="number">2.</span>红黑树  拆分红黑树</span><br><span class="line">            <span class="number">3.</span>链表   如果是</span><br><span class="line">                		(e.hash &amp; oldCap) == <span class="number">0</span>则原位置不变</span><br><span class="line">                	反之</span><br><span class="line">						新链表位置为原下标+老数组容量</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hash()方法</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*当Key为空的时候返回0,说明支持Null值传入</span></span><br><span class="line"><span class="comment">	  当Key非空时  key经过hashcode()传入h中 再与h右移16位进行异或运算  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实我们还有一些东西没有讲到 就是前面put方法中i = (n - <span class="number">1</span>) &amp; hash的意义在哪</span><br><span class="line">参数n是数组长度或者经过resize()扩容后的数组长度，那么n常是二的倍数</span><br><span class="line">n的表现形式类似为<span class="number">0000</span> .... <span class="number">0000</span> <span class="number">1000</span>   直接与hash值做&amp;运算那么结果只跟数组长度有关</span><br><span class="line">则n-<span class="number">1</span>的二进制为 <span class="number">0000</span> .... <span class="number">0000</span> <span class="number">0111</span> </span><br><span class="line">再与hash做与运算，可以降低hash碰撞</span><br><span class="line">    </span><br><span class="line">h ^ (h&gt;&gt;&gt;<span class="number">16</span>)的意义</span><br><span class="line">假设有一个哈希值为 <span class="number">11000000</span> <span class="number">00111100</span>  <span class="number">11000000</span> <span class="number">00110011</span></span><br><span class="line">我们直接与n-<span class="number">1</span>做&amp;运算 <span class="number">0000</span> .... <span class="number">0000</span> <span class="number">0111</span>  那么只有低位有效与高位无关</span><br><span class="line">    </span><br><span class="line">h和进行h的无符号右移<span class="number">16</span>位异或运算        <span class="number">00000000</span> <span class="number">00000000</span>  <span class="number">11000000</span> <span class="number">00111100</span></span><br><span class="line">    							^  <span class="number">11000000</span> <span class="number">00111100</span>  <span class="number">11000000</span> <span class="number">00110011</span></span><br><span class="line">那么高位也能参与运算 所以能降低hash碰撞</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> get()方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    	<span class="comment">//将key和hash值传入getNode()方法中， 最后返回null或者getNode取得的结点的value值</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组非空且数组中存有数据，所以取得数组中索引的第一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果第一个结点哈希值相同，并且Key的地址或者值相同 则说明找到元素就是第一个元素，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果头结点还有后置结点，则取出后置结点</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果这个是红黑树 调用红黑树的getTreeNode()方法</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//反之就是普通的链表</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//判断哈希值相同，并且Key的地址或者值相同 则说明找到元素，返回元素e</span></span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);<span class="comment">//当后置结点为空的时候结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断结束说明没有找到这个Key对应的结点，返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="4、HashMap在jdk1-7产生死循环"   >
          <a href="#4、HashMap在jdk1-7产生死循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#4、HashMap在jdk1-7产生死循环" class="headerlink" title="4、HashMap在jdk1.7产生死循环"></a>4、HashMap在jdk1.7产生死循环</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">因为HashMap在<span class="number">1.7</span>的时候采用的是头插法，所以在并发情况下扩容可能会产生死循环</span><br><span class="line"></span><br><span class="line">正常情况A-&gt;B-&gt;C  那么当扩容时，应该是C-&gt;B-&gt;A</span><br><span class="line"></span><br><span class="line">并发扩容下的异常情况  A-&gt;B-&gt;C  假设现在有两个线程T1,线程T2</span><br><span class="line">							那么此时T1和T2指向A结点，并且T1.NEXT和T2.NEXT都指向B结点</span><br><span class="line">				  线程T1进行扩容，线程T2进行休眠</span><br><span class="line">				  T1扩容之后ABC的关系变成了==&gt;  C-&gt;B&gt;A  </span><br><span class="line">				  线程T2在T1在扩容时是不可知的。那么线程T2指向在A结点而T2.NEXT指向B  但是因为扩容之后B.NEXT是A </span><br><span class="line">				  这就是死循环</span><br></pre></td></tr></table></div></figure>




        <h3 id="2、HashTable"   >
          <a href="#2、HashTable" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、HashTable" class="headerlink" title="2、HashTable"></a>2、HashTable</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">//定义数组用来存储数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">//定义一个变量用来记录哈希表中的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法"   >
          <a href="#1、构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <p>1.空参构造</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个默认的哈希表 容量为11 负载因子为0.75</span></span><br></pre></td></tr></table></div></figure>

<p>2.有参构造</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">        <span class="comment">//创建一个指定容量，负载因子为0.75的哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">//当指定容量为负数时抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        	<span class="comment">//当加载因子为空或者小于等于0时抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        	<span class="comment">//当指定容量为0时，将转化为1</span></span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    	<span class="comment">//创建一个指定容量的哈希表</span></span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//扩容阈值，在指定容量*0.75和最大容量+1之间的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">    <span class="comment">//传入一个存在的map,直接创建负载因子为0.75,容量为原集合的两倍或者11之间的最大值的哈希表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法"   >
          <a href="#2、常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">put方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果value为空则抛出异常 说明不支持空值</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    	<span class="comment">//取得哈希 然后对数组长度做模运算, 获得索引值</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            	<span class="comment">//如果key值相同则返回老值用新值替代老值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">    	<span class="comment">//当key值不存在时添加元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当哈希表的元素个数大于等于阈值 调用rehash()扩容</span></span><br><span class="line">            </span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    	<span class="comment">//因为数据不存在所以直接插入到哈希表中 并且记录个数++</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rehash方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    	<span class="comment">//取出老哈希表长度</span></span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//新的容量为老容量的两倍+1</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="comment">//如果老数组达到了上限，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//新容量如果超过了上限,则新容量为上限</span></span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//操作数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    </span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//记录新阈值为 新容量*负载因子和最大上限+1之间的最小值	</span></span><br><span class="line">        table = newMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">                <span class="comment">//取出每一个元素</span></span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line">				</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//将每一个元素放到扩容后的新数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">    			<span class="comment">//当哈希值存在且Key值存在时 返回对应结点的Value           </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回NUll 代表不存在这个K-V对</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="3、TreeMap"   >
          <a href="#3、TreeMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、TreeMap" class="headerlink" title="3、TreeMap"></a>3、TreeMap</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这个树的比较器,如果使用元素的自然排序则为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于统计树有多少个实体</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计数器，统计操作次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Red-black mechanics</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span>   <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法-1"   >
          <a href="#1、构造方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法-1" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个比较器为空的树,排序方法为自然排序</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line"><span class="comment">//传入比较器，构造一个指定比较器的空树</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line"><span class="comment">//传入已有map，构造一个自然比较的树，然后调用putAll()方法把元素存入</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//传入已有的SortedMap,取得原有map的构造器 调用buildFormSorted方法 创建一个红黑树</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法-1"   >
          <a href="#2、常用方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法-1" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">put方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果r==null则说明这是一个空树，根节点为空</span></span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">			<span class="comment">//不允许空值作为Key值传入</span></span><br><span class="line">            </span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//将数据插入到根节点,树的大小+1,记录操作数++ 结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//反之，这个树不是一个空树</span></span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    	<span class="comment">//获得比较器cpr</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//通过比较器的比较方法从根节点开始找是否有相同结点</span></span><br><span class="line">                <span class="comment">//如果比根节点小则往左子树找,比根节点大则往右子树找,找到相同结点就调用setValue方法更新数据</span></span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当比较器为空的时候,通过自然排序找是否有相同的结点</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//运行到这里 说明树有数据但是树中没有相同的数据，并且经过上面查找循环parent已经指向了叶子结点</span></span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">    	<span class="comment">//将新的数据作为找到的叶子结点的子节点插入</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">    	<span class="comment">//调用方法对树进行调整</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调整红黑树的结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">        x.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    	<span class="comment">//调用getEntry方法 将Key传入</span></span><br><span class="line">        <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">    	<span class="comment">//如果key值对应的Entry不存在则返回null，如果存在则返回对应的value值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    	<span class="comment">//返回当Key为空则抛出空指针异常</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    	<span class="comment">//获得比较器</span></span><br><span class="line">    </span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果p存在，则调用compareTo()方法  通过比较器的排序方法比较</span></span><br><span class="line"><span class="comment">            	if cpm==0 则说明存在  直接返回</span></span><br><span class="line"><span class="comment">            	   cpm&lt;0  未找到结点,找左子树</span></span><br><span class="line"><span class="comment">            	   cpm&gt;0  未找到结点，找右子树</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size()方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于返回树的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="4、LinkedHashMap"   >
          <a href="#4、LinkedHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#4、LinkedHashMap" class="headerlink" title="4、LinkedHashMap"></a>4、LinkedHashMap</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3801124242820219131L</span>;</span><br><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//头结点指针</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">   <span class="comment">//尾结点指针</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//哈希映射的迭代排序方法：true表示访问顺序，false表示插入顺序。</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法-2"   >
          <a href="#1、构造方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法-2" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//调用父类的调用方法 即默认容器大小为16 负载因子为0.75  迭代排序方法为false表示插入顺序。</span></span><br><span class="line">    <span class="comment">//创建一个插入序的LinkedHashMap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//传入容量大小和负载因子,然后调用父类的构造方法  创建一个插入序的LinkedHashMap</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//传入容量大小,然后调用父类的构造方法  创建一个插入序的LinkedHashMap</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//调用父类的空参构造,创建一个插入序的LinkedHashMap</span></span><br><span class="line">    <span class="comment">//调用putMapEntries()方法把元素存入</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                         <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">    <span class="comment">//传入容量、负载因子、排序顺序   创建一个自定义容量、负载因子和排序顺序的LinkedHashMap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结:在如果不传入排序方式，默认都是创建一个插入序的LinkedHashMap</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法-2"   >
          <a href="#2、常用方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法-2" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line">put方法</span><br><span class="line">说实话我找了一会发现没有put方法在LinkedHashMap中,这怎么可能呢?那就应该是没有重写Put方法而是直接调用了父类的put方法,我们拿回原来HashMap中的Put方法进来</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//将Key,Value传入 然后调用putVal()进行返回;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		参数</span></span><br><span class="line"><span class="comment">    			1:hash值  这个是调用了hash()方法之后的结果</span></span><br><span class="line"><span class="comment">    		   	2:key值   这个是传入的Key</span></span><br><span class="line"><span class="comment">    		   	3:Value值 这个是传入的Value值</span></span><br><span class="line"><span class="comment">    		   	4:onlyIfAbsent  表示如果存在键相同时是否更新旧值为新值 true是不更新旧值 false是更新旧值为新值</span></span><br><span class="line"><span class="comment">    		   	5:evict         传入true</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		定义一个Node[]数组 tab </span></span><br><span class="line"><span class="comment">    		定义一个Node结点 p</span></span><br><span class="line"><span class="comment">    		定义一个变量n  用于记录数组长度</span></span><br><span class="line"><span class="comment">    		定义一个变量i  用于记录索引</span></span><br><span class="line"><span class="comment">    	*/</span> </span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//先将本地的table数组赋值给tab 再把tab的长度赋值给n  </span></span><br><span class="line">            <span class="comment">//如果tab为空或者长度为0，将tab进行resize()方法扩容之后的长度赋值给n</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    		<span class="comment">//将n-1和hash值做与运算 赋值给索引i 如果再将结点p指向tab[i] 并且判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果tab[i]为空即这个位置为空 则调用newNode()方法，将hash值，K,V，和下一个结点为NULL传入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">        	return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    	Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            this.hash = hash;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">            this.value = value;</span></span><br><span class="line"><span class="comment">            this.next = next;</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之  tab[i]不为空 即这个位置有元素了 下面第一个IF有三种情况</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="comment">//1.如果这个位置p的hash和传入的hash相同 并且 (p的key和传入的k地址相同||p的key和key值相同)</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//则将这个位置p赋值给结点e，并且跳出第一个if语句</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//反之位置P和传入的数据不同 ，判断 p instanceof TreeNode 即判断p是否为树(红黑树)</span></span><br><span class="line">                <span class="comment">//如果是则添加到红黑树里面 调用putTreeVal()方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最终位置P和传入的数据不同也不是红黑树结构 ==&gt;那么应该是链表结构</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//死循环 用一个变量binCount记录链表长度</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//当p不指向下一个结点，则将这个数据变成新的结点插入p的后继节点中</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//对循环次数做判断 </span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        <span class="comment">//当binCount&gt;=7的时候说明已经至少循环7次,即添加此次数据之后链表长度应该到8了,调用treeifyBin()方法，尝试转化成红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果e的hash值相同且key相同(地址或值)相同 则直接跳出循环 </span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//将指针p指向下一个结点 [在if ((e = p.next) == null) &#123;...&#125;判断时e指向了p的下一个结点]</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//-------------这里结束第一个IF语句---------------------------</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//如果e不为空 即说明e和新值发生了哈希碰撞，e为老结点</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//onlyIfAbsent是用来判断是否更新旧值的，为False时说明更新旧值为新值</span></span><br><span class="line">                    <span class="comment">//支持更新旧值或者老值为NUll时，新值代替旧值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">    			   void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; 这个方法仅允许LinkedHashMap调用</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//返回老值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//操作记录数++</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断添加操作之后数组是否需要进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();  </span><br><span class="line">    	<span class="comment">//调用resize()方法扩容</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//空实现</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	void afterNodeInsertion(boolean evict) &#123; &#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们不难得出里面有两个方法仅供LinkedHashMap调用</span><br><span class="line">因为HashMap中是空实现，那我们就需要关注这两个方法，这个会在常用方法区底部详细说说</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove方法  因为有上面put方法的经验,所以直接找到父类的Remove方法</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们关注到这里有一个 afterNodeRemoval(node)方法，这个方法也是仅供LinkedHashMap调用</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果这个结点为空则返回空值说明不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            <span class="comment">//存在数据,如果排序是访问顺序的话调用afterNodeAccess()方法</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//返回数据</span></span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------底下是HashMap仅供LinkedHashMap的方法-----------------------</span><br><span class="line">afterNodeAccess方法</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//移动结点到链表尾部 说明最近有被使用过    </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            <span class="comment">//当accessOrder为true 即排序是访问顺序的LinkedHashMap</span></span><br><span class="line">            <span class="comment">//并且当尾结点不为传入的结点e的时候</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里执行的逻辑是链表的双端删除,将e结点前后的结点相互链接,然后将e放到链表的尾部</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterNodeInsertion方法</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//这里注释说可能用于删除最老的结点?而什么是最老结点?我想到了最久未被使用的结点</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            <span class="comment">//当evict为true 并且头结点非空 而且需要removeEldestEntry()方法返回true</span></span><br><span class="line">            <span class="comment">//而当看向removeEldestEntry方法,它是返回false的,所以这个方法放在插入数据之后很奇怪，因为不会调用</span></span><br><span class="line">            <span class="comment">//可能需要我们自己扩展重写方法，实现相应的删除头结点操作</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;()方法返回<span class="literal">true</span></span><br><span class="line">            <span class="title function_">removeNode</span><span class="params">(hash(key)</span>, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//回调父类的removeNode()方法删除结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterNodeRemoval方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    	<span class="comment">//链表的双端删除  将结点e两端结点项链，然后e因为没有引用会被GC给回收</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></div></figure>


        <h4 id="3、额外"   >
          <a href="#3、额外" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、额外" class="headerlink" title="3、额外"></a>3、额外</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为LinkedHashMap有afterNodeRemoval、afterNodeInsertion、afterNodeAccess三个特有的方法，提供一个思路用于实现LRU算法</span><br><span class="line">    </span><br><span class="line">LRU算法即=最近最少被使用，我们可以利用afterNodeAccess将最近使用过的结点放到链表的尾部，然后慢慢地头部结点就是最近最少未被使用的结点，当需要淘汰结点时我们将头部结点淘汰就完成了LRU算法的构成</span><br><span class="line"></span><br><span class="line">在这里仅仅提供思路</span><br></pre></td></tr></table></div></figure>




        <h3 id="5、ConcurrentHashMap"   >
          <a href="#5、ConcurrentHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#5、ConcurrentHashMap" class="headerlink" title="5、ConcurrentHashMap"></a>5、ConcurrentHashMap</h3>
      <p>【1.8以后】</p>
<p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//最大的容量 即1左移30位==&gt;1*2^30</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//默认的容量16,必须为2的幂次方(最少是1最大是MAXIMUM_CAPACITY)</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//最大的数组大小</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//默认的并发级别，未使用但是为了与老版本版本兼容而保留</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//负载因子0.75</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//链表转化为树的阈值为8</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//红黑树退化为链表阈值为6</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//数组转化为树的阈值为64，最少是4*TREEIFY_THRESHOLD以避免调整大小阈值和树化阈值之间的冲突。</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Encodings for Node hash fields. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes  当前hash正在迁移</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; <span class="comment">// hash for roots of trees	   当前hash是个树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>; <span class="comment">// hash for transient reservations 当前hash已经被预定</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">    * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">    * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">    * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">    * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">    * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">    * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">    * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">    * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// views</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></div></figure>

<p>1.如何理解ConcurrentHashMap的安全性</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当count==null说明没有这个数据</span></span><br><span class="line">               map.put(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               map.put(<span class="string">&quot;count&quot;</span>,count+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  当两个线程t1、t2进入程序中查询到count==null</span></span><br><span class="line"><span class="comment">       *   都进入if条件中，那么执行结果是执行两次put(&quot;count&quot;,1)，数据造成丢失</span></span><br><span class="line"><span class="comment">       *   ConcurrentHashMap是无法保证又写又查的情况下线程安全</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//经过改造之后</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当count==null说明没有这个数据</span></span><br><span class="line">               <span class="keyword">if</span>(map.putIfAbsent(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>)==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当执行putIfAbsent()方法执行成功则会返回null,我们就跳出循环</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(map.replace(<span class="string">&quot;count&quot;</span>,count,count+<span class="number">1</span>))&#123;</span><br><span class="line">                   <span class="comment">//我们利用CAS机制，修改数据</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* 当两个线程t1、t2进入程序中查询到Count==null</span></span><br><span class="line"><span class="comment">       *  都进入IF条件中，我们假设先获得cpu的是t1,那么t1执行完putIFAbsent()方法之后得到返回null值跳出循环</span></span><br><span class="line"><span class="comment">       *  而t2再进入判断时就跳不出循环，第二次进入循环的时候就会走下面的分支</span></span><br><span class="line"><span class="comment">       *  使用replace方法对老值做替换</span></span><br><span class="line"><span class="comment">       *  这样我们就保证了两次操作的不丢失==&gt;数据的不被破坏</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法-3"   >
          <a href="#1、构造方法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法-3" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//创建一个默认容量为16的表【数组】   </span></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    	<span class="comment">//把cap赋值给sizeCtl，创建一个指定大小的表</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">     	<span class="comment">//创建一个默认容量的数组，把数据都存入</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">     	<span class="comment">//调用ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)方法</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                             <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">     <span class="comment">//创建一个指定大小，指定扩容因子的ConcurrentHashMap</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>经过上面的构造函数,我们基本都能发现有一个sizeCtl,我们详细说说sizeCtl有什么意义</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table initialization and resizing control.  When negative, thetable is being initialized or resized: -1 for initialization, else -(1 + the number of active resizing threads).  Otherwise,when table is null, holds the initial table size to use upon creation, or 0 for default. After initialization, holds the next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sizeCtl用来代表现在数组的状态</span><br><span class="line">   sizeCtl== -<span class="number">1</span>  ---&gt;说明现在数组正在初始化</span><br><span class="line">   sizeCtl==  <span class="number">0</span>  ---&gt;说明数组未被初始化，用的默认容量<span class="number">16</span></span><br><span class="line">   sizeCtl&gt;   <span class="number">0</span>	 ---&gt;如果数组未被初始化，则记录数组的初始容量，如果已经初始化过，那么记录的是数组扩容阈值(容量*负载因子<span class="number">0.75</span>)</span><br><span class="line">   sizeCtl&lt;  -<span class="number">1</span>  ---&gt;说明数组正在扩容, 值为-(n+<span class="number">1</span>).n为正在扩容中的线程数</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法-3"   >
          <a href="#2、常用方法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法-3" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line">Put方法 </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    	<span class="comment">//调用下面的putVal()方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    	<span class="comment">//说明Key和Value不允许设为空值，否则抛出空指针异常</span></span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    	<span class="comment">//得到Key对应的hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            <span class="comment">//设置一个临时表tab,然后死循环</span></span><br><span class="line">            </span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            变量说明  f:表示数组索引i位置的数据 即tab[i]</span></span><br><span class="line"><span class="comment">            		 n:表示数组长度</span></span><br><span class="line"><span class="comment">            		 i:表示索引</span></span><br><span class="line"><span class="comment">            		 fh:tab[i]的哈希值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            	<span class="comment">//tab为空指针或者tab中没有数据,将数组长度由n记录,调用initTable()方法</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            	<span class="comment">//把初始化之后的表给临时表table中,因为后面没有其他语句所以进入下一次循环</span></span><br><span class="line">            	</span><br><span class="line">            	</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//数组已经初始化了,将数据插入Map中    </span></span><br><span class="line">                <span class="comment">//取出索引i位置的数据交给f,如果f不存在，说明数组中这个位置为空</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="comment">//则将f以cas的方式插入数据 ==&gt;将索引i的数据以null设置成新结点</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            tabAt(数组,i) 表示获得索引为为i的数组元素即table[i]</span></span><br><span class="line"><span class="comment">            casTabAt(数组,1,2,3) 表示数组将索引i位置的数据以cas的方式从2修改到3</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Encodings for Node hash fields. </span></span><br><span class="line"><span class="comment">            static final int MOVED     = -1; // hash for forwarding nodes  当前hash正在迁移</span></span><br><span class="line"><span class="comment">            static final int TREEBIN   = -2; // hash for roots of trees	   当前hash是个树</span></span><br><span class="line"><span class="comment">            static final int RESERVED  = -3; // hash for transient reservations 当前hash已经被预定</span></span><br><span class="line"><span class="comment">            static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">//如果fh是MOVED的话 则说明当前数组在扩容，需要当前线程进行帮助数据迁移</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//fh！= -1</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   对f进行加锁，而f是tab[i]这个位置的数据</span></span><br><span class="line"><span class="comment">                   tab[i]这个位置要么是1.一个结点</span></span><br><span class="line"><span class="comment">                   				要么是2.一个结点挂着红黑树</span></span><br><span class="line"><span class="comment">                   				要么是3.一个结点挂着链表</span></span><br><span class="line"><span class="comment">                   	而对f进行加锁则意思是锁住f这个桶,即不锁住整个数组只是锁住索引i这个位置下的数据</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//再一次对f进行判断</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//如果fh&gt;=0 说明是正常数据</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//将binCount计数器置为1  说明这有一个数据</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                <span class="comment">//将f赋值给结点e,进行死循环</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    <span class="comment">//如果e的哈希值和当前哈希值相同,并且当前key的地址或者内容相同</span></span><br><span class="line">                                    <span class="comment">//说明找到老的数据，提取到原数据放到oldval中</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    </span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        <span class="comment">//onlyIfAbsent为False时说明更新旧值为新值，为ture则不做处理</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">//如果f是个树</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断是否需要转化成红黑树, 调用treeifyBin方法尝试转化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    	<span class="comment">//调用addCount方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. </span></span><br><span class="line"><span class="comment">static final int MOVED     = -1; // hash for forwarding nodes  当前hash正在迁移</span></span><br><span class="line"><span class="comment">static final int TREEBIN   = -2; // hash for roots of trees	   当前hash是个树</span></span><br><span class="line"><span class="comment">static final int RESERVED  = -3; // hash for transient reservations 当前hash已经被预定</span></span><br><span class="line"><span class="comment">static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    <span class="comment">//HASH_BITS = 01111111 11111111 11111111 11111111  </span></span><br><span class="line">    <span class="comment">//计算出的哈希值与HASH_BITS做与运算保证结果是正数，因为负数有特殊的含义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//initTable用于初始化表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    	<span class="comment">//循环判断是否为空，直到初始化成功</span></span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当表为null或者表长度为0时,说明未被初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//sizeCtl&lt;0时说明正在扩容</span></span><br><span class="line">                <span class="comment">//当前线程放弃cpu的使用权，在这里自旋</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//当sizeCtl运行到这里，说明sc&gt;=0  利用cas将sizeCtl设置为-1意思是将他置为初始化</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//再一次进行对表的判断，是否为空表 防止多线程情况下的多次初始化  </span></span><br><span class="line">                        <span class="comment">/*例如线程t2刚好运行到if底部的sc=n-(n&gt;&gt;&gt;2) 而线程t1运行到这个判断，如果不做判断则会多次初始化</span></span><br><span class="line"><span class="comment">                        所以这个再次判断是确保只初始化一次</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="comment">//将sc大于0则设为sc,否则设置为默认的长度16</span></span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                        <span class="comment">//将sc设为扩容阈值 n-n/4 即0.75n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//更新sizeCtl设为扩容阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//用于辅助线程迁移</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//treeifyBin 尝试转化成红黑树</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                <span class="comment">//当数组长度小于最大数组限制即64的时候调用tryPresize方法</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)</span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//判断c是否到达了最大限度，如果到达了就设置为最大限度，如果没达到就调用tableSizeFor方法</span></span><br><span class="line">    	<span class="comment">//因为tableSizeFor方法在HashMap中提到过，就是为了保证最后是二的n次幂</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//sc如果大于等于0，说明数组未被初始化或者是数组已经初始化过，sc记录的是扩容阈值</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果表为null或者n长度为0说明未被初始化过</span></span><br><span class="line">                n = (sc &gt; c) ? sc : c;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//将sizeCtl置为-1用来表示正在初始化</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                            table = nt;</span><br><span class="line">                            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        sizeCtl = sc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">                <span class="comment">//表已经初始化过，判断c是否达到阈值或者n是否超出最大数组长度 </span></span><br><span class="line">                <span class="comment">//如果没有达到阈值或者n已经超出限制,那么不做处理跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">                <span class="comment">//开始扩容</span></span><br><span class="line">                <span class="comment">//rs得到的是一个扩容戳(高十六位代表扩容标识，低16位做扩容线程数)</span></span><br><span class="line">                <span class="comment">//sizeCtl小于-1 则sizeCtl=-(n+1)，n表示正在扩容的线程数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt;[] nt;</span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transfer()方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于数据迁移    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="type">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="小结-1"   >
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>底层原理</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>底层是Node[]数组+链表+红黑树构成,默认容量为16,负载因子是0.75,扩容是原容量的两倍,线程不安全</td>
<td align="left">无序、非线程安全</td>
</tr>
<tr>
<td>HashTable</td>
<td>底层是哈希表(数组),默认容量是11,负载因子是0.75,扩容时新数组是原数组左移1位+1,即容量是原来两倍+1,因为被synchronized修饰所以是线程安全的</td>
<td align="left">线程安全、效率低</td>
</tr>
<tr>
<td>TreeMap</td>
<td>底层是二叉树(红黑树)</td>
<td align="left">可排序、非线程安全</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>底层是HashMap,默认容量为16，负载因子是0.75，默认排序方式是插入序，线程不安全，可用于开发LRU算法的实现</td>
<td align="left">有序、非线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>采用了synchronized+CAS的机制实现了线程安全</td>
<td align="left">线程安全</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/13/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/">RabbitMQ面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="RabbitMQ怎么保证消息的不丢失"   >
          <a href="#RabbitMQ怎么保证消息的不丢失" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ怎么保证消息的不丢失" class="headerlink" title="RabbitMQ怎么保证消息的不丢失"></a>RabbitMQ怎么保证消息的不丢失</h1>
      <p>我答:</p>
<p>1.RabbitMQ在生产端有确认机制，打开生产确认消息机制，当生产者消息没有发到交换机时会调用ConfirmCallBack函数，当交换机消息没有发到Queue时会有一个ReturnsCallBack函数。这样我们保证了消息到达队列的不丢失</p>
<p>2.消息的持久化，防止因为MQ宕机导致消息的不丢失，主要是交换机、队列和消息的持久化</p>
<p>3.在消费端有一个签收机制，我们可以打开签收机制设置为Auto 由Spring来判断是否产生异常，如果异常了设置一个ReSet机制，重试三次之后发送到Error队列由人工干涉</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消息的不丟失主要由三方面考虑</span><br><span class="line">1.RabbitMQ在生产端有确认机制，打开生产确认消息机制，当生产者消息没有发到交换机时会调用ConfirmCallBack函数，当交换机消息没有发到Queue时会有一个ReturnsCallBack函数。这样我们保证了消息到达队列的不丢失</span><br><span class="line"></span><br><span class="line">2.消息的持久化，防止因为MQ宕机导致消息的不丢失，主要是交换机、队列和消息的持久化</span><br><span class="line"></span><br><span class="line">3.在消费端有一个签收机制，我们可以打开签收机制设置为Auto 由Spring来判断是否产生异常，如果异常了设置一个ReSet机制，重试三次之后发送到Error队列由人工干涉</span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ怎么保障消息的幂等性"   >
          <a href="#RabbitMQ怎么保障消息的幂等性" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ怎么保障消息的幂等性" class="headerlink" title="RabbitMQ怎么保障消息的幂等性"></a>RabbitMQ怎么保障消息的幂等性</h1>
      <p>我答:1.可以引用一个全局的唯一ID，消费者要消费的时候查询Redis如果存在这个全局ID则说明已经消费过了</p>
<p>​		2.利用DB的主键，消费者查询MySql中的主键存在即说明消息也消费过了</p>
<p>​		3.利用Redis的Set命令，因为Key是唯一的，所以有天生的互斥性</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.可以引用一个全局的唯一ID，消费者要消费的时候查询Redis如果存在这个全局ID则说明已经消费过了</span><br><span class="line"></span><br><span class="line">2.利用DB的主键，消费者查询MySql中的主键存在即说明消息也消费过了</span><br><span class="line"></span><br><span class="line">3.利用Redis的Set命令，因为Key是唯一的，所以有天生的互斥性</span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ中死信队列？延时队列有了解过吗？"   >
          <a href="#RabbitMQ中死信队列？延时队列有了解过吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ中死信队列？延时队列有了解过吗？" class="headerlink" title="RabbitMQ中死信队列？延时队列有了解过吗？"></a>RabbitMQ中死信队列？延时队列有了解过吗？</h1>
      <p>我答：</p>
<p>1.RabbitMQ中死信队列也就是一个正常的交换机，主要是为了处理死信的。</p>
<p>​	一般因为三个原因会导致消息成为死信：1.消息超时了</p>
<p>​																		 2.消息数量超过了队列限制消息数目 </p>
<p>​																		 3.消息被拒签了</p>
<p>2.延时队列:RabbitMQ是不能直接创建延时队列的，但是我们可以通过对设置TTL和死信队列来达到延时队列的效果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.RabbitMQ中死信队列也就是一个正常的交换机，主要是为了处理死信的。</span><br><span class="line"></span><br><span class="line">  一般因为三个原因会导致消息成为死信：1.消息超时了</span><br><span class="line"></span><br><span class="line">								2.消息数量超过了队列限制消息数目 </span><br><span class="line"></span><br><span class="line">								3.消息被拒签了</span><br><span class="line"></span><br><span class="line">2.延时队列:RabbitMQ是不能直接创建延时队列的，但是我们可以通过对设置TTL和死信队列来达到延时队列的效果</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ中如果有100w条消息堆积，是如何解决的-消息堆积"   >
          <a href="#RabbitMQ中如果有100w条消息堆积，是如何解决的-消息堆积" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ中如果有100w条消息堆积，是如何解决的-消息堆积" class="headerlink" title="RabbitMQ中如果有100w条消息堆积，是如何解决的(消息堆积)"></a>RabbitMQ中如果有100w条消息堆积，是如何解决的(消息堆积)</h1>
      <p>我答:1.RabbitMQ中可以设置消费者能一次处理的消息个数，这样可以有效的保障MQ的正常使用</p>
<p>​         2.消息和Queue可以设置过期时间，当TTL到了之后消息会成为死信或被丢弃，但是这样会导致消息的丢失</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我在开发中没有遇到过这样的问题，但是如果发生了消息堆积也是有解决方案</span><br><span class="line">	1.增多消费者数目，提高消费速度</span><br><span class="line">	2.在消费者端开启线程池，加快处理速度[消费者总数不变]</span><br><span class="line">	3.采用惰性队列，扩大队列容积      【创建队列的时候加上lazy】 </span><br><span class="line">	    采用惰性队列的优势：①接收消息然后存放到磁盘中而不是内存中 ②性能比较稳定，消息上限高</span><br><span class="line">	    			劣势：1.受限于磁盘IO</span><br><span class="line">	    				 2.消费者要消费消息的时候才会将磁盘中的消息读取到内存中，会降低消息的时效性</span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ的高可用机制有了解过吗？"   >
          <a href="#RabbitMQ的高可用机制有了解过吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的高可用机制有了解过吗？" class="headerlink" title="RabbitMQ的高可用机制有了解过吗？"></a>RabbitMQ的高可用机制有了解过吗？</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在开发中我运用了镜像队列的方式来保证高可用</span><br><span class="line">镜像队列本质上就是主从模式，所有操作在主节点中完成然后备份到镜像节点。</span><br><span class="line">当主节点宕机挂掉之后，镜像节点就会上位成为主节点。</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/13/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/">RabbitMQ使用【进阶篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">27分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="如何保证RabbitMQ的消息发送可靠性"   >
          <a href="#如何保证RabbitMQ的消息发送可靠性" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何保证RabbitMQ的消息发送可靠性" class="headerlink" title="如何保证RabbitMQ的消息发送可靠性"></a>如何保证RabbitMQ的消息发送可靠性</h1>
      
        <h2 id="利用确认机制和回退机制"   >
          <a href="#利用确认机制和回退机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用确认机制和回退机制" class="headerlink" title="利用确认机制和回退机制"></a>利用确认机制和回退机制</h2>
      
        <h3 id="1-确认机制"   >
          <a href="#1-确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-确认机制" class="headerlink" title="(1)确认机制:"></a>(1)确认机制:</h3>
      <p>生产者与交换机之间有一个确认机制，当开启确认机制之后，无论消息是否发送到交换机都会调用一个ConfirmCallBack的函数</p>

        <h4 id="相关代码"   >
          <a href="#相关代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码" class="headerlink" title="相关代码:"></a>相关代码:</h4>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">#   设置消息发送确认模式  none:无需确认(默认) correlated:消息从生产者到交换机调用回调函数  simple：单个确认(发一条确认一条)</span><br><span class="line">  	publisher-confirm-type: correlated</span><br></pre></td></tr></table></div></figure>

<p>POM</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></div></figure>

<p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_CONFIRM_NAME=<span class="string">&quot;topic_ConfirmExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_CONFIRM_NAME=<span class="string">&quot;topic_Confirmqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息的可靠性保障 确认模式*/</span></span><br><span class="line"><span class="comment">//创建交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">bootConfirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_CONFIRM_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">bootConfirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_CONFIRM_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Queue和交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bootConfirmBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;ConfirmExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;ConfirmQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;confirm.*&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Produce</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * confirm(CorrelationData correlationData, boolean b, String s)</span></span><br><span class="line"><span class="comment">    * 参数1  配置信息</span></span><br><span class="line"><span class="comment">    * 参数2  是否正常到Exchange  如果是为True,如果不是为false;</span></span><br><span class="line"><span class="comment">    * 参数3  错误原因</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">//确认模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToConfirmSend</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> b, String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Confirm方法被调用了&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功收到消息&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;失败消息原因&quot;</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME,<span class="string">&quot;confirm.haha&quot;</span>,<span class="string">&quot;需要确认信息&quot;</span>);<span class="comment">//成功发送</span></span><br><span class="line"><span class="comment">//rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME+&quot;000&quot;,&quot;confirm.hehe&quot;,&quot;确认信息&quot;);//失败发送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>代码效果</p>

        <h5 id="1-成功发送："   >
          <a href="#1-成功发送：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-成功发送：" class="headerlink" title="1.成功发送："></a>1.成功发送：</h5>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713155029776.png"  alt="image-20230713155029776">
      </p>

        <h5 id="2-失败发送"   >
          <a href="#2-失败发送" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-失败发送" class="headerlink" title="2.失败发送"></a>2.失败发送</h5>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713155150627.png"  alt="image-20230713155150627">
      </p>

        <h3 id="2-回退机制"   >
          <a href="#2-回退机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-回退机制" class="headerlink" title="(2)回退机制"></a>(2)回退机制</h3>
      
        <h4 id="相关代码-1"   >
          <a href="#相关代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-1" class="headerlink" title="相关代码"></a>相关代码</h4>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">#   设置消息发送回退模式</span><br><span class="line">    publisher-returns: <span class="literal">true</span></span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Produce</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToConfirmSend</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	回退模式，只有在Exchange到Queue失败才会执行的回调函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    	rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行了ReturnCallback方法&quot;</span>);</span><br><span class="line">                System.out.println(returnedMessage.getMessage()); <span class="comment">//获得消息体</span></span><br><span class="line">                System.out.println(returnedMessage.getExchange());<span class="comment">//获得交换机信息</span></span><br><span class="line">                System.out.println(returnedMessage.getReplyCode());<span class="comment">//获得错误代码</span></span><br><span class="line">                System.out.println(returnedMessage.getRoutingKey());<span class="comment">//获得路由key</span></span><br><span class="line">                System.out.println(returnedMessage.getReplyText());<span class="comment">//获得被退回原因</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//正确发送 错误路由</span></span><br><span class="line">         rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME,<span class="string">&quot;return.haha&quot;</span>,<span class="string">&quot;需要确认信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_CONFIRM_NAME=<span class="string">&quot;topic_ConfirmExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_CONFIRM_NAME=<span class="string">&quot;topic_Confirmqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息的可靠性保障 确认模式*/</span></span><br><span class="line"><span class="comment">//创建交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">bootConfirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_CONFIRM_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">bootConfirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_CONFIRM_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Queue和交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bootConfirmBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;ConfirmExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;ConfirmQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;confirm.*&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="效果"   >
          <a href="#效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果" class="headerlink" title="效果"></a>效果</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713161242108.png"  alt="image-20230713161242108">
      </p>

        <h1 id="RabbitMQ的消息接收的确认"   >
          <a href="#RabbitMQ的消息接收的确认" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的消息接收的确认" class="headerlink" title="RabbitMQ的消息接收的确认"></a>RabbitMQ的消息接收的确认</h1>
      <p>设置Queue到消费者的确认方式</p>

        <h2 id="相关代码-2"   >
          <a href="#相关代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-2" class="headerlink" title="相关代码"></a>相关代码</h2>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">#    设置ACK签收模式   manual为手动签收   none为无需确认  auto为自动确认</span><br><span class="line">    listener:</span><br><span class="line">      direct:</span><br><span class="line">        acknowledge-mode: manual</span><br></pre></td></tr></table></div></figure>

<p>消费者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQconfirmListen</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_Confirmqueue&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;正在处理业务逻辑...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//签收消息</span></span><br><span class="line">            <span class="comment">/*basicAck(long deliveryTag, boolean multiple)</span></span><br><span class="line"><span class="comment">             * 参数1:消息标签</span></span><br><span class="line"><span class="comment">             * 参数2:是否支持多条消息的签收</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> i=<span class="number">3</span>/<span class="number">0</span> ; <span class="comment">//模仿出错</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//        因为异常拒绝签收</span></span><br><span class="line">            <span class="comment">/* basicNack(long deliveryTag, boolean multiple, boolean requeue)</span></span><br><span class="line"><span class="comment">             * 参数1:消息标签</span></span><br><span class="line"><span class="comment">             * 参数2:是否支持多条消息的签收</span></span><br><span class="line"><span class="comment">             * 参数3：是否退回队列</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-1"   >
          <a href="#效果-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3>
      
        <h4 id="1-正常签收"   >
          <a href="#1-正常签收" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-正常签收" class="headerlink" title="(1)正常签收"></a>(1)正常签收</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713163939606.png"  alt="image-20230713163939606">
      </p>

        <h4 id="2-异常签收"   >
          <a href="#2-异常签收" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-异常签收" class="headerlink" title="(2)异常签收"></a>(2)异常签收</h4>
      <p>![](RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91&#x2F;image-20230713162956067.png</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713163128985.png"  alt="image-20230713163128985">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/image-20230713163221136.png"  alt="image-20230713163221136">
      </p>

        <h1 id="RabbitMQ的消费端限流"   >
          <a href="#RabbitMQ的消费端限流" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的消费端限流" class="headerlink" title="RabbitMQ的消费端限流"></a>RabbitMQ的消费端限流</h1>
      <p>使用场景:限制消费端的接收消息的数量，防止因为系统维护等导致队列中的消息多,因而导致一个消费端巨量的压力过大，影响系统性能</p>
<p>实现要求</p>
<p>1.打开手动签收模式</p>
<p>2.将application中的prefetch设置为可消费的消息数量</p>

        <h2 id="相关代码-3"   >
          <a href="#相关代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-3" class="headerlink" title="相关代码"></a>相关代码</h2>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line"></span><br><span class="line">#    设置ACK签收模式   manual为手动签收   none为无需确认  auto为自动确认</span><br><span class="line">    listener:</span><br><span class="line">      direct:</span><br><span class="line">        acknowledge-mode: manual</span><br><span class="line">#  设置消费端一次能接受的消息数量</span><br><span class="line">        prefetch: <span class="number">1</span></span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual</span><br><span class="line">        prefetch: <span class="number">1</span></span><br></pre></td></tr></table></div></figure>

<p>消费者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QosListen</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_Confirmqueue&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"><span class="comment">//          手动签收消息</span></span><br><span class="line"><span class="comment">//            channel.basicAck(deliveryTag, true);</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendQos</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">           rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME, <span class="string">&quot;confirm.haha&quot;</span>, <span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;条信息，&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-2"   >
          <a href="#效果-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713165421300.png"  alt="image-20230713165421300">
      
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713165439057.png"  alt="image-20230713165439057">
      </p>
<p>总共有20条 19条Ready  1条未被签收</p>

        <h1 id="RabbitMQ的TTL"   >
          <a href="#RabbitMQ的TTL" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的TTL" class="headerlink" title="RabbitMQ的TTL"></a>RabbitMQ的TTL</h1>
      <p>消息到达存活时间之后还未被消费则会被自动清除</p>

        <h2 id="队列设置过期时间"   >
          <a href="#队列设置过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列设置过期时间" class="headerlink" title="队列设置过期时间"></a>队列设置过期时间</h2>
      
        <h3 id="相关代码-4"   >
          <a href="#相关代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-4" class="headerlink" title="相关代码"></a>相关代码</h3>
      <p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_TTL_NAME=<span class="string">&quot;topic_TtlExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_TTL_NAME=<span class="string">&quot;topic_Ttlqueue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;TtlExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">TtlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_TTL_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;TtlQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">TtlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_TTL_NAME).ttl(<span class="number">10000</span>).build(); <span class="comment">//设置队列消息过期时间为10S</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Queue和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">TtlBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;TtlExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;TtlQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;ttl.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendTTL</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">           rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_TTL_NAME, <span class="string">&quot;ttl.haha&quot;</span>, <span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;条信息，&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="效果-3"   >
          <a href="#效果-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713170744420.png"  alt="image-20230713170744420">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/image-20230713170756794.png"  alt="image-20230713170756794">
      </p>

        <h2 id="单个消息设置过期时间"   >
          <a href="#单个消息设置过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#单个消息设置过期时间" class="headerlink" title="单个消息设置过期时间"></a>单个消息设置过期时间</h2>
      
        <h3 id="相关代码-5"   >
          <a href="#相关代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-5" class="headerlink" title="相关代码"></a>相关代码</h3>
      <p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendTTLMessage</span><span class="params">()</span>&#123;</span><br><span class="line">       rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_TTL_NAME, <span class="string">&quot;ttl.haha&quot;</span>,<span class="string">&quot;ttl...&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">               message.getMessageProperties().setExpiration(String.valueOf(<span class="number">5000</span>));<span class="comment">//设置过期时间为5s</span></span><br><span class="line">               <span class="keyword">return</span>  message;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="效果-4"   >
          <a href="#效果-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713171755975.png"  alt="image-20230713171755975">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/image-20230713171808499.png"  alt="image-20230713171808499">
      </p>

        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h2>
      <p>1.当Queue的TTL和消息的TTL共同存在的时候，则会优先执行短的</p>
<p>2.当消息的过期时间到了 但是不在队列的首部的时候不会立即删除[像Redis的惰性删除，只有在调用的时候发现过期了才删除]</p>

        <h1 id="死信队列"   >
          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1>
      <p>当消息过期\被拒绝签收\队伍消息长度达到限制的消息则会放到死信队列中</p>
<p>死信队列也是一个交换机，它的存在是处理死信的交换机，其他与正常交换机没有区别</p>

        <h2 id="相关代码-6"   >
          <a href="#相关代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-6" class="headerlink" title="相关代码"></a>相关代码</h2>
      <p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_DLX_NAME=<span class="string">&quot;topic_DLxExchange&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_DLX_NAME=<span class="string">&quot;topic_DLXqueue&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_DLXTRUE_NAME=<span class="string">&quot;topic_DLEtureExchange&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_DLXTRUE_NAME=<span class="string">&quot;topic_DLXtruequeue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建死信交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXExchange&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Exchange <span class="title function_">DLXExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_DLX_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建死信Queue</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXQueue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">DLXQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DLX_NAME).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建正常交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXTrueExchange&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Exchange <span class="title function_">DLXTrueExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_DLXTRUE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建正常Queue</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXTrueQueue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">DLXTrueQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;DLXExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DLXTRUE_NAME).ttl(<span class="number">100000</span>).maxLength(<span class="number">10</span>).deadLetterExchange(exchange.getName()).deadLetterRoutingKey(<span class="string">&quot;dlx.haha&quot;</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//正常Queue和交换机绑定</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">DLXTrueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;DLXTrueExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;DLXTrueQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;info.#&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//死信Queue和死信交换机绑定</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">DLXBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;DLXExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;DLXQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dlx.*&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>生产者代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendDlxMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_DLXTRUE_NAME, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;这是&quot;</span>+i+<span class="string">&quot;条消息&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line"><span class="comment">//                        message.getMessageProperties().setExpiration(String.valueOf(6000));</span></span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>消费者代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxListen</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_DLXtruequeue&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"><span class="comment">//          手动签收消息</span></span><br><span class="line">            <span class="type">int</span> i=<span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//不签收消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;拒绝签收消息&quot;</span>);</span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-5"   >
          <a href="#效果-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-5" class="headerlink" title="效果"></a>效果</h3>
      
        <h4 id="1-当消息到了过期时间"   >
          <a href="#1-当消息到了过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-当消息到了过期时间" class="headerlink" title="(1)当消息到了过期时间"></a>(1)当消息到了过期时间</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181912511.png"  alt="image-20230713181912511">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181933839.png"  alt="image-20230713181933839">
      </p>

        <h4 id="2-当消息长度超过了队列限制"   >
          <a href="#2-当消息长度超过了队列限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-当消息长度超过了队列限制" class="headerlink" title="(2)当消息长度超过了队列限制"></a>(2)当消息长度超过了队列限制</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181912511.png"  alt="image-20230713181912511">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181933839.png"  alt="image-20230713181933839">
      </p>

        <h4 id="3-消息在消费端拒收"   >
          <a href="#3-消息在消费端拒收" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-消息在消费端拒收" class="headerlink" title="(3)消息在消费端拒收"></a>(3)消息在消费端拒收</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713183932822.png"  alt="image-20230713183932822">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713183952193.png"  alt="image-20230713183952193">
      </p>

        <h3 id="提示"   >
          <a href="#提示" class="heading-link"><i class="fas fa-link"></i></a><a href="#提示" class="headerlink" title="提示"></a>提示</h3>
      <p>当消息总数超过队列长度限制时，因为队列是先进先出的，所以成为死信的消息应该是先进入队列的消息</p>

        <h1 id="延迟队列"   >
          <a href="#延迟队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1>
      <p>RabbitMQ无法直接创建延迟队列，但是可以通过TTL和死信队列达到延迟队列的效果，则这样延迟队列为该死信队列的Queue</p>

        <h1 id="消息补偿机制"   >
          <a href="#消息补偿机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h1>
      <p>【图片来源于CSDN，借鉴于此】</p>
<p>【<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_48481908/article/details/120160022?ops_request_misc=&request_id=&biz_id=102&utm_term=RabbitMQ%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-120160022.nonecase&spm=1018.2226.3001.4187%E3%80%91" >https://blog.csdn.net/m0_48481908/article/details/120160022?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=RabbitMQ%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-120160022.nonecase&amp;spm=1018.2226.3001.4187】</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6I235YyF6JuL5LuK5aSp5pyJ5aW95aW95a2m5Lmg5ZCX77yf,size_14,color_FFFFFF,t_70,g_se,x_16.png"  alt="在这里插入图片描述">
      </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">1.生产者生产数据并写入自己的数据库</span><br><span class="line">2.生产者发送消息给Q1，并且会延迟一段时间发送相同的消息给Q3。Q1会被Consumer监听到，会产生一个确认信息的信号给Q2,Q2会被回调检查服务监听到，此时会直接将消息写到MDB中</span><br><span class="line">3.消费者将消费数据写入自己的DB中。</span><br><span class="line">4.延迟发送相同的消息给Q3，Q3被回调检查服务监听，会与MDB中数据比对，如果MDB中没有这个消息则说明Q3的消息未被消费，即发送消息给Q1失败，则会调用Producer重发消息</span><br><span class="line">5.定时检查服务来检查生产者DB和MessageDB 如果不一致，如业务DB多于消息MDB则说明有消息未被消费。则需要生产者重发消息【这是为了防止发送消息和延迟发送消息都失败的情况】</span><br></pre></td></tr></table></div></figure>


        <h1 id="消息幂等性的保证"   >
          <a href="#消息幂等性的保证" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息幂等性的保证" class="headerlink" title="消息幂等性的保证"></a>消息幂等性的保证</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">消息的幂等性：指的是消息的多次执行和一次执行的效果是一样的</span><br><span class="line"></span><br><span class="line">比如消费者的确认时宕机 导致生产者多次发送同样的消息，所以此时要保证消息的幂等性，不要重复消费</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line"></span><br><span class="line">1.使用Redis的Set命令，因为Set的Key是唯一的，所以这样不会重复消费消息</span><br><span class="line"></span><br><span class="line">2.使用UUID等方式，全局唯一ID，所以每次消息来了去Redis查是否有这个UUID，如果有则说明消费过</span><br><span class="line"></span><br><span class="line">3.利用数据库主键的方式，因为主键也是唯一的</span><br></pre></td></tr></table></div></figure>


        <h1 id="消息转换器"   >
          <a href="#消息转换器" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringAMQP中会有一个消息转化器(MessageConverter)，当我们调用RabbitTamplate的convertAndSend方法的时候，传入的消息参数都是Object类型，然后他会在底层帮我们进行一个序列化，而这个序列化是基于Java底层的ObjectOutPutStream来实现。</span><br><span class="line">我们可以引入一个Json格式的消息转化器来达到约定大于配置将Spring自带的消息转化器替代，我们用JSon格式做序列化</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="相关代码-7"   >
          <a href="#相关代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-7" class="headerlink" title="相关代码"></a>相关代码</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pom依赖</span><br><span class="line">&lt;!--        定义json格式转化器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></div></figure>

<p>启动类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br><span class="line">因为约定大于配置，自己创建一个Bean来覆盖初始的消息转化器</span><br></pre></td></tr></table></div></figure>

<p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_OBJECT_NAME=<span class="string">&quot;direct_ObjectExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_OBJECT_NAME=<span class="string">&quot;direct_Objectqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Object交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;ObjectExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">ObjectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_OBJECT_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;ObjectQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">ObjectQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_OBJECT_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Queue和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">ObjectBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;ObjectExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;ObjectQueue&quot;)</span> Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;queue.object&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToObjectMessage</span><span class="params">()</span>&#123;</span><br><span class="line"> 	HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_OBJECT_NAME,<span class="string">&quot;queue.object&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>消费者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectListen</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;direct_Objectqueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Map&lt;String,Object&gt; msg)</span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-6"   >
          <a href="#效果-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-6" class="headerlink" title="效果"></a>效果</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230720224428282.png" >
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230720225911561.png"  alt="image-20230720225911561">
      </p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>单机RabbitMq的启动命令</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start 启动</span><br><span class="line">service rabbitmq-server stop  停机</span><br><span class="line">service rabbitmq-server restart 重启</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/12/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">Java基础面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-12</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="final修饰符有学习过吗？它有什么使用场景"   >
          <a href="#final修饰符有学习过吗？它有什么使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#final修饰符有学习过吗？它有什么使用场景" class="headerlink" title="final修饰符有学习过吗？它有什么使用场景"></a>final修饰符有学习过吗？它有什么使用场景</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Final修饰符表示是最终的</span><br><span class="line">Final修饰符可以用于修饰变量、方法、类</span><br><span class="line"><span class="number">1</span>)Final修饰变量的时候:这个变量叫常量，一旦被赋值就不能改变</span><br><span class="line"><span class="number">2</span>)Final修饰方法的时候:这个方法不能被子类重写</span><br><span class="line"><span class="number">3</span>)Final修饰类的时候:这个类是最终类，不能被继承</span><br></pre></td></tr></table></div></figure>


        <h1 id="jvm、jdk、jre的区别"   >
          <a href="#jvm、jdk、jre的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#jvm、jdk、jre的区别" class="headerlink" title="jvm、jdk、jre的区别"></a>jvm、jdk、jre的区别</h1>
      <p>jvm是java虚拟机，里面含有java运行的一切要求</p>
<p>jdk是java提供的api库</p>
<p>jre是最小开发环境</p>
<p>jvm、jdk、jre的关系是jvm包含jdk包含jre</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM:JVM为java虚拟机</span><br><span class="line">JRE:JRE为Java运行环境，JRE包括标准类库和JVM</span><br><span class="line">JDK:JDK为Java开发环境，JDK包括了JRE和开发工具</span><br><span class="line">    </span><br><span class="line">总结:JDK包含JRE，JRE包含JVM，如果只需要运行java程序只要装JRE即可</span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230721203141902.png"  alt="image-20230721203141902">
      </p>

        <h1 id="java的八大基本类型"   >
          <a href="#java的八大基本类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#java的八大基本类型" class="headerlink" title="java的八大基本类型"></a>java的八大基本类型</h1>
      <p>我答:</p>
<p>Char、short、int、Long、Float、Double、String、Boolean</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整型:<span class="type">byte</span>、<span class="type">short</span>、<span class="type">int</span>、<span class="type">long</span></span><br><span class="line">字符型：<span class="type">char</span></span><br><span class="line">浮点型：Float、Double</span><br><span class="line">布尔型：Boolean</span><br></pre></td></tr></table></div></figure>


        <h1 id="多态如何实现的"   >
          <a href="#多态如何实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#多态如何实现的" class="headerlink" title="多态如何实现的"></a>多态如何实现的</h1>
      
        <h1 id="进程和线程的区别"   >
          <a href="#进程和线程的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1>
      
        <h1 id="同步和异步的区别"   >
          <a href="#同步和异步的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h1>
      
        <h1 id="如何理解序列化"   >
          <a href="#如何理解序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何理解序列化" class="headerlink" title="如何理解序列化"></a>如何理解序列化</h1>
      
        <h1 id="HashMap-和-TreeMap-讲讲？"   >
          <a href="#HashMap-和-TreeMap-讲讲？" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashMap-和-TreeMap-讲讲？" class="headerlink" title="HashMap 和 TreeMap 讲讲？"></a>HashMap 和 TreeMap 讲讲？</h1>
      
        <h1 id="讲讲-Java-提供了哪些锁？它们有什么区别？"   >
          <a href="#讲讲-Java-提供了哪些锁？它们有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲-Java-提供了哪些锁？它们有什么区别？" class="headerlink" title="讲讲 Java 提供了哪些锁？它们有什么区别？"></a>讲讲 Java 提供了哪些锁？它们有什么区别？</h1>
      
        <h1 id="有了解过集合吗？看过底层源码吗？"   >
          <a href="#有了解过集合吗？看过底层源码吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过集合吗？看过底层源码吗？" class="headerlink" title="有了解过集合吗？看过底层源码吗？"></a>有了解过集合吗？看过底层源码吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有了解过集合，看过底层源码</span><br><span class="line">集合就是有两个顶级接口Collection单列集合和Map双列集合</span><br><span class="line">Collection接口的子接口有List、Set</span><br><span class="line">List接口的实现类有ArrayList、LinkedList、Vector</span><br><span class="line">Set接口的实现类有HashSet、TreeSet、LinkedHashSet</span><br><span class="line">而Map集合的实现类有HashMap、LinkedHashMap、HashTable、TreeMap、ConcurrentHashMap</span><br><span class="line">您看我具体要从哪方面讲讲呢?</span><br></pre></td></tr></table></div></figure>




        <h1 id="ArrayList底层是怎么进行创建和扩容的呢？"   >
          <a href="#ArrayList底层是怎么进行创建和扩容的呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayList底层是怎么进行创建和扩容的呢？" class="headerlink" title="ArrayList底层是怎么进行创建和扩容的呢？"></a>ArrayList底层是怎么进行创建和扩容的呢？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList底层是创建了一个Object数组来存放数据的，默认的空参构造时创建一个数组长度为<span class="number">10</span>的Obejct数组，也可以在构建方法传入指定长度，构建一个指定长度的Object数组。</span><br><span class="line">ArrayList在添加数据的时候会判断这个数组是不是满了，一旦满了就进行扩容，ArrayList的扩容是原来容量的<span class="number">1.5</span>倍</span><br><span class="line">具体操作是拿出老容量加上老容量右移一位再赋值给新数组，然后把老数组的元素copy到新数组中，最后添加新加入的数据</span><br></pre></td></tr></table></div></figure>




        <h1 id="集合是怎么处理哈希碰撞的？"   >
          <a href="#集合是怎么处理哈希碰撞的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合是怎么处理哈希碰撞的？" class="headerlink" title="集合是怎么处理哈希碰撞的？"></a>集合是怎么处理哈希碰撞的？</h1>
      <p>我答：</p>
<p>集合获取这个索引I是把集合长度n-1再和由key经过hashcode方法得到的哈希值做一个与运算<br>由key算出的hash值具体是 拿出key经过hashcode获得一个哈希值，将这个哈希值和这个哈希值无符号右移16位做一个异或运算 使得高位数据也能参与hash中 最后得到的值传回去</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当发生哈希碰撞的时候有以下几种解决哈希碰撞的方法：链式寻址法、再hash算法、公共溢出法、线性探测法</span><br><span class="line">而HashMap在处理哈希碰撞的时候就是利用链式寻址法和红黑树，<span class="number">1.7</span>是将新数据插入到链表头部，而<span class="number">1.8</span>会将数据插入到链表尾部，并且插入新数据的时候会进行判断链表长度是否超过<span class="number">8</span>且数组长度超过<span class="number">64</span>，如果超过了则会转成红黑树结构，红黑树是为了优化因为链表过长导致搜索时间复杂度增加的一个问题</span><br></pre></td></tr></table></div></figure>




        <h1 id="有了解过锁吗-Lock和Sychorized那些"   >
          <a href="#有了解过锁吗-Lock和Sychorized那些" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过锁吗-Lock和Sychorized那些" class="headerlink" title="有了解过锁吗?Lock和Sychorized那些"></a>有了解过锁吗?Lock和Sychorized那些</h1>
      
        <h1 id="final修饰方法会怎么样？final修饰类会怎么样"   >
          <a href="#final修饰方法会怎么样？final修饰类会怎么样" class="heading-link"><i class="fas fa-link"></i></a><a href="#final修饰方法会怎么样？final修饰类会怎么样" class="headerlink" title="final修饰方法会怎么样？final修饰类会怎么样?"></a>final修饰方法会怎么样？final修饰类会怎么样?</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>修饰方法会让方法无法被重写</span><br><span class="line"><span class="keyword">final</span>修饰类会使这个类成为最终类,无法被继承</span><br></pre></td></tr></table></div></figure>




        <h1 id="Integer和int能直接进行比较吗？"   >
          <a href="#Integer和int能直接进行比较吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integer和int能直接进行比较吗？" class="headerlink" title="Integer和int能直接进行比较吗？"></a>Integer和int能直接进行比较吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer类型和Int值能直接比较，因为在Integer会进行自动拆箱和装箱</span><br><span class="line">在Integer和<span class="type">int</span>进行比较的时候Integer会自动拆箱成<span class="type">int</span>类型</span><br></pre></td></tr></table></div></figure>




        <h1 id="Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？"   >
          <a href="#Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？" class="headerlink" title="Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？"></a>Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer底层有一个<span class="type">int</span>的缓冲数组，缓冲数组的范围是负<span class="number">128</span>到正<span class="number">127</span>，在这个范围里会直接找到缓冲区的地址</span><br><span class="line">在缓冲数据的边界也能进行直接比较的</span><br></pre></td></tr></table></div></figure>




        <h1 id="和equals方法的区别"   >
          <a href="#和equals方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#和equals方法的区别" class="headerlink" title="&#x3D;&#x3D;和equals方法的区别"></a>&#x3D;&#x3D;和equals方法的区别</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==在比较基本数据类型的时候比较的是具体的值,而在比较引用数据类型的时候比较两边的地址值</span><br><span class="line">equals方法比较的是两边的属性值</span><br></pre></td></tr></table></div></figure>




        <h1 id="有了解过Volatile关键字吗？"   >
          <a href="#有了解过Volatile关键字吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过Volatile关键字吗？" class="headerlink" title="有了解过Volatile关键字吗？"></a>有了解过Volatile关键字吗？</h1>
      
        <h1 id="说说SpringMVC的执行流程"   >
          <a href="#说说SpringMVC的执行流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说SpringMVC的执行流程" class="headerlink" title="说说SpringMVC的执行流程"></a>说说SpringMVC的执行流程</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP请求会发送到DispatcherServlet(前端控制器)中然后DisPatcherServlet会通过url找到HandlerMapping(处理器映射器)获得映射，HandlerMapping会将这个hander处理器和拦截器一起发送回DisPatcherServlet中，DisPatcherServlet会通过映射查到HandleAdapter(处理器适配器),HandleAdapater会找到具体的Handle,然后将Handle传回来的ModelandView传回给DisPatcherServlet，DisPachthersevlet去找View <span class="title function_">Reslover</span><span class="params">(视图解析器)</span>,View Reslover会将解析出来的View返回给DisPachterServlet，然后DisPachter再渲染反映给前端</span><br><span class="line">而现在一般是面向接口编程，我们不用返回View而是Handle通过ResponBody注解再通过(HttpMessageConverter)消息转化器返回一个Json格式的数据就可以了</span><br></pre></td></tr></table></div></figure>




        <h1 id="ArrayList-线程安全吗？Vector-呢？那并发性能高的-ArrayList-是什么？"   >
          <a href="#ArrayList-线程安全吗？Vector-呢？那并发性能高的-ArrayList-是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayList-线程安全吗？Vector-呢？那并发性能高的-ArrayList-是什么？" class="headerlink" title="ArrayList 线程安全吗？Vector 呢？那并发性能高的 ArrayList 是什么？"></a>ArrayList 线程安全吗？Vector 呢？那并发性能高的 ArrayList 是什么？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList线程不安全，而Vector是线程安全的，</span><br><span class="line">ArrayList底层是Object数组，默认初始化的数组长度为<span class="number">10</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="线程池有用过吗？有哪些参数？"   >
          <a href="#线程池有用过吗？有哪些参数？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池有用过吗？有哪些参数？" class="headerlink" title="线程池有用过吗？有哪些参数？"></a>线程池有用过吗？有哪些参数？</h1>
      
        <h1 id="线程池如何配置？有什么策略策略？"   >
          <a href="#线程池如何配置？有什么策略策略？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何配置？有什么策略策略？" class="headerlink" title="线程池如何配置？有什么策略策略？"></a>线程池如何配置？有什么策略策略？</h1>
      
        <h1 id="讲讲-ThreadPoolExecutor-的七个参数？怎么配置？"   >
          <a href="#讲讲-ThreadPoolExecutor-的七个参数？怎么配置？" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲-ThreadPoolExecutor-的七个参数？怎么配置？" class="headerlink" title="讲讲 ThreadPoolExecutor 的七个参数？怎么配置？"></a>讲讲 ThreadPoolExecutor 的七个参数？怎么配置？</h1>
      
        <h1 id="能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？"   >
          <a href="#能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？" class="headerlink" title="能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？"></a>能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？</h1>
      
        <h1 id="普通For、增强For和ForEach的区别"   >
          <a href="#普通For、增强For和ForEach的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通For、增强For和ForEach的区别" class="headerlink" title="普通For、增强For和ForEach的区别"></a>普通For、增强For和ForEach的区别</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通For是通过索引I来获得元素，而增强For是通过迭代器来获得元素</span><br><span class="line">ForEach就是增强For</span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="未整理区"   >
          <a href="#未整理区" class="heading-link"><i class="fas fa-link"></i></a><a href="#未整理区" class="headerlink" title="未整理区"></a>未整理区</h1>
      
        <h2 id="与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程"   >
          <a href="#与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程" class="headerlink" title="&#x3D;&#x3D;与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程"></a>&#x3D;&#x3D;与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程</h2>
      
        <h2 id="Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景-排行榜，实时排名，去重统计"   >
          <a href="#Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景-排行榜，实时排名，去重统计" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景-排行榜，实时排名，去重统计" class="headerlink" title="Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景(排行榜，实时排名，去重统计)"></a>Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景(排行榜，实时排名，去重统计)</h2>
      
        <h2 id="你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。"   >
          <a href="#你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。" class="heading-link"><i class="fas fa-link"></i></a><a href="#你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。" class="headerlink" title="你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。"></a>你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。</h2>
      
        <h2 id="什么是回表？"   >
          <a href="#什么是回表？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h2>
      
        <h2 id="MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题"   >
          <a href="#MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题" class="headerlink" title="MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题"></a>MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题</h2>
      
        <h2 id="编程题：输入一个整数，转为二进制，并求出1个个数。"   >
          <a href="#编程题：输入一个整数，转为二进制，并求出1个个数。" class="heading-link"><i class="fas fa-link"></i></a><a href="#编程题：输入一个整数，转为二进制，并求出1个个数。" class="headerlink" title="编程题：输入一个整数，转为二进制，并求出1个个数。"></a>编程题：输入一个整数，转为二进制，并求出1个个数。</h2>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/12/MySql%E9%9D%A2%E8%AF%95%E9%A2%98/">MySql面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-12</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">4.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">23分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="InnoDb和MyIsam的区别"   >
          <a href="#InnoDb和MyIsam的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#InnoDb和MyIsam的区别" class="headerlink" title="InnoDb和MyIsam的区别"></a>InnoDb和MyIsam的区别</h1>
      <p>我答:</p>
<p>MySql5以后默认的引擎是InnoDB,InnoDB支持行锁、事务</p>
<p>MyIsam主要在内存中，不支持事务</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主要从四个方面来区别</span><br><span class="line">InnoDB支持事务、行级锁、外键</span><br><span class="line">而Myisam不支持事务、行级锁、外键</span><br><span class="line"></span><br><span class="line">存储结构的不同</span><br><span class="line">    </span><br><span class="line">InnoDB的存储方式是索引和数据存放在.idb文件中</span><br><span class="line">myisam的存储是索引和数据分开存放 索引存在.MYI中 数据存在.MYD中</span><br></pre></td></tr></table></div></figure>


        <h1 id="介绍一下Mysql中事务的特性"   >
          <a href="#介绍一下Mysql中事务的特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Mysql中事务的特性" class="headerlink" title="介绍一下Mysql中事务的特性"></a>介绍一下Mysql中事务的特性</h1>
      <p>我答:mySql的事务主要有四个特性 ACID</p>
<p>1.原子性2.一致性3.隔离性4.。。。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">事务是一组操作的集合，它是一个不可分割的操作单元，当事务提交之后，这些操作要么同时成功要么同时失败</span><br><span class="line">事务有四个特性即ACID</span><br><span class="line"><span class="number">1.</span>原子性:表示事务是不可分割的操作单元，事务内的操作要么全部被执行要么全部不被执行</span><br><span class="line"><span class="number">2.</span>一致性:事务完成时，所有数据必须保持一致状态，主要是约束一致性和数据一致性</span><br><span class="line"><span class="number">3.</span>隔离性:数据库提供的隔离机制，保证一个事务内部是对其他并发事务隔离的</span><br><span class="line"><span class="number">4.</span>持久性:当事务一旦提交,它对数据库中数据改变应该是永久的</span><br><span class="line">实现事务的原子性和一致性依赖于undo log日志 而事务的持久性依赖于redo log日志</span><br><span class="line">就举一个转账的例子:当A向B转账<span class="number">500</span>元时，原子性提现在A和B操作要么同时成功要么同时失败，而一致性表现在当A减少<span class="number">500</span>元B就必须要增加<span class="number">500</span>元保证数据的一致，隔离性表现在A像B转账的时候不会受到其他事务的影响，而持久性体现在一旦转账成功，数据修改就是永久性的。</span><br></pre></td></tr></table></div></figure>


        <h1 id="并发事务会带来哪些问题？"   >
          <a href="#并发事务会带来哪些问题？" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发事务会带来哪些问题？" class="headerlink" title="并发事务会带来哪些问题？"></a>并发事务会带来哪些问题？</h1>
      <p>我答：1.脏读2.不可重复读3.幻读</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务并发操作可能会带来有四个问题</span><br><span class="line"><span class="number">1.</span>更新丢失:更新丢失又分为两种一种是回滚覆盖，一种是更新覆盖，我们解决更新丢失一般采用乐观锁的思想加入版本号</span><br><span class="line"><span class="number">2.</span>脏读:脏读指一个事务读到了另一个事务还未提交的数据，那么读到的数据就是脏数据</span><br><span class="line"><span class="number">3.</span>不可重复读:不可重复读意思是当事务多次读取同一行数据时，前后读到的数据不一致</span><br><span class="line"><span class="number">4.</span>幻读:幻读指的是在事务按照相同条件查询，而前后查询到的数据行数的不一致，通常是当插入操作时查询数据不存在而当执行插入操作时数据又存在了。</span><br></pre></td></tr></table></div></figure>


        <h1 id="并发事务带来的更新丢失是什么"   >
          <a href="#并发事务带来的更新丢失是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发事务带来的更新丢失是什么" class="headerlink" title="并发事务带来的更新丢失是什么?"></a>并发事务带来的更新丢失是什么?</h1>
      <p>我答:在并发操作下，可能会产生数据覆盖的情况，导致前一个线程的数据被覆盖也就是更新丢失了</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">更新丢失是当多个事务更新同一行数据的时候可能产生的数据丢失现象，更新丢失分为两钟：</span><br><span class="line">    一种是回滚覆盖，一种是更新覆盖</span><br><span class="line">    回滚覆盖：当事务进行回滚操作时，把其他事务提交的数据给覆盖了</span><br><span class="line">    更新覆盖：当事务进行更新操作时，把其他事务提交的数据给覆盖了 【例如一个更新年龄一个更新金额，后提交的会把前一个给覆盖了】</span><br><span class="line">    </span><br><span class="line">我们解决更新丢失是采用乐观锁的机制，方案是版本号，通过版本号确认是否数据被修改过</span><br></pre></td></tr></table></div></figure>


        <h2 id="读未提交怎么解决回滚覆盖问题"   >
          <a href="#读未提交怎么解决回滚覆盖问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#读未提交怎么解决回滚覆盖问题" class="headerlink" title="读未提交怎么解决回滚覆盖问题"></a>读未提交怎么解决回滚覆盖问题</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">读未提交的机制主要是引入排它锁和共享锁</span><br><span class="line"></span><br><span class="line">当事务开启之后，对一条数据进行修改则会引入一个共享读锁和排他写锁，所以可以避免回滚覆盖</span><br><span class="line"></span><br><span class="line">回滚覆盖案例</span><br><span class="line">例如事务A和事务B都要对同一行数据进行修改，假设数据金额为<span class="number">100</span></span><br><span class="line">---------------</span><br><span class="line">事务A开启   				数据金额为<span class="number">100</span></span><br><span class="line">事务B开启	并将数据改为<span class="number">120</span></span><br><span class="line">事务B提交					数据金额为<span class="number">120</span></span><br><span class="line">事务A回滚					数据金额为<span class="number">100</span></span><br><span class="line">这样两个事务结束最终的金额到了<span class="number">100</span>,事务A回滚导致了事务B的更新丢失</span><br><span class="line"></span><br><span class="line">读未提交的情况下</span><br><span class="line">--------------</span><br><span class="line">事务A开启					数据金额为<span class="number">100</span></span><br><span class="line">事务B开启						</span><br><span class="line">事务B修改数据,将金额改为<span class="number">120</span>,同时添加了一个排他写锁    </span><br><span class="line">事务A想要修改数据，则会被排斥</span><br><span class="line">事务B释放排它锁			  数据金额为<span class="number">120</span></span><br><span class="line">事务B提交					数据金额为<span class="number">120</span>    </span><br><span class="line">事务A想要修改数据金额的时候    读取到的数据为<span class="number">120</span></span><br><span class="line">于是当事务A回滚			  回滚数据依然是<span class="number">120</span></span><br><span class="line"></span><br><span class="line">读未提交级别解决了回滚丢失的现象</span><br></pre></td></tr></table></div></figure>


        <h2 id="读未提交和读已提交为什么能解决回滚覆盖而解决不了提交覆盖？"   >
          <a href="#读未提交和读已提交为什么能解决回滚覆盖而解决不了提交覆盖？" class="heading-link"><i class="fas fa-link"></i></a><a href="#读未提交和读已提交为什么能解决回滚覆盖而解决不了提交覆盖？" class="headerlink" title="读未提交和读已提交为什么能解决回滚覆盖而解决不了提交覆盖？"></a>读未提交和读已提交为什么能解决回滚覆盖而解决不了提交覆盖？</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">读未提交和读已提交解决回滚覆盖而无法解决提交覆盖</span><br><span class="line">解决回滚覆盖主要是依赖于排他锁和共享锁</span><br><span class="line"></span><br><span class="line">无法解决提交覆盖</span><br><span class="line">提交覆盖案例</span><br><span class="line">例如事务A和事务B都要对同一行数据进行修改，假设数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">------------</span><br><span class="line">事务A开启					数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">事务B开启	修改金额为<span class="number">120</span>	</span><br><span class="line">事务B提交					数据金额为<span class="number">120</span>，年龄为<span class="number">50</span></span><br><span class="line">事务A修改	修改年龄为<span class="number">70</span></span><br><span class="line">事务A提交					数据金额为<span class="number">100</span>，年龄为<span class="number">70</span></span><br><span class="line">这样两个事务结束最终的金额到了<span class="number">100</span>,事务A的提交导致了事务B的更新丢失(事务B更新金额被丢失了)</span><br><span class="line">    </span><br><span class="line">读已提交的情况下</span><br><span class="line">--------------</span><br><span class="line">事务A开启					数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">事务B开启						</span><br><span class="line">事务B修改数据,将金额改为<span class="number">120</span>,同时添加了一个排他写锁    将金额<span class="number">120</span>，年龄<span class="number">50</span>写入undo_log中</span><br><span class="line">事务A想要修改数据，则会被排斥，且因为MVCC机制事务只能读取到已经提交的事务</span><br><span class="line">事务B释放排它锁			  数据金额为<span class="number">100</span>，年龄<span class="number">50</span>   				</span><br><span class="line">事务A修改年龄为<span class="number">70</span>		      将金额<span class="number">100</span>，年龄<span class="number">70</span>写入undo_log</span><br><span class="line">事务B提交					提交根据B的undo_log版本数据的金额为<span class="number">120</span>，年龄<span class="number">50</span></span><br><span class="line">于是当事务A提交			  提交根据A的undo_log版本数据的金额是<span class="number">100</span>，年龄<span class="number">70</span></span><br><span class="line"></span><br><span class="line">事务A的提交了之后redoLogBuffer中的数据刷到硬盘中,最终的数据是金额<span class="number">100</span>，年龄<span class="number">70</span>而覆盖了事务B的提交</span><br><span class="line">读未提交和读已提交都无法解决提交覆盖的问题</span><br></pre></td></tr></table></div></figure>


        <h2 id="可重复读怎么解决提交覆盖的问题？"   >
          <a href="#可重复读怎么解决提交覆盖的问题？" class="heading-link"><i class="fas fa-link"></i></a><a href="#可重复读怎么解决提交覆盖的问题？" class="headerlink" title="可重复读怎么解决提交覆盖的问题？"></a>可重复读怎么解决提交覆盖的问题？</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">读未提交和读已提交解决回滚覆盖而无法解决提交覆盖，解决回滚覆盖主要是依赖于排他锁和共享锁</span><br><span class="line">而可重复读和串行化可以解决提交覆盖问题</span><br><span class="line">    </span><br><span class="line">提交覆盖案例</span><br><span class="line">例如事务A和事务B都要对同一行数据进行修改，假设数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">------------</span><br><span class="line">事务A开启					数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">事务B开启	修改金额为<span class="number">120</span>	</span><br><span class="line">事务B提交					数据金额为<span class="number">120</span>，年龄为<span class="number">50</span></span><br><span class="line">事务A修改	修改年龄为<span class="number">70</span></span><br><span class="line">事务A提交					数据金额为<span class="number">100</span>，年龄为<span class="number">70</span></span><br><span class="line">这样两个事务结束最终的金额到了<span class="number">100</span>,事务A的提交导致了事务B的更新丢失(事务B更新金额被丢失了)</span><br><span class="line">    </span><br><span class="line">可重复读级别下</span><br><span class="line">例如事务A和事务B都要对同一行数据进行修改，假设数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">------------</span><br><span class="line">事务A开启	查询数据	  快照版本金额为<span class="number">100</span>，年龄<span class="number">50</span>	实际数据金额为<span class="number">100</span>，年龄为<span class="number">50</span></span><br><span class="line">事务B开启	查询数据      快照版本金额为<span class="number">100</span>，年龄<span class="number">50</span>	</span><br><span class="line">事务B修改，修改金额为<span class="number">120</span>  快照版本金额为<span class="number">100</span>，年龄<span class="number">50</span> 实际数据金额为<span class="number">100</span>，年龄为<span class="number">50</span>  undo_log版本链中的数据金额为<span class="number">120</span>，年龄<span class="number">50</span></span><br><span class="line">事务B提交  将undo_log中的数据写入到redo_log		 实际数据金额为<span class="number">120</span>，年龄<span class="number">50</span></span><br><span class="line">事务A查询				快照数据依然为金额<span class="number">100</span>，年龄<span class="number">50</span>  实际数据金额为<span class="number">120</span>，年龄<span class="number">50</span></span><br><span class="line">事务A修改，修改年龄为<span class="number">70</span>	</span><br><span class="line">    修改操作是当前读，那么undo_log在修改之前的数据是金额<span class="number">120</span>，年龄<span class="number">50</span> </span><br><span class="line">    修改之后undo_log版本链中的数据是金额<span class="number">120</span>，年龄<span class="number">70</span></span><br><span class="line">事务A提交				undo_log版本链中的数据金额为<span class="number">120</span>，年龄<span class="number">70</span>，所以最终提交的金额是<span class="number">120</span>，年龄<span class="number">70</span></span><br><span class="line">    </span><br><span class="line"> 于是可重复读可以解决提交覆盖的问题，依赖于MVCC机制和锁</span><br></pre></td></tr></table></div></figure>




        <h1 id="事务隔离级别有哪些？MySql默认的事务隔离级别是哪个"   >
          <a href="#事务隔离级别有哪些？MySql默认的事务隔离级别是哪个" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务隔离级别有哪些？MySql默认的事务隔离级别是哪个" class="headerlink" title="事务隔离级别有哪些？MySql默认的事务隔离级别是哪个"></a>事务隔离级别有哪些？MySql默认的事务隔离级别是哪个</h1>
      <p>我答:读未提交、读已提交(RC)、可重复读(RR)、串行化</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务隔离级别有四个：</span><br><span class="line"><span class="number">1.</span>读未提交：脏读、不可重复读、幻读都没有解决</span><br><span class="line"><span class="number">2.</span>读已提交：解决了脏读的问题，没有解决不可重复读、幻读</span><br><span class="line"><span class="number">3.</span>可重复读：解决了脏读、不可重复读的问题，没有解决幻读的现象，这是MySql默认的事务级别</span><br><span class="line"><span class="number">4.</span>串行化：解决了脏读、不可重复读、幻读，但是因为事务是串行执行(排队)，所以性能较差</span><br></pre></td></tr></table></div></figure>

<div class="table-container"><table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">回滚覆盖</th>
<th align="center">提交覆盖</th>
<th align="center">幻读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交（READ UNCOMMITTED）</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交（READ COMMITTED）</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读（REPEATABLE READ)</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">串行化  （SERIALIZABLE）</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table></div>

        <h1 id="Redo-Log和Undo-Log的区别"   >
          <a href="#Redo-Log和Undo-Log的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redo-Log和Undo-Log的区别" class="headerlink" title="Redo Log和Undo Log的区别"></a>Redo Log和Undo Log的区别</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redo Log:当数据发生变化的时，redo log buffer会先将数据写入到redo log file中，当数据库宕机时可以冲redo log file中恢复数据</span><br><span class="line">undo log:记录的是数据的逻辑日志，他主要的作用在提供回滚和MVCC中。当日志执行回滚操作的时候读取undo log来回滚到之前的数据</span><br><span class="line">    </span><br><span class="line">redo log保证了事务的持久性，而undo log保证了事务的原子性和一致性</span><br></pre></td></tr></table></div></figure>


        <h1 id="事务的隔离性是怎么保证的-（说说MVCC机制的理解）"   >
          <a href="#事务的隔离性是怎么保证的-（说说MVCC机制的理解）" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务的隔离性是怎么保证的-（说说MVCC机制的理解）" class="headerlink" title="事务的隔离性是怎么保证的?（说说MVCC机制的理解）"></a>事务的隔离性是怎么保证的?（说说MVCC机制的理解）</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">事务的隔离性主要是依靠锁+MVCC机制的实现</span><br><span class="line">其中MVCC指的是多版本并发空值，MVCC实现主要是有三个部分</span><br><span class="line">    第一个部分是隐藏字段，在Mysql中会有三个隐藏字段<span class="number">1.</span>事务ID(trx_id)<span class="number">2.</span>回滚指针(roll_pointer)<span class="number">3.</span>隐式主键(ROW_id)</span><br><span class="line">    第二个部分是undo log版本链，每个数据都有多个版本，多版本之间通过undo log链进行链接，链头是最新版本即最新数据，链尾是最老版本即最老数据</span><br><span class="line">    第三部分是Read View，ReadView解决的是一个事务选择的哪个版本的问题，而不同隔离级别的快照读也不同，RC级别下每一条Select语句都会生成ReadView 而RR级别只会在第一次执行Select生成ReadView然后后面复用这个ReadView，所以RR解决了不可重复读的问题，而RC没有解决不可重复读的问题</span><br></pre></td></tr></table></div></figure>


        <h1 id="说说MySql的主从复制"   >
          <a href="#说说MySql的主从复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说MySql的主从复制" class="headerlink" title="说说MySql的主从复制"></a>说说MySql的主从复制</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MySql的主从搭建主要的用途：</span><br><span class="line"><span class="number">1.</span>实时灾备，用于故障切换</span><br><span class="line"><span class="number">2.</span>读写分离</span><br><span class="line"><span class="number">3.</span>用于数据备份</span><br><span class="line"></span><br><span class="line">MySql的主从复制的实现主要是以下三个步骤</span><br><span class="line"><span class="number">1.</span>主库开启了Binlog日志，当事务提交的时候会将记录在二进制日志文件binlog中</span><br><span class="line"><span class="number">2.</span>从库的IOthread读取到主库的BinLog日志的信息写到自己的中继日志 relay Log中</span><br><span class="line"><span class="number">3.</span>从库从relay Log进行数据的重做</span><br></pre></td></tr></table></div></figure>


        <h1 id="你们项目中有没有使用过分库分表呢"   >
          <a href="#你们项目中有没有使用过分库分表呢" class="heading-link"><i class="fas fa-link"></i></a><a href="#你们项目中有没有使用过分库分表呢" class="headerlink" title="你们项目中有没有使用过分库分表呢?"></a>你们项目中有没有使用过分库分表呢?</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">分库分表主要是因为单机存储达到瓶颈或者连接数，处理能力达到上限才需要用到</span><br><span class="line">我项目中没有用到分库分表[当单表数据量超过1000w或者20G时可以考虑分库分表]</span><br><span class="line">而对数据库优化这方面我学习到了分库分表的思想</span><br><span class="line"></span><br><span class="line">分库分表就是把一个数据库的数据分散存放到多个数据库上，分库分表包括垂直分库、垂直分表、水平分库、水平分表这四部分</span><br><span class="line"><span class="number">1.</span>垂直分库，将一个数据库按照业务不同来进行分库，将不同业务的表分布到不同数据库中</span><br><span class="line"><span class="number">2.</span>垂直分库，将一个数据库的表按照字段分表，不同字段分到不同表中</span><br><span class="line"><span class="number">3.</span>水平分库，将一个数据库的表，分散到不同数据库中【表结构一样数据不一样】</span><br><span class="line"><span class="number">4.</span>水平分表，将一个表的数据，分散到不同的表中【可以是同一个数据库中】</span><br></pre></td></tr></table></div></figure>


        <h1 id="说说数据库中锁的种类"   >
          <a href="#说说数据库中锁的种类" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说数据库中锁的种类" class="headerlink" title="说说数据库中锁的种类"></a>说说数据库中锁的种类</h1>
      
        <h1 id="我们如何定位慢查询"   >
          <a href="#我们如何定位慢查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#我们如何定位慢查询" class="headerlink" title="我们如何定位慢查询"></a>我们如何定位慢查询</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>我们可以开启MySql的慢查询日志，我们通过查看慢查询日志的信息可以知道慢查询的情况</span><br><span class="line"><span class="number">2.</span>通过show profile命令可以知道每一条SQL的执行耗时的基本情况，然后通过show profile <span class="keyword">for</span> query query_id 查询到指定的SQL各个阶段的耗时情况</span><br><span class="line"><span class="number">3.</span>通过在SQL语句前面添加explain关键字，查询当前sql的执行计划,可以通过key和key_len字段知道是否有命中索引，索引是否失效，通过type字段查看是否有优化空间，是否存在全盘扫描或者全索引扫描，通过extra字段知道是否有回表</span><br></pre></td></tr></table></div></figure>


        <h1 id="什么是聚簇索引和非聚簇索引"   >
          <a href="#什么是聚簇索引和非聚簇索引" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是聚簇索引和非聚簇索引" class="headerlink" title="什么是聚簇索引和非聚簇索引"></a>什么是聚簇索引和非聚簇索引</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">聚簇索引主要是数据和索引放在一起，索引结构的叶子结点保存了行数据。一般情况下是主键作为聚簇索引</span><br><span class="line">非聚簇索引就是数据和索引分开存放的，叶子结点存放的是对应主键的位置，我们创建的索引通常都是非聚簇索引</span><br></pre></td></tr></table></div></figure>


        <h1 id="什么是回表查询"   >
          <a href="#什么是回表查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是回表查询" class="headerlink" title="什么是回表查询"></a>什么是回表查询</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过非聚簇索引找到的数据不够，要通过主键值返回去查询聚簇索引获得整个行数据这个情况就是回表查询</span><br></pre></td></tr></table></div></figure>


        <h1 id="什么是覆盖索引？"   >
          <a href="#什么是覆盖索引？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">覆盖索引指的是在查询时使用了索引，并且需要返回的列，在本次查找中可以全部找到。可以不用通过回表查询，这样能显著提高性能</span><br></pre></td></tr></table></div></figure>


        <h1 id="什么情况下会造成索引失效？"   >
          <a href="#什么情况下会造成索引失效？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么情况下会造成索引失效？" class="headerlink" title="什么情况下会造成索引失效？"></a>什么情况下会造成索引失效？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>使用联合索引违背了最左前缀法则.</span><br><span class="line"><span class="number">2.</span>字符串没有加单引号，会导致类型转化造成了索引失效</span><br><span class="line"><span class="number">3.</span>在索引列上进行了运算操作，会导致索引失效</span><br><span class="line"><span class="number">4.</span>使用了模糊匹配，如果仅仅是尾部模糊匹配索引不会失效，而使用了头部模糊匹配索引会失效、</span><br><span class="line"><span class="number">5.</span>使用了or关键字，or条件一侧有索引一侧没有索引会造成索引失效，而两侧都有索引则不会失效</span><br><span class="line"><span class="number">6.</span>数据分布造成影响，如果使用索引比走全表扫描还慢则不会使用索引</span><br><span class="line"><span class="number">7.</span>范围查询右边的列索引会失效 如使用&lt;,&gt;则右边的列会失效</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="数据库优化"   >
          <a href="#数据库优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySql优化我觉得主要从两个部分</span><br></pre></td></tr></table></div></figure>


        <h2 id="设计层面进行优化"   >
          <a href="#设计层面进行优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#设计层面进行优化" class="headerlink" title="设计层面进行优化"></a>设计层面进行优化</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>可以使用MySql主从集群，可以防止单个MySql宕机导致服务不可用，搭建集群可以保证服务的高可用</span><br><span class="line"><span class="number">2.</span>可以使用主从结构，进行读写分离</span><br><span class="line"><span class="number">3.</span>可以使用分库分表的思想，降低单个服务器节点上的IO压力</span><br></pre></td></tr></table></div></figure>


        <h2 id="SQL优化"   >
          <a href="#SQL优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>查询尽量使用索引来进行数据扫描</span><br><span class="line"><span class="number">2.</span>join优化，尽量使用inner join而不使用left join和right join 如果必须要用，则一定要以小表驱动</span><br><span class="line"><span class="number">3.</span>联合查询尽量用union all 替代union    union会多一次过滤操作，降低性能</span><br><span class="line"><span class="number">4.</span>插入数据的时候，批量插入，顺序插入 如果要大批量插入使用load命令</span><br><span class="line"><span class="number">5.</span>主键优化，主键长度尽量短、顺序插入</span><br><span class="line"><span class="number">6.</span>limit优化 使用覆盖索引+子查询</span><br><span class="line"><span class="number">7.</span>count优化 count(<span class="number">1</span>)≈count(*)&gt;count(主键id)&gt;count(字段)</span><br><span class="line"><span class="number">8.</span>update优化 尽量根据主键\索引更新数据  防止行锁升级成表锁java</span><br><span class="line"><span class="number">9.</span>group by  索引，多字段满足最左前缀法则</span><br><span class="line"><span class="number">10.</span>order by 直接通过索引返回数据</span><br></pre></td></tr></table></div></figure>


        <h1 id="为什么MySql用B-树不用跳表？"   >
          <a href="#为什么MySql用B-树不用跳表？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么MySql用B-树不用跳表？" class="headerlink" title="为什么MySql用B+树不用跳表？"></a>为什么MySql用B+树不用跳表？</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/11/SpringBoot%E9%9D%A2%E8%AF%95%E9%A1%8C/">SpringBoot面试題</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-11</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">367</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">2分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="SpringBoot的核心配置类"   >
          <a href="#SpringBoot的核心配置类" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringBoot的核心配置类" class="headerlink" title="SpringBoot的核心配置类"></a>SpringBoot的核心配置类</h1>
      <p>我答:</p>
<p>@AutoWired</p>
<p>@Resouce</p>
<p>@RequestMapping</p>
<p>@RestController</p>
<p>@Configuration</p>
<p>@Bean</p>
<p>@Service</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplicaion 标志这个类是个SpringBoot启动类</span><br><span class="line">@SpringBootConfiguration 这个注解被@Configuration注解标记着 意味着这个类就是个配置类</span><br><span class="line">@EnableAutoConfiguration 这个注解向Spring容器注入一个Selector，用来加载SpringBoot自动配置类，最后自动加载为配置Bean</span><br><span class="line">@Conditional...</span><br><span class="line">		例如@ConditionalOnBean  当有这个Bean对象的时候创建</span><br><span class="line">		   @ConditionalOnMissingBean 当没有这个Bean对象的时候创建</span><br><span class="line">			...</span><br></pre></td></tr></table></div></figure>

<p>​	</p>

        <h1 id="SpringBoot的自动配置原理"   >
          <a href="#SpringBoot的自动配置原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringBoot的自动配置原理" class="headerlink" title="SpringBoot的自动配置原理"></a>SpringBoot的自动配置原理</h1>
      <p>我答：</p>
<p>Spring启动的时候会解读@EnableAutoConfiguration注解，这里有个@Import注解主要导入到IOC容器管理中，底层有个@defforImportSelector为底层注入自动配置</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">通过@SpringBootConfiguration注解导入了@EnableAutoConfiguration注解</span><br><span class="line">@EnableAutoConfiguration注解导入了@Import注解</span><br><span class="line">Spring启动的时候加载IOC容器就会解析@Import注解</span><br><span class="line">@import注解导入了@deferredImportSelector注解(它会将SpringBoot自动配置的类放到最后，方便我们自己的Bean类覆盖)</span><br><span class="line">通过读取/META-INF/spring.factors文件</span><br><span class="line">读取到所有的AutoConfigurationClass类型的类</span><br><span class="line">最后通过@ConditionalOn...注解排除无效的自动配置类</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="Spring和SpringBoot的区别和关系"   >
          <a href="#Spring和SpringBoot的区别和关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring和SpringBoot的区别和关系" class="headerlink" title="Spring和SpringBoot的区别和关系"></a>Spring和SpringBoot的区别和关系</h1>
      <p>我答:</p>
<p>SpingBoot就是简易的Spring，基于SpringBoot能快速构成一个Spring框架的项目</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringBoot是Spring生态的一个产品</span><br><span class="line">Spring Framework是一个框架</span><br><span class="line">SpringBoot不是一个框架，SpringBoot可以快速构建基于Spring框架的脚手架(包括了Spring和其他框架)，为开发Spring生态其他框架铺平道路</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/11/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/">Redis面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-11</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">21分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>#复习用   </p>

        <h1 id="布隆过滤器有了解过吗？"   >
          <a href="#布隆过滤器有了解过吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#布隆过滤器有了解过吗？" class="headerlink" title="布隆过滤器有了解过吗？"></a>布隆过滤器有了解过吗？</h1>
      <p>我答:Bloom过滤器主要是BitMap的这种0101的位图，主要作用是做一个白名单的过滤，当请求打进来的时候去查找白名单这个数据是否为1如果是1的话则放行如果是0的话则将数据返回</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">布隆过滤器是一些由0101构成的位图，通过它自身的Hash算法把数据存入多个位置将其置位1，当查询这个数据的时候这些位同时都为1的时候说明数据可能存在，而这些位有一个不为1则说明该数据不存在</span><br><span class="line"></span><br><span class="line">优点：1.他是一串二进制数组组成的所以占用空间小</span><br><span class="line">	 2.hash速度快，查询速度也快，时间复杂度为O(k),k为K个哈希函数，原因是底层都是01的数组 只要知道偏移量就很快知道是否为1</span><br><span class="line">	 3.数据的加密性，数据只有0和1 所以别人不知道这个数据代表着什么意思</span><br><span class="line">	 </span><br><span class="line">缺点:</span><br><span class="line">	 1.不易于删除 有可能一个位对应多个数据，存在误判</span><br></pre></td></tr></table></div></figure>


        <h1 id="Redis为什么这么快"   >
          <a href="#Redis为什么这么快" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h1>
      <p>我答: 第一、Redis是内存中的一种存放Key-Value值的NoSql数据库，因为它在内存中所以他的运行速度较快</p>
<p>​		 第二、Redis是单线程的，所有操作都是单线程处理的，所以Redis自己处理业务逻辑的时候不用上锁所以速度快		 </p>
<p>​         第三、Redis因为有IO的多路复用则能高效的提升Redis的运行效率</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、Redis是在内存中的 没有额外的磁盘IO上面的开销</span><br><span class="line">2、Redis是单线程的，没有多个线程的切换上下文和锁的限制</span><br><span class="line">3、Redis是多路IO复用，用一个线程来轮询多个时间描述符</span><br><span class="line">4、Redis底层对数据结构进行了优化</span><br></pre></td></tr></table></div></figure>




        <h1 id="缓存穿透、雪崩、击穿、预热"   >
          <a href="#缓存穿透、雪崩、击穿、预热" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存穿透、雪崩、击穿、预热" class="headerlink" title="缓存穿透、雪崩、击穿、预热"></a>缓存穿透、雪崩、击穿、预热</h1>
      <p>我答:</p>
<p>缓存穿透：在Redis没有数据并且在MySql也没有数据，非法人员利用这个漏洞不断把请求打到MySql中导致MySql的性能降低</p>
<p>解决方案: 1.返回空值 2.利用布隆过滤器对其筛选  3.利用分布式锁</p>
<p>缓存雪崩：大量热点Key的同时失效或者是Redis单机宕机导致的大量请求打到MySql中</p>
<p>解决方案：1.部署集群防止Redis单机宕机造成的影响 2.分散设置Key的过期时间，不要同时过期</p>
<p>缓存击穿：某个热点Key的突然失效，导致请求直接打到MySql中 </p>
<p>解决方案：1.利用分布式锁</p>
<p>缓存预热：在服务还未提供之前将MySql的数据提前写入到Redis中 防止缓存击穿</p>
<p>​		 </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透：一个数据在Redis中没有在MySql中也没有则会多次反复的打到MySql服务器上，可能会造成MySql服务器的宕机</span><br><span class="line">	   	解决方案 </span><br><span class="line">	   		1.返回空值:将返回的空值写入Redis中 例如：Key =1 value =null </span><br><span class="line">	   		优点是操作简单 </span><br><span class="line">	   		缺点是大量为NUll的数据会占用内存 并且有可能会导致数据不一致[后期MySql存入了Key=1的值 但是Redis的值依旧是NULL]</span><br><span class="line">	    	2.利用Bloom过滤器 </span><br><span class="line">	    	3.利用分布式锁</span><br><span class="line">缓存雪崩:大量Key同时过期或者Redis宕机导致MySql一次性接入大量请求导致失效或者宕机</span><br><span class="line">		解决方案</span><br><span class="line">			1.将多个Key分开设置过期时间防止同时失效 </span><br><span class="line">			2.利用集群，防止单机的Redis宕机</span><br><span class="line">缓存击穿:一个热点Key的忽然失效导致大量请求打到MySql服务器中</span><br><span class="line">		解决方案</span><br><span class="line">			1.利用分布式锁 查询数据之后发现数据过期了,设置一个互斥锁,等待数据库将缓存写回Redis中，写回Redis之后再进行返回数据</span><br><span class="line">		   	特点是 高一致性、性能较差</span><br><span class="line">		    2.设置逻辑过期  Redis中不设置过期时间 但是会带有一个过期时间的字段 当查询这个字段过期了 会设置互斥锁对数据进行重新写回Redis。这个线程不用等数据的缓存更新而是直接返回过期的数据 。当更新完缓存之后的线程再查询这个数据时则返回最新的数据</span><br><span class="line">		    特点是 高可用、性能较好、可能会导致返回数据的不一致性</span><br></pre></td></tr></table></div></figure>


        <h1 id="LRU和LFU的实现原理"   >
          <a href="#LRU和LFU的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#LRU和LFU的实现原理" class="headerlink" title="LRU和LFU的实现原理"></a>LRU和LFU的实现原理</h1>
      <p>我答：</p>
<p>LRU是最少最近被使用到，LRU是淘汰最远未被使用的页</p>
<p>LFU是最近最低频次被使用到,而LFU是淘汰最少频率的页</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LRU用双向链表维护 头插法将最近使用到的放在头部，当需要淘汰老的数据的时候则在尾部的淘汰就可以了</span><br><span class="line">LFU是Redis Object 底层有一个计数器如最近被使用到则计数器重新置位1开始计数，则计数数值大的被淘汰</span><br></pre></td></tr></table></div></figure>


        <h1 id="Redis为什么要选择用单线程？"   >
          <a href="#Redis为什么要选择用单线程？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis为什么要选择用单线程？" class="headerlink" title="Redis为什么要选择用单线程？"></a>Redis为什么要选择用单线程？</h1>
      <p>Redis操作都是原子性的，单线程没有多线程这种切换线程的上下文和锁资源的抢夺</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis中CPU不是限制Redis的瓶颈，Redis的瓶颈可能是网络带宽或者是内存不足引起的，既然单线程容易处理业务逻辑，就不会使用到多线程了</span><br></pre></td></tr></table></div></figure>




        <h1 id="Redis底层对数据结构进行了哪方面的优化"   >
          <a href="#Redis底层对数据结构进行了哪方面的优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis底层对数据结构进行了哪方面的优化" class="headerlink" title="Redis底层对数据结构进行了哪方面的优化?"></a>Redis底层对数据结构进行了哪方面的优化?</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">【底层有封装Len长度 所以获得数据的数很快】</span><br><span class="line">1.String   底层是SDS 简单动态字符串 因为底层是c而c语言中没有字符串 字符串只是字符数组以&#x27;\0的方式结束的字符数组 所以redis底层自己封装了一个字符串</span><br><span class="line">有三个编码格式 1.int 2.embStr 3.raw</span><br><span class="line">当数字是int 当不是整数且字符数小于等于39则是embStr  当字符数大于39的时候是Raw</span><br><span class="line"></span><br><span class="line">2.Hash  底层是ZipList和HashTable【Redis6以前】 底层是Listpack和HashTable[Redis7以后]  </span><br><span class="line">当结点个数小于512个 并且每个结点长度小于64个时[默认]用ziplist 超过了就转成HashTable</span><br><span class="line">ZipList是连续的一串Node节点 每个节点会存放上一个节点的长度 因此会有连锁更新的现象[当第一个节点更新导致后面所有的节点都更新]</span><br><span class="line">Listpack是紧凑列表 不会记录上一个节点长度 只会记录当前节点长度</span><br><span class="line"></span><br><span class="line">3.list类型 底层是quicklist+ziplist【Redis6以前】 底层是quicklist+listpack[Redis7以后] </span><br><span class="line">quickList 是一个双向链表和压缩表</span><br><span class="line"></span><br><span class="line">4.set类型</span><br><span class="line">intset+HashTable 哈希表+整数集合</span><br><span class="line"></span><br><span class="line">5.zset类型 底层是zipList+skipList[Redis6以前] 底层是zipList+SkipList[Redis7以后]</span><br><span class="line">SkipList是跳表 跳表底层是链表+多级索引</span><br><span class="line">跳表的时间复杂度是O(LogN)</span><br><span class="line">最上层是 1个索引</span><br><span class="line">倒数第二层是两个索引</span><br><span class="line">倒数第三层是4个索引</span><br><span class="line">第一层是2的N次方-1个索引  所以一共树的高度是LogN</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="讲讲对Redis哈希分槽的理解"   >
          <a href="#讲讲对Redis哈希分槽的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲对Redis哈希分槽的理解" class="headerlink" title="讲讲对Redis哈希分槽的理解"></a>讲讲对Redis哈希分槽的理解</h1>
      <p>Redis分三个片区 总的片区为16384 在分成这么多片区的时候已经够Redis使用了。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis在集群的時候要对数据进行分片算法   要算出某个数据的槽位是多少即由这个槽位下的节点来管理数据</span><br><span class="line">slot = CRC（16）算法 % 16384；</span><br><span class="line">对集群中每个节点会率先对16384个槽位进行分配  然后哈希分片算法算出的是多少槽位就会在这个槽位下的节点管理</span><br></pre></td></tr></table></div></figure>


        <h1 id="讲讲Redis的过期键删除策略"   >
          <a href="#讲讲Redis的过期键删除策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲Redis的过期键删除策略" class="headerlink" title="讲讲Redis的过期键删除策略"></a>讲讲Redis的过期键删除策略</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定时删除：给Key设置一个过期时间，一旦这个过期时间到了就立即删除(立即删除)</span><br><span class="line">惰性删除：给Key设置一个过期时间，当Key过期之后不会主动删除而是等下次再被调用的时候再判断Key是否过期，如果过期了就删除并且返回空</span><br><span class="line">定期删除: 每隔一段时间执行删除过期键的操作，采用随机抽取的策略</span><br><span class="line"></span><br><span class="line">Redis采用了惰性删除+定期删除的策略</span><br></pre></td></tr></table></div></figure>




        <h1 id="讲讲Redis的淘汰算法策略"   >
          <a href="#讲讲Redis的淘汰算法策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲Redis的淘汰算法策略" class="headerlink" title="讲讲Redis的淘汰算法策略"></a>讲讲Redis的淘汰算法策略</h1>
      <p>   1.一有过期就删除  这样会大量占用Redis Redis大部分都用于删除Key值会影响性能</p>
<ol start="2">
<li><p>完全没有过期 因为内存是有限的，如果缓存一直不删除则会一直堆积在内存中</p>
<p>3.随机过期的值   这样会导致仍然有部分漏网之鱼未被删除</p>
</li>
<li><p>随机删除值    这样会导致有效Key的删除</p>
</li>
<li><p>LRU算法 删除最近最少被使用的Key</p>
</li>
<li><p>LFU算法 删除最近使用频率最小的Key</p>
</li>
</ol>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">定期删除+惰性删除配合使用</span><br><span class="line">定期删除：Redis定期检查Key的过期时间。 一旦发现过期的时候就删除 这个缺点是频繁扫描会降低性能</span><br><span class="line">惰性删除：Redis在要使用Key的时候检查是否过期，一旦过期就删除 这样的弊端是有些Key一直未被使用但是过期了会占用空间</span><br><span class="line"></span><br><span class="line">八大策略</span><br><span class="line">4(定期、LRU、LFU、随机)*2(过期不过期)</span><br><span class="line">1.不删除  内存不足时会直接报错</span><br><span class="line">2.定期删除过期</span><br><span class="line">3.利用LRU删除过期</span><br><span class="line">4.利用LRU删除【不论过期不过期】</span><br><span class="line">5.利用LFU删除过期</span><br><span class="line">6.利用LFU删除【不论过期不过期】</span><br><span class="line">7.随机删除过期</span><br><span class="line">8.随机删除【不论过期不过期】</span><br></pre></td></tr></table></div></figure>


        <h1 id="聊聊Redis怎么实现的IO多路复用"   >
          <a href="#聊聊Redis怎么实现的IO多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#聊聊Redis怎么实现的IO多路复用" class="headerlink" title="聊聊Redis怎么实现的IO多路复用"></a>聊聊Redis怎么实现的IO多路复用</h1>
      <p>Redis用一个文件监听器来监听多个网络IO，用Select+poll+Epoll函数进行IO多路复用</p>
<p>Redis用一个进程来监听多个网络IO，一旦有IO请求的时候则会唤醒线程用Epoll函数处理要有网络请求的IO，若没有请求时则会阻塞线程，这样可以减少无用的操作，提升效率</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis底层用文件事件处理器，监听多个Socket，根据Socket分发给不同的文件处理器</span><br><span class="line">Redis用一个进程来监听多个Socket，一旦有Socket时则会唤醒线程用Epoll函数，若没有请求时则会阻塞线程，这样可以减少无用的操作，提升效率</span><br></pre></td></tr></table></div></figure>




        <h1 id="为什么Key没有设置过期时间但是却被Redis删除了"   >
          <a href="#为什么Key没有设置过期时间但是却被Redis删除了" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么Key没有设置过期时间但是却被Redis删除了" class="headerlink" title="为什么Key没有设置过期时间但是却被Redis删除了"></a>为什么Key没有设置过期时间但是却被Redis删除了</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置了最大内存限制之后，超过限制容量可能触发了淘汰策略  </span><br><span class="line">可能是随机删除Key、利用LRU删除Key、利用LFU删除Key</span><br></pre></td></tr></table></div></figure>




        <h1 id="为什么Redis的哈希槽是16384个"   >
          <a href="#为什么Redis的哈希槽是16384个" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么Redis的哈希槽是16384个" class="headerlink" title="为什么Redis的哈希槽是16384个"></a>为什么Redis的哈希槽是16384个</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为16384/8/=2KB 而65536/8=8KB  </span><br><span class="line">用65536个槽位的话心跳包的消息头要8KB，过于庞大 而16384个槽位只要2KB</span><br></pre></td></tr></table></div></figure>




        <h1 id="Redis数据持久化策略有哪些？"   >
          <a href="#Redis数据持久化策略有哪些？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis数据持久化策略有哪些？" class="headerlink" title="Redis数据持久化策略有哪些？"></a>Redis数据持久化策略有哪些？</h1>
      <p>我答：利用aof存储  2.利用rdb的方式存储  </p>
<p>利用RDB的方式存储 则保存的是历史指令，每一个指令都会被记录在RDB中 当Redis宕机重启后会重读RDB文件  恢复数据</p>
<p>利用AOF存储 保存的是改变最终数据的指令  他将最后实现数据的指令存在.aof文件中  最后要重启Redis之后只需要执行少部分影响数据的指令即可</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一共有两钟：1.RDB 2.AOF </span><br><span class="line">RDB:是快照文件，把整个Redis数据写入在内存中，当Redis重启时可以从快照恢复数据</span><br><span class="line">AOF:是追加写入文件，只记录写命令，当Redis宕机重启时重新执行一遍命令来恢复数据</span><br><span class="line"></span><br><span class="line">RDB和AOF优缺点: RDB是二进制文件，体积比较小，恢复速度更快，但是丢数据风险更高</span><br><span class="line">			  AOF是写入文件，体积比较大，恢复速度更慢但是丢数据风险更低，我们可以配置刷盘策略来设置多久写入命令</span><br></pre></td></tr></table></div></figure>




        <h1 id="Redis作为缓存，MySql的数据如何与Redis进行同步-双写一致性"   >
          <a href="#Redis作为缓存，MySql的数据如何与Redis进行同步-双写一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis作为缓存，MySql的数据如何与Redis进行同步-双写一致性" class="headerlink" title="Redis作为缓存，MySql的数据如何与Redis进行同步?(双写一致性)"></a>Redis作为缓存，MySql的数据如何与Redis进行同步?(双写一致性)</h1>
      <p>我答：Redis作为缓存，而MySql作为底单数据  我们一般是业务先写入MySql中然后利用Canal监控对Redis和MySql的数据变化，当MySql的数据发生变化的时候查询MySql写回到Redis中保持了数据的一致性</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.延迟双删 </span><br><span class="line">延迟双删:先把缓存删除再更新数据库数据最后延迟删除缓存，延时主要是为了数据库的主从一致。</span><br><span class="line">        缺点是1.我们不能准确把控延时的时间</span><br><span class="line">             2.延时的过程仍然有脏数据的风险 </span><br><span class="line">             【	</span><br><span class="line">             	假如有线程T1,T2,T3 当线程T1删除了缓存更新数据库的时候</span><br><span class="line">             	线程T2发现缓存没有之后查询DB获取到未更新完的数据(老数据)，然后写回缓存</span><br><span class="line">             	线程T3发现缓存没有之后查询DB获取到未更新完的数据(老数据)，然后要写回缓存之前阻塞</span><br><span class="line">             	线程T1更新完数据之后 </span><br><span class="line">             	一定时间之后删除缓存(删除线程T2写回的老数据)</span><br><span class="line">             	这个时候T3唤醒，执行了写回缓存操作</span><br><span class="line">             	那么就会造成缓存和DB数据不一致的情况 出现了脏数据</span><br><span class="line">              </span><br><span class="line">             】</span><br><span class="line">2.利用分布式锁【保证数据的实时性】[利用Redisson实现]</span><br><span class="line">             1)读数据的时候利用共享读锁</span><br><span class="line">             2)在写数据的时候利用互斥写锁</span><br><span class="line">        特性是：利用读写锁可以保证数据的强一致性，但是写锁会堵塞其他线程降低性能</span><br><span class="line">3.利用异步通知的方式</span><br><span class="line">            1)利用MQ的方式，更新数据之后，通知缓存删除</span><br><span class="line">            2)利用canal的方式，Canal伪装成MySql的一个节点，通过读取binlog数据。再同步写回Redis中</span><br></pre></td></tr></table></div></figure>


        <h1 id="如果数据库有1000w条数据，但是Redis只能存20w的数据，如何保证Redis保存的是热点数据呢？"   >
          <a href="#如果数据库有1000w条数据，但是Redis只能存20w的数据，如何保证Redis保存的是热点数据呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果数据库有1000w条数据，但是Redis只能存20w的数据，如何保证Redis保存的是热点数据呢？" class="headerlink" title="如果数据库有1000w条数据，但是Redis只能存20w的数据，如何保证Redis保存的是热点数据呢？"></a>如果数据库有1000w条数据，但是Redis只能存20w的数据，如何保证Redis保存的是热点数据呢？</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllKeys-Lru  选择最近最少访问的数据淘汰</span><br></pre></td></tr></table></div></figure>


        <h1 id="Redis脑裂现象怎么解决？"   >
          <a href="#Redis脑裂现象怎么解决？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis脑裂现象怎么解决？" class="headerlink" title="Redis脑裂现象怎么解决？"></a>Redis脑裂现象怎么解决？</h1>
      <p>我答：Redis的脑裂现象主要出现于master存入数据时，哨兵因为网络波动无法检测到Master于是投票选举了一个salve上位成master，这样原Master连接回来只能成为Slave，造成了数据丢失，解决方案是可以在配置中配置至少有Slave节点才能执行写操作</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">脑裂现象主要出现于master存入数据时，哨兵因为网络波动无法检测到Master于是投票选举了一个salve上位成master，这样原Master连接回来只能成为Slave，造成了数据丢失</span><br><span class="line">	解决方案是1.可以在配置中配置至少有Slave节点才能执行写操作</span><br><span class="line">			2.可以设置主从节点之间的最大延迟时间，如果超过了延迟时间则拒绝写入</span><br></pre></td></tr></table></div></figure>




        <h2 id="为什么Redis中使用跳表而不用B-树呢？-跳表"   >
          <a href="#为什么Redis中使用跳表而不用B-树呢？-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么Redis中使用跳表而不用B-树呢？-跳表" class="headerlink" title="为什么Redis中使用跳表而不用B+树呢？-跳表"></a>为什么Redis中使用跳表而不用B+树呢？-跳表</h2>
      
        <h1 id="底层实现是什么数据结构-跳表"   >
          <a href="#底层实现是什么数据结构-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#底层实现是什么数据结构-跳表" class="headerlink" title="底层实现是什么数据结构-跳表"></a>底层实现是什么数据结构-跳表</h1>
      
        <h1 id="结点的数据结构保存了什么信息-跳表"   >
          <a href="#结点的数据结构保存了什么信息-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#结点的数据结构保存了什么信息-跳表" class="headerlink" title="结点的数据结构保存了什么信息-跳表"></a>结点的数据结构保存了什么信息-跳表</h1>
      
        <h1 id="新结点的层数如何确定-跳表"   >
          <a href="#新结点的层数如何确定-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#新结点的层数如何确定-跳表" class="headerlink" title="新结点的层数如何确定?-跳表"></a>新结点的层数如何确定?-跳表</h1>
      
        <h1 id="跳表的创建过程-跳表"   >
          <a href="#跳表的创建过程-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#跳表的创建过程-跳表" class="headerlink" title="跳表的创建过程?-跳表"></a>跳表的创建过程?-跳表</h1>
      
        <h1 id="跳表最多多少层-跳表"   >
          <a href="#跳表最多多少层-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#跳表最多多少层-跳表" class="headerlink" title="跳表最多多少层?-跳表"></a>跳表最多多少层?-跳表</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/09/%E6%A8%A1%E6%8B%9F%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/">模拟电话面试复盘</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-09</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">18分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>前言</strong></p>
<p>这个模拟电话面试是我和学习搭子为了我求职提前做的准备</p>
<p>大概是一周左右确认一个时间然后拿出半个小时进行一个模拟的过程，不过这个模拟的结果和过程需要我单独复盘，于是有这篇复盘篇出来</p>

        <h1 id="07-1"   >
          <a href="#07-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#07-1" class="headerlink" title="07&#x2F;1"></a>07&#x2F;1</h1>
      
        <h2 id="Spring事务什么时候会失效？"   >
          <a href="#Spring事务什么时候会失效？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring事务什么时候会失效？" class="headerlink" title="Spring事务什么时候会失效？"></a>Spring事务什么时候会失效？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring的事务什么时候会失效?我能想到下面几个点。第一，当Spring容器的事务传播行为不支持事务的时候会失效，第二年是当用到的方法是调用对象内部的时候没有走AOP代理，所以这个时候索引会失效</span><br></pre></td></tr></table></div></figure>


        <h2 id="说说MySql的主从复制"   >
          <a href="#说说MySql的主从复制" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说MySql的主从复制" class="headerlink" title="说说MySql的主从复制"></a>说说MySql的主从复制</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mysql的主从复制有几点好处 低一点是容灾备份，当主机发生故障的时候丛集可以上位维持系统的可用，第二点是可以读写分离，让读操作在从机中进行，降低Master的请求压力</span><br><span class="line"></span><br><span class="line">进行主从复制首先要主机开启Binlog日志，然后从机去读取Binlog日志中的数据写到自己的中继日志。然后再数据重做</span><br></pre></td></tr></table></div></figure>




        <h2 id="你们项目中有没有使用过分库分表呢"   >
          <a href="#你们项目中有没有使用过分库分表呢" class="heading-link"><i class="fas fa-link"></i></a><a href="#你们项目中有没有使用过分库分表呢" class="headerlink" title="你们项目中有没有使用过分库分表呢?"></a>你们项目中有没有使用过分库分表呢?</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们项目没有用到分库分表的操作，因为这个项目表数据是比较小的，我能说说这个分库分表的思路</span><br><span class="line">分库分表有四种 第一种垂直分库 把数据库按照业务逻辑进行分库 第二种是垂直分表，把表存储到不同的额数据库中 这个时候一般是用于冷热数据的分离，把常用的数据提取到一个表中 第三十中是水平分库 水平分库是指把一个数据库的数据分到不同的数据库中可以使当前主机也可以是不同主机  最后是水评分表 水平分表是指把表分到同一个数据库中的而不同表中</span><br></pre></td></tr></table></div></figure>


        <h2 id="事务的隔离性是怎么保证的-（说说MVCC机制的理解）"   >
          <a href="#事务的隔离性是怎么保证的-（说说MVCC机制的理解）" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务的隔离性是怎么保证的-（说说MVCC机制的理解）" class="headerlink" title="事务的隔离性是怎么保证的?（说说MVCC机制的理解）"></a>事务的隔离性是怎么保证的?（说说MVCC机制的理解）</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MVCC机制的实现主要取决于三个部分 第一个部分是饮食字段 有trx_id 事务ID，还有阴市住建 当Mysql没有主键的时候会自动添加一个主键 还有事回滚指针 指向的是undo log版本链</span><br><span class="line">第二个就是undo log版本链</span><br><span class="line">第三个是看当前的事务隔离级别然后根据事务隔离级别找到不同的处理方案，像是RC 读已提交就是会每一次select的时候都会形成一个快照，然后去读取这个快照的信息，而RR 则是第一次select的时候会成圣做一个快照 然后面的查询都是这个版本的快照</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="说说你对AOP的理解"   >
          <a href="#说说你对AOP的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说你对AOP的理解" class="headerlink" title="说说你对AOP的理解"></a>说说你对AOP的理解</h2>
      
        <h2 id="能说说SpringMVC的工作流程吗？"   >
          <a href="#能说说SpringMVC的工作流程吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#能说说SpringMVC的工作流程吗？" class="headerlink" title="能说说SpringMVC的工作流程吗？"></a>能说说SpringMVC的工作流程吗？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC的工作机制</span><br><span class="line">当HTTP请求来到，会有一个DispatcherServlet(前端控制器)来进行空值处理请求，通过handlermapping找到具体的handler处理器和拦截器 同意返回给dispatcherlservlet，dispatchselet在经过这个映射结果找到handleradpater handler适配器，handler适配器找到handler就是我们自己定义的controller ，最后controller返回数据和视图 适配器封装成modelandview 返回给前端处理器，前端处理器会那刀这个modeladnvie未找到viewReslover然后对数据进行解析，视图接气息将是最后解析出来的view返回给dispaterservlet</span><br><span class="line"> dispatcherselevct最后渲染view</span><br><span class="line"> 而现在面向接口编程，我们很少用到返回view的过程，一般我们在conteroller后用responseBOdy注解将结果经过httpmessageConverser消息转换器转换成json格式数据返回</span><br></pre></td></tr></table></div></figure>


        <h2 id="Spring和SpringBoot的区别和关系"   >
          <a href="#Spring和SpringBoot的区别和关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring和SpringBoot的区别和关系" class="headerlink" title="Spring和SpringBoot的区别和关系"></a>Spring和SpringBoot的区别和关系</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SpringFTAME是一个框架，而SpringbOOT是基于Spring的一个脚手架 SpringBoot包含了其他狂阶的API，以便快速成圣spring项目</span><br></pre></td></tr></table></div></figure>


        <h2 id="缓存穿透、雪崩、击穿、预热"   >
          <a href="#缓存穿透、雪崩、击穿、预热" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓存穿透、雪崩、击穿、预热" class="headerlink" title="缓存穿透、雪崩、击穿、预热"></a>缓存穿透、雪崩、击穿、预热</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透是指一个数据在redis中没有在mysql中也没有，然后不法分子通过这个请求对应的数据不断达到mysql中，我们的解决方案可以使布隆过滤器或者是返回一个空值写回给redis中</span><br><span class="line">缓存击穿是指某个一个热点kEY的突然失效，然后大量请求达到Mysql中，我们可以社遏制一个逻辑过期，也可以采用分布式锁的放水阀来解决这个问题</span><br><span class="line">换粗雪崩是指Redis的大量KEy的跟同事失效，或者是单机Redis的宕机导致的大量请求达到MYSQL中，我们的解决方案是可以设置不随机的够哦骑士剑将热点Keysh失效的时间分开</span><br><span class="line">缓存预热是指提供服务之前，我们自己将数据从mysql写回到redis提前对数据进行一个写入操作</span><br></pre></td></tr></table></div></figure>


        <h2 id="讲讲Redis的淘汰算法策略"   >
          <a href="#讲讲Redis的淘汰算法策略" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲Redis的淘汰算法策略" class="headerlink" title="讲讲Redis的淘汰算法策略"></a>讲讲Redis的淘汰算法策略</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reids的数据淘汰有两个策略一个是定期删除还有一个是惰性删除，然后定期删除是不断轮询一些数据 来对数据过期时间多而检查，如果这个数据到了过期时间就主动删除，惰性删除是值Redis不会直接删除过期数据，而是让他对方在Redis中，当需要用到这个数据然后会对过期时间进行一个判断，如果过期了就删除这个数据。但是这个方式会造成内存的浪费  而定期闪回造成CPu的浪费 降低性能，还有一个方式是随机删除，随机删除部分数据</span><br><span class="line"></span><br><span class="line">rEDis有八个删除数据厕所 基于4种删除方式 就是定期删除 LRU删除 LFU删除 随机删除 和删除数据类型有两种 是就是跟过期和不过期数据，一共就是4*2有八种</span><br><span class="line">第一种是不删除数据 </span><br><span class="line">定期删除过期数据 lru删除过期数据  lru删除数据</span><br><span class="line">lfu删除过期数据 lfu删除数据</span><br><span class="line">随机删除过期数据 随机删除数据</span><br><span class="line">LRU是最近最少未被使用</span><br><span class="line">lfu删除是最近最频率低删除</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="Redis作为缓存，MySql的数据如何与Redis进行同步-双写一致性"   >
          <a href="#Redis作为缓存，MySql的数据如何与Redis进行同步-双写一致性" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis作为缓存，MySql的数据如何与Redis进行同步-双写一致性" class="headerlink" title="Redis作为缓存，MySql的数据如何与Redis进行同步?(双写一致性)"></a>Redis作为缓存，MySql的数据如何与Redis进行同步?(双写一致性)</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis和Mysql的数据进行数据同步可以使魂村双删策略</span><br><span class="line">先删除数据然后再更新数据库最后在删除缓存， 但是这个情况会存在一定脏数据的可能</span><br><span class="line">然后我们有最终一致性的方案 一个是利于是分布式锁 的同步更新，这种方法可以保证数据的高一致性但是会降低性能，还有一种是异步通知  比如用消息队列进行数据更新 或者是阿里巴巴开源的Canal来对数据库binlog日志的监控然后写回给redis 这样异步通知的方式可以性能较高但是会有存在一定时间数据的不一致的情况 要按业务选择</span><br></pre></td></tr></table></div></figure>


        <h2 id="结点的数据结构保存了什么信息-跳表"   >
          <a href="#结点的数据结构保存了什么信息-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#结点的数据结构保存了什么信息-跳表" class="headerlink" title="结点的数据结构保存了什么信息-跳表"></a>结点的数据结构保存了什么信息-跳表</h2>
      
        <h2 id="RabbitMQ中死信队列？延时队列有了解过吗？"   >
          <a href="#RabbitMQ中死信队列？延时队列有了解过吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ中死信队列？延时队列有了解过吗？" class="headerlink" title="RabbitMQ中死信队列？延时队列有了解过吗？"></a>RabbitMQ中死信队列？延时队列有了解过吗？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">死信队列是就是死信交换机 是用来处理死信的，他和正常交换机没有缺什么太大差异</span><br><span class="line">死信就是ttl时间超过了 或者是当确认模式中拒绝签收后不返回元队列的消息叫死信</span><br><span class="line"></span><br><span class="line">延迟队列由了解过，延迟队列在RabbitMQ中没有办法直接生命一个延迟队列，但是我们可以用死信对垒家TTL来达到同样的效果</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="介绍一下Mysql中事务的特性"   >
          <a href="#介绍一下Mysql中事务的特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Mysql中事务的特性" class="headerlink" title="介绍一下Mysql中事务的特性"></a>介绍一下Mysql中事务的特性</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">事务就是一组相同的操作单元，这组操作只能同时成功或者同时不成功。</span><br><span class="line">事务的四大特性是有原子性、一致性、隔离丁和持久性</span><br><span class="line">比如A向B转账然后A少500块钱B要多出500块钱 这个部分是原子的 只能A转账成功B钱增加或者是两个同时势必爱，一致性是指这个数据总量要最后一直，A少500B就一定要多500，隔离性是指在这个A想B转账的国女恒中不会被外界的因素影响，而一致性是当事务一旦提交这个数据就要被永久的写到数据库中</span><br></pre></td></tr></table></div></figure>


        <h2 id="并发事务会带来哪些问题？"   >
          <a href="#并发事务会带来哪些问题？" class="heading-link"><i class="fas fa-link"></i></a><a href="#并发事务会带来哪些问题？" class="headerlink" title="并发事务会带来哪些问题？"></a>并发事务会带来哪些问题？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">并发事务会带来脏读 不可重复读幻读的三种问题，还有一个是更新丢失的方面</span><br><span class="line">脏读是指一个数据读到了另一个未提交事务更新后的数据</span><br><span class="line">不可重复读是指在一个事务前后读取的数据不一致</span><br><span class="line">幻读是指当事务在读取数据的前后总条数不医用氧，比如插入数据 的时候查到这个数据没有然后插入的时候这个数据也已经存在 就 好像出现了幻觉一样</span><br><span class="line">更新丢失分成两种一种是提交覆盖和回滚覆盖</span><br><span class="line">提交覆盖是指一个事务A和事务B在处理同一个数据的时候,A提交的数据被B提交的数据覆盖了。</span><br><span class="line">回滚覆盖是指事务A和事务B，A更新之后UB回滚了导致这个更新丢失</span><br></pre></td></tr></table></div></figure>


        <h2 id="什么情况下会造成索引失效？"   >
          <a href="#什么情况下会造成索引失效？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么情况下会造成索引失效？" class="headerlink" title="什么情况下会造成索引失效？"></a>什么情况下会造成索引失效？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一般是最左前缀法则失效的时候，然后或者是查询的时候用了模糊查询。模糊查询的左边用了占位符 或者是用or语句的时候前有两边有一边索引。还有用运算符号的时候 用大鱼号小于号比较</span><br></pre></td></tr></table></div></figure>


        <h2 id="数据库优化"   >
          <a href="#数据库优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据库优化我主要从两个方面来说</span><br><span class="line">第一种可以从设计架构方面 就是数据库可以设置成集群、分库分表、主重复值</span><br><span class="line">第二方面是对Sql的优化 就从具体的SQL优化那方面</span><br></pre></td></tr></table></div></figure>


        <h2 id="final修饰符有学习过吗？它有什么使用场景"   >
          <a href="#final修饰符有学习过吗？它有什么使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#final修饰符有学习过吗？它有什么使用场景" class="headerlink" title="final修饰符有学习过吗？它有什么使用场景"></a>final修饰符有学习过吗？它有什么使用场景</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有学习过 final可以用于修饰方法、对象、变量</span><br><span class="line">当final修饰变量的时候这个变量就叫做常量，只能赋值一次</span><br><span class="line">当final修饰方法的时候这个方法无法被子类重写</span><br><span class="line">当final修饰类的时候这个类是最终类，不能被继承没有子类</span><br></pre></td></tr></table></div></figure>


        <h2 id="进程和线程的区别"   >
          <a href="#进程和线程的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程是操作系统最小的处理的单元</span><br><span class="line">而线程是进程里面的东西 </span><br><span class="line">进程可以创造线程</span><br></pre></td></tr></table></div></figure>


        <h2 id="有了解过集合吗？看过底层源码吗？"   >
          <a href="#有了解过集合吗？看过底层源码吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过集合吗？看过底层源码吗？" class="headerlink" title="有了解过集合吗？看过底层源码吗？"></a>有了解过集合吗？看过底层源码吗？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有了解过集合看过地城源码 </span><br><span class="line">集合是有两个定级接口一个collection单列机和 还有一个是map集合双列集合</span><br><span class="line">collection下游两个子接口一个是list接口 list接口下面有arryalist、linkedlist、vector</span><br><span class="line">还有一个接口是set接口 set接口下的实现类有hashset treeset linkedhashset</span><br><span class="line">而map就扣下游hashmap、linkedhashmap、hashtable、treemap、concrueenthashmap</span><br></pre></td></tr></table></div></figure>


        <h2 id="集合是怎么处理哈希碰撞的？"   >
          <a href="#集合是怎么处理哈希碰撞的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合是怎么处理哈希碰撞的？" class="headerlink" title="集合是怎么处理哈希碰撞的？"></a>集合是怎么处理哈希碰撞的？</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">处理哈希碰撞有链式巡执法、显性探测法、再hash发</span><br><span class="line">而季节处理这个哈希碰撞的时候使用链式巡执法 ，因为集合底层是数组+链表+红黑树构成的，当发生哈希碰撞的时候在jdk1.7之前是头插法将新数据插入到链表头部而jdk1.8之后用的是尾插法 然后红黑树是为了解决这个链表过程导致这个时间复杂度上升的问题</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="线程池如何配置？有什么策略策略？"   >
          <a href="#线程池如何配置？有什么策略策略？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何配置？有什么策略策略？" class="headerlink" title="线程池如何配置？有什么策略策略？"></a>线程池如何配置？有什么策略策略？</h2>
      
        <h2 id="SpringMVC的主要组件有哪些"   >
          <a href="#SpringMVC的主要组件有哪些" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringMVC的主要组件有哪些" class="headerlink" title="SpringMVC的主要组件有哪些"></a>SpringMVC的主要组件有哪些</h2>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要有五个组件 一个是dispatcherselect前端控制器，hadnlermapping handler映射器 handleradapter 前端适配器 hander 就是我们写的controller 还有一个是ViewReselover 视图解析器</span><br></pre></td></tr></table></div></figure>




        <h1 id="08-1"   >
          <a href="#08-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#08-1" class="headerlink" title="08&#x2F;1"></a>08&#x2F;1</h1>
      
        <h2 id="说说你对AOP的理解-1"   >
          <a href="#说说你对AOP的理解-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说你对AOP的理解-1" class="headerlink" title="说说你对AOP的理解"></a>说说你对AOP的理解</h2>
      
        <h2 id="什么是SpringMVC？"   >
          <a href="#什么是SpringMVC？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SpringMVC？" class="headerlink" title="什么是SpringMVC？"></a>什么是SpringMVC？</h2>
      
        <h2 id="能说说SpringMVC的工作流程吗？-1"   >
          <a href="#能说说SpringMVC的工作流程吗？-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#能说说SpringMVC的工作流程吗？-1" class="headerlink" title="能说说SpringMVC的工作流程吗？"></a>能说说SpringMVC的工作流程吗？</h2>
      
        <h2 id="SpringBoot的自动配置原理"   >
          <a href="#SpringBoot的自动配置原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringBoot的自动配置原理" class="headerlink" title="SpringBoot的自动配置原理"></a>SpringBoot的自动配置原理</h2>
      
        <h2 id="SpringMVC有哪些常用注解？"   >
          <a href="#SpringMVC有哪些常用注解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringMVC有哪些常用注解？" class="headerlink" title="SpringMVC有哪些常用注解？"></a>SpringMVC有哪些常用注解？</h2>
      
        <h2 id="LRU和LFU的实现原理"   >
          <a href="#LRU和LFU的实现原理" class="heading-link"><i class="fas fa-link"></i></a><a href="#LRU和LFU的实现原理" class="headerlink" title="LRU和LFU的实现原理"></a>LRU和LFU的实现原理</h2>
      
        <h2 id="Redis底层对数据结构进行了哪方面的优化"   >
          <a href="#Redis底层对数据结构进行了哪方面的优化" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis底层对数据结构进行了哪方面的优化" class="headerlink" title="Redis底层对数据结构进行了哪方面的优化?"></a>Redis底层对数据结构进行了哪方面的优化?</h2>
      
        <h2 id="聊聊Redis怎么实现的IO多路复用"   >
          <a href="#聊聊Redis怎么实现的IO多路复用" class="heading-link"><i class="fas fa-link"></i></a><a href="#聊聊Redis怎么实现的IO多路复用" class="headerlink" title="聊聊Redis怎么实现的IO多路复用"></a>聊聊Redis怎么实现的IO多路复用</h2>
      
        <h2 id="为什么Key没有设置过期时间但是却被Redis删除了"   >
          <a href="#为什么Key没有设置过期时间但是却被Redis删除了" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么Key没有设置过期时间但是却被Redis删除了" class="headerlink" title="为什么Key没有设置过期时间但是却被Redis删除了"></a>为什么Key没有设置过期时间但是却被Redis删除了</h2>
      
        <h2 id="Redis数据持久化策略有哪些？"   >
          <a href="#Redis数据持久化策略有哪些？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis数据持久化策略有哪些？" class="headerlink" title="Redis数据持久化策略有哪些？"></a>Redis数据持久化策略有哪些？</h2>
      
        <h2 id="跳表的创建过程-跳表"   >
          <a href="#跳表的创建过程-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#跳表的创建过程-跳表" class="headerlink" title="跳表的创建过程?-跳表"></a>跳表的创建过程?-跳表</h2>
      
        <h2 id="RabbitMQ中死信队列？延时队列有了解过吗？-1"   >
          <a href="#RabbitMQ中死信队列？延时队列有了解过吗？-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ中死信队列？延时队列有了解过吗？-1" class="headerlink" title="RabbitMQ中死信队列？延时队列有了解过吗？"></a>RabbitMQ中死信队列？延时队列有了解过吗？</h2>
      
        <h2 id="什么是回表查询"   >
          <a href="#什么是回表查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是回表查询" class="headerlink" title="什么是回表查询"></a>什么是回表查询</h2>
      
        <h2 id="什么情况下会造成索引失效？-1"   >
          <a href="#什么情况下会造成索引失效？-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么情况下会造成索引失效？-1" class="headerlink" title="什么情况下会造成索引失效？"></a>什么情况下会造成索引失效？</h2>
      
        <h2 id="jvm、jdk、jre的区别"   >
          <a href="#jvm、jdk、jre的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#jvm、jdk、jre的区别" class="headerlink" title="jvm、jdk、jre的区别"></a>jvm、jdk、jre的区别</h2>
      
        <h2 id="多态如何实现的"   >
          <a href="#多态如何实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#多态如何实现的" class="headerlink" title="多态如何实现的"></a>多态如何实现的</h2>
      
        <h2 id="如何理解序列化"   >
          <a href="#如何理解序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何理解序列化" class="headerlink" title="如何理解序列化"></a>如何理解序列化</h2>
      
        <h2 id="有了解过集合吗？看过底层源码吗？-1"   >
          <a href="#有了解过集合吗？看过底层源码吗？-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过集合吗？看过底层源码吗？-1" class="headerlink" title="有了解过集合吗？看过底层源码吗？"></a>有了解过集合吗？看过底层源码吗？</h2>
      
        <h2 id="Integer和int能直接进行比较吗？"   >
          <a href="#Integer和int能直接进行比较吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integer和int能直接进行比较吗？" class="headerlink" title="Integer和int能直接进行比较吗？"></a>Integer和int能直接进行比较吗？</h2>
      
        <h2 id="线程池如何配置？有什么策略策略？-1"   >
          <a href="#线程池如何配置？有什么策略策略？-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何配置？有什么策略策略？-1" class="headerlink" title="线程池如何配置？有什么策略策略？"></a>线程池如何配置？有什么策略策略？</h2>
      
        <h2 id="新结点的层数如何确定-跳表"   >
          <a href="#新结点的层数如何确定-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#新结点的层数如何确定-跳表" class="headerlink" title="新结点的层数如何确定?-跳表"></a>新结点的层数如何确定?-跳表</h2>
      
        <h2 id="你们项目中有没有使用过分库分表呢-1"   >
          <a href="#你们项目中有没有使用过分库分表呢-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#你们项目中有没有使用过分库分表呢-1" class="headerlink" title="你们项目中有没有使用过分库分表呢?"></a>你们项目中有没有使用过分库分表呢?</h2>
      
        <h2 id="说说数据库中锁的种类"   >
          <a href="#说说数据库中锁的种类" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说数据库中锁的种类" class="headerlink" title="说说数据库中锁的种类"></a>说说数据库中锁的种类</h2>
      
        <h2 id="介绍一下Mysql中事务的特性-1"   >
          <a href="#介绍一下Mysql中事务的特性-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下Mysql中事务的特性-1" class="headerlink" title="介绍一下Mysql中事务的特性"></a>介绍一下Mysql中事务的特性</h2>
      
        <h1 id="08-2"   >
          <a href="#08-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#08-2" class="headerlink" title="08&#x2F;2"></a>08&#x2F;2</h1>
      
        <h2 id="线程sleep-方法和-wait-方法对比"   >
          <a href="#线程sleep-方法和-wait-方法对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程sleep-方法和-wait-方法对比" class="headerlink" title="线程sleep() 方法和 wait() 方法对比"></a>线程sleep() 方法和 wait() 方法对比</h2>
      
        <h2 id="什么是线程上下文切换"   >
          <a href="#什么是线程上下文切换" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换?"></a>什么是线程上下文切换?</h2>
      
        <h2 id="说说乐观锁和悲观锁"   >
          <a href="#说说乐观锁和悲观锁" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说乐观锁和悲观锁" class="headerlink" title="说说乐观锁和悲观锁"></a>说说乐观锁和悲观锁</h2>
      
        <h2 id="Set的无序性和不可重复性的含义是什么"   >
          <a href="#Set的无序性和不可重复性的含义是什么" class="heading-link"><i class="fas fa-link"></i></a><a href="#Set的无序性和不可重复性的含义是什么" class="headerlink" title="Set的无序性和不可重复性的含义是什么"></a>Set的无序性和不可重复性的含义是什么</h2>
      
        <h2 id="如果一个业务没有处理完没有结束你们是怎么处理的"   >
          <a href="#如果一个业务没有处理完没有结束你们是怎么处理的" class="heading-link"><i class="fas fa-link"></i></a><a href="#如果一个业务没有处理完没有结束你们是怎么处理的" class="headerlink" title="如果一个业务没有处理完没有结束你们是怎么处理的?"></a>如果一个业务没有处理完没有结束你们是怎么处理的?</h2>
      
        <h2 id="CAS无锁有了解过吗"   >
          <a href="#CAS无锁有了解过吗" class="heading-link"><i class="fas fa-link"></i></a><a href="#CAS无锁有了解过吗" class="headerlink" title="CAS无锁有了解过吗"></a>CAS无锁有了解过吗</h2>
      
        <h2 id="数据去重原理，HashSet底层"   >
          <a href="#数据去重原理，HashSet底层" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据去重原理，HashSet底层" class="headerlink" title="数据去重原理，HashSet底层"></a>数据去重原理，HashSet底层</h2>
      
        <h2 id="介绍一下HashMap的参数和机制"   >
          <a href="#介绍一下HashMap的参数和机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#介绍一下HashMap的参数和机制" class="headerlink" title="介绍一下HashMap的参数和机制"></a>介绍一下HashMap的参数和机制</h2>
      
        <h2 id="线程池如何配置？有什么策略策略？-2"   >
          <a href="#线程池如何配置？有什么策略策略？-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何配置？有什么策略策略？-2" class="headerlink" title="线程池如何配置？有什么策略策略？"></a>线程池如何配置？有什么策略策略？</h2>
      
        <h2 id="说说SpringMVC的执行流程"   >
          <a href="#说说SpringMVC的执行流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说SpringMVC的执行流程" class="headerlink" title="说说SpringMVC的执行流程"></a>说说SpringMVC的执行流程</h2>
      
        <h2 id="Integer和int能直接进行比较吗？-1"   >
          <a href="#Integer和int能直接进行比较吗？-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integer和int能直接进行比较吗？-1" class="headerlink" title="Integer和int能直接进行比较吗？"></a>Integer和int能直接进行比较吗？</h2>
      
        <h2 id="HashMap-和-TreeMap-讲讲？"   >
          <a href="#HashMap-和-TreeMap-讲讲？" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashMap-和-TreeMap-讲讲？" class="headerlink" title="HashMap 和 TreeMap 讲讲？"></a>HashMap 和 TreeMap 讲讲？</h2>
      
        <h2 id="为什么MySql用B-树不用跳表？"   >
          <a href="#为什么MySql用B-树不用跳表？" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么MySql用B-树不用跳表？" class="headerlink" title="为什么MySql用B+树不用跳表？"></a>为什么MySql用B+树不用跳表？</h2>
      
        <h2 id="唯一索引和普通索引在mysql底层有什么区别？"   >
          <a href="#唯一索引和普通索引在mysql底层有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#唯一索引和普通索引在mysql底层有什么区别？" class="headerlink" title="唯一索引和普通索引在mysql底层有什么区别？"></a>唯一索引和普通索引在mysql底层有什么区别？</h2>
      
        <h2 id="我们如何定位慢查询"   >
          <a href="#我们如何定位慢查询" class="heading-link"><i class="fas fa-link"></i></a><a href="#我们如何定位慢查询" class="headerlink" title="我们如何定位慢查询"></a>我们如何定位慢查询</h2>
      
        <h2 id="事务隔离级别有哪些？MySql默认的事务隔离级别是哪个"   >
          <a href="#事务隔离级别有哪些？MySql默认的事务隔离级别是哪个" class="heading-link"><i class="fas fa-link"></i></a><a href="#事务隔离级别有哪些？MySql默认的事务隔离级别是哪个" class="headerlink" title="事务隔离级别有哪些？MySql默认的事务隔离级别是哪个"></a>事务隔离级别有哪些？MySql默认的事务隔离级别是哪个</h2>
      
        <h2 id="RabbitMQ怎么保障消息的幂等性"   >
          <a href="#RabbitMQ怎么保障消息的幂等性" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ怎么保障消息的幂等性" class="headerlink" title="RabbitMQ怎么保障消息的幂等性"></a>RabbitMQ怎么保障消息的幂等性</h2>
      
        <h2 id="底层实现是什么数据结构-跳表"   >
          <a href="#底层实现是什么数据结构-跳表" class="heading-link"><i class="fas fa-link"></i></a><a href="#底层实现是什么数据结构-跳表" class="headerlink" title="底层实现是什么数据结构-跳表"></a>底层实现是什么数据结构-跳表</h2>
      
        <h2 id="聊聊Redis怎么实现的IO多路复用-1"   >
          <a href="#聊聊Redis怎么实现的IO多路复用-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#聊聊Redis怎么实现的IO多路复用-1" class="headerlink" title="聊聊Redis怎么实现的IO多路复用"></a>聊聊Redis怎么实现的IO多路复用</h2>
      
        <h2 id="Redis作为缓存，MySql的数据如何与Redis进行同步"   >
          <a href="#Redis作为缓存，MySql的数据如何与Redis进行同步" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis作为缓存，MySql的数据如何与Redis进行同步" class="headerlink" title="Redis作为缓存，MySql的数据如何与Redis进行同步?"></a>Redis作为缓存，MySql的数据如何与Redis进行同步?</h2>
      
        <h2 id="讲讲对Redis哈希分槽的理解"   >
          <a href="#讲讲对Redis哈希分槽的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲对Redis哈希分槽的理解" class="headerlink" title="讲讲对Redis哈希分槽的理解"></a>讲讲对Redis哈希分槽的理解</h2>
      </div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/3/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">48</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">19</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2024</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Kkker1</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>