<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-16%C3%9716.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/bonbon-32%C3%9732.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="KkkerAn&#39;s Blog">
<meta property="og:url" content="https://username.github.io/page/2/index.html">
<meta property="og:site_name" content="KkkerAn&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="KkkerAn">
<meta name="twitter:card" content="summary"><title>KkkerAn's Blog</title><link ref="canonical" href="https://username.github.io/page/2/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: true,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">WelCome to My Blog</div><div class="header-banner-info__subtitle">回忆像一块彩色橡皮糖,被拉长了,颜色淡了,但还是甜</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/21/JavaSE%E5%9F%BA%E7%A1%80%E3%80%90%E6%80%BB%E7%BB%93%E7%AF%87%E3%80%91/">JavaSE基础【总结篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-21</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">658</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">3分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><strong>前言</strong></p>
<p>这个文档记录的是JavaSE的基础，本着我学习的路线再进一步深化和理解，这个过程是一个必不可少的过程。</p>
<p><em>光学别人的是别人教的好而不是我学的好，想要真正掌握必须自己重新查一遍、看一遍</em></p>
<p>复盘和深化学习路线参考于Java从入门到精通(第六版)目录，这一块要重新学习的主要是最最最基础的内容</p>
<hr>

        <h1 id="Java语言基础"   >
          <a href="#Java语言基础" class="heading-link"><i class="fas fa-link"></i></a><a href="#Java语言基础" class="headerlink" title="Java语言基础"></a>Java语言基础</h1>
      
        <h2 id="基本数据类型"   >
          <a href="#基本数据类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2>
      <p>一共八个基本数据类型</p>
<p>整型：byte,short,int,long</p>
<p>浮点型:float,double</p>
<p>布尔型:boolean</p>
<p>字符型:char</p>
<div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>字节数</th>
<th>二进制位</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节</td>
<td>8</td>
<td>[-2^7,2^7-1]</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>16</td>
<td>[-2^15,2^15-1]</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>32</td>
<td>[-2^31,2^31-1]</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>64</td>
<td>[-2^63,2^63-1]</td>
</tr>
<tr>
<td>float(单精度)</td>
<td>4字节</td>
<td>32</td>
<td></td>
</tr>
<tr>
<td>double(双精度)</td>
<td>8字节</td>
<td>64</td>
<td></td>
</tr>
<tr>
<td>boolean</td>
<td>1字节</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>2字节</td>
<td>16</td>
<td>[0,2^16-1]</td>
</tr>
</tbody></table></div>

        <h2 id="变量和常量"   >
          <a href="#变量和常量" class="heading-link"><i class="fas fa-link"></i></a><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2>
      <p>变量:在程序运行过程中，可以发生变化的量</p>
<p>常量:在程序运行过程中，不会发生变化的量</p>
<p>常量一般用final关键字进行修饰，只能赋值一次</p>
<p>变量有成员变量、局部变量、静态变量、参数变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成员变量：定义在类中、方法外的变量，可以被类中的方法调用，可以被权限修饰符修饰</span><br><span class="line">局部变量：定义在方法体、代码块中的变量，作用域仅限当前方法、代码块中，局部变量在使用前必须先声明，并且不能被权限修饰符修饰</span><br><span class="line">静态变量：定义在类中、方法外的变量，并且用<span class="keyword">static</span>关键字修饰，可以被权限修饰符修饰</span><br><span class="line">参数变量: 方法声明时的变量，作用域仅限于方法体中</span><br></pre></td></tr></table></div></figure>




        <h2 id="运算符"   >
          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2>
      <p>&amp;符号和&amp;&amp;之间有什么区别？</p>
<p>&amp;是普通与，无论第一个条件如何都会进行第二个条件判断，&amp;&amp;是短路与，如果第一个条件为false就不会进入第二个条件判断</p>
<p>|符号和||之间有什么区别？</p>
<p>同理，|是普通或，无论第一个条件如何都会进行第二个条件判断，||是短路或，如果第一个条件为true就不会进入第二个条件判断</p>

        <h2 id="数据类型转换"   >
          <a href="#数据类型转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2>
      
        <h2 id="关键字"   >
          <a href="#关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2>
      
        <h2 id="权限修饰符"   >
          <a href="#权限修饰符" class="heading-link"><i class="fas fa-link"></i></a><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2>
      <hr>

        <h1 id="数组"   >
          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组" class="headerlink" title="数组"></a>数组</h1>
      
        <h2 id="一维数组"   >
          <a href="#一维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2>
      
        <h2 id="二维数组"   >
          <a href="#二维数组" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2>
      
        <h2 id="数组的基本操作"   >
          <a href="#数组的基本操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h2>
      <hr>

        <h1 id="类和对象"   >
          <a href="#类和对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1>
      
        <h2 id="对象"   >
          <a href="#对象" class="heading-link"><i class="fas fa-link"></i></a><a href="#对象" class="headerlink" title="对象"></a>对象</h2>
      
        <h2 id="类"   >
          <a href="#类" class="heading-link"><i class="fas fa-link"></i></a><a href="#类" class="headerlink" title="类"></a>类</h2>
      
        <h3 id="面向对象的操作"   >
          <a href="#面向对象的操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象的操作" class="headerlink" title="面向对象的操作"></a>面向对象的操作</h3>
      <hr>

        <h1 id="字符串"   >
          <a href="#字符串" class="heading-link"><i class="fas fa-link"></i></a><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1>
      <hr>

        <h1 id="异常"   >
          <a href="#异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#异常" class="headerlink" title="异常"></a>异常</h1>
      <hr>

        <h1 id="枚举"   >
          <a href="#枚举" class="heading-link"><i class="fas fa-link"></i></a><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1>
      <hr>

        <h1 id="反射与注解"   >
          <a href="#反射与注解" class="heading-link"><i class="fas fa-link"></i></a><a href="#反射与注解" class="headerlink" title="反射与注解"></a>反射与注解</h1>
      <hr>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/20/JavaSE%E5%9F%BA%E7%A1%80-%E9%94%81%E3%80%90%E6%BA%90%E7%A0%81%E7%AF%87%E3%80%91/">JavaSE基础-锁【源码篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">31分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Lock"   >
          <a href="#Lock" class="heading-link"><i class="fas fa-link"></i></a><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1>
      <p>我们首先要看JUC标准中的Lock接口</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//获取锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	除非当前线程被中断，否则获取锁</span></span><br><span class="line"><span class="comment">	1.如果锁可用则直接获取锁</span></span><br><span class="line"><span class="comment">	2.如果锁不可用，则当前线程会被禁用并处于休眠状态直到两钟情况产生</span></span><br><span class="line"><span class="comment">		1).锁被当前线程获取</span></span><br><span class="line"><span class="comment">		2).其他线程会中断当前线程，并且支持中断锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	只有锁是空闲的时候才能获取锁</span></span><br><span class="line"><span class="comment">	1.如果锁可用则获取锁，返回true</span></span><br><span class="line"><span class="comment">	2.如果锁不可用则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	当锁在规定时间内是空闲并且没有线程中断，那么获取锁</span></span><br><span class="line"><span class="comment">	形参:  </span></span><br><span class="line"><span class="comment">		1.规定锁的超时时间</span></span><br><span class="line"><span class="comment">		2.规定时间单位</span></span><br><span class="line"><span class="comment">	返回值：</span></span><br><span class="line"><span class="comment">		1.true 获取锁成功</span></span><br><span class="line"><span class="comment">		2.false 超时，获取锁失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建一个新的Condition实例</span></span><br></pre></td></tr></table></div></figure>

<p>我们接下来要看Lock的实现类</p>

        <h2 id="1-ReentrantLock"   >
          <a href="#1-ReentrantLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-ReentrantLock" class="headerlink" title="1.ReentrantLock"></a>1.ReentrantLock</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">/*一个可重入互斥锁</span></span><br><span class="line"><span class="comment">      当构造函数接收一个公平性参数，当设置为ture时，则下次获得锁的是等得最久的线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7373984872572414699L</span>;</span><br><span class="line"><span class="comment">//串行化ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*提供所有实施机制的同步器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></div></figure>

<p>内部类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">     </span><br><span class="line"> 	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="构造方法"   >
          <a href="#构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个Reentrantlock实例，相当于ReentrantLock(false),创建了一个非公平可重入锁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*	---有关的详细代码---</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	static final class NonfairSync extends Sync &#123;</span></span><br><span class="line"><span class="comment">        private static final long serialVersionUID = 7316153563782823691L;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        final void lock() &#123;</span></span><br><span class="line"><span class="comment">            if (compareAndSetState(0, 1))</span></span><br><span class="line"><span class="comment">                setExclusiveOwnerThread(Thread.currentThread());</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                acquire(1);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        protected final boolean tryAcquire(int acquires) &#123;</span></span><br><span class="line"><span class="comment">            return nonfairTryAcquire(acquires);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //因为NonfairSync类只有继承父类下的空参构造，所以会调用new Sync();</span></span><br><span class="line"><span class="comment">    abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span></span><br><span class="line"><span class="comment">        abstract void lock();</span></span><br><span class="line"><span class="comment">        final boolean nonfairTryAcquire(int acquires) &#123;...&#125;</span></span><br><span class="line"><span class="comment">        protected final boolean tryRelease(int releases) &#123;...&#125;</span></span><br><span class="line"><span class="comment">       	...</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    //同理因为Sync类也没有空参构造，会调用父类的空参构造 即new AbstractQueuedSynchronizer();</span></span><br><span class="line"><span class="comment">    public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer</span></span><br><span class="line"><span class="comment">    implements java.io.Serializable &#123;</span></span><br><span class="line"><span class="comment">    protected AbstractQueuedSynchronizer() &#123; &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //同上，且因为abstract类是个抽象类</span></span><br><span class="line"><span class="comment">    //所以父类也是空参构造，那么这个方法最后调用的结果就是new AbstractOwnableSynchronizer()</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //那么先暂时按官方说明的理解，调用了一个ReentrantLock(false),创建了一个非公平可重入锁</span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    <span class="comment">//通过指定公平策略，创建一个实例ReentrantLock</span></span><br><span class="line">    <span class="comment">//当fair为true则创建FairSync反之创建NonfairSync();</span></span><br><span class="line">    <span class="comment">//默认情况下空参构造是创建一个非公平的可重入互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br></pre></td></tr></table></div></figure>




        <h3 id="常用方法"   >
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3>
      
        <h4 id="lock方法"   >
          <a href="#lock方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#lock方法" class="headerlink" title="lock方法"></a>lock方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync.lock()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//所以要去找sync的子类看具体的方法实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认情况下:创建一个NonfairSync</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//nonfairsync.lock()</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//锁状态从0更新到1则说明线程获取了互斥锁</span></span><br><span class="line">&#125;   </span><br><span class="line">    <span class="comment">/*-----详情代码----</span></span><br><span class="line"><span class="comment">    我们可以先通过判断成功与否来反推这个IF语句到底在干吗</span></span><br><span class="line"><span class="comment">    条件成立:</span></span><br><span class="line"><span class="comment">    protected final void setExclusiveOwnerThread(Thread thread) &#123;</span></span><br><span class="line"><span class="comment">        exclusiveOwnerThread = thread;</span></span><br><span class="line"><span class="comment">        //这个方法执行成功后，会获得互斥锁</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    private transient Thread exclusiveOwnerThread;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    条件不成立:</span></span><br><span class="line"><span class="comment">    public final void acquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">        if (!tryAcquire(arg) &amp;&amp;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span></span><br><span class="line"><span class="comment">        	//	当尝试获取锁失败并且添加到等待队列中，则会线程自己中断自己</span></span><br><span class="line"><span class="comment">            selfInterrupt();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //尝试获取锁</span></span><br><span class="line"><span class="comment">    protected boolean tryAcquire(int arg) &#123;</span></span><br><span class="line"><span class="comment">        throw new UnsupportedOperationException();</span></span><br><span class="line"><span class="comment">        //尝试获取锁，如果获取将使同步器处于非法操作则抛出异常</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //给当前创建结点并且给一个标识表示当前线程正在抢夺互斥锁</span></span><br><span class="line"><span class="comment">    private Node addWaiter(Node mode) &#123;</span></span><br><span class="line"><span class="comment">        Node node = new Node(Thread.currentThread(), mode);</span></span><br><span class="line"><span class="comment">        //创建当前线程的结点</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        // Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line"><span class="comment">        Node pred = tail;</span></span><br><span class="line"><span class="comment">        if (pred != null) &#123;</span></span><br><span class="line"><span class="comment">            node.prev = pred;</span></span><br><span class="line"><span class="comment">            if (compareAndSetTail(pred, node)) &#123;</span></span><br><span class="line"><span class="comment">        		//利用cas机制将当前线程结点添加到队尾，然后返回Node结束方法</span></span><br><span class="line"><span class="comment">                pred.next = node;</span></span><br><span class="line"><span class="comment">                return node;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        //运行到这里说明加入等待队尾失败        </span></span><br><span class="line"><span class="comment">        enq(node);</span></span><br><span class="line"><span class="comment">        //调用enq(node)</span></span><br><span class="line"><span class="comment">        return node;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    //enq为等待队列，这里会不断死循环直到数据插入到等待队列队尾</span></span><br><span class="line"><span class="comment">    private Node enq(final Node node) &#123;</span></span><br><span class="line"><span class="comment">        for (;;) &#123;</span></span><br><span class="line"><span class="comment">            Node t = tail;</span></span><br><span class="line"><span class="comment">            if (t == null) &#123; // Must initialize</span></span><br><span class="line"><span class="comment">            	//如果队尾为空，说明该队列还没有创建，初始化</span></span><br><span class="line"><span class="comment">                if (compareAndSetHead(new Node()))</span></span><br><span class="line"><span class="comment">                	//创建新结点插入队首，此时队伍只有队首一个元素,将尾结点指向第一个头结点</span></span><br><span class="line"><span class="comment">                    tail = head;</span></span><br><span class="line"><span class="comment">            &#125; else &#123;</span></span><br><span class="line"><span class="comment">            	//队伍中有数据，那么将结点插入队伍</span></span><br><span class="line"><span class="comment">                node.prev = t;</span></span><br><span class="line"><span class="comment">                if (compareAndSetTail(t, node)) &#123;</span></span><br><span class="line"><span class="comment">                    t.next = node;</span></span><br><span class="line"><span class="comment">                    return t;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    因此我们大概可以知道如果状态从0置为1则说明获得了锁，失败了就会加入重试队伍中重试获取锁</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    判断条件:这里调用的是AbstractQueuedSynchronizer父类的方法</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">    protected final boolean compareAndSetState(int expect, int update) &#123;</span></span><br><span class="line"><span class="comment">        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span></span><br><span class="line"><span class="comment">        //参数1:调用的位置 参数2:偏移量 参数3:期待数  参数4:更新后的值</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    stateOffset = unsafe.objectFieldOffset (AbstractQueuedSynchronizer.class.getDeclaredField(&quot;state&quot;));0</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public native long objectFieldOffset(Field var1);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//创建了一个公平同步器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//FairSync.lock</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//尝试获得互斥锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//尝试获取互斥锁，如果成立返回true,反之线程加入等待队伍</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="tryLock方法"   >
          <a href="#tryLock方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryLock方法" class="headerlink" title="tryLock方法"></a>tryLock方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试获取锁，以非公平的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//尝试以非公平的方式获取锁</span></span><br><span class="line"><span class="comment">//如果锁是第一次获取则状态置为1</span></span><br><span class="line"><span class="comment">//如果锁已经被当前线程获取过，那么状态会是原来的状态+1</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="comment">//获得当前线程</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="comment">//获得当前状态</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                	<span class="comment">//如果用cas机制成功将0更新成参数</span></span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="comment">//将该线程设置为互斥锁的获得者</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//返回true表示获得锁成功 锁的状态为1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            	<span class="comment">//如果当前线程已经是锁的获得者了</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">                <span class="comment">//将c加入参数值然后交给下一个nextc变量</span></span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="comment">//将nextc设置成锁的状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//返回true表示获得锁成功，锁的状态为当前状态+1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    		<span class="comment">//返回false表示获得锁失败</span></span><br><span class="line">        &#125;    </span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>


        <h4 id="unlock方法"   >
          <a href="#unlock方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#unlock方法" class="headerlink" title="unlock方法"></a>unlock方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//设置了状态-1 </span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果队首不为空并且结点不是置于等待状态，调用unparkSuccessor()方法</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            	</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//返回true表示解锁成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    	<span class="comment">//返回false表示解锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图设置state状态来释放独占锁，如果解锁导致同步器非法，那么就抛出异常</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    	<span class="comment">//获得结点的等待状态,此时传入的结点是队首元素</span></span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//如果ws小于0 那么用compareAndSetWaitStatus方法将node结点的等待状态置为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    	<span class="comment">//获得下一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果下一个结点为空或者下一个结点的等待状态大于0</span></span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//那么将下一个结点置为空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="comment">//从队尾结点开始循环，当尾结点不是当前结点并且非空的时候进入循环，每次循环结束t将指向前一个结点</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//当t的状态字小于等于0的时候</span></span><br><span class="line">                    s = t;</span><br><span class="line">            		<span class="comment">//将s置于t</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果s不为空</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    		<span class="comment">//将下一个线程解除阻塞，即唤醒下一个等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Makes available the permit for the given thread, if it was not already available. If the thread was blocked on park then it will unblock. Otherwise, its next call to park is guaranteed not to block. This operation is not guaranteed to have any effect at all if the given thread has not been started.</span></span><br><span class="line"><span class="comment">形参:</span></span><br><span class="line"><span class="comment">thread – the thread to unpark, or null, in which case this operation has no effect</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">unpark</span><span class="params">(Object var1)</span>;</span><br></pre></td></tr></table></div></figure>


        <h2 id="ReentrantReadWriteLock"   >
          <a href="#ReentrantReadWriteLock" class="heading-link"><i class="fas fa-link"></i></a><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2>
      <p>变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6992448646407690164L</span>;</span><br><span class="line"><span class="comment">//串行化ID</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">//内部类 读锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">//内部类 写锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> TID_OFFSET;</span><br></pre></td></tr></table></div></figure>

<p>内部类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2274990926593161451L</span>;</span><br><span class="line">    <span class="comment">//串行化ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">writerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">readerShouldBlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //如果当前线程前面有一个排队线程则返回true</span></span><br><span class="line"><span class="comment">    //当线程位于队首或者队列为空则返回false</span></span><br><span class="line"><span class="comment">    public final boolean hasQueuedPredecessors() &#123;</span></span><br><span class="line"><span class="comment">        // The correctness of this depends on head being initialized</span></span><br><span class="line"><span class="comment">        // before tail and on head.next being accurate if the current</span></span><br><span class="line"><span class="comment">        // thread is first in queue.</span></span><br><span class="line"><span class="comment">        Node t = tail; // Read fields in reverse initialization order</span></span><br><span class="line"><span class="comment">        Node h = head;</span></span><br><span class="line"><span class="comment">        Node s;</span></span><br><span class="line"><span class="comment">        return h != t &amp;&amp;</span></span><br><span class="line"><span class="comment">            ((s = h.next) == null || s.thread != Thread.currentThread());</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">         * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">         * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">         * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;</span><br><span class="line">            <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="构造方法-1"   >
          <a href="#构造方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">    <span class="comment">//默认创建一个非公平的ReentrantReadWriteLock</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//调用ReentrantReadWriteLock(boolean fair) 方法 传入false参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    <span class="comment">//给定指定参数，创建相应的读锁写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">        readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="方法"   >
          <a href="#方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#方法" class="headerlink" title="方法"></a>方法</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回写锁</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回读锁</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="title function_">readLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回是否公平</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isFair</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync <span class="keyword">instanceof</span> FairSync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回锁的拥有线程</span></span><br><span class="line"><span class="keyword">protected</span> Thread <span class="title function_">getOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getOwner();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回读锁数量，用于监测系统状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getReadLockCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getReadLockCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询写锁是否空闲</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isWriteLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isWriteLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询当前线程是否有写锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isWriteLockedByCurrentThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询当前线程写锁的可重入数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWriteHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getWriteHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询当前线程读锁的可重入数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getReadHoldCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.getReadHoldCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>


        <h3 id="Sync常用方法"   >
          <a href="#Sync常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sync常用方法" class="headerlink" title="Sync常用方法"></a>Sync常用方法</h3>
      
        <h4 id="sync方法"   >
          <a href="#sync方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#sync方法" class="headerlink" title="sync方法"></a>sync方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Sync() &#123;</span><br><span class="line">            readHolds = <span class="keyword">new</span> <span class="title class_">ThreadLocalHoldCounter</span>();</span><br><span class="line">            <span class="comment">//调用ThreadLocalHoldCounter()</span></span><br><span class="line">            </span><br><span class="line">            setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">            <span class="comment">//设置状态字，确保readHolds的可见性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalHoldCounter</span> <span class="keyword">extends</span> <span class="title class_">ThreadLocal</span>&lt;HoldCounter&gt; &#123;</span><br><span class="line">            <span class="keyword">public</span> HoldCounter <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HoldCounter</span>();</span><br><span class="line">                <span class="comment">//调用方法 直接返回HoldCounter</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HoldCounter</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//设置数量为0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">tid</span> <span class="operator">=</span> getThreadId(Thread.currentThread());</span><br><span class="line">            <span class="comment">//获取当前线程id，使得被标记省的被垃圾回收</span></span><br><span class="line">        &#125;        </span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquire方法"   >
          <a href="#tryAcquire方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果是可重入获取或者队列策略允许，则该线程有权利加锁，那么将更新锁的状态并且设置持有者为当前线程</span></span><br><span class="line"><span class="comment">         	如果读或写计数器非0，且不是当前线程持有，则返回false</span></span><br><span class="line"><span class="comment">         	如果计数器将达到上限，则返回false</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    		<span class="comment">//获取锁的状态</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    		<span class="comment">//获取锁的可重入数计数</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">//如果可重入数计数为空或者锁非当前线程持有，那么返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="comment">//如果可重入数大于最大数量，抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                <span class="comment">//可重入锁加锁成功</span></span><br><span class="line">                <span class="comment">//将计数器设回状态中</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">// 能运行到这里也没有抛出异常 那么说明锁空闲</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||!compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="comment">//进行判断，如果写操作被阻塞或者CAS机制发现更新操作失败(即多线程情况下别人线程已经获取了锁)</span></span><br><span class="line">                <span class="comment">//加锁失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    		<span class="comment">//将当前线程设置为锁的持有者，返回true</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryRelease方法"   >
          <a href="#tryRelease方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="comment">//当锁不是当前线程持有，则抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//运行到这里说明锁的持有者是当前线程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    		<span class="comment">//将当前状态数减去1之后设置为更新后的状态数</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    		<span class="comment">//如果更新之后数据为0，那么说明锁空闲</span></span><br><span class="line">            <span class="keyword">if</span> (free) </span><br><span class="line">                <span class="comment">//锁空闲之后设置者为null</span></span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//设置更新之后的状态字</span></span><br><span class="line">            setState(nextc);</span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//返回可重入次数</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">            <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">            <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    	<span class="comment">//如果当前线程不是锁的持有者则返回false</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryWriteLock方法"   >
          <a href="#tryWriteLock方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryWriteLock方法" class="headerlink" title="tryWriteLock方法"></a>tryWriteLock方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryWriteLock</span><span class="params">()</span> &#123;</span><br><span class="line">    		<span class="comment">//获取当前线程和锁的状态字</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果锁有持有者</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">                <span class="comment">//获取锁的可重入数</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="comment">//如果锁并非当前线程持有，则加写锁失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                    <span class="comment">//如果锁的可重入数达到上限，则抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="comment">//执行到这里还没有抛出异常说明可重入数未达到上限或者锁空闲</span></span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">                <span class="comment">//用CAS机制设置状态失败</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    			<span class="comment">//返回false</span></span><br><span class="line">    </span><br><span class="line">    		<span class="comment">//如果加锁成功，那么将锁持有者设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryReadLock方法"   >
          <a href="#tryReadLock方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryReadLock方法" class="headerlink" title="tryReadLock方法"></a>tryReadLock方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">对读锁使用tryLock()方法</span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReadLock</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">          	<span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">                <span class="comment">//获取锁的状态</span></span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">//锁可重入数非空或者锁的持有者不是当前线程，则加锁失败</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">                <span class="comment">//获取分享状态字</span></span><br><span class="line">                <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">                    <span class="comment">//如果分享数达到上限 抛出异常</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="comment">//用CAS给状态c设置数据</span></span><br><span class="line">                    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果r为空</span></span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//那么读锁持有数设置为1，第一头结点设置为当前线程</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">//r非空，那么头结点获取线程数+1</span></span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//缓冲区线程数设置为头结点线程数</span></span><br><span class="line">                        <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            <span class="comment">//如果rh为空或者rh的线程id不等于当前线程id</span></span><br><span class="line">                            cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//加锁成功</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="tryAcquireShared方法"   >
          <a href="#tryAcquireShared方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#tryAcquireShared方法" class="headerlink" title="tryAcquireShared方法"></a>tryAcquireShared方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> unused)</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            如果写锁被另一个线程持有，则失败</span></span><br><span class="line"><span class="comment">            如果当前线程能有资格持有写锁。询问队列策略是否应该被阻塞</span></span><br><span class="line"><span class="comment">            	没有被阻塞，用CAS机制给锁更新状态和计数</span></span><br><span class="line"><span class="comment">            如果加锁失败，那么可能是线程不能持有写锁，或者CAS更新失败，或者计数器饱和	</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="comment">//判断写锁是否被其他线程持有</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sharedCount(c);</span><br><span class="line">    			<span class="comment">//将计数状态交给r</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//当不被阻塞,并且计数器小于最大值以及更新状态成功</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果计数器为0 ，那么将当前线程设置为第一个顾客，可重入计数为1</span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    <span class="comment">//如果第一个获取锁的是当前线程，那么将计数器+1</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">HoldCounter</span> <span class="variable">rh</span> <span class="operator">=</span> cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="literal">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h1 id="synchronized关键字"   >
          <a href="#synchronized关键字" class="heading-link"><i class="fas fa-link"></i></a><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/20/Sprng%E9%9D%A2%E8%AF%95%E9%A2%98/">Sprng面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">428</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">2分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Spring的事务传播行为"   >
          <a href="#Spring的事务传播行为" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring的事务传播行为" class="headerlink" title="Spring的事务传播行为"></a>Spring的事务传播行为</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事务有七种传播行为</span><br><span class="line"><span class="number">1.</span>REQUIRED:支持当前事务，当前有事务则直接加入该事务，当没有事务会创建一个新事务</span><br><span class="line"><span class="number">2.</span>SUPPORTS：支持当前事务，如果当前没事务就以非事务的方式进行</span><br><span class="line"><span class="number">3.</span>MANDATORY:支持当前事务，必须要有事务否则抛出异常</span><br><span class="line"><span class="number">4.</span>REQUIRES_NEW:不管有没有事务，都会开启新事务，会把当前事务挂起，当新事务执行结束老事务才会继续运行</span><br><span class="line"><span class="number">5.</span>NOT_SUPPORTED:以非事务的方式进行，如果有事务则把事务挂起</span><br><span class="line"><span class="number">6.</span>NEVER:不允许有事务，如果有事务则抛出异常</span><br><span class="line"><span class="number">7.</span>NESTED:如果当前有事务则嵌套在当前事务，如果没有会新建一个事务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">REQUIRED和NESTED的区别:REQUIRED是同一个事务，子进程回滚也会导致父进程回滚，NESTED是嵌套事务，子事务回滚不会导致父事务回滚，</span><br></pre></td></tr></table></div></figure>












        <h1 id="Spring事务什么时候会失效？"   >
          <a href="#Spring事务什么时候会失效？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring事务什么时候会失效？" class="headerlink" title="Spring事务什么时候会失效？"></a>Spring事务什么时候会失效？</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Bean对象没有被Spirng容器管理：自己new出来的bean对象而不是IOC中的Bean</span><br><span class="line">2.方法的访问权限不是Public，方法的访问权限是private也会失效</span><br><span class="line">3.数据库不支持事务，所以Spring的事务会失效</span><br><span class="line">4.异常被捕获了，导致本该回滚的数据没有回滚</span><br><span class="line">5.异常类型错误或者配置错误</span><br><span class="line">6.数据源没有配置事务管理器</span><br><span class="line">7.自身调用:本方法内调用本方法，那么就没有走aop的代理过程，所以会失效</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h1 id="Spring事务的本质？"   >
          <a href="#Spring事务的本质？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring事务的本质？" class="headerlink" title="Spring事务的本质？"></a>Spring事务的本质？</h1>
      
        <h1 id="说说你对IOC的理解"   >
          <a href="#说说你对IOC的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说你对IOC的理解" class="headerlink" title="说说你对IOC的理解"></a>说说你对IOC的理解</h1>
      
        <h1 id="说说你对AOP的理解"   >
          <a href="#说说你对AOP的理解" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说你对AOP的理解" class="headerlink" title="说说你对AOP的理解"></a>说说你对AOP的理解</h1>
      
        <h1 id="AutoWired和Resource的区别"   >
          <a href="#AutoWired和Resource的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#AutoWired和Resource的区别" class="headerlink" title="AutoWired和Resource的区别?"></a>AutoWired和Resource的区别?</h1>
      </div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/20/SpringMVC%E9%9D%A2%E8%AF%95%E9%A2%98/">SpringMVC面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">565</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">3分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="什么是SpringMVC"   >
          <a href="#什么是SpringMVC" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringMVC是Spring框架下的一个模块，用于处理web请求，基于MVC的web框架,而MVC是一种设计模式</span><br><span class="line">    M -model模型 </span><br><span class="line">   	V -View 视图</span><br><span class="line">    C -controller控制器</span><br></pre></td></tr></table></div></figure>


        <h1 id="能说说SpringMVC的工作流程吗？"   >
          <a href="#能说说SpringMVC的工作流程吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#能说说SpringMVC的工作流程吗？" class="headerlink" title="能说说SpringMVC的工作流程吗？"></a>能说说SpringMVC的工作流程吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>用户发送HTTP请求到前端控制器DispatcherServlet</span><br><span class="line"><span class="number">2.</span>DispatcherServlet调用handlerMapping(处理器映射器)找到映射器</span><br><span class="line"><span class="number">3.</span>handlerMapping通过url路径生成对应的处理器和拦截器，一起返回给DispatcherServlet</span><br><span class="line"><span class="number">4.</span>DispatcherServlet调用handlerAdapter(处理器适配器)</span><br><span class="line"><span class="number">5.</span>handlerApadter调用handler(处理器)[也就是我们写的Controller]</span><br><span class="line"><span class="number">6.</span>handler处理返回结果封装成ModelandView</span><br><span class="line"><span class="number">7.</span>handlerApadter将返回结果ModelandView返回给DispatcherServlet</span><br><span class="line"><span class="number">8.</span>DispatcherServlet将ModelandView发送给ViewReslover(视图解析器)</span><br><span class="line"><span class="number">9.</span>ViewReslover解析之后返回具体的View</span><br><span class="line"><span class="number">10.</span>DisPatcherServlet将View渲染</span><br><span class="line"><span class="number">11.</span>DisPatcherServlet相应用户</span><br><span class="line">    </span><br><span class="line">而面向接口编程有不同的工作流程</span><br><span class="line"><span class="number">1.</span>用户发送HTTP请求到前端控制器DispatcherServlet</span><br><span class="line"><span class="number">2.</span>DispatcherServlet调用handlerMapping(处理器映射器)找到映射器</span><br><span class="line"><span class="number">3.</span>handlerMapping通过url路径生成对应的处理器和拦截器，一起返回给DispatcherServlet</span><br><span class="line"><span class="number">4.</span>DispatcherServlet调用handlerAdapter(处理器适配器)</span><br><span class="line"><span class="number">5.</span>handlerApadter调用handler(处理器)[也就是我们写的Controller]</span><br><span class="line"><span class="number">6.</span>方法上添加ReSponseBody</span><br><span class="line"><span class="number">7.</span>通过HttpMessageConverter来返回结果转为Json格式并响应</span><br></pre></td></tr></table></div></figure>


        <h1 id="SpringMVC的主要组件有哪些"   >
          <a href="#SpringMVC的主要组件有哪些" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringMVC的主要组件有哪些" class="headerlink" title="SpringMVC的主要组件有哪些"></a>SpringMVC的主要组件有哪些</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主要有五个组件:DisPatcherServlet、handlerMapping、handlerAdapter、handler、ViewReslover</span><br><span class="line"></span><br><span class="line">1.DisPatcherServlet:前端控制器    整个流程的控制中心，调用其他组件来处理网络请求</span><br><span class="line">2.handlerMapping   :处理器映射器  负责根据网络请求不同找到对应的处理器映射</span><br><span class="line">3.hander           :处理器       对具体的请求进行处理，通常是我们写的Controller</span><br><span class="line">4.handerAdapter    :处理器适配器  通过特定的规则去执行handler</span><br><span class="line">5.ViewReslover     :视图解析器    用于解析处理结果生成View</span><br></pre></td></tr></table></div></figure>


        <h1 id="SpringMVC有哪些常用注解？"   >
          <a href="#SpringMVC有哪些常用注解？" class="heading-link"><i class="fas fa-link"></i></a><a href="#SpringMVC有哪些常用注解？" class="headerlink" title="SpringMVC有哪些常用注解？"></a>SpringMVC有哪些常用注解？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> :用于处理请求url的注解，可用于类和方法上，用于类上则所有方法都需要有这个父地址</span><br><span class="line"><span class="meta">@RequestBody</span>    :实现接收网络请求中的JSON数据</span><br><span class="line"><span class="meta">@ResponseBody</span>   :用于返回Json格式的数据</span><br></pre></td></tr></table></div></figure>


        <h1 id="Spring、SpringMVC、SpringBoot的区别"   >
          <a href="#Spring、SpringMVC、SpringBoot的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#Spring、SpringMVC、SpringBoot的区别" class="headerlink" title="Spring、SpringMVC、SpringBoot的区别"></a>Spring、SpringMVC、SpringBoot的区别</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring是一个开发框架，核心的IOC和AOP</span><br><span class="line">SpringMVC是Spring的一个模块，用于处理网络请求的模块</span><br><span class="line">SpringBoot是基于Spring的一个脚手架，为开发Spring生态其他框架铺平道路</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/19/%E6%9F%90%E5%A4%A7%E5%8E%82%E7%9A%84%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%BA%BF%E4%B8%8B%E9%9D%A2%E8%AF%95/">某大厂的实习生线下面试</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>一开始约的是两点面试，然后我是一点半就到了，搞来搞去变得直接上去在别人办公室里，等上一个哥们面试结束，然后直接就开始了。</p>
<h2 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2><p>1.简单介绍一下自己的家庭情况和学校的实习、学习情况，主修的课程、技能等</p>
<p>2.看你简历上有一个仿今日头条的项目?是出于什么目的进行开发的呢？</p>
<p>3.项目是几个人组成的小组?每个人的成员构成和职责是什么样的？</p>
<p>4.你负责的是哪个角色？</p>
<p>5.你应该也有在网上学习java，能说一下你在互联网是通过什么渠道学习的呢？</p>
<p>6.你了解前端开发吗？</p>
<p>7.有了解过集合吗？看过底层源码吗？</p>
<p>8.ArrayList底层是怎么进行创建和扩容的呢？</p>
<p>9.集合是怎么处理哈希碰撞的？</p>
<p>10.有了解过锁吗?Lock和Sychorized那些</p>
<p>11.final修饰符有学习过吗？它有什么使用场景</p>
<p>12.final修饰方法会怎么样？final修饰类会怎么样?</p>
<p>13.Integer和int能直接进行比较吗？</p>
<p>14.Integer底层有一个缓冲数组，在这个缓冲数组边界能直接使用吗？</p>
<p>15.&#x3D;&#x3D;和equals方法的区别</p>
<p>16.有了解过Volatile关键字吗？</p>
<p>17.说说SpringMVC的执行流程</p>
<p>18.说说你对Vue和H5的理解</p>
<p>19.V-show和V-if的使用场景</p>
<p>20.有了解过垃圾回收机制吗？</p>
<p>21.jdk1.8之后默认的GC是哪个？</p>
<p>22.有了解过主流的数据库吗？</p>
<p>23.说说你对Mysql优化的理解</p>
<p>24.有了解过范式和反范式吗？</p>
<p>25.你在项目中有使用过Redis，能说说你基于什么情况考虑使用的Redis呢?</p>
<p>26.Redis常用的数据类型有哪些？</p>
<p>27.你在Redis的环境下有没有开发部署过项目</p>

        <h2 id="-1"   >
          <a href="#-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#-1" class="headerlink" title="&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;"></a>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</h2>
      <p>技术面部分结束了，然后hr问我有没有想对公司了解的情况</p>
<p>我当时问的是1.实习的时间段，是否支持转正</p>
<p>​						2.上班工作的时间段</p>
<p>然后这个时候技术面试官追问了一条能不能接收996的情况</p>
<p>总结和复盘：</p>
<p>首先，我要感谢这个公司能给我一个这个时间段的一个技术线下面试，在目前我所在的阶段，这个机会是千载难逢的，这是不可否认的。</p>
<p>其次，我因为是第一次线下面试，经过这个技术面才能知道学习到的东西和当时在小房子里面能想起来的东西真的差距很大。</p>
<p>我进去脑子一片空白，和技术面试官大眼瞪小眼，你看着我我看着你，然后他问的东西有些其实我都知道也系统学习过看过源码，但是在当时的环境下，我脑子里面什么都不知道，所有的都是基于平常的理解再一点点一点点的复述出来。</p>
<p>第三，因为第一个问题就把我问爆了有点，我自己答得不对，甚至有可能是全错，这个面试官眉头一皱，我就知道这次其实噶了，但是万幸的是在这个时间段失败是可以接受的事，因为只有经过这次面试，我才知道在日常学习和真的面试中你能脑子里想出来的东西是不一样的，我得加强对面试情况的测试。</p>
<p>真得重新准备准备下EE的内容，因为基础有点忘记了搞得答出来很没有底气，我都不知道是对是错，等校招的时候好好发挥一下，在这个时间段就应该多投实习面试，去多尝试面试，锻炼面试经验</p>
<p>可以说很多准备的东西都没有问到，问到的都是偏向基础和底层，而这块确实是我现在目前尚未发现的问题。</p>
<p>输一场也不一定是坏事，是吧</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/19/JavaSE%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%90%E6%BA%90%E7%A0%81%E7%AF%87%E3%80%91/">JavaSE基础-并发编程【源码篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-19</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">0</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/15/JavaSE%E5%9F%BA%E7%A1%80-%E9%9B%86%E5%90%88%E3%80%90%E6%BA%90%E7%A0%81%E7%AF%87%E3%80%91/">JavaSE基础-集合【源码篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-15</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">19.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">165分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="集合"   >
          <a href="#集合" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合" class="headerlink" title="集合"></a>集合</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">集合与数组的区别：1.集合的长度可变，而数组的长度不可变</span><br><span class="line">			   2.集合只能存引用数据类型，而数组能存基本数据类型和引用数据类型</span><br><span class="line">			   3.集合可以存放多种数据类型，而数组在定义是只能存放同一种的数据类型</span><br></pre></td></tr></table></div></figure>

<p>集合分为两种，一种是继承Collection的单列集合List和Set，另一种就是实现Map接口的双列集合</p>

        <h2 id="Collection的子接口"   >
          <a href="#Collection的子接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Collection的子接口" class="headerlink" title="Collection的子接口"></a>Collection的子接口</h2>
      
        <h3 id="1-List接口"   >
          <a href="#1-List接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-List接口" class="headerlink" title="(1)List接口"></a>(1)List接口</h3>
      <p>list的特性是：可重复、有序、有索引、可插入Null</p>
<p>实现List接口的实现类是ArrayList、LinkedList、Vector</p>

        <h4 id="1、ArrayList"   >
          <a href="#1、ArrayList" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h4>
      <p>ArrayList底层：</p>
<p>变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//默认长度</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//空数组</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认初始化情况下的空数组</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">创建ArrayList的时候：</span><br><span class="line"><span class="number">1.</span>无参构造 </span><br><span class="line">    <span class="comment">//  Constructs an empty list with an initial capacity of ten. 构建一个空的list并且将初始容量为10</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    //  The array buffer into which the elements of the ArrayList are stored. 这个缓冲区被用于存储ArrayList对象</span></span><br><span class="line"><span class="comment">    //  The capacity of the ArrayList is the length of this array buffer.  ArrayList的容量取决于这个缓冲区长度</span></span><br><span class="line"><span class="comment">    //  Any empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA will be expanded to DEFAULT_CAPACITY when the first element is added. </span></span><br><span class="line"><span class="comment">    	任何空的ArrayList当缓冲区等于空的地址与默认为空的实例相等时将会扩容默认的容量当第一次元素添加</span></span><br><span class="line"><span class="comment">    	</span></span><br><span class="line"><span class="comment">		transient Object[] elementData;   </span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	//	Shared empty array instance used for default sized empty instances.  用于默认大小的空实例的共享空数组实例。</span></span><br><span class="line"><span class="comment">	//  We distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when first element is added.</span></span><br><span class="line"><span class="comment">		我们将其与EMPTY_ELEMENTDATA区分开来，以了解添加第一个元素时要膨胀多少。</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">总结 空参构造就是创建一个大小为<span class="number">0</span>的Object数组  它会当第一次元素添加的时候扩容</span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity. 构造一个指定大小容量的空List</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list   参数：这个List的容量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity is negative</span></span><br><span class="line"><span class="comment">     	抛出异常当这个指定的容量为负数时</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">       共享一个空的数组实例用来代表空数组</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">       private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;  <span class="comment">//传入参数：指定的容量</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">            <span class="comment">//如果这个参数大于0 则将创建一个这个参数大小的Object数组 并且赋值给缓冲区</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个参数等于0 则将空数组实例赋值给缓冲区</span></span><br><span class="line">            <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果这个参数为负数 则抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">总结 </span><br><span class="line">    参数大于<span class="number">0</span>的时候会创建一个这个参数大小的数组 </span><br><span class="line">    参数等于<span class="number">0</span>的时候会创建一个大小为<span class="number">0</span>的数组</span><br><span class="line">    参数小于<span class="number">0</span>的时候会抛出异常</span><br><span class="line">有参构造<span class="number">2</span>：</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified collection, in the order they are returned by the collection&#x27;s iterator.</span></span><br><span class="line"><span class="comment">     * 创建一个List，该List包含参数集合中的元素，按参数集合的迭代器返回的顺序排列。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list  </span></span><br><span class="line"><span class="comment">       参数c是一个要被放入这个新list中的集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">       当参数集合是空集合的时候抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">    	<span class="comment">//先将C数组化放到对象数组a中</span></span><br><span class="line">        <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果数组a的长度不等于0的话，即这个传入进来的集合非空</span></span><br><span class="line">            <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;</span><br><span class="line">        <span class="comment">//如果集合C也是一个ArrayList 就将a传入缓存区的指针中</span></span><br><span class="line">                elementData = a;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果集合C不是ArrayList,就用Arrays.copy这个数组存入一个对象数组中，再传入ElementData中</span></span><br><span class="line">                elementData = Arrays.copyOf(a, size, Object[].class);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当数组长度为0的时候，为空List</span></span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">总结：这个有参构造就是将集合的全部拷贝</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>

<p>不仅如此，现在只是了解了ArrayList怎么创建的数组，但是空参构造会调用父类的构造方法，所以我们要看一下父类的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>父类AbstractList</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">AbstractList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="number">2.</span>父类AbstractCollection</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line"> <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>但是问题来了，ArrayList已知创建一个大小为0的Object数组，并且提到会在第一次添加元素的时候进行扩容，这个扩容又是怎么处理的呢？我们重点要关注一下Add方法，且由于ArrayList的父类是抽象类，所以我们只要关注本身的Add方法即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list. 添加一个元素进入这个list的尾部</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e element to be appended to this list 参数：一个将要被添加到list中的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)  </span></span><br><span class="line"><span class="comment">   返回true </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">   私有化一个size 用来表示这个ArrayList的长度(包含元素的个数)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//用来记录集合操作的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>; 定义数组的最大长度</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//调用ensureCapacityInternal() 方法 传入size(现在这个ArrayList元素个数)+1</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="comment">//将size自增后将E插入进这个Object数组(缓存区) ==&gt; 插入数组尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;							</span><br><span class="line">    <span class="comment">//返回Ture</span></span><br><span class="line">&#125;																	  </span><br><span class="line">																	  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入参数 minCapacity即需要的最小长度</span></span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    <span class="comment">//先看参数calculateCapacity(elementData, minCapacity)   </span></span><br><span class="line">    <span class="comment">//这个calculateCapacity()方法会返回一个数据，即扩容的大小</span></span><br><span class="line">    <span class="comment">//调用 ensureExplicitCapacity()方法，将计算出的大小传入进去</span></span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入参数:是经过计算之后算出的长度(默认长度10或者是大于10且是需要的最小长度)</span></span><br><span class="line">	</span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="comment">//modCount是用来记录集合被操作过的次数  自增</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//说明这段代码是考虑过溢出的</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//如果需要的长度减去数组长度&gt;0的话 触发生长函数</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">//将缓冲区数组和需要最小长度传入</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="comment">//如果这个缓冲区是等于默认的空数组实例 即空数组</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    <span class="comment">/*返回一个最大值(在默认大小和最小需要长度之间)</span></span><br><span class="line"><span class="comment">    	已知默认长度为10，假如目前数组中有0个数据一次性插入12个数据</span></span><br><span class="line"><span class="comment">    	那么minCapacity应该为12  最小长度为现在数组个数+需要插入个数</span></span><br><span class="line"><span class="comment">    	于是最终返回12</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当缓存区数组是存在数据的，那么直接返回需要的最小集合长度</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入参数：默认10或者是大于10但是需要的最小长度</span></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">//定义一个变量 记录老数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个变量 记录新数组的长度  新数组的长度等于老数组的长度+老数组右移一位</span></span><br><span class="line"><span class="comment">    	如： 老数组长度为10  则二进制是1010  右移一位就是101  ==&gt; 5</span></span><br><span class="line"><span class="comment">    	    所以新数组的长度是10+5  即新数组的长度是老数组的1.5倍  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">    	<span class="comment">//如果新数组长度比需要的最小长度还小 则将新数组长度直接设为需要的最小长度</span></span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    	<span class="comment">//如果新数组长度比数组最大长度还大 则调用hugeCapacity()方法</span></span><br><span class="line">    	<span class="comment">//这个方法会1.抛出堆栈溢出错误2.返回定义的数组最大长度\整数的最大长度</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    	最后将老数组拷贝到新数组中，再赋值回老数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">	<span class="comment">//传入需要的最小长度</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">    <span class="comment">//如果是小于0 则抛出异常  堆栈溢出</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">    	<span class="comment">//如果最小长度比定义的最大数组长度还大，则直接返回整数的最大长度，否则返回定义的数组最大长度</span></span><br><span class="line">        Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>所以关注子类的构造方法即可</p>

        <h4 id="2、LinkedList"   >
          <a href="#2、LinkedList" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、LinkedList" class="headerlink" title="2、LinkedList"></a>2、LinkedList</h4>
      <p>linkedList底层:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">结构:</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123;</span><br><span class="line">	<span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; first; <span class="comment">//定义LinkedList的首结点</span></span><br><span class="line">	<span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//定义LinkedList的尾结点</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里是Node的结构</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = element;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>因此我们可以得出LinkedList的Node结构示意图</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">Node<E> prev</th>
<th align="center">element</th>
<th align="center">Node<E> next</th>
</tr>
</thead>
</table></div>
<p>并且LinkedList是一个双端链表，它记录了头结点和尾结点的位置</p>
<p>我们接下来也要探究一下构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list. 创建一个空list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified collection, in the order they are returned by the collection&#x27;s  iterator.</span></span><br><span class="line"><span class="comment">     创建一个list，新list包含传入参数集合的元素和构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();   <span class="comment">//调用空参构造</span></span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c); <span class="comment">//返回调用函数的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        checkPositionIndex(index); </span><br><span class="line">        <span class="comment">//将LinkedList的容量传入</span></span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();  <span class="comment">//将传入的集合C进行数组化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;     <span class="comment">//记录C中的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)           <span class="comment">//如果C是空集合则返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;        <span class="comment">//定义两个节点</span></span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;       <span class="comment">//如果index==size 即添加的位置在链表的尾部</span></span><br><span class="line">            succ = <span class="literal">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">            <span class="comment">//设置index前结点为LinkedList的尾结点,尾结点设为空</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;				   <span class="comment">//如果index!=size，说明添加的索引位置不在链表尾部，而是在队中	</span></span><br><span class="line">            <span class="comment">//如果不位链表的尾部 </span></span><br><span class="line">            <span class="comment">//取出index结点的数据。</span></span><br><span class="line">            <span class="comment">//将succ置为index结点的数据，并将succ的前置结点信息交给pred，即pred指向index的前置结点</span></span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//遍历数组a</span></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) o;</span><br><span class="line">            <span class="comment">//@SuppressWarnings(&quot;unchecked&quot;) 告诉编译器不要出现警告信息 E e =(E) o 强制类型转换成E</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建新结点newNode 将前驱结点设为pred 传入数据 尾结点置空 </span></span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">//如果前驱结点为空  则第一个节点就是newNode; 即这是链表第一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//反之，前驱结点的后继结点设为新结点</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将前驱结点的指针往后移动到新节点上</span></span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//循环结束</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">/*在循环开始之前,对index和size进行了判断</span></span><br><span class="line"><span class="comment">        	如果index==size，说明这是链表尾部添加的数据。则将succ=null,pred=last即将pred置为链表尾部</span></span><br><span class="line"><span class="comment">        		循环结束之后pred=newNode即说明pred指向的是新结点的位置</span></span><br><span class="line"><span class="comment">        	如果index!=size，说明这不是尾部添加的数据，而是在链表中间添加的数据</span></span><br><span class="line"><span class="comment">        		我们将index索引位置的结点取出来了并将其保存于succ中，前置结点的信息保存在pred中</span></span><br><span class="line"><span class="comment">        		当循环结束之后pred中的位置指向新结点的位置</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="literal">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">            <span class="comment">//说明这是链表尾部添加的数据，当循环结束之后我们只要把last指针指向pred 即尾指针指向最后添加的结点即可</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之这是队中的数据</span></span><br><span class="line">            <span class="comment">//将新结点的后继结点置为succ 即置为原本index索引位置上的结点</span></span><br><span class="line">            <span class="comment">//将succ的前置结点设为新结点，保证双向链表的建立</span></span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">		<span class="comment">//将C中元素个数加入到size中</span></span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="comment">//modCount++ 指的是记录这个链表操作次数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isPositionIndex(index))</span><br><span class="line">            <span class="comment">//如果返回False 则抛出异常</span></span><br><span class="line">            <span class="comment">//这个函数在有参构造时调用会返回True，不会进入IF语句中</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isPositionIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt;= size;</span><br><span class="line">        <span class="comment">/*当index大于等于0并且index小于等于size 时返回True   </span></span><br><span class="line"><span class="comment">           有参构造调用方法的时候传入的index==size，所以这个方法调用时会返回true</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>除了关注LinkedList本身的构造函数我们也要关注一下父类的构造</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>父类AbstractSequentialList</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">AbstractSequentialList</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span>父类AbstractList</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="title function_">AbstractList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="number">3.</span>父类AbstractCollection</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以关注子类的构造方法即可</p>

        <h4 id="3、Vector"   >
          <a href="#3、Vector" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、Vector" class="headerlink" title="3、Vector"></a>3、Vector</h4>
      <p>Vector属性:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] elementData;    <span class="comment">//定义一个Object数组</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> elementCount;		   <span class="comment">//定义变量记录元素个数</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="type">int</span> capacityIncrement;   <span class="comment">//定义容器应该增长时的数量</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">2767605614048989439L</span>; <span class="comment">//序列化ID</span></span><br><span class="line">   </span><br></pre></td></tr></table></div></figure>

<p>Vector的添加方法:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">        modCount++;  </span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = obj;</span><br><span class="line">     	<span class="comment">//记录操作数+1 确保容量大小 然后将数据存放到新的索引位置中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    	<span class="comment">//记录操作数+1 确保容量大小 然后将数据存放到新的索引位置中 返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">        ensureCapacityHelper(elementCount + numNew);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> elementCount - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        elementCount += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">//记录操作数++  当index为负或者大于容量个数时抛出索引越界异常</span></span><br><span class="line">    	<span class="comment">//扩容，拷贝原数组到扩容后的新数组</span></span><br><span class="line">    	<span class="comment">//当参数中的集合元素不为0的时候返回true反之false</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>分析ArrayList、LinkedList和Vector的不同点某过于Vector方法中都带有Synchronized锁</p>
<p>即说明Vector是同步的，是线程安全的而ArrayList、LinkedList是不同步的，是线程不安全的</p>

        <h3 id="2-Set接口"   >
          <a href="#2-Set接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-Set接口" class="headerlink" title="(2)Set接口"></a>(2)Set接口</h3>
      <p>Set的特性有:不可重复、无序、无索引、可以存NULL【只能存一个】</p>

        <h4 id="1、HashSet"   >
          <a href="#1、HashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、HashSet" class="headerlink" title="1、HashSet"></a>1、HashSet</h4>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">5024744406713321676L</span>; <span class="comment">//序列化ID</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map; 					<span class="comment">//HashMap</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();        <span class="comment">//一个Objectg对象</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">     //构造一个空的set,HashMap初始容量为16并且负载因子0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个HashMap，容量为<span class="number">16</span>并且负载因子为<span class="number">0.75</span>    </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">【<span class="number">1</span>】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new set containing the elements in the specified collection.</span></span><br><span class="line"><span class="comment">        The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor(0.75) and an initial capacity sufficient to contain the elements in the specified collection.</span></span><br><span class="line"><span class="comment">	 //创建一个set包含了这个传入集合的元素，这个HashMap将是默认的负载因子0.75，创建的容量大小足够包含传入参数集合的元素</span></span><br><span class="line"><span class="comment">	 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    	<span class="comment">//将会调用HashSet(int initialCapacity)方法  </span></span><br><span class="line">    	<span class="comment">//调用方法传入参数为 c的大小/0.75后+1 与 16的最大值</span></span><br><span class="line">        addAll(c);  </span><br><span class="line">    	<span class="comment">//调用父类的addAll()方法 传入指定集合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)                      <span class="comment">//遍历集合的每一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="literal">true</span>;			</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        <span class="comment">//这个方法返回True说明集合因此改变，如果集合由于任何原因而拒绝添加特定元素，而不是因为它已经包含该元素，那么它必须抛出异常（而不是返回false）。此实现总是抛出UnsupportedOperationException。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">即创建一个HashMap，初始负载因子为<span class="number">0.75</span>,初始容量可以容下原本集合的元素或者<span class="number">16</span>个    </span><br><span class="line">【<span class="number">2</span>】</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment">     //构建一个HashMap,负载因子和容量都需要作为参数传入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个HashMap，负载因子和容量都需要作为参数传入       </span><br><span class="line">【<span class="number">3</span>】</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has the specified initial capacity and default load factor (0.75).</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个HashMap，负载因子为<span class="number">0.75</span>，容量需要作为参数传入</span><br><span class="line">【<span class="number">4</span>】</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a new, empty linked hash set.  (This package private constructor is only used by LinkedHashSet.)</span></span><br><span class="line"><span class="comment">     //这个构造方法专属于LinkedHashSet</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     The backingHashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>      dummy             ignored (distinguishes this constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment">     //dummy参数表示被忽略(与其他构造函数相比)</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">     *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line">即创建一个LinkedHashMap(多态的关系)</span><br><span class="line">    </span><br></pre></td></tr></table></div></figure>

<p>同时因为HashSet有父类，所以我们也要看一下父类的构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、父类AbstractSet</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSet</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractSet</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>、父类AbstractCollection</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">AbstractCollection</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></div></figure>

<p>所以关注子类的构造方法即可</p>
<p>所以HashSet底层都是创建了一个HashMap或者LinkedHashMap实现</p>

        <h4 id="2、LinkedHashSet"   >
          <a href="#2、LinkedHashSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、LinkedHashSet" class="headerlink" title="2、LinkedHashSet"></a>2、LinkedHashSet</h4>
      <p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	调用父类HashSet的方法</span></span><br><span class="line"><span class="comment">	HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span></span><br><span class="line"><span class="comment">        map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span></span><br><span class="line"><span class="comment">        //传入参数容量16和负载因子0.75  </span></span><br><span class="line"><span class="comment">        //调用LinkedHashMap&lt;&gt;(initialCapacity, loadFactor)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">LinkedHashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(Math.max(<span class="number">2</span>*c.size(), <span class="number">11</span>), <span class="number">.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>LinkedHashSet的构造方法最后都是调用父类HashSet的有参构造，即HashSet(int initialCapacity, float loadFactor, boolean dummy)</p>
<p>所以要一探究竟这LinkedHashSet到底是什么实现还得等到双端链表中的LinkedHashMap</p>
<p>所以先不谈</p>

        <h4 id="3、TreeSet"   >
          <a href="#3、TreeSet" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、TreeSet" class="headerlink" title="3、TreeSet"></a>3、TreeSet</h4>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></div></figure>

<p>构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、无参构造</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">创建一个TreeMap对象</span><br><span class="line"><span class="number">2</span>、有参构造</span><br><span class="line">	TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(comparator));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeSet</span><span class="params">(SortedSet&lt;E&gt; s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(s.comparator());</span><br><span class="line">        addAll(s);</span><br><span class="line">    &#125;</span><br><span class="line">创建TreeMap对象</span><br></pre></td></tr></table></div></figure>

<p>所以TreeSet底层是封装了TreeMap对象来实现效果</p>

        <h3 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>底层原理</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>底层实际上是Object数组,开始初始容量为10,扩容为原来的1.5倍,因为是数组结构所以利于查找不利增删</td>
<td>有序、可重复、有索引、非线程安全</td>
</tr>
<tr>
<td>LinkedList</td>
<td>底层是双端链表,所以利于增删不利于查找</td>
<td>有序、可重复、有索引、非线程安全</td>
</tr>
<tr>
<td>Vector</td>
<td>底层是Object数组,但是因为方法中加有synchronized关键字,所以多线程下线程安全,但是效率低下</td>
<td>有序、可重复、有索引、线程安全</td>
</tr>
<tr>
<td>HashSet</td>
<td>底层封装了HashMap，本质上就是一个HashMap，默认初始容量为16，负载因子为0.75,每次扩容为原来容量的两倍。因为底层是HashMap所以线程不安全</td>
<td>无序、不可重复、没有索引、非线程安全</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>底层封装了LinkedHashMap，默认初始容量为16，负载因子为0.75,线程不安全</td>
<td>无序、不可重复、没有索引</td>
</tr>
<tr>
<td>TreeSet</td>
<td>底层封装了TreeMap，TreeMap底层是二叉树(红黑树),所以线程不安全</td>
<td>无序、不可重复、没有索引、非线程安全</td>
</tr>
</tbody></table></div>

        <h2 id="Map的子接口"   >
          <a href="#Map的子接口" class="heading-link"><i class="fas fa-link"></i></a><a href="#Map的子接口" class="headerlink" title="Map的子接口"></a>Map的子接口</h2>
      
        <h3 id="1、HashMap"   >
          <a href="#1、HashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、HashMap" class="headerlink" title="1、HashMap"></a>1、HashMap</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个默认的容量   1左移4位 即二进制1 ==&gt; 10000 则初始容量为16</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个最大的容量   1左移30位即二进制1 ==&gt;100000000000000000000000000000 即最大容量为1073741824</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义默认的负载因子  0.75</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个链表的长度,当链表的长度达到这个长度会转化成红黑树      链表转化长度阈值为8</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个退化的阈值，当红黑树的链表长度低于这个数则会转化为链表  红黑树退化长度阈值为6</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个数组的长度，当数组的长度大于64的时候才会转化成红黑树   数组转化长度阈值为64</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Node数组 用于存放结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个entrySet 存放键值对</span></span><br><span class="line">   <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个变量记录Map数量</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个变量用于记录集合的操作次数</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="type">int</span> modCount;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//（javadoc描述在序列化时为true。此外，如果表数组尚未分配，则此字段将保留初始数组容量，或零表示DEFAULT_initial_capacity。）</span></span><br><span class="line"><span class="comment">//数组扩容阈值</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法："   >
          <a href="#1、构造方法：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法：" class="headerlink" title="1、构造方法："></a>1、构造方法：</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    	<span class="comment">//将默认的加载因子为0.75给成员变量loadFactor中</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    	<span class="comment">//传入一个初始容量和一个默认的负载因子0.75 </span></span><br><span class="line">    	<span class="comment">//然后调用public HashMap(int initialCapacity, float loadFactor) </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">//如果容量是负数，则抛出异常</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="comment">//如果容量超过了设定的最大容量 则将最大容量给变量init</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="comment">//如果负载因子小于等于0，或者负载因子为空则抛出异常</span></span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//将这个传入的负载因子传入成员变量loadFactor中</span></span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">     	<span class="comment">//调用tableSizeFor(int cap) 将结果给threshold 即调用结果就是数组扩容的阈值   </span></span><br><span class="line">        <span class="comment">//调用这个方法就知道下次数组该什么时候扩容，但是这个数据是1:最大容量:n+1</span></span><br><span class="line">        <span class="comment">//我们后续会在resize()方法将阈值进行调整</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设传入的数cap=11 则n会等于10 </span></span><br><span class="line"><span class="comment">        因为执行到最后n |= n &gt;&gt;&gt; 16  n会无符号右移16位所以二进制位表示会是32位的</span></span><br><span class="line"><span class="comment">        【无符号右移】高位补零</span></span><br><span class="line"><span class="comment">        n的二进制数字为0000 0000 0000 0000 0000 0000 0000 1010</span></span><br><span class="line"><span class="comment">        n | = n &gt;&gt;&gt;1  即 n = 0000 1010 | 0000 0101  ==&gt; 0000 1111</span></span><br><span class="line"><span class="comment">        n | = n &gt;&gt;&gt;2  即 n = 0000 1111 | 0000 0011  ==&gt; 0000 1111</span></span><br><span class="line"><span class="comment">        ....</span></span><br><span class="line"><span class="comment">        因此我们可以知道这个结果n最后一定会是二进制的倍数-1  我们这里假设得到的数就是15        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当n&lt;0时返回1 否则n&gt;=0会进入判断n是否大于等于最大的容量 如果是则返回最大容量 反之则返回n+1</span></span><br><span class="line">        <span class="comment">//所以我们最后返回的数据就是16</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">//将默认的加载因子0.75赋值给成员变量loadFactor</span></span><br><span class="line">        </span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//调用PutMapEntries()方法  传入一个已经存在的map</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	形参:</span></span><br><span class="line"><span class="comment">		m – the map</span></span><br><span class="line"><span class="comment">		evict – false when initially constructing this map, else true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">        <span class="comment">//用s记录集合m的大小</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">                <span class="comment">//s&gt;0 且table ==null 说明传入的集合非空但是接收的集合为空</span></span><br><span class="line">                <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">                <span class="comment">//将s除以负载因子后+1 用ft记录下来</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                <span class="comment">//用变量t记录结果：如果ft小于最大的容量则为ft 反之则为最大的容量  【用于限制ft的最大大小】</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">                    <span class="comment">//如果t大于数组扩容因子，调用数组扩容函数计算出需要的容量并且记录在threshold中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            	<span class="comment">//s&gt;0但是table不是null 说明传入的集合非空且接收的集合非空  </span></span><br><span class="line">                <span class="comment">//s&gt;threshold 说明超过了数组的阈值，需要对数组扩容 调用resize()方法</span></span><br><span class="line">                resize();  <span class="comment">//resize()方法到扩容那方面在展开说</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">                <span class="comment">//遍历entryset然后调用putval()方法，简单说就是将数据传入新的集合中</span></span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">                <span class="comment">//put方法后面再展开说</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></div></figure>

<p>小结：HashTable底层是用Node[]数组和链表+红黑树组成</p>
<p>我们来说说刚刚忽略的内部类</p>

        <h4 id="2、内部类"   >
          <a href="#2、内部类" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、内部类" class="headerlink" title="2、内部类"></a>2、内部类</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//指向下一个结点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.hash = hash;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//重写了HashCode方法，返回值是对象key哈希值和Value哈希值异或结果</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//SetValue方法会将老数据进行返回 </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">/*重写了Equals方法 1.当地址相同直接返回tree</span></span><br><span class="line"><span class="comment">    					  2.地址不同则比较Entry实体，如果元素相同则返回True</span></span><br><span class="line"><span class="comment">    					  反之都不同则返回False</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">       </span><br><span class="line">    	TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">       	<span class="comment">//记录红黑树的父节点</span></span><br><span class="line">    	</span><br><span class="line">    	TreeNode&lt;K,V&gt; left;</span><br><span class="line">    	<span class="comment">//记录左子节点</span></span><br><span class="line">    </span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">    	<span class="comment">//记录右子节点</span></span><br><span class="line">    </span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    	<span class="comment">//记录前一个结点 【HashMap由数组+链表+红黑树构成，红黑树是链表转化而成的，所以数组中有结点用于挂载红黑树】 </span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    	<span class="type">boolean</span> red;</span><br><span class="line">    	<span class="comment">//记录结点是红还是黑</span></span><br><span class="line">    	</span><br><span class="line">        TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns root of tree containing this node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="3、常用方法"   >
          <a href="#3、常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line">Put方法:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//将Key,Value传入 然后调用putVal()进行返回;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		参数</span></span><br><span class="line"><span class="comment">    			1:hash值  这个是调用了hash()方法之后的结果</span></span><br><span class="line"><span class="comment">    		   	2:key值   这个是传入的Key</span></span><br><span class="line"><span class="comment">    		   	3:Value值 这个是传入的Value值</span></span><br><span class="line"><span class="comment">    		   	4:onlyIfAbsent  表示如果存在键相同时是否更新旧值为新值 true是不更新旧值 false是更新旧值为新值</span></span><br><span class="line"><span class="comment">    		   	5:evict         传入true</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		定义一个Node[]数组 tab </span></span><br><span class="line"><span class="comment">    		定义一个Node结点 p</span></span><br><span class="line"><span class="comment">    		定义一个变量n  用于记录数组长度</span></span><br><span class="line"><span class="comment">    		定义一个变量i  用于记录索引</span></span><br><span class="line"><span class="comment">    	*/</span> </span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//先将本地的table数组赋值给tab 再把tab的长度赋值给n  </span></span><br><span class="line">            <span class="comment">//如果tab为空或者长度为0，将tab进行resize()方法扩容之后的长度赋值给n</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    		<span class="comment">//将n-1和hash值做与运算 赋值给索引i 如果再将结点p指向tab[i] 并且判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果tab[i]为空即这个位置为空 则调用newNode()方法，将hash值，K,V，和下一个结点为NULL传入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">        	return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    	Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            this.hash = hash;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">            this.value = value;</span></span><br><span class="line"><span class="comment">            this.next = next;</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之  tab[i]不为空 即这个位置有元素了 下面第一个IF有三种情况</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="comment">//1.如果这个位置p的hash和传入的hash相同 并且 (p的key和传入的k地址相同||p的key和key值相同)</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//则将这个位置p赋值给结点e，并且跳出第一个if语句</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//反之位置P和传入的数据不同 ，判断 p instanceof TreeNode 即判断p是否为树(红黑树)</span></span><br><span class="line">                <span class="comment">//如果是则添加到红黑树里面 调用putTreeVal()方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最终位置P和传入的数据不同也不是红黑树结构 ==&gt;那么应该是链表结构</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//死循环 用一个变量binCount记录链表长度</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//当p不指向下一个结点，则将这个数据变成新的结点插入p的后继节点中</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//对循环次数做判断 </span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        <span class="comment">//当binCount&gt;=7的时候说明已经至少循环7次,即添加此次数据之后链表长度应该到8了,调用treeifyBin()方法，尝试转化成红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果e的hash值相同且key相同(地址或值)相同 则直接跳出循环 </span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//将指针p指向下一个结点 [在if ((e = p.next) == null) &#123;...&#125;判断时e指向了p的下一个结点]</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//-------------这里结束第一个IF语句---------------------------</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//如果e不为空 即说明e和新值发生了哈希碰撞，e为老结点</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//onlyIfAbsent是用来判断是否更新旧值的，为False时说明更新旧值为新值</span></span><br><span class="line">                    <span class="comment">//支持更新旧值或者老值为NUll时，新值代替旧值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">    			   void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; 这个方法仅允许LinkedHashMap调用</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//返回老值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//操作记录数++</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断添加操作之后数组是否需要进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();  </span><br><span class="line">    	<span class="comment">//调用resize()方法扩容</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//空实现</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	void afterNodeInsertion(boolean evict) &#123; &#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//是红黑树则添加到红黑树里，这里是红黑树调整的规则，暂不做分析</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                                       <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="type">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法是用来链表尝试转换成红黑树的  </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">//当数组长度小于64的时候我们进行扩容，将链表的值散落的落在数组上来提高查找效率而不转化成红黑树</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resize()方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">        <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	变量用处：1.oldTab :记录老的数组</span></span><br><span class="line"><span class="comment">    			2.oldCap:记录老的容量，老数组为空则为0</span></span><br><span class="line"><span class="comment">    			3.oldThr:记录原扩容阈值</span></span><br><span class="line"><span class="comment">    			4.newcap:记录新的容量</span></span><br><span class="line"><span class="comment">    			5.newThr:记录新的扩容阈值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当老数组中存在元素时走这个分支</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">                <span class="comment">//如果老数组大于等于最大限制容量，则扩容阈值为Integer最大值</span></span><br><span class="line">                <span class="comment">//这个情况下数组已经达到了最大值，不能再扩容</span></span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">           			<span class="comment">//newCap是oldCap左移一位即newCap是oldCap的两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                <span class="comment">//如果老数组扩大两倍还小于数组最大限制，并且老数组大于等于默认容量 </span></span><br><span class="line">                <span class="comment">//则设置新的阈值：为老阈值两倍</span></span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//当老数组不存在元素时</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            <span class="comment">//如果老数组阈值大于0，则新数组的容量就是老数组的阈值</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">//如果老数组阈值小于等于0  就进行默认的方式进行扩容</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">            <span class="comment">//新数组的容量为默认的数值(16)</span></span><br><span class="line">            <span class="comment">//新数组的扩容阈值为(扩容因子*初始容量)= 0.75*16=12</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			newThr==0有两种情况 1.oldCap&gt;=MAXIMUM_CAPACITY 即老数组的容量达到极限</span></span><br><span class="line"><span class="comment">							  2.oldCap&lt;=0&amp;&amp;oldThr&gt;0 即老数组不存在元素，且老数组阈值不为0</span></span><br><span class="line"><span class="comment">			当老数组不存在元素但是老数组阈值不为0则说明  它经过tableSizeFor()方法设置过初始阈值</span></span><br><span class="line"><span class="comment">			我们通过这个resize方法这个分支调整新的阈值  </span></span><br><span class="line"><span class="comment">			例如tableSizeFor()之后初始阈值为16,经过这个调整会变成16*0.75=12</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">            <span class="comment">//ft=新数组容量*加载因子  用来记录新数组的扩容阈值</span></span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="comment">//如果新数组容量没达到极限并且扩容阈值小于极限 则新数组的扩容阈值为计算出的ft 反之阈值则是Integer的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//将新阈值传入变量threshold中</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">        <span class="comment">//创建Node[]数组，传入newTab中  我们在构造方法中没有见到创建数组的操作，而在resize()中见到了创造数组</span></span><br><span class="line">    	<span class="comment">//第一次put的时候调用resize方法创建数组 为了延时加载，提高效率</span></span><br><span class="line">    </span><br><span class="line">    	table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果老数组非空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                <span class="comment">//遍历老数组  j作为索引值，当j小于老数组容量时条件成立</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果老数组索引位置上有元素 则交给中间变量e记录  然后将这个位置置为空</span></span><br><span class="line">                    oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                        <span class="comment">//如果e的后继结点为null，因为e的位置是在数组上所以这个条件成立时说明这个位置只有一个元素</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">                    		则将e.hash&amp;(newCap-1)计算出索引值index，将e存入newTab[index]中</span></span><br><span class="line"><span class="comment">                    		这个index很熟悉我们好像在哪里见过？</span></span><br><span class="line"><span class="comment">                    		if ((p = tab[i = (n - 1) &amp; hash]) == null)</span></span><br><span class="line"><span class="comment">                    		put方法中的条件判断中出现了这个索引计算公式</span></span><br><span class="line"><span class="comment">                    		说明新索引值和老索引值用的是同一个计算公式</span></span><br><span class="line"><span class="comment">                    	*/</span></span><br><span class="line">                    	<span class="comment">//将e存入新数组的新下标位置即可</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//如果e是红黑树结构 则拆分红黑树 </span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//反之e是链表</span></span><br><span class="line">                        </span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                      	<span class="comment">/*</span></span><br><span class="line"><span class="comment">                      		变量</span></span><br><span class="line"><span class="comment">                      			lohead:记录链表旧位置的头结点</span></span><br><span class="line"><span class="comment">                      			loTail:记录链表旧位置的尾结点</span></span><br><span class="line"><span class="comment">                      			hihead:记录链表新位置的头结点</span></span><br><span class="line"><span class="comment">                      			hitial:记录链表新位置的尾结点</span></span><br><span class="line"><span class="comment">                      	*/</span>  </span><br><span class="line">                        </span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="comment">//将next指向e的后置节点</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//如果当前位置哈希和老数组容量做与运算等于0</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                    <span class="comment">//如果旧链表尾结点为空</span></span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                	<span class="comment">//则将e置为头结点</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    <span class="comment">//将尾结点的后置结点置为e</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                <span class="comment">//则链表旧位置的尾结点为e</span></span><br><span class="line">                                loTail = e;</span><br><span class="line">                                </span><br><span class="line">                                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                                	这段好像有点字都认识，但是合在一起就不知道什么意思了</span></span><br><span class="line"><span class="comment">                                	再重新读一遍，如果经过运算等于0条件成立</span></span><br><span class="line"><span class="comment">                                		如果旧链表尾结点没数据，则将e置于头结点</span></span><br><span class="line"><span class="comment">                                		如果旧链表结尾有数据，则将e插入链表尾部</span></span><br><span class="line"><span class="comment">                                		比如第一次插入就是没数据，e插入链表中作为头结点和尾结点</span></span><br><span class="line"><span class="comment">                                			第二次插入数据时，e插入链表尾部，并将尾结点指针往后移动</span></span><br><span class="line"><span class="comment">                                			---</span></span><br><span class="line"><span class="comment">                                	这段代码的意思是如果当前位置哈希和老数组容量做与运算等于0 则保持位置不变</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                                </span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//反之则说明要变动位置，这里与上面原理一样，不过是在新的位置</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                      	</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                            <span class="comment">//结束循环之后旧链表位置不变的存入同一个下标中</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                            <span class="comment">//结束循环之后，链表要变动位置的要存入下标为:老下标+老数组容量</span></span><br><span class="line">                            </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line">小结:</span><br><span class="line">	这里告诉我们数组扩容的原理以及元素位置的处理:</span><br><span class="line">			<span class="number">1.</span>数组    存入下标为e.hash &amp; (newCap - <span class="number">1</span>)中</span><br><span class="line">			<span class="number">2.</span>红黑树  拆分红黑树</span><br><span class="line">            <span class="number">3.</span>链表   如果是</span><br><span class="line">                		(e.hash &amp; oldCap) == <span class="number">0</span>则原位置不变</span><br><span class="line">                	反之</span><br><span class="line">						新链表位置为原下标+老数组容量</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hash()方法</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/*当Key为空的时候返回0,说明支持Null值传入</span></span><br><span class="line"><span class="comment">	  当Key非空时  key经过hashcode()传入h中 再与h右移16位进行异或运算  </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">其实我们还有一些东西没有讲到 就是前面put方法中i = (n - <span class="number">1</span>) &amp; hash的意义在哪</span><br><span class="line">参数n是数组长度或者经过resize()扩容后的数组长度，那么n常是二的倍数</span><br><span class="line">n的表现形式类似为<span class="number">0000</span> .... <span class="number">0000</span> <span class="number">1000</span>   直接与hash值做&amp;运算那么结果只跟数组长度有关</span><br><span class="line">则n-<span class="number">1</span>的二进制为 <span class="number">0000</span> .... <span class="number">0000</span> <span class="number">0111</span> </span><br><span class="line">再与hash做与运算，可以降低hash碰撞</span><br><span class="line">    </span><br><span class="line">h ^ (h&gt;&gt;&gt;<span class="number">16</span>)的意义</span><br><span class="line">假设有一个哈希值为 <span class="number">11000000</span> <span class="number">00111100</span>  <span class="number">11000000</span> <span class="number">00110011</span></span><br><span class="line">我们直接与n-<span class="number">1</span>做&amp;运算 <span class="number">0000</span> .... <span class="number">0000</span> <span class="number">0111</span>  那么只有低位有效与高位无关</span><br><span class="line">    </span><br><span class="line">h和进行h的无符号右移<span class="number">16</span>位异或运算        <span class="number">00000000</span> <span class="number">00000000</span>  <span class="number">11000000</span> <span class="number">00111100</span></span><br><span class="line">    							^  <span class="number">11000000</span> <span class="number">00111100</span>  <span class="number">11000000</span> <span class="number">00110011</span></span><br><span class="line">那么高位也能参与运算 所以能降低hash碰撞</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> get()方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">    	<span class="comment">//将key和hash值传入getNode()方法中， 最后返回null或者getNode取得的结点的value值</span></span><br><span class="line"> 	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;(first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//数组非空且数组中存有数据，所以取得数组中索引的第一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//如果第一个结点哈希值相同，并且Key的地址或者值相同 则说明找到元素就是第一个元素，直接返回</span></span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果头结点还有后置结点，则取出后置结点</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//如果这个是红黑树 调用红黑树的getTreeNode()方法</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//反之就是普通的链表</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//判断哈希值相同，并且Key的地址或者值相同 则说明找到元素，返回元素e</span></span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);<span class="comment">//当后置结点为空的时候结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断结束说明没有找到这个Key对应的结点，返回NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></div></figure>




        <h4 id="4、HashMap在jdk1-7产生死循环"   >
          <a href="#4、HashMap在jdk1-7产生死循环" class="heading-link"><i class="fas fa-link"></i></a><a href="#4、HashMap在jdk1-7产生死循环" class="headerlink" title="4、HashMap在jdk1.7产生死循环"></a>4、HashMap在jdk1.7产生死循环</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">因为HashMap在<span class="number">1.7</span>的时候采用的是头插法，所以在并发情况下扩容可能会产生死循环</span><br><span class="line"></span><br><span class="line">正常情况A-&gt;B-&gt;C  那么当扩容时，应该是C-&gt;B-&gt;A</span><br><span class="line"></span><br><span class="line">并发扩容下的异常情况  A-&gt;B-&gt;C  假设现在有两个线程T1,线程T2</span><br><span class="line">							那么此时T1和T2指向A结点，并且T1.NEXT和T2.NEXT都指向B结点</span><br><span class="line">				  线程T1进行扩容，线程T2进行休眠</span><br><span class="line">				  T1扩容之后ABC的关系变成了==&gt;  C-&gt;B&gt;A  </span><br><span class="line">				  线程T2在T1在扩容时是不可知的。那么线程T2指向在A结点而T2.NEXT指向B  但是因为扩容之后B.NEXT是A </span><br><span class="line">				  这就是死循环</span><br></pre></td></tr></table></div></figure>




        <h3 id="2、HashTable"   >
          <a href="#2、HashTable" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、HashTable" class="headerlink" title="2、HashTable"></a>2、HashTable</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">//定义数组用来存储数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"><span class="comment">//定义一个变量用来记录哈希表中的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"><span class="comment">//扩容阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> loadFactor;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法"   >
          <a href="#1、构造方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <p>1.空参构造</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个默认的哈希表 容量为11 负载因子为0.75</span></span><br></pre></td></tr></table></div></figure>

<p>2.有参构造</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">        <span class="comment">//创建一个指定容量，负载因子为0.75的哈希表</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">//当指定容量为负数时抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        	<span class="comment">//当加载因子为空或者小于等于0时抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        	<span class="comment">//当指定容量为0时，将转化为1</span></span><br><span class="line">            initialCapacity = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    	<span class="comment">//创建一个指定容量的哈希表</span></span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//扩容阈值，在指定容量*0.75和最大容量+1之间的最小值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">    <span class="comment">//传入一个存在的map,直接创建负载因子为0.75,容量为原集合的两倍或者11之间的最大值的哈希表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法"   >
          <a href="#2、常用方法" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">put方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">// Make sure the value is not null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果value为空则抛出异常 说明不支持空值</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    	<span class="comment">//取得哈希 然后对数组长度做模运算, 获得索引值</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            	<span class="comment">//如果key值相同则返回老值用新值替代老值</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        addEntry(hash, key, value, index);</span><br><span class="line">    	<span class="comment">//当key值不存在时添加元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当哈希表的元素个数大于等于阈值 调用rehash()扩容</span></span><br><span class="line">            </span><br><span class="line">            rehash();</span><br><span class="line"></span><br><span class="line">            tab = table;</span><br><span class="line">            hash = key.hashCode();</span><br><span class="line">            index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Creates the new entry.</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">        tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    	<span class="comment">//因为数据不存在所以直接插入到哈希表中 并且记录个数++</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rehash方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    	<span class="comment">//取出老哈希表长度</span></span><br><span class="line">        Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    	<span class="comment">//新的容量为老容量的两倍+1</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">                <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">                <span class="comment">//如果老数组达到了上限，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//新容量如果超过了上限,则新容量为上限</span></span><br><span class="line">            newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//操作数+1</span></span><br><span class="line">        modCount++;</span><br><span class="line">    </span><br><span class="line">        threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//记录新阈值为 新容量*负载因子和最大上限+1之间的最小值	</span></span><br><span class="line">        table = newMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">                <span class="comment">//取出每一个元素</span></span><br><span class="line">                Entry&lt;K,V&gt; e = old;</span><br><span class="line">                old = old.next;</span><br><span class="line">				</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">                e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">                newMap[index] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//将每一个元素放到扩容后的新数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="literal">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">    			<span class="comment">//当哈希值存在且Key值存在时 返回对应结点的Value           </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//返回NUll 代表不存在这个K-V对</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="3、TreeMap"   >
          <a href="#3、TreeMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、TreeMap" class="headerlink" title="3、TreeMap"></a>3、TreeMap</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这个树的比较器,如果使用元素的自然排序则为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="built_in">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根节点</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//用于统计树有多少个实体</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//计数器，统计操作次数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Red-black mechanics</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">RED</span>   <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法-1"   >
          <a href="#1、构造方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法-1" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>空参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">()</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建一个比较器为空的树,排序方法为自然排序</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> K&gt; comparator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.comparator = comparator;</span><br><span class="line"><span class="comment">//传入比较器，构造一个指定比较器的空树</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = <span class="literal">null</span>;</span><br><span class="line">        putAll(m);</span><br><span class="line"><span class="comment">//传入已有map，构造一个自然比较的树，然后调用putAll()方法把元素存入</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeMap</span><span class="params">(SortedMap&lt;K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        comparator = m.comparator();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            buildFromSorted(m.size(), m.entrySet().iterator(), <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.io.IOException cannotHappen) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//传入已有的SortedMap,取得原有map的构造器 调用buildFormSorted方法 创建一个红黑树</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法-1"   >
          <a href="#2、常用方法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法-1" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">put方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; t = root;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果r==null则说明这是一个空树，根节点为空</span></span><br><span class="line">            compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">			<span class="comment">//不允许空值作为Key值传入</span></span><br><span class="line">            </span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, <span class="literal">null</span>);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            modCount++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//将数据插入到根节点,树的大小+1,记录操作数++ 结束方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//反之，这个树不是一个空树</span></span><br><span class="line">        <span class="type">int</span> cmp;</span><br><span class="line">        Entry&lt;K,V&gt; parent;</span><br><span class="line">        <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> K&gt; cpr = comparator;</span><br><span class="line">    	<span class="comment">//获得比较器cpr</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (cpr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//通过比较器的比较方法从根节点开始找是否有相同结点</span></span><br><span class="line">                <span class="comment">//如果比根节点小则往左子树找,比根节点大则往右子树找,找到相同结点就调用setValue方法更新数据</span></span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = cpr.compare(key, t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当比较器为空的时候,通过自然排序找是否有相同的结点</span></span><br><span class="line">            <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                parent = t;</span><br><span class="line">                cmp = k.compareTo(t.key);</span><br><span class="line">                <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                    t = t.left;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                    t = t.right;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">            &#125; <span class="keyword">while</span> (t != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//运行到这里 说明树有数据但是树中没有相同的数据，并且经过上面查找循环parent已经指向了叶子结点</span></span><br><span class="line">        Entry&lt;K,V&gt; e = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(key, value, parent);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            parent.left = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent.right = e;</span><br><span class="line">    	<span class="comment">//将新的数据作为找到的叶子结点的子节点插入</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        fixAfterInsertion(e);</span><br><span class="line">    	<span class="comment">//调用方法对树进行调整</span></span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//调整红黑树的结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">        x.color = RED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x != <span class="literal">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateLeft(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateRight(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">                <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(y, BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    x = parentOf(parentOf(x));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                        x = parentOf(x);</span><br><span class="line">                        rotateRight(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setColor(parentOf(x), BLACK);</span><br><span class="line">                    setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                    rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    	<span class="comment">//调用getEntry方法 将Key传入</span></span><br><span class="line">        <span class="keyword">return</span> (p==<span class="literal">null</span> ? <span class="literal">null</span> : p.value);</span><br><span class="line">    	<span class="comment">//如果key值对应的Entry不存在则返回null，如果存在则返回对应的value值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title function_">getEntry</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    	<span class="comment">//返回当Key为空则抛出空指针异常</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Comparable&lt;? <span class="built_in">super</span> K&gt; k = (Comparable&lt;? <span class="built_in">super</span> K&gt;) key;</span><br><span class="line">    	<span class="comment">//获得比较器</span></span><br><span class="line">    </span><br><span class="line">        Entry&lt;K,V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*如果p存在，则调用compareTo()方法  通过比较器的排序方法比较</span></span><br><span class="line"><span class="comment">            	if cpm==0 则说明存在  直接返回</span></span><br><span class="line"><span class="comment">            	   cpm&lt;0  未找到结点,找左子树</span></span><br><span class="line"><span class="comment">            	   cpm&gt;0  未找到结点，找右子树</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> k.compareTo(p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">size()方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于返回树的大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="4、LinkedHashMap"   >
          <a href="#4、LinkedHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#4、LinkedHashMap" class="headerlink" title="4、LinkedHashMap"></a>4、LinkedHashMap</h3>
      <p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3801124242820219131L</span>;</span><br><span class="line"><span class="comment">//序列化ID</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//头结点指针</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line">   <span class="comment">//尾结点指针</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="comment">//哈希映射的迭代排序方法：true表示访问顺序，false表示插入顺序。</span></span><br><span class="line">   <span class="keyword">final</span> <span class="type">boolean</span> accessOrder;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法-2"   >
          <a href="#1、构造方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法-2" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//调用父类的调用方法 即默认容器大小为16 负载因子为0.75  迭代排序方法为false表示插入顺序。</span></span><br><span class="line">    <span class="comment">//创建一个插入序的LinkedHashMap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//传入容量大小和负载因子,然后调用父类的构造方法  创建一个插入序的LinkedHashMap</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity);</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//传入容量大小,然后调用父类的构造方法  创建一个插入序的LinkedHashMap</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        accessOrder = <span class="literal">false</span>;</span><br><span class="line">        putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//调用父类的空参构造,创建一个插入序的LinkedHashMap</span></span><br><span class="line">    <span class="comment">//调用putMapEntries()方法把元素存入</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor,</span></span><br><span class="line"><span class="params">                         <span class="type">boolean</span> accessOrder)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.accessOrder = accessOrder;</span><br><span class="line">    <span class="comment">//传入容量、负载因子、排序顺序   创建一个自定义容量、负载因子和排序顺序的LinkedHashMap</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">小结:在如果不传入排序方式，默认都是创建一个插入序的LinkedHashMap</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法-2"   >
          <a href="#2、常用方法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法-2" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line">put方法</span><br><span class="line">说实话我找了一会发现没有put方法在LinkedHashMap中,这怎么可能呢?那就应该是没有重写Put方法而是直接调用了父类的put方法,我们拿回原来HashMap中的Put方法进来</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//将Key,Value传入 然后调用putVal()进行返回;</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,<span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		参数</span></span><br><span class="line"><span class="comment">    			1:hash值  这个是调用了hash()方法之后的结果</span></span><br><span class="line"><span class="comment">    		   	2:key值   这个是传入的Key</span></span><br><span class="line"><span class="comment">    		   	3:Value值 这个是传入的Value值</span></span><br><span class="line"><span class="comment">    		   	4:onlyIfAbsent  表示如果存在键相同时是否更新旧值为新值 true是不更新旧值 false是更新旧值为新值</span></span><br><span class="line"><span class="comment">    		   	5:evict         传入true</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    		定义一个Node[]数组 tab </span></span><br><span class="line"><span class="comment">    		定义一个Node结点 p</span></span><br><span class="line"><span class="comment">    		定义一个变量n  用于记录数组长度</span></span><br><span class="line"><span class="comment">    		定义一个变量i  用于记录索引</span></span><br><span class="line"><span class="comment">    	*/</span> </span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//先将本地的table数组赋值给tab 再把tab的长度赋值给n  </span></span><br><span class="line">            <span class="comment">//如果tab为空或者长度为0，将tab进行resize()方法扩容之后的长度赋值给n</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    		<span class="comment">//将n-1和hash值做与运算 赋值给索引i 如果再将结点p指向tab[i] 并且判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果tab[i]为空即这个位置为空 则调用newNode()方法，将hash值，K,V，和下一个结点为NULL传入</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    		</span><br><span class="line">    		<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">        	return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    	Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span></span><br><span class="line"><span class="comment">            this.hash = hash;</span></span><br><span class="line"><span class="comment">            this.key = key;</span></span><br><span class="line"><span class="comment">            this.value = value;</span></span><br><span class="line"><span class="comment">            this.next = next;</span></span><br><span class="line"><span class="comment">        &#125;	</span></span><br><span class="line"><span class="comment">    		*/</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//反之  tab[i]不为空 即这个位置有元素了 下面第一个IF有三种情况</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) </span><br><span class="line">            <span class="comment">//1.如果这个位置p的hash和传入的hash相同 并且 (p的key和传入的k地址相同||p的key和key值相同)</span></span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//则将这个位置p赋值给结点e，并且跳出第一个if语句</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//反之位置P和传入的数据不同 ，判断 p instanceof TreeNode 即判断p是否为树(红黑树)</span></span><br><span class="line">                <span class="comment">//如果是则添加到红黑树里面 调用putTreeVal()方法</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//最终位置P和传入的数据不同也不是红黑树结构 ==&gt;那么应该是链表结构</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//死循环 用一个变量binCount记录链表长度</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//当p不指向下一个结点，则将这个数据变成新的结点插入p的后继节点中</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="comment">//对循环次数做判断 </span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">        <span class="comment">//当binCount&gt;=7的时候说明已经至少循环7次,即添加此次数据之后链表长度应该到8了,调用treeifyBin()方法，尝试转化成红黑树</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果e的hash值相同且key相同(地址或值)相同 则直接跳出循环 </span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//将指针p指向下一个结点 [在if ((e = p.next) == null) &#123;...&#125;判断时e指向了p的下一个结点]</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//-------------这里结束第一个IF语句---------------------------</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="comment">//如果e不为空 即说明e和新值发生了哈希碰撞，e为老结点</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">//onlyIfAbsent是用来判断是否更新旧值的，为False时说明更新旧值为新值</span></span><br><span class="line">                    <span class="comment">//支持更新旧值或者老值为NUll时，新值代替旧值</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                // Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="comment">    			   void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; 这个方法仅允许LinkedHashMap调用</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//返回老值</span></span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">    	<span class="comment">//操作记录数++</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//判断添加操作之后数组是否需要进行扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();  </span><br><span class="line">    	<span class="comment">//调用resize()方法扩容</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//空实现</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">    	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    	void afterNodeInsertion(boolean evict) &#123; &#125;</span></span><br><span class="line"><span class="comment">    	*/</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们不难得出里面有两个方法仅供LinkedHashMap调用</span><br><span class="line">因为HashMap中是空实现，那我们就需要关注这两个方法，这个会在常用方法区底部详细说说</span><br><span class="line">afterNodeAccess(e);</span><br><span class="line">afterNodeInsertion(evict);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Remove方法  因为有上面put方法的经验,所以直接找到父类的Remove方法</span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们关注到这里有一个 afterNodeRemoval(node)方法，这个方法也是仅供LinkedHashMap调用</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果这个结点为空则返回空值说明不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder)</span><br><span class="line">            <span class="comment">//存在数据,如果排序是访问顺序的话调用afterNodeAccess()方法</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//返回数据</span></span><br><span class="line">        <span class="keyword">return</span> e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------底下是HashMap仅供LinkedHashMap的方法-----------------------</span><br><span class="line">afterNodeAccess方法</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//移动结点到链表尾部 说明最近有被使用过    </span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            <span class="comment">//当accessOrder为true 即排序是访问顺序的LinkedHashMap</span></span><br><span class="line">            <span class="comment">//并且当尾结点不为传入的结点e的时候</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//这里执行的逻辑是链表的双端删除,将e结点前后的结点相互链接,然后将e放到链表的尾部</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterNodeInsertion方法</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//这里注释说可能用于删除最老的结点?而什么是最老结点?我想到了最久未被使用的结点</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">        <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">            <span class="comment">//当evict为true 并且头结点非空 而且需要removeEldestEntry()方法返回true</span></span><br><span class="line">            <span class="comment">//而当看向removeEldestEntry方法,它是返回false的,所以这个方法放在插入数据之后很奇怪，因为不会调用</span></span><br><span class="line">            <span class="comment">//可能需要我们自己扩展重写方法，实现相应的删除头结点操作</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;()方法返回<span class="literal">true</span></span><br><span class="line">            <span class="title function_">removeNode</span><span class="params">(hash(key)</span>, key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//回调父类的removeNode()方法删除结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterNodeRemoval方法</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    	<span class="comment">//链表的双端删除  将结点e两端结点项链，然后e因为没有引用会被GC给回收</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">            tail = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a.before = b;</span><br><span class="line">    &#125;    </span><br></pre></td></tr></table></div></figure>


        <h4 id="3、额外"   >
          <a href="#3、额外" class="heading-link"><i class="fas fa-link"></i></a><a href="#3、额外" class="headerlink" title="3、额外"></a>3、额外</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">因为LinkedHashMap有afterNodeRemoval、afterNodeInsertion、afterNodeAccess三个特有的方法，提供一个思路用于实现LRU算法</span><br><span class="line">    </span><br><span class="line">LRU算法即=最近最少被使用，我们可以利用afterNodeAccess将最近使用过的结点放到链表的尾部，然后慢慢地头部结点就是最近最少未被使用的结点，当需要淘汰结点时我们将头部结点淘汰就完成了LRU算法的构成</span><br><span class="line"></span><br><span class="line">在这里仅仅提供思路</span><br></pre></td></tr></table></div></figure>




        <h3 id="5、ConcurrentHashMap"   >
          <a href="#5、ConcurrentHashMap" class="heading-link"><i class="fas fa-link"></i></a><a href="#5、ConcurrentHashMap" class="headerlink" title="5、ConcurrentHashMap"></a>5、ConcurrentHashMap</h3>
      <p>【1.8以后】</p>
<p>基本变量</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//最大的容量 即1左移30位==&gt;1*2^30</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//默认的容量16,必须为2的幂次方(最少是1最大是MAXIMUM_CAPACITY)</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//最大的数组大小</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONCURRENCY_LEVEL</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="comment">//默认的并发级别，未使用但是为了与老版本版本兼容而保留</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//负载因子0.75</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="comment">//链表转化为树的阈值为8</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="comment">//红黑树退化为链表阈值为6</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"><span class="comment">//数组转化为树的阈值为64，最少是4*TREEIFY_THRESHOLD以避免调整大小阈值和树化阈值之间的冲突。</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TRANSFER_STRIDE</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_BITS</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RESIZERS</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; (<span class="number">32</span> - RESIZE_STAMP_BITS)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESIZE_STAMP_SHIFT</span> <span class="operator">=</span> <span class="number">32</span> - RESIZE_STAMP_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Encodings for Node hash fields. </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOVED</span>     <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// hash for forwarding nodes  当前hash正在迁移</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEBIN</span>   <span class="operator">=</span> -<span class="number">2</span>; <span class="comment">// hash for roots of trees	   当前hash是个树</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RESERVED</span>  <span class="operator">=</span> -<span class="number">3</span>; <span class="comment">// hash for transient reservations 当前hash已经被预定</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HASH_BITS</span> <span class="operator">=</span> <span class="number">0x7fffffff</span>; <span class="comment">// usable bits of normal node hash  </span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Number of CPUS, to place bounds on some sizings */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NCPU</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The array of bins. Lazily initialized upon first insertion.</span></span><br><span class="line"><span class="comment">    * Size is always a power of two. Accessed directly by iterators.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next table to use; non-null only while resizing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Base counter value, used mainly when there is no contention,</span></span><br><span class="line"><span class="comment">    * but also as a fallback during table initialization</span></span><br><span class="line"><span class="comment">    * races. Updated via CAS.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> baseCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Table initialization and resizing control.  When negative, the</span></span><br><span class="line"><span class="comment">    * table is being initialized or resized: -1 for initialization,</span></span><br><span class="line"><span class="comment">    * else -(1 + the number of active resizing threads).  Otherwise,</span></span><br><span class="line"><span class="comment">    * when table is null, holds the initial table size to use upon</span></span><br><span class="line"><span class="comment">    * creation, or 0 for default. After initialization, holds the</span></span><br><span class="line"><span class="comment">    * next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The next table index (plus one) to split while resizing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> transferIndex;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Table of counter cells. When non-null, size is a power of 2.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// views</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> KeySetView&lt;K,V&gt; keySet;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> ValuesView&lt;K,V&gt; values;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> EntrySetView&lt;K,V&gt; entrySet;</span><br></pre></td></tr></table></div></figure>

<p>1.如何理解ConcurrentHashMap的安全性</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       ConcurrentHashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">       <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当count==null说明没有这个数据</span></span><br><span class="line">               map.put(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               map.put(<span class="string">&quot;count&quot;</span>,count+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  当两个线程t1、t2进入程序中查询到count==null</span></span><br><span class="line"><span class="comment">       *   都进入if条件中，那么执行结果是执行两次put(&quot;count&quot;,1)，数据造成丢失</span></span><br><span class="line"><span class="comment">       *   ConcurrentHashMap是无法保证又写又查的情况下线程安全</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//经过改造之后</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> map.get(<span class="string">&quot;count&quot;</span>);</span><br><span class="line">           <span class="keyword">if</span>(count==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当count==null说明没有这个数据</span></span><br><span class="line">               <span class="keyword">if</span>(map.putIfAbsent(<span class="string">&quot;count&quot;</span>,<span class="number">1</span>)==<span class="literal">null</span>)&#123;</span><br><span class="line">               <span class="comment">//当执行putIfAbsent()方法执行成功则会返回null,我们就跳出循环</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(map.replace(<span class="string">&quot;count&quot;</span>,count,count+<span class="number">1</span>))&#123;</span><br><span class="line">                   <span class="comment">//我们利用CAS机制，修改数据</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/* 当两个线程t1、t2进入程序中查询到Count==null</span></span><br><span class="line"><span class="comment">       *  都进入IF条件中，我们假设先获得cpu的是t1,那么t1执行完putIFAbsent()方法之后得到返回null值跳出循环</span></span><br><span class="line"><span class="comment">       *  而t2再进入判断时就跳不出循环，第二次进入循环的时候就会走下面的分支</span></span><br><span class="line"><span class="comment">       *  使用replace方法对老值做替换</span></span><br><span class="line"><span class="comment">       *  这样我们就保证了两次操作的不丢失==&gt;数据的不被破坏</span></span><br><span class="line"><span class="comment">       * */</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="1、构造方法-3"   >
          <a href="#1、构造方法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#1、构造方法-3" class="headerlink" title="1、构造方法"></a>1、构造方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>无参构造</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//创建一个默认容量为16的表【数组】   </span></span><br><span class="line"><span class="number">2.</span>有参构造</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">    	<span class="comment">//把cap赋值给sizeCtl，创建一个指定大小的表</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">        putAll(m);</span><br><span class="line">     	<span class="comment">//创建一个默认容量的数组，把数据都存入</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">     	<span class="comment">//调用ConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)方法</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,</span></span><br><span class="line"><span class="params">                             <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">        <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">     <span class="comment">//创建一个指定大小，指定扩容因子的ConcurrentHashMap</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>经过上面的构造函数,我们基本都能发现有一个sizeCtl,我们详细说说sizeCtl有什么意义</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Table initialization and resizing control.  When negative, thetable is being initialized or resized: -1 for initialization, else -(1 + the number of active resizing threads).  Otherwise,when table is null, holds the initial table size to use upon creation, or 0 for default. After initialization, holds the next element count value upon which to resize the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sizeCtl用来代表现在数组的状态</span><br><span class="line">   sizeCtl== -<span class="number">1</span>  ---&gt;说明现在数组正在初始化</span><br><span class="line">   sizeCtl==  <span class="number">0</span>  ---&gt;说明数组未被初始化，用的默认容量<span class="number">16</span></span><br><span class="line">   sizeCtl&gt;   <span class="number">0</span>	 ---&gt;如果数组未被初始化，则记录数组的初始容量，如果已经初始化过，那么记录的是数组扩容阈值(容量*负载因子<span class="number">0.75</span>)</span><br><span class="line">   sizeCtl&lt;  -<span class="number">1</span>  ---&gt;说明数组正在扩容, 值为-(n+<span class="number">1</span>).n为正在扩容中的线程数</span><br></pre></td></tr></table></div></figure>


        <h4 id="2、常用方法-3"   >
          <a href="#2、常用方法-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#2、常用方法-3" class="headerlink" title="2、常用方法"></a>2、常用方法</h4>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br></pre></td><td class="code"><pre><span class="line">Put方法 </span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">    	<span class="comment">//调用下面的putVal()方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    	<span class="comment">//说明Key和Value不允许设为空值，否则抛出空指针异常</span></span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    	<span class="comment">//得到Key对应的hash值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            <span class="comment">//设置一个临时表tab,然后死循环</span></span><br><span class="line">            </span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            变量说明  f:表示数组索引i位置的数据 即tab[i]</span></span><br><span class="line"><span class="comment">            		 n:表示数组长度</span></span><br><span class="line"><span class="comment">            		 i:表示索引</span></span><br><span class="line"><span class="comment">            		 fh:tab[i]的哈希值</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            	<span class="comment">//tab为空指针或者tab中没有数据,将数组长度由n记录,调用initTable()方法</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            	<span class="comment">//把初始化之后的表给临时表table中,因为后面没有其他语句所以进入下一次循环</span></span><br><span class="line">            	</span><br><span class="line">            	</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//数组已经初始化了,将数据插入Map中    </span></span><br><span class="line">                <span class="comment">//取出索引i位置的数据交给f,如果f不存在，说明数组中这个位置为空</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                    <span class="comment">//则将f以cas的方式插入数据 ==&gt;将索引i的数据以null设置成新结点</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            tabAt(数组,i) 表示获得索引为为i的数组元素即table[i]</span></span><br><span class="line"><span class="comment">            casTabAt(数组,1,2,3) 表示数组将索引i位置的数据以cas的方式从2修改到3</span></span><br><span class="line"><span class="comment">          </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           </span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Encodings for Node hash fields. </span></span><br><span class="line"><span class="comment">            static final int MOVED     = -1; // hash for forwarding nodes  当前hash正在迁移</span></span><br><span class="line"><span class="comment">            static final int TREEBIN   = -2; // hash for roots of trees	   当前hash是个树</span></span><br><span class="line"><span class="comment">            static final int RESERVED  = -3; // hash for transient reservations 当前hash已经被预定</span></span><br><span class="line"><span class="comment">            static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash </span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">//如果fh是MOVED的话 则说明当前数组在扩容，需要当前线程进行帮助数据迁移</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//fh！= -1</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                   <span class="comment">/*</span></span><br><span class="line"><span class="comment">                   对f进行加锁，而f是tab[i]这个位置的数据</span></span><br><span class="line"><span class="comment">                   tab[i]这个位置要么是1.一个结点</span></span><br><span class="line"><span class="comment">                   				要么是2.一个结点挂着红黑树</span></span><br><span class="line"><span class="comment">                   				要么是3.一个结点挂着链表</span></span><br><span class="line"><span class="comment">                   	而对f进行加锁则意思是锁住f这个桶,即不锁住整个数组只是锁住索引i这个位置下的数据</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//再一次对f进行判断</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//如果fh&gt;=0 说明是正常数据</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//将binCount计数器置为1  说明这有一个数据</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                <span class="comment">//将f赋值给结点e,进行死循环</span></span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    <span class="comment">//如果e的哈希值和当前哈希值相同,并且当前key的地址或者内容相同</span></span><br><span class="line">                                    <span class="comment">//说明找到老的数据，提取到原数据放到oldval中</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    </span><br><span class="line">                                    </span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        <span class="comment">//onlyIfAbsent为False时说明更新旧值为新值，为ture则不做处理</span></span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="literal">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">//如果f是个树</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//判断是否需要转化成红黑树, 调用treeifyBin方法尝试转化</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    	<span class="comment">//调用addCount方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Encodings for Node hash fields. </span></span><br><span class="line"><span class="comment">static final int MOVED     = -1; // hash for forwarding nodes  当前hash正在迁移</span></span><br><span class="line"><span class="comment">static final int TREEBIN   = -2; // hash for roots of trees	   当前hash是个树</span></span><br><span class="line"><span class="comment">static final int RESERVED  = -3; // hash for transient reservations 当前hash已经被预定</span></span><br><span class="line"><span class="comment">static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    <span class="comment">//HASH_BITS = 01111111 11111111 11111111 11111111  </span></span><br><span class="line">    <span class="comment">//计算出的哈希值与HASH_BITS做与运算保证结果是正数，因为负数有特殊的含义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//initTable用于初始化表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    	<span class="comment">//循环判断是否为空，直到初始化成功</span></span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当表为null或者表长度为0时,说明未被初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//sizeCtl&lt;0时说明正在扩容</span></span><br><span class="line">                <span class="comment">//当前线程放弃cpu的使用权，在这里自旋</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//当sizeCtl运行到这里，说明sc&gt;=0  利用cas将sizeCtl设置为-1意思是将他置为初始化</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//再一次进行对表的判断，是否为空表 防止多线程情况下的多次初始化  </span></span><br><span class="line">                        <span class="comment">/*例如线程t2刚好运行到if底部的sc=n-(n&gt;&gt;&gt;2) 而线程t1运行到这个判断，如果不做判断则会多次初始化</span></span><br><span class="line"><span class="comment">                        所以这个再次判断是确保只初始化一次</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="comment">//将sc大于0则设为sc,否则设置为默认的长度16</span></span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                        <span class="comment">//将sc设为扩容阈值 n-n/4 即0.75n</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//更新sizeCtl设为扩容阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i,</span></span><br><span class="line"><span class="params">                                        Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="type">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Helps transfer if a resize is in progress.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//用于辅助线程迁移</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//treeifyBin 尝试转化成红黑树</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                <span class="comment">//当数组长度小于最大数组限制即64的时候调用tryPresize方法</span></span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="literal">null</span>)</span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    	<span class="comment">//判断c是否到达了最大限度，如果到达了就设置为最大限度，如果没达到就调用tableSizeFor方法</span></span><br><span class="line">    	<span class="comment">//因为tableSizeFor方法在HashMap中提到过，就是为了保证最后是二的n次幂</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//sc如果大于等于0，说明数组未被初始化或者是数组已经初始化过，sc记录的是扩容阈值</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果表为null或者n长度为0说明未被初始化过</span></span><br><span class="line">                n = (sc &gt; c) ? sc : c;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//将sizeCtl置为-1用来表示正在初始化</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                            table = nt;</span><br><span class="line">                            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        sizeCtl = sc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">                <span class="comment">//表已经初始化过，判断c是否达到阈值或者n是否超出最大数组长度 </span></span><br><span class="line">                <span class="comment">//如果没有达到阈值或者n已经超出限制,那么不做处理跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">                <span class="comment">//开始扩容</span></span><br><span class="line">                <span class="comment">//rs得到的是一个扩容戳(高十六位代表扩容标识，低16位做扩容线程数)</span></span><br><span class="line">                <span class="comment">//sizeCtl小于-1 则sizeCtl=-(n+1)，n表示正在扩容的线程数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt;[] nt;</span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="literal">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transfer()方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于数据迁移    </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextn</span> <span class="operator">=</span> nextTab.length;</span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="type">int</span> sc;</span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    nextTable = <span class="literal">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="literal">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="literal">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="title class_">TreeBin</span>&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            advance = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>




        <h3 id="小结-1"   >
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3>
      <div class="table-container"><table>
<thead>
<tr>
<th></th>
<th>底层原理</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>底层是Node[]数组+链表+红黑树构成,默认容量为16,负载因子是0.75,扩容是原容量的两倍,线程不安全</td>
<td align="left">无序、非线程安全</td>
</tr>
<tr>
<td>HashTable</td>
<td>底层是哈希表(数组),默认容量是11,负载因子是0.75,扩容时新数组是原数组左移1位+1,即容量是原来两倍+1,因为被synchronized修饰所以是线程安全的</td>
<td align="left">线程安全、效率低</td>
</tr>
<tr>
<td>TreeMap</td>
<td>底层是二叉树(红黑树)</td>
<td align="left">可排序、非线程安全</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>底层是HashMap,默认容量为16，负载因子是0.75，默认排序方式是插入序，线程不安全，可用于开发LRU算法的实现</td>
<td align="left">有序、非线程安全</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>采用了synchronized+CAS的机制实现了线程安全</td>
<td align="left">线程安全</td>
</tr>
</tbody></table></div>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/13/RabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/">RabbitMQ面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">6分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="RabbitMQ怎么保证消息的不丢失"   >
          <a href="#RabbitMQ怎么保证消息的不丢失" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ怎么保证消息的不丢失" class="headerlink" title="RabbitMQ怎么保证消息的不丢失"></a>RabbitMQ怎么保证消息的不丢失</h1>
      <p>我答:</p>
<p>1.RabbitMQ在生产端有确认机制，打开生产确认消息机制，当生产者消息没有发到交换机时会调用ConfirmCallBack函数，当交换机消息没有发到Queue时会有一个ReturnsCallBack函数。这样我们保证了消息到达队列的不丢失</p>
<p>2.消息的持久化，防止因为MQ宕机导致消息的不丢失，主要是交换机、队列和消息的持久化</p>
<p>3.在消费端有一个签收机制，我们可以打开签收机制设置为Auto 由Spring来判断是否产生异常，如果异常了设置一个ReSet机制，重试三次之后发送到Error队列由人工干涉</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">消息的不丟失主要由三方面考虑</span><br><span class="line">1.RabbitMQ在生产端有确认机制，打开生产确认消息机制，当生产者消息没有发到交换机时会调用ConfirmCallBack函数，当交换机消息没有发到Queue时会有一个ReturnsCallBack函数。这样我们保证了消息到达队列的不丢失</span><br><span class="line"></span><br><span class="line">2.消息的持久化，防止因为MQ宕机导致消息的不丢失，主要是交换机、队列和消息的持久化</span><br><span class="line"></span><br><span class="line">3.在消费端有一个签收机制，我们可以打开签收机制设置为Auto 由Spring来判断是否产生异常，如果异常了设置一个ReSet机制，重试三次之后发送到Error队列由人工干涉</span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ怎么保障消息的幂等性"   >
          <a href="#RabbitMQ怎么保障消息的幂等性" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ怎么保障消息的幂等性" class="headerlink" title="RabbitMQ怎么保障消息的幂等性"></a>RabbitMQ怎么保障消息的幂等性</h1>
      <p>我答:1.可以引用一个全局的唯一ID，消费者要消费的时候查询Redis如果存在这个全局ID则说明已经消费过了</p>
<p>​		2.利用DB的主键，消费者查询MySql中的主键存在即说明消息也消费过了</p>
<p>​		3.利用Redis的Set命令，因为Key是唯一的，所以有天生的互斥性</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.可以引用一个全局的唯一ID，消费者要消费的时候查询Redis如果存在这个全局ID则说明已经消费过了</span><br><span class="line"></span><br><span class="line">2.利用DB的主键，消费者查询MySql中的主键存在即说明消息也消费过了</span><br><span class="line"></span><br><span class="line">3.利用Redis的Set命令，因为Key是唯一的，所以有天生的互斥性</span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ中死信队列？延时队列有了解过吗？"   >
          <a href="#RabbitMQ中死信队列？延时队列有了解过吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ中死信队列？延时队列有了解过吗？" class="headerlink" title="RabbitMQ中死信队列？延时队列有了解过吗？"></a>RabbitMQ中死信队列？延时队列有了解过吗？</h1>
      <p>我答：</p>
<p>1.RabbitMQ中死信队列也就是一个正常的交换机，主要是为了处理死信的。</p>
<p>​	一般因为三个原因会导致消息成为死信：1.消息超时了</p>
<p>​																		 2.消息数量超过了队列限制消息数目 </p>
<p>​																		 3.消息被拒签了</p>
<p>2.延时队列:RabbitMQ是不能直接创建延时队列的，但是我们可以通过对设置TTL和死信队列来达到延时队列的效果</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.RabbitMQ中死信队列也就是一个正常的交换机，主要是为了处理死信的。</span><br><span class="line"></span><br><span class="line">  一般因为三个原因会导致消息成为死信：1.消息超时了</span><br><span class="line"></span><br><span class="line">								2.消息数量超过了队列限制消息数目 </span><br><span class="line"></span><br><span class="line">								3.消息被拒签了</span><br><span class="line"></span><br><span class="line">2.延时队列:RabbitMQ是不能直接创建延时队列的，但是我们可以通过对设置TTL和死信队列来达到延时队列的效果</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ中如果有100w条消息堆积，是如何解决的-消息堆积"   >
          <a href="#RabbitMQ中如果有100w条消息堆积，是如何解决的-消息堆积" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ中如果有100w条消息堆积，是如何解决的-消息堆积" class="headerlink" title="RabbitMQ中如果有100w条消息堆积，是如何解决的(消息堆积)"></a>RabbitMQ中如果有100w条消息堆积，是如何解决的(消息堆积)</h1>
      <p>我答:1.RabbitMQ中可以设置消费者能一次处理的消息个数，这样可以有效的保障MQ的正常使用</p>
<p>​         2.消息和Queue可以设置过期时间，当TTL到了之后消息会成为死信或被丢弃，但是这样会导致消息的丢失</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我在开发中没有遇到过这样的问题，但是如果发生了消息堆积也是有解决方案</span><br><span class="line">	1.增多消费者数目，提高消费速度</span><br><span class="line">	2.在消费者端开启线程池，加快处理速度[消费者总数不变]</span><br><span class="line">	3.采用惰性队列，扩大队列容积      【创建队列的时候加上lazy】 </span><br><span class="line">	    采用惰性队列的优势：①接收消息然后存放到磁盘中而不是内存中 ②性能比较稳定，消息上限高</span><br><span class="line">	    			劣势：1.受限于磁盘IO</span><br><span class="line">	    				 2.消费者要消费消息的时候才会将磁盘中的消息读取到内存中，会降低消息的时效性</span><br></pre></td></tr></table></div></figure>


        <h1 id="RabbitMQ的高可用机制有了解过吗？"   >
          <a href="#RabbitMQ的高可用机制有了解过吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的高可用机制有了解过吗？" class="headerlink" title="RabbitMQ的高可用机制有了解过吗？"></a>RabbitMQ的高可用机制有了解过吗？</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在开发中我运用了镜像队列的方式来保证高可用</span><br><span class="line">镜像队列本质上就是主从模式，所有操作在主节点中完成然后备份到镜像节点。</span><br><span class="line">当主节点宕机挂掉之后，镜像节点就会上位成为主节点。</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/13/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/">RabbitMQ使用【进阶篇】</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-13</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.2k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">27分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="如何保证RabbitMQ的消息发送可靠性"   >
          <a href="#如何保证RabbitMQ的消息发送可靠性" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何保证RabbitMQ的消息发送可靠性" class="headerlink" title="如何保证RabbitMQ的消息发送可靠性"></a>如何保证RabbitMQ的消息发送可靠性</h1>
      
        <h2 id="利用确认机制和回退机制"   >
          <a href="#利用确认机制和回退机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#利用确认机制和回退机制" class="headerlink" title="利用确认机制和回退机制"></a>利用确认机制和回退机制</h2>
      
        <h3 id="1-确认机制"   >
          <a href="#1-确认机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-确认机制" class="headerlink" title="(1)确认机制:"></a>(1)确认机制:</h3>
      <p>生产者与交换机之间有一个确认机制，当开启确认机制之后，无论消息是否发送到交换机都会调用一个ConfirmCallBack的函数</p>

        <h4 id="相关代码"   >
          <a href="#相关代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码" class="headerlink" title="相关代码:"></a>相关代码:</h4>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">#   设置消息发送确认模式  none:无需确认(默认) correlated:消息从生产者到交换机调用回调函数  simple：单个确认(发一条确认一条)</span><br><span class="line">  	publisher-confirm-type: correlated</span><br></pre></td></tr></table></div></figure>

<p>POM</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></div></figure>

<p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_CONFIRM_NAME=<span class="string">&quot;topic_ConfirmExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_CONFIRM_NAME=<span class="string">&quot;topic_Confirmqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息的可靠性保障 确认模式*/</span></span><br><span class="line"><span class="comment">//创建交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">bootConfirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_CONFIRM_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">bootConfirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_CONFIRM_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Queue和交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bootConfirmBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;ConfirmExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;ConfirmQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;confirm.*&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Produce</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * confirm(CorrelationData correlationData, boolean b, String s)</span></span><br><span class="line"><span class="comment">    * 参数1  配置信息</span></span><br><span class="line"><span class="comment">    * 参数2  是否正常到Exchange  如果是为True,如果不是为false;</span></span><br><span class="line"><span class="comment">    * 参数3  错误原因</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="comment">//确认模式</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToConfirmSend</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> b, String s)</span> &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;Confirm方法被调用了&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(b)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;成功收到消息&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;失败消息原因&quot;</span>+s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME,<span class="string">&quot;confirm.haha&quot;</span>,<span class="string">&quot;需要确认信息&quot;</span>);<span class="comment">//成功发送</span></span><br><span class="line"><span class="comment">//rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME+&quot;000&quot;,&quot;confirm.hehe&quot;,&quot;确认信息&quot;);//失败发送</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>代码效果</p>

        <h5 id="1-成功发送："   >
          <a href="#1-成功发送：" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-成功发送：" class="headerlink" title="1.成功发送："></a>1.成功发送：</h5>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713155029776.png"  alt="image-20230713155029776">
      </p>

        <h5 id="2-失败发送"   >
          <a href="#2-失败发送" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-失败发送" class="headerlink" title="2.失败发送"></a>2.失败发送</h5>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713155150627.png"  alt="image-20230713155150627">
      </p>

        <h3 id="2-回退机制"   >
          <a href="#2-回退机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-回退机制" class="headerlink" title="(2)回退机制"></a>(2)回退机制</h3>
      
        <h4 id="相关代码-1"   >
          <a href="#相关代码-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-1" class="headerlink" title="相关代码"></a>相关代码</h4>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">#   设置消息发送回退模式</span><br><span class="line">    publisher-returns: <span class="literal">true</span></span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Produce</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToConfirmSend</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	回退模式，只有在Exchange到Queue失败才会执行的回调函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    	rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returnedMessage)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行了ReturnCallback方法&quot;</span>);</span><br><span class="line">                System.out.println(returnedMessage.getMessage()); <span class="comment">//获得消息体</span></span><br><span class="line">                System.out.println(returnedMessage.getExchange());<span class="comment">//获得交换机信息</span></span><br><span class="line">                System.out.println(returnedMessage.getReplyCode());<span class="comment">//获得错误代码</span></span><br><span class="line">                System.out.println(returnedMessage.getRoutingKey());<span class="comment">//获得路由key</span></span><br><span class="line">                System.out.println(returnedMessage.getReplyText());<span class="comment">//获得被退回原因</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//正确发送 错误路由</span></span><br><span class="line">         rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME,<span class="string">&quot;return.haha&quot;</span>,<span class="string">&quot;需要确认信息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_CONFIRM_NAME=<span class="string">&quot;topic_ConfirmExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_CONFIRM_NAME=<span class="string">&quot;topic_Confirmqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*消息的可靠性保障 确认模式*/</span></span><br><span class="line"><span class="comment">//创建交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">bootConfirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_CONFIRM_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;ConfirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">bootConfirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_CONFIRM_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Queue和交换机绑定</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bootConfirmBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;ConfirmExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;ConfirmQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;confirm.*&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="效果"   >
          <a href="#效果" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果" class="headerlink" title="效果"></a>效果</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713161242108.png"  alt="image-20230713161242108">
      </p>

        <h1 id="RabbitMQ的消息接收的确认"   >
          <a href="#RabbitMQ的消息接收的确认" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的消息接收的确认" class="headerlink" title="RabbitMQ的消息接收的确认"></a>RabbitMQ的消息接收的确认</h1>
      <p>设置Queue到消费者的确认方式</p>

        <h2 id="相关代码-2"   >
          <a href="#相关代码-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-2" class="headerlink" title="相关代码"></a>相关代码</h2>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">#    设置ACK签收模式   manual为手动签收   none为无需确认  auto为自动确认</span><br><span class="line">    listener:</span><br><span class="line">      direct:</span><br><span class="line">        acknowledge-mode: manual</span><br></pre></td></tr></table></div></figure>

<p>消费者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQconfirmListen</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_Confirmqueue&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;正在处理业务逻辑...&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//签收消息</span></span><br><span class="line">            <span class="comment">/*basicAck(long deliveryTag, boolean multiple)</span></span><br><span class="line"><span class="comment">             * 参数1:消息标签</span></span><br><span class="line"><span class="comment">             * 参数2:是否支持多条消息的签收</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">int</span> i=<span class="number">3</span>/<span class="number">0</span> ; <span class="comment">//模仿出错</span></span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//        因为异常拒绝签收</span></span><br><span class="line">            <span class="comment">/* basicNack(long deliveryTag, boolean multiple, boolean requeue)</span></span><br><span class="line"><span class="comment">             * 参数1:消息标签</span></span><br><span class="line"><span class="comment">             * 参数2:是否支持多条消息的签收</span></span><br><span class="line"><span class="comment">             * 参数3：是否退回队列</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            channel.basicNack(deliveryTag, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-1"   >
          <a href="#效果-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3>
      
        <h4 id="1-正常签收"   >
          <a href="#1-正常签收" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-正常签收" class="headerlink" title="(1)正常签收"></a>(1)正常签收</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713163939606.png"  alt="image-20230713163939606">
      </p>

        <h4 id="2-异常签收"   >
          <a href="#2-异常签收" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-异常签收" class="headerlink" title="(2)异常签收"></a>(2)异常签收</h4>
      <p>![](RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91&#x2F;image-20230713162956067.png</p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713163128985.png"  alt="image-20230713163128985">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/image-20230713163221136.png"  alt="image-20230713163221136">
      </p>

        <h1 id="RabbitMQ的消费端限流"   >
          <a href="#RabbitMQ的消费端限流" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的消费端限流" class="headerlink" title="RabbitMQ的消费端限流"></a>RabbitMQ的消费端限流</h1>
      <p>使用场景:限制消费端的接收消息的数量，防止因为系统维护等导致队列中的消息多,因而导致一个消费端巨量的压力过大，影响系统性能</p>
<p>实现要求</p>
<p>1.打开手动签收模式</p>
<p>2.将application中的prefetch设置为可消费的消息数量</p>

        <h2 id="相关代码-3"   >
          <a href="#相关代码-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-3" class="headerlink" title="相关代码"></a>相关代码</h2>
      <p>application.yml</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line"></span><br><span class="line">#    设置ACK签收模式   manual为手动签收   none为无需确认  auto为自动确认</span><br><span class="line">    listener:</span><br><span class="line">      direct:</span><br><span class="line">        acknowledge-mode: manual</span><br><span class="line">#  设置消费端一次能接受的消息数量</span><br><span class="line">        prefetch: <span class="number">1</span></span><br><span class="line">      simple:</span><br><span class="line">        acknowledge-mode: manual</span><br><span class="line">        prefetch: <span class="number">1</span></span><br></pre></td></tr></table></div></figure>

<p>消费者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QosListen</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_Confirmqueue&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"><span class="comment">//          手动签收消息</span></span><br><span class="line"><span class="comment">//            channel.basicAck(deliveryTag, true);</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendQos</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">           rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_CONFIRM_NAME, <span class="string">&quot;confirm.haha&quot;</span>, <span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;条信息，&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-2"   >
          <a href="#效果-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713165421300.png"  alt="image-20230713165421300">
      
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713165439057.png"  alt="image-20230713165439057">
      </p>
<p>总共有20条 19条Ready  1条未被签收</p>

        <h1 id="RabbitMQ的TTL"   >
          <a href="#RabbitMQ的TTL" class="heading-link"><i class="fas fa-link"></i></a><a href="#RabbitMQ的TTL" class="headerlink" title="RabbitMQ的TTL"></a>RabbitMQ的TTL</h1>
      <p>消息到达存活时间之后还未被消费则会被自动清除</p>

        <h2 id="队列设置过期时间"   >
          <a href="#队列设置过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列设置过期时间" class="headerlink" title="队列设置过期时间"></a>队列设置过期时间</h2>
      
        <h3 id="相关代码-4"   >
          <a href="#相关代码-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-4" class="headerlink" title="相关代码"></a>相关代码</h3>
      <p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_TTL_NAME=<span class="string">&quot;topic_TtlExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_TTL_NAME=<span class="string">&quot;topic_Ttlqueue&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;TtlExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">TtlExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_TTL_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;TtlQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">TtlQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_TTL_NAME).ttl(<span class="number">10000</span>).build(); <span class="comment">//设置队列消息过期时间为10S</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Queue和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">TtlBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;TtlExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;TtlQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;ttl.*&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendTTL</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">           rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_TTL_NAME, <span class="string">&quot;ttl.haha&quot;</span>, <span class="string">&quot;这是第&quot;</span>+i+<span class="string">&quot;条信息，&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="效果-3"   >
          <a href="#效果-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-3" class="headerlink" title="效果"></a>效果</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713170744420.png"  alt="image-20230713170744420">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/image-20230713170756794.png"  alt="image-20230713170756794">
      </p>

        <h2 id="单个消息设置过期时间"   >
          <a href="#单个消息设置过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#单个消息设置过期时间" class="headerlink" title="单个消息设置过期时间"></a>单个消息设置过期时间</h2>
      
        <h3 id="相关代码-5"   >
          <a href="#相关代码-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-5" class="headerlink" title="相关代码"></a>相关代码</h3>
      <p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendTTLMessage</span><span class="params">()</span>&#123;</span><br><span class="line">       rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_TTL_NAME, <span class="string">&quot;ttl.haha&quot;</span>,<span class="string">&quot;ttl...&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">               message.getMessageProperties().setExpiration(String.valueOf(<span class="number">5000</span>));<span class="comment">//设置过期时间为5s</span></span><br><span class="line">               <span class="keyword">return</span>  message;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="效果-4"   >
          <a href="#效果-4" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-4" class="headerlink" title="效果"></a>效果</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713171755975.png"  alt="image-20230713171755975">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/RabbitMQ%E4%BD%BF%E7%94%A8%E3%80%90%E8%BF%9B%E9%98%B6%E7%AF%87%E3%80%91/image-20230713171808499.png"  alt="image-20230713171808499">
      </p>

        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h2>
      <p>1.当Queue的TTL和消息的TTL共同存在的时候，则会优先执行短的</p>
<p>2.当消息的过期时间到了 但是不在队列的首部的时候不会立即删除[像Redis的惰性删除，只有在调用的时候发现过期了才删除]</p>

        <h1 id="死信队列"   >
          <a href="#死信队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1>
      <p>当消息过期\被拒绝签收\队伍消息长度达到限制的消息则会放到死信队列中</p>
<p>死信队列也是一个交换机，它的存在是处理死信的交换机，其他与正常交换机没有区别</p>

        <h2 id="相关代码-6"   >
          <a href="#相关代码-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-6" class="headerlink" title="相关代码"></a>相关代码</h2>
      <p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_DLX_NAME=<span class="string">&quot;topic_DLxExchange&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_DLX_NAME=<span class="string">&quot;topic_DLXqueue&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_DLXTRUE_NAME=<span class="string">&quot;topic_DLEtureExchange&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_DLXTRUE_NAME=<span class="string">&quot;topic_DLXtruequeue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建死信交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXExchange&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Exchange <span class="title function_">DLXExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_DLX_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建死信Queue</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXQueue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">DLXQueue</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DLX_NAME).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建正常交换机</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXTrueExchange&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Exchange <span class="title function_">DLXTrueExchange</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_DLXTRUE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//创建正常Queue</span></span><br><span class="line">   <span class="meta">@Bean(&quot;DLXTrueQueue&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> Queue <span class="title function_">DLXTrueQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;DLXExchange&quot;)</span> Exchange exchange)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DLXTRUE_NAME).ttl(<span class="number">100000</span>).maxLength(<span class="number">10</span>).deadLetterExchange(exchange.getName()).deadLetterRoutingKey(<span class="string">&quot;dlx.haha&quot;</span>).build();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//正常Queue和交换机绑定</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">DLXTrueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;DLXTrueExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;DLXTrueQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;info.#&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//死信Queue和死信交换机绑定</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Binding <span class="title function_">DLXBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;DLXExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;DLXQueue&quot;)</span> Queue queue)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;dlx.*&quot;</span>).noargs();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>生产者代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToSendDlxMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">                rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_DLXTRUE_NAME, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;这是&quot;</span>+i+<span class="string">&quot;条消息&quot;</span>, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line"><span class="comment">//                        message.getMessageProperties().setExpiration(String.valueOf(6000));</span></span><br><span class="line">                        <span class="keyword">return</span> message;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>消费者代码</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DlxListen</span> <span class="keyword">implements</span> <span class="title class_">ChannelAwareMessageListener</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;topic_DLXtruequeue&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line"><span class="comment">//          手动签收消息</span></span><br><span class="line">            <span class="type">int</span> i=<span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">            channel.basicAck(deliveryTag, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//不签收消息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;拒绝签收消息&quot;</span>);</span><br><span class="line">            channel.basicNack(deliveryTag,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-5"   >
          <a href="#效果-5" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-5" class="headerlink" title="效果"></a>效果</h3>
      
        <h4 id="1-当消息到了过期时间"   >
          <a href="#1-当消息到了过期时间" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-当消息到了过期时间" class="headerlink" title="(1)当消息到了过期时间"></a>(1)当消息到了过期时间</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181912511.png"  alt="image-20230713181912511">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181933839.png"  alt="image-20230713181933839">
      </p>

        <h4 id="2-当消息长度超过了队列限制"   >
          <a href="#2-当消息长度超过了队列限制" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-当消息长度超过了队列限制" class="headerlink" title="(2)当消息长度超过了队列限制"></a>(2)当消息长度超过了队列限制</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181912511.png"  alt="image-20230713181912511">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713181933839.png"  alt="image-20230713181933839">
      </p>

        <h4 id="3-消息在消费端拒收"   >
          <a href="#3-消息在消费端拒收" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-消息在消费端拒收" class="headerlink" title="(3)消息在消费端拒收"></a>(3)消息在消费端拒收</h4>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713183932822.png"  alt="image-20230713183932822">
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230713183952193.png"  alt="image-20230713183952193">
      </p>

        <h3 id="提示"   >
          <a href="#提示" class="heading-link"><i class="fas fa-link"></i></a><a href="#提示" class="headerlink" title="提示"></a>提示</h3>
      <p>当消息总数超过队列长度限制时，因为队列是先进先出的，所以成为死信的消息应该是先进入队列的消息</p>

        <h1 id="延迟队列"   >
          <a href="#延迟队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1>
      <p>RabbitMQ无法直接创建延迟队列，但是可以通过TTL和死信队列达到延迟队列的效果，则这样延迟队列为该死信队列的Queue</p>

        <h1 id="消息补偿机制"   >
          <a href="#消息补偿机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h1>
      <p>【图片来源于CSDN，借鉴于此】</p>
<p>【<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_48481908/article/details/120160022?ops_request_misc=&request_id=&biz_id=102&utm_term=RabbitMQ%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-120160022.nonecase&spm=1018.2226.3001.4187%E3%80%91" >https://blog.csdn.net/m0_48481908/article/details/120160022?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=RabbitMQ%E6%B6%88%E6%81%AF%E8%A1%A5%E5%81%BF&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-120160022.nonecase&amp;spm=1018.2226.3001.4187】</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6I235YyF6JuL5LuK5aSp5pyJ5aW95aW95a2m5Lmg5ZCX77yf,size_14,color_FFFFFF,t_70,g_se,x_16.png"  alt="在这里插入图片描述">
      </p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">1.生产者生产数据并写入自己的数据库</span><br><span class="line">2.生产者发送消息给Q1，并且会延迟一段时间发送相同的消息给Q3。Q1会被Consumer监听到，会产生一个确认信息的信号给Q2,Q2会被回调检查服务监听到，此时会直接将消息写到MDB中</span><br><span class="line">3.消费者将消费数据写入自己的DB中。</span><br><span class="line">4.延迟发送相同的消息给Q3，Q3被回调检查服务监听，会与MDB中数据比对，如果MDB中没有这个消息则说明Q3的消息未被消费，即发送消息给Q1失败，则会调用Producer重发消息</span><br><span class="line">5.定时检查服务来检查生产者DB和MessageDB 如果不一致，如业务DB多于消息MDB则说明有消息未被消费。则需要生产者重发消息【这是为了防止发送消息和延迟发送消息都失败的情况】</span><br></pre></td></tr></table></div></figure>


        <h1 id="消息幂等性的保证"   >
          <a href="#消息幂等性的保证" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息幂等性的保证" class="headerlink" title="消息幂等性的保证"></a>消息幂等性的保证</h1>
      <figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">消息的幂等性：指的是消息的多次执行和一次执行的效果是一样的</span><br><span class="line"></span><br><span class="line">比如消费者的确认时宕机 导致生产者多次发送同样的消息，所以此时要保证消息的幂等性，不要重复消费</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line"></span><br><span class="line">1.使用Redis的Set命令，因为Set的Key是唯一的，所以这样不会重复消费消息</span><br><span class="line"></span><br><span class="line">2.使用UUID等方式，全局唯一ID，所以每次消息来了去Redis查是否有这个UUID，如果有则说明消费过</span><br><span class="line"></span><br><span class="line">3.利用数据库主键的方式，因为主键也是唯一的</span><br></pre></td></tr></table></div></figure>


        <h1 id="消息转换器"   >
          <a href="#消息转换器" class="heading-link"><i class="fas fa-link"></i></a><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpringAMQP中会有一个消息转化器(MessageConverter)，当我们调用RabbitTamplate的convertAndSend方法的时候，传入的消息参数都是Object类型，然后他会在底层帮我们进行一个序列化，而这个序列化是基于Java底层的ObjectOutPutStream来实现。</span><br><span class="line">我们可以引入一个Json格式的消息转化器来达到约定大于配置将Spring自带的消息转化器替代，我们用JSon格式做序列化</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h2 id="相关代码-7"   >
          <a href="#相关代码-7" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关代码-7" class="headerlink" title="相关代码"></a>相关代码</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pom依赖</span><br><span class="line">&lt;!--        定义json格式转化器--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></div></figure>

<p>启动类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br><span class="line">因为约定大于配置，自己创建一个Bean来覆盖初始的消息转化器</span><br></pre></td></tr></table></div></figure>

<p>RabbitMQConfig</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXCHANGE_OBJECT_NAME=<span class="string">&quot;direct_ObjectExchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_OBJECT_NAME=<span class="string">&quot;direct_Objectqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Object交换机</span></span><br><span class="line">    <span class="meta">@Bean(&quot;ObjectExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">ObjectExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_OBJECT_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Queue</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;ObjectQueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">ObjectQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_OBJECT_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Queue和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">ObjectBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;ObjectExchange&quot;)</span> Exchange exchange, <span class="meta">@Qualifier(&quot;ObjectQueue&quot;)</span> Queue queue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;queue.object&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<p>生产者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ToObjectMessage</span><span class="params">()</span>&#123;</span><br><span class="line"> 	HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    rabbitTemplate.convertAndSend(RabbitMqConfig.EXCHANGE_OBJECT_NAME,<span class="string">&quot;queue.object&quot;</span>,map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>消费者端</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectListen</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;direct_Objectqueue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(Map&lt;String,Object&gt; msg)</span>&#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="效果-6"   >
          <a href="#效果-6" class="heading-link"><i class="fas fa-link"></i></a><a href="#效果-6" class="headerlink" title="效果"></a>效果</h3>
      <p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230720224428282.png" >
      </p>
<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/image-20230720225911561.png"  alt="image-20230720225911561">
      </p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>单机RabbitMq的启动命令</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service rabbitmq-server start 启动</span><br><span class="line">service rabbitmq-server stop  停机</span><br><span class="line">service rabbitmq-server restart 重启</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2023/07/12/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">Java基础面试题</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-07-12</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">9分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="final修饰符有学习过吗？它有什么使用场景"   >
          <a href="#final修饰符有学习过吗？它有什么使用场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#final修饰符有学习过吗？它有什么使用场景" class="headerlink" title="final修饰符有学习过吗？它有什么使用场景"></a>final修饰符有学习过吗？它有什么使用场景</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Final修饰符表示是最终的</span><br><span class="line">Final修饰符可以用于修饰变量、方法、类</span><br><span class="line"><span class="number">1</span>)Final修饰变量的时候:这个变量叫常量，一旦被赋值就不能改变</span><br><span class="line"><span class="number">2</span>)Final修饰方法的时候:这个方法不能被子类重写</span><br><span class="line"><span class="number">3</span>)Final修饰类的时候:这个类是最终类，不能被继承</span><br></pre></td></tr></table></div></figure>


        <h1 id="jvm、jdk、jre的区别"   >
          <a href="#jvm、jdk、jre的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#jvm、jdk、jre的区别" class="headerlink" title="jvm、jdk、jre的区别"></a>jvm、jdk、jre的区别</h1>
      <p>jvm是java虚拟机，里面含有java运行的一切要求</p>
<p>jdk是java提供的api库</p>
<p>jre是最小开发环境</p>
<p>jvm、jdk、jre的关系是jvm包含jdk包含jre</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JVM:JVM为java虚拟机</span><br><span class="line">JRE:JRE为Java运行环境，JRE包括标准类库和JVM</span><br><span class="line">JDK:JDK为Java开发环境，JDK包括了JRE和开发工具</span><br><span class="line">    </span><br><span class="line">总结:JDK包含JRE，JRE包含JVM，如果只需要运行java程序只要装JRE即可</span><br></pre></td></tr></table></div></figure>

<p>
        <img   class="lazyload lazyload-gif"
          src="/images/loading.svg" data-src="/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/image-20230721203141902.png"  alt="image-20230721203141902">
      </p>

        <h1 id="java的八大基本类型"   >
          <a href="#java的八大基本类型" class="heading-link"><i class="fas fa-link"></i></a><a href="#java的八大基本类型" class="headerlink" title="java的八大基本类型"></a>java的八大基本类型</h1>
      <p>我答:</p>
<p>Char、short、int、Long、Float、Double、String、Boolean</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">整型:<span class="type">byte</span>、<span class="type">short</span>、<span class="type">int</span>、<span class="type">long</span></span><br><span class="line">字符型：<span class="type">char</span></span><br><span class="line">浮点型：Float、Double</span><br><span class="line">布尔型：Boolean</span><br></pre></td></tr></table></div></figure>


        <h1 id="多态如何实现的"   >
          <a href="#多态如何实现的" class="heading-link"><i class="fas fa-link"></i></a><a href="#多态如何实现的" class="headerlink" title="多态如何实现的"></a>多态如何实现的</h1>
      
        <h1 id="进程和线程的区别"   >
          <a href="#进程和线程的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1>
      
        <h1 id="同步和异步的区别"   >
          <a href="#同步和异步的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h1>
      
        <h1 id="如何理解序列化"   >
          <a href="#如何理解序列化" class="heading-link"><i class="fas fa-link"></i></a><a href="#如何理解序列化" class="headerlink" title="如何理解序列化"></a>如何理解序列化</h1>
      
        <h1 id="HashMap-和-TreeMap-讲讲？"   >
          <a href="#HashMap-和-TreeMap-讲讲？" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashMap-和-TreeMap-讲讲？" class="headerlink" title="HashMap 和 TreeMap 讲讲？"></a>HashMap 和 TreeMap 讲讲？</h1>
      
        <h1 id="讲讲-Java-提供了哪些锁？它们有什么区别？"   >
          <a href="#讲讲-Java-提供了哪些锁？它们有什么区别？" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲-Java-提供了哪些锁？它们有什么区别？" class="headerlink" title="讲讲 Java 提供了哪些锁？它们有什么区别？"></a>讲讲 Java 提供了哪些锁？它们有什么区别？</h1>
      
        <h1 id="有了解过集合吗？看过底层源码吗？"   >
          <a href="#有了解过集合吗？看过底层源码吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过集合吗？看过底层源码吗？" class="headerlink" title="有了解过集合吗？看过底层源码吗？"></a>有了解过集合吗？看过底层源码吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">有了解过集合，看过底层源码</span><br><span class="line">集合就是有两个顶级接口Collection单列集合和Map双列集合</span><br><span class="line">Collection接口的子接口有List、Set</span><br><span class="line">List接口的实现类有ArrayList、LinkedList、Vector</span><br><span class="line">Set接口的实现类有HashSet、TreeSet、LinkedHashSet</span><br><span class="line">而Map集合的实现类有HashMap、LinkedHashMap、HashTable、TreeMap、ConcurrentHashMap</span><br><span class="line">您看我具体要从哪方面讲讲呢?</span><br></pre></td></tr></table></div></figure>




        <h1 id="ArrayList底层是怎么进行创建和扩容的呢？"   >
          <a href="#ArrayList底层是怎么进行创建和扩容的呢？" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayList底层是怎么进行创建和扩容的呢？" class="headerlink" title="ArrayList底层是怎么进行创建和扩容的呢？"></a>ArrayList底层是怎么进行创建和扩容的呢？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList底层是创建了一个Object数组来存放数据的，默认的空参构造时创建一个数组长度为<span class="number">10</span>的Obejct数组，也可以在构建方法传入指定长度，构建一个指定长度的Object数组。</span><br><span class="line">ArrayList在添加数据的时候会判断这个数组是不是满了，一旦满了就进行扩容，ArrayList的扩容是原来容量的<span class="number">1.5</span>倍</span><br><span class="line">具体操作是拿出老容量加上老容量右移一位再赋值给新数组，然后把老数组的元素copy到新数组中，最后添加新加入的数据</span><br></pre></td></tr></table></div></figure>




        <h1 id="集合是怎么处理哈希碰撞的？"   >
          <a href="#集合是怎么处理哈希碰撞的？" class="heading-link"><i class="fas fa-link"></i></a><a href="#集合是怎么处理哈希碰撞的？" class="headerlink" title="集合是怎么处理哈希碰撞的？"></a>集合是怎么处理哈希碰撞的？</h1>
      <p>我答：</p>
<p>集合获取这个索引I是把集合长度n-1再和由key经过hashcode方法得到的哈希值做一个与运算<br>由key算出的hash值具体是 拿出key经过hashcode获得一个哈希值，将这个哈希值和这个哈希值无符号右移16位做一个异或运算 使得高位数据也能参与hash中 最后得到的值传回去</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当发生哈希碰撞的时候有以下几种解决哈希碰撞的方法：链式寻址法、再hash算法、公共溢出法、线性探测法</span><br><span class="line">而HashMap在处理哈希碰撞的时候就是利用链式寻址法和红黑树，<span class="number">1.7</span>是将新数据插入到链表头部，而<span class="number">1.8</span>会将数据插入到链表尾部，并且插入新数据的时候会进行判断链表长度是否超过<span class="number">8</span>且数组长度超过<span class="number">64</span>，如果超过了则会转成红黑树结构，红黑树是为了优化因为链表过长导致搜索时间复杂度增加的一个问题</span><br></pre></td></tr></table></div></figure>




        <h1 id="有了解过锁吗-Lock和Sychorized那些"   >
          <a href="#有了解过锁吗-Lock和Sychorized那些" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过锁吗-Lock和Sychorized那些" class="headerlink" title="有了解过锁吗?Lock和Sychorized那些"></a>有了解过锁吗?Lock和Sychorized那些</h1>
      
        <h1 id="final修饰方法会怎么样？final修饰类会怎么样"   >
          <a href="#final修饰方法会怎么样？final修饰类会怎么样" class="heading-link"><i class="fas fa-link"></i></a><a href="#final修饰方法会怎么样？final修饰类会怎么样" class="headerlink" title="final修饰方法会怎么样？final修饰类会怎么样?"></a>final修饰方法会怎么样？final修饰类会怎么样?</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>修饰方法会让方法无法被重写</span><br><span class="line"><span class="keyword">final</span>修饰类会使这个类成为最终类,无法被继承</span><br></pre></td></tr></table></div></figure>




        <h1 id="Integer和int能直接进行比较吗？"   >
          <a href="#Integer和int能直接进行比较吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integer和int能直接进行比较吗？" class="headerlink" title="Integer和int能直接进行比较吗？"></a>Integer和int能直接进行比较吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer类型和Int值能直接比较，因为在Integer会进行自动拆箱和装箱</span><br><span class="line">在Integer和<span class="type">int</span>进行比较的时候Integer会自动拆箱成<span class="type">int</span>类型</span><br></pre></td></tr></table></div></figure>




        <h1 id="Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？"   >
          <a href="#Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？" class="headerlink" title="Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？"></a>Integer底层有一个缓冲数组，在这个缓冲数组边界能直接进行比较吗？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer底层有一个<span class="type">int</span>的缓冲数组，缓冲数组的范围是负<span class="number">128</span>到正<span class="number">127</span>，在这个范围里会直接找到缓冲区的地址</span><br><span class="line">在缓冲数据的边界也能进行直接比较的</span><br></pre></td></tr></table></div></figure>




        <h1 id="和equals方法的区别"   >
          <a href="#和equals方法的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#和equals方法的区别" class="headerlink" title="&#x3D;&#x3D;和equals方法的区别"></a>&#x3D;&#x3D;和equals方法的区别</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==在比较基本数据类型的时候比较的是具体的值,而在比较引用数据类型的时候比较两边的地址值</span><br><span class="line">equals方法比较的是两边的属性值</span><br></pre></td></tr></table></div></figure>




        <h1 id="有了解过Volatile关键字吗？"   >
          <a href="#有了解过Volatile关键字吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#有了解过Volatile关键字吗？" class="headerlink" title="有了解过Volatile关键字吗？"></a>有了解过Volatile关键字吗？</h1>
      
        <h1 id="说说SpringMVC的执行流程"   >
          <a href="#说说SpringMVC的执行流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#说说SpringMVC的执行流程" class="headerlink" title="说说SpringMVC的执行流程"></a>说说SpringMVC的执行流程</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP请求会发送到DispatcherServlet(前端控制器)中然后DisPatcherServlet会通过url找到HandlerMapping(处理器映射器)获得映射，HandlerMapping会将这个hander处理器和拦截器一起发送回DisPatcherServlet中，DisPatcherServlet会通过映射查到HandleAdapter(处理器适配器),HandleAdapater会找到具体的Handle,然后将Handle传回来的ModelandView传回给DisPatcherServlet，DisPachthersevlet去找View <span class="title function_">Reslover</span><span class="params">(视图解析器)</span>,View Reslover会将解析出来的View返回给DisPachterServlet，然后DisPachter再渲染反映给前端</span><br><span class="line">而现在一般是面向接口编程，我们不用返回View而是Handle通过ResponBody注解再通过(HttpMessageConverter)消息转化器返回一个Json格式的数据就可以了</span><br></pre></td></tr></table></div></figure>




        <h1 id="ArrayList-线程安全吗？Vector-呢？那并发性能高的-ArrayList-是什么？"   >
          <a href="#ArrayList-线程安全吗？Vector-呢？那并发性能高的-ArrayList-是什么？" class="heading-link"><i class="fas fa-link"></i></a><a href="#ArrayList-线程安全吗？Vector-呢？那并发性能高的-ArrayList-是什么？" class="headerlink" title="ArrayList 线程安全吗？Vector 呢？那并发性能高的 ArrayList 是什么？"></a>ArrayList 线程安全吗？Vector 呢？那并发性能高的 ArrayList 是什么？</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList线程不安全，而Vector是线程安全的，</span><br><span class="line">ArrayList底层是Object数组，默认初始化的数组长度为<span class="number">10</span></span><br></pre></td></tr></table></div></figure>




        <h1 id="线程池有用过吗？有哪些参数？"   >
          <a href="#线程池有用过吗？有哪些参数？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池有用过吗？有哪些参数？" class="headerlink" title="线程池有用过吗？有哪些参数？"></a>线程池有用过吗？有哪些参数？</h1>
      
        <h1 id="线程池如何配置？有什么策略策略？"   >
          <a href="#线程池如何配置？有什么策略策略？" class="heading-link"><i class="fas fa-link"></i></a><a href="#线程池如何配置？有什么策略策略？" class="headerlink" title="线程池如何配置？有什么策略策略？"></a>线程池如何配置？有什么策略策略？</h1>
      
        <h1 id="讲讲-ThreadPoolExecutor-的七个参数？怎么配置？"   >
          <a href="#讲讲-ThreadPoolExecutor-的七个参数？怎么配置？" class="heading-link"><i class="fas fa-link"></i></a><a href="#讲讲-ThreadPoolExecutor-的七个参数？怎么配置？" class="headerlink" title="讲讲 ThreadPoolExecutor 的七个参数？怎么配置？"></a>讲讲 ThreadPoolExecutor 的七个参数？怎么配置？</h1>
      
        <h1 id="能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？"   >
          <a href="#能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？" class="heading-link"><i class="fas fa-link"></i></a><a href="#能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？" class="headerlink" title="能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？"></a>能说一下ThreadPoolExecutor核心线程数、最大线程数、工作队列之间的数量关系吗？</h1>
      
        <h1 id="普通For、增强For和ForEach的区别"   >
          <a href="#普通For、增强For和ForEach的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通For、增强For和ForEach的区别" class="headerlink" title="普通For、增强For和ForEach的区别"></a>普通For、增强For和ForEach的区别</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普通For是通过索引I来获得元素，而增强For是通过迭代器来获得元素</span><br><span class="line">ForEach就是增强For</span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="未整理区"   >
          <a href="#未整理区" class="heading-link"><i class="fas fa-link"></i></a><a href="#未整理区" class="headerlink" title="未整理区"></a>未整理区</h1>
      
        <h2 id="与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程"   >
          <a href="#与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程" class="headerlink" title="&#x3D;&#x3D;与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程"></a>&#x3D;&#x3D;与equals的区别，String类里面的equals方法实现看过吗，大概的实现流程</h2>
      
        <h2 id="Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景-排行榜，实时排名，去重统计"   >
          <a href="#Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景-排行榜，实时排名，去重统计" class="heading-link"><i class="fas fa-link"></i></a><a href="#Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景-排行榜，实时排名，去重统计" class="headerlink" title="Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景(排行榜，实时排名，去重统计)"></a>Redis有哪些常见数据类型，string，hash，还有zset的内部实现用的什么数据结构，zset数据结构有哪些应用场景(排行榜，实时排名，去重统计)</h2>
      
        <h2 id="你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。"   >
          <a href="#你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。" class="heading-link"><i class="fas fa-link"></i></a><a href="#你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。" class="headerlink" title="你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。"></a>你的项目中用到了分布式锁，使用分布式锁的时候需要注意哪些问题，分布式锁的使用场景（答的商品秒杀）；为什么要用分布式锁，不用synchronized锁住代码块来保证线程安全。</h2>
      
        <h2 id="什么是回表？"   >
          <a href="#什么是回表？" class="heading-link"><i class="fas fa-link"></i></a><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h2>
      
        <h2 id="MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题"   >
          <a href="#MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题" class="heading-link"><i class="fas fa-link"></i></a><a href="#MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题" class="headerlink" title="MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题"></a>MySQL存储引擎Innodb的数据结构，可以用hashmap吗，索引用有序数组查询效率会怎么样，有什么问题</h2>
      
        <h2 id="编程题：输入一个整数，转为二进制，并求出1个个数。"   >
          <a href="#编程题：输入一个整数，转为二进制，并求出1个个数。" class="heading-link"><i class="fas fa-link"></i></a><a href="#编程题：输入一个整数，转为二进制，并求出1个个数。" class="headerlink" title="编程题：输入一个整数，转为二进制，并求出1个个数。"></a>编程题：输入一个整数，转为二进制，并求出1个个数。</h2>
      </div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://images-kkblog.oss-cn-hangzhou.aliyuncs.com/E7977EEC2FEF2A2B9146704271490ED2.png" alt="avatar"></div><p class="sidebar-ov-author__text">步子小也好，走得慢也好，是在往前走就好</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.389081641" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://github.com/Kkker1" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/" target="_blank" rel="noopener" data-popover="social.KKKer1An@163.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="far fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">32</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>KkkerAn</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lazyload@2.0.0-rc.2/lazyload.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script type="application/json" src="/search.xml"></script></body></html>